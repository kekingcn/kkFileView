var OV = (() => {
	var _f = Object.defineProperty;
	var xy = Object.getOwnPropertyDescriptor;
	var yy = Object.getOwnPropertyNames;
	var _y = Object.prototype.hasOwnProperty;
	var Ym = (r, e) => {
			for (var t in e) _f(r, t, {
				get: e[t],
				enumerable: !0
			})
		},
		by = (r, e, t, n) => {
			if (e && typeof e == "object" || typeof e == "function")
				for (let i of yy(e)) !_y.call(r, i) && i !== t && _f(r, i, {
					get: () => e[i],
					enumerable: !(n = xy(e, i)) || n.enumerable
				});
			return r
		};
	var My = r => by(_f({}, "__esModule", {
		value: !0
	}), r);
	var w1 = {};
	Ym(w1, {
		CreateHeaderButton: () => M1,
		SetWebsiteEventHandler: () => y1,
		StartEmbed: () => b1,
		StartWebsite: () => _1
	});
	var xc = null,
		Zm = new Set;

	function bf(r) {
		xc = r
	}

	function ll(r) {
		return xc === null ? null : xc + "/" + r
	}

	function ds(r) {
		return new Promise((e, t) => {
			if (xc === null) {
				t();
				return
			}
			if (Zm.has(r)) {
				e();
				return
			}
			let n = document.createElement("script");
			n.type = "text/javascript", n.src = ll(r), n.onload = () => {
				Zm.add(r), e()
			}, n.onerror = () => {
				t()
			}, document.head.appendChild(n)
		})
	}
	var Km = 57.29577951308232,
		ps = .017453292519943;

	function cl(r) {
		return Math.abs(r) < 1e-8
	}

	function yc(r, e) {
		return e - r > 1e-8
	}

	function Jm(r, e) {
		return r - e > 1e-8
	}

	function _c(r, e) {
		return e - r > -1e-8
	}

	function bc(r, e) {
		return r - e > -1e-8
	}

	function Yt(r, e) {
		return Math.abs(e - r) < 1e-8
	}

	function Mf(r, e, t) {
		return Math.abs(e - r) < t
	}

	function vr(r) {
		return r > 1e-8
	}

	function ro(r) {
		return r < -1e-8
	}
	var lt = {
		X: 1,
		Y: 2,
		Z: 3
	};
	var Rt = class {
		constructor(e, t) {
			this.x = e, this.y = t
		}
		Clone() {
			return new Rt(this.x, this.y)
		}
	};

	function so(r, e) {
		return Yt(r.x, e.x) && Yt(r.y, e.y)
	}

	function wf(r, e) {
		return new Rt(r.x - e.x, r.y - e.y)
	}

	function Tf(r, e) {
		return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y))
	}

	function qn(r) {
		return Math.round(parseFloat(r))
	}

	function $m(r) {
		let e = qn(r.paddingLeft) + qn(r.paddingRight),
			t = qn(r.borderLeftWidth) + qn(r.borderRightWidth),
			n = qn(r.marginLeft) + qn(r.marginRight);
		return e + t + n
	}

	function Qm(r) {
		let e = qn(r.paddingTop) + qn(r.paddingBottom),
			t = qn(r.borderTopWidth) + qn(r.borderBottomWidth),
			n = qn(r.marginTop) + qn(r.marginBottom);
		return e + t + n
	}

	function eg(r, e, t) {
		let n = getComputedStyle(r),
			i = e - $m(n),
			s = t - Qm(n);
		return {
			width: i,
			height: s
		}
	}

	function oo(r, e, t) {
		if (r.getBoundingClientRect) {
			let n = r.getBoundingClientRect();
			e -= n.left, t -= n.top
		}
		return window.pageXOffset && window.pageYOffset && (e += window.pageXOffset, t += window.pageYOffset), new Rt(e, t)
	}

	function ms(r, e, t) {
		let n = document.createElement(r);
		return e && (n.className = e), t && (n.innerHTML = t), n
	}

	function Zt(r, e, t, n) {
		let i = ms(e, t, n);
		return r.appendChild(i), i
	}

	function _e(r, e, t) {
		return Zt(r, "div", e, t)
	}

	function li(r) {
		for (; r.firstChild;) r.removeChild(r.firstChild)
	}

	function ao(r, e) {
		e.parentNode.insertBefore(r, e)
	}

	function tg(r, e) {
		e.parentNode.insertBefore(r, e.nextSibling)
	}

	function At(r, e) {
		e ? r.style.display = "block" : r.style.display = "none"
	}

	function Mc(r) {
		return r.offsetParent !== null
	}

	function Bo(r, e) {
		r.style.width = e.toString() + "px"
	}

	function ci(r, e) {
		r.style.height = e.toString() + "px"
	}

	function Go(r) {
		let e = getComputedStyle(r);
		return r.offsetWidth + qn(e.marginLeft) + qn(e.marginRight)
	}

	function Fr(r) {
		let e = getComputedStyle(r);
		return r.offsetHeight + qn(e.marginTop) + qn(e.marginBottom)
	}

	function ng(r, e) {
		let t = getComputedStyle(r);
		Bo(r, e - $m(t))
	}

	function gs(r, e) {
		let t = getComputedStyle(r);
		ci(r, e - Qm(t))
	}

	function ui(r, e) {
		return ms("div", r, e)
	}
	var nt = class {
			constructor(e, t, n) {
				this.r = e, this.g = t, this.b = n
			}
			Set(e, t, n) {
				this.r = e, this.g = t, this.b = n
			}
			Clone() {
				return new nt(this.r, this.g, this.b)
			}
		},
		Qn = class {
			constructor(e, t, n, i) {
				this.r = e, this.g = t, this.b = n, this.a = i
			}
			Set(e, t, n, i) {
				this.r = e, this.g = t, this.b = n, this.a = i
			}
			Clone() {
				return new Qn(this.r, this.g, this.b, this.a)
			}
		};

	function Cn(r) {
		return parseInt(Math.round(r * 255), 10)
	}

	function lo(r) {
		return r / 255
	}

	function Ki(r, e, t) {
		return new nt(Cn(r), Cn(e), Cn(t))
	}

	function vs(r) {
		return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
	}

	function ul(r) {
		return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
	}

	function Fn(r) {
		let e = parseInt(r, 10)
			.toString(16);
		for (; e.length < 2;) e = "0" + e;
		return e
	}

	function Pi(r) {
		let e = Fn(r.r),
			t = Fn(r.g),
			n = Fn(r.b);
		return e + t + n
	}

	function Sf(r) {
		let e = Fn(r.r),
			t = Fn(r.g),
			n = Fn(r.b),
			i = Fn(r.a);
		return e + t + n + i
	}

	function ig(r) {
		return new nt(r[0], r[1], r[2])
	}

	function co(r, e) {
		return r.r === e.r && r.g === e.g && r.b === e.b
	}

	function fn(r) {
		return new TextDecoder("utf-8")
			.decode(r)
	}

	function wc(r) {
		return new TextEncoder()
			.encode(r)
			.buffer
	}

	function hl(r) {
		let e = "data:";
		if (!r.startsWith(e)) return null;
		let t = r.indexOf(";");
		if (t === -1) return null;
		let n = r.indexOf(",");
		if (n === -1) return null;
		let i = r.substring(e.length, e.length + t - 5),
			s = atob(r.substring(n + 1)),
			o = new ArrayBuffer(s.length),
			a = new Uint8Array(o);
		for (let c = 0; c < s.length; c++) a[c] = s.charCodeAt(c);
		return {
			mimeType: i,
			buffer: o
		}
	}

	function Vo(r) {
		if (r == null) return "";
		let e = r.split("/");
		return e.length === 0 ? "" : e[e.length - 1]
	}

	function uo(r) {
		let e = new Blob([r]);
		return URL.createObjectURL(e)
	}

	function rg(r, e) {
		let t = new Blob([r], {
			type: e
		});
		return URL.createObjectURL(t)
	}

	function sg(r) {
		URL.revokeObjectURL(r)
	}

	function og(r, e) {
		let t = null,
			n = s => {
				s.preventDefault();
				let o = s.clientX - t;
				e.onSplit(o)
			},
			i = () => {
				document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", i), document.removeEventListener("mouseleave", i), t = null
			};
		r.addEventListener("mousedown", s => {
			t = s.clientX, e.onSplitStart(), document.addEventListener("mousemove", n), document.addEventListener("mouseup", i), document.addEventListener("mouseleave", i)
		})
	}

	function Ef(r, e) {
		return r.length > 0 ? r : e
	}

	function ag(r) {
		return Ef(r, "No Name")
	}

	function Tc(r) {
		return Ef(r, "No Name")
	}

	function Sc(r) {
		return Ef(r, "No Name")
	}

	function Cf() {
		return window.matchMedia("(hover: hover)")
			.matches
	}

	function lg(r) {
		window.matchMedia("(max-width: 800px)")
			.addEventListener("change", r)
	}

	function cg() {
		return window.matchMedia("(max-width: 800px)")
			.matches
	}

	function Ec(r, e) {
		function t(i, s) {
			let o = window.innerWidth,
				a = i.getBoundingClientRect(),
				c = i.offsetWidth,
				l = i.offsetHeight,
				u = s.offsetWidth,
				h = 10,
				f = a.left + c / 2 - u / 2;
			return f + u > o - h && (f = o - u - h), f < h && (f = h), f = Math.max(f, 0), {
				left: f,
				top: a.top + l + h
			}
		}
		if (!Cf()) return;
		let n = null;
		r.addEventListener("mouseover", () => {
			n = _e(document.body, "ov_tooltip", e);
			let i = t(r, n);
			n.style.left = i.left + "px", n.style.top = i.top + "px"
		}), r.addEventListener("mouseout", () => {
			n.remove()
		})
	}

	function ug(r) {
		let e = document.createElement("input");
		e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.setAttribute("value", r), document.body.appendChild(e), e.select(), document.execCommand("copy"), document.body.removeChild(e)
	}

	function Af(r, e) {
		let t = document.createElement("a");
		t.href = r, t.download = e, document.body.appendChild(t), t.click(), document.body.removeChild(t)
	}

	function If(r, e) {
		let t = uo(r);
		Af(t, e)
	}

	function fl(r, e) {
		let t = ui("ov_svg_icon");
		return e && t.classList.add(e), Zt(t, "i", "icon icon-" + r), t
	}

	function Xn(r, e, t) {
		let n = fl(e, t);
		return r.appendChild(n), n
	}

	function Ur(r, e) {
		let t = r.firstChild;
		t.className = "icon icon-" + e
	}

	function Cc(r) {
		let e = "#" + Pi(r),
			t = new nt(Math.max(0, r.r - 50), Math.max(0, r.g - 50), Math.max(0, r.b - 50)),
			n = "#" + Pi(t),
			i = ui("ov_color_circle");
		return i.style.background = e, i.style.border = "1px solid " + n, i
	}

	function hg(r) {
		return r.r * .299 + r.g * .587 + r.b * .114 > 186
	}

	function Ac(r, e, t, n) {
		let i = null;
		og(r, {
			onSplitStart: () => {
				i = Go(e)
			},
			onSplit: s => {
				let c = 0;
				t ? c = i - s : c = i + s, c < 280 ? c = 280 : c > 450 && (c = 450), ng(e, c), n()
			}
		})
	}

	function fg(r, e) {
		async function t(s, o) {
			let a = s.createReader();
			return new Promise((c, l) => {
				a.readEntries(async u => {
					for (let h of u) h.isFile ? o.push(h) : h.isDirectory && await t(h, o);
					c()
				}, u => {
					l(u)
				})
			})
		}
		async function n(s, o) {
			let a = [];
			for (let l of s) l.isFile ? a.push(l) : l.isDirectory && await t(l, a);
			let c = await Promise.all(a.map(l => new Promise((u, h) => {
				l.file(f => {
					u(f)
				}, f => {
					h(f)
				})
			})));
			o(c)
		}
		let i = null;
		if (DataTransferItem && (DataTransferItem.prototype.getAsEntry ? i = DataTransferItem.prototype.getAsEntry : DataTransferItem.prototype.webkitGetAsEntry && (i = DataTransferItem.prototype.webkitGetAsEntry)), i !== null) {
			let s = [];
			for (let o of r.items) {
				let a = i.call(o);
				a !== null && s.push(a)
			}
			n(s, o => {
				e(o)
			})
		} else e(r.files)
	}

	function dg(r, e, t) {
		let n = Zt(r, "input", e);
		n.setAttribute("type", "text");
		let i = null;
		return n.addEventListener("input", () => {
			n.value = n.value.replace(/[^0-9]/g, ""), t && (i !== null && clearTimeout(i), i = setTimeout(() => {
				t(n.value)
			}, 1e3))
		}), n
	}

	function Ic(r, e, t, n, i) {
		let s = Zt(r, "label");
		s.setAttribute("for", e);
		let o = Zt(s, "input", "ov_checkbox");
		return o.setAttribute("type", "checkbox"), o.setAttribute("id", e), o.checked = n, Zt(s, "span", null, t), i && o.addEventListener("change", i), o
	}

	function pg(r, e, t, n, i, s) {
		let o = Zt(r, "label");
		o.setAttribute("for", e);
		let a = Zt(o, "input", "ov_radio_button");
		return a.setAttribute("type", "radio"), a.setAttribute("id", e), a.setAttribute("name", t), a.checked = i, Zt(o, "span", null, n), s && a.addEventListener("change", s), a
	}

	function mg(r, e, t) {
		let n = Zt(r, "input", "ov_slider");
		return n.setAttribute("type", "range"), n.setAttribute("min", e.toString()), n.setAttribute("max", t.toString()), n
	}

	function gg(r, e, t, n) {
		let i = _e(r, "ov_select_container"),
			s = Zt(i, "select", "ov_select");
		for (let o of e) Zt(s, "option", null, o);
		return s.selectedIndex = t, n && s.addEventListener("change", () => {
			n(s.selectedIndex)
		}), s
	}

	function Rf(r, e) {
		function t(a, c) {
			c ? a.classList.add("on") : a.classList.remove("on")
		}
		let n = !1,
			i = null,
			s = "ov_toggle";
		e && (s += " " + e);
		let o = _e(r, s);
		return _e(o, "ov_toggle_slider"), o.addEventListener("click", () => {
			n = !n, t(o, n), i && i()
		}), {
			element: o,
			GetStatus: () => n,
			SetStatus: a => {
				n = a, t(o, n)
			},
			OnChange: a => {
				i = a
			}
		}
	}
	var Rc = null;

	function vg(r) {
		Rc = r
	}
	function vn(r, e, t){Rc?.(r,e,t)}
	var Le = class {
		constructor(e, t, n) {
			this.x = e, this.y = t, this.z = n
		}
		Length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		}
		MultiplyScalar(e) {
			return this.x *= e, this.y *= e, this.z *= e, this
		}
		Normalize() {
			let e = this.Length();
			return e > 0 && this.MultiplyScalar(1 / e), this
		}
		Offset(e, t) {
			let n = e.Clone()
				.Normalize();
			return this.x += n.x * t, this.y += n.y * t, this.z += n.z * t, this
		}
		Rotate(e, t, n) {
			let i = e.Clone()
				.Normalize(),
				s = i.x,
				o = i.y,
				a = i.z,
				c = this.x - n.x,
				l = this.y - n.y,
				u = this.z - n.z,
				h = Math.sin(t),
				f = Math.cos(t);
			return this.x = -s * (-s * c - o * l - a * u) * (1 - f) + c * f + (-a * l + o * u) * h, this.y = -o * (-s * c - o * l - a * u) * (1 - f) + l * f + (a * c - s * u) * h, this.z = -a * (-s * c - o * l - a * u) * (1 - f) + u * f + (-o * c + s * l) * h, this.x += n.x, this.y += n.y, this.z += n.z, this
		}
		Clone() {
			return new Le(this.x, this.y, this.z)
		}
	};

	function Ji(r, e) {
		return Yt(r.x, e.x) && Yt(r.y, e.y) && Yt(r.z, e.z)
	}

	function xg(r, e) {
		return new Le(r.x + e.x, r.y + e.y, r.z + e.z)
	}

	function Un(r, e) {
		return new Le(r.x - e.x, r.y - e.y, r.z - e.z)
	}

	function Mi(r, e) {
		return Math.sqrt((r.x - e.x) * (r.x - e.x) + (r.y - e.y) * (r.y - e.y) + (r.z - e.z) * (r.z - e.z))
	}

	function Pf(r, e) {
		return r.x * e.x + r.y * e.y + r.z * e.z
	}

	function yg(r, e) {
		let t = r.Clone()
			.Normalize(),
			n = e.Clone()
			.Normalize();
		if (Ji(t, n)) return 0;
		let i = Pf(t, n);
		return Math.acos(i)
	}

	function Br(r, e) {
		let t = new Le(0, 0, 0);
		return t.x = r.y * e.z - r.z * e.y, t.y = r.z * e.x - r.x * e.z, t.z = r.x * e.y - r.y * e.x, t
	}

	function Pc(r, e, t) {
		return Math.sqrt(r * r + e * e + t * t)
	}

	function Gr(r) {
		return new Le(r[0], r[1], r[2])
	}
	var xr = class {
		constructor(e, t, n, i) {
			this.eye = e, this.center = t, this.up = n, this.fov = i
		}
		Clone() {
			return new xr(this.eye.Clone(), this.center.Clone(), this.up.Clone(), this.fov)
		}
	};

	function _g(r, e) {
		return Ji(r.eye, e.eye) && Ji(r.center, e.center) && Ji(r.up, e.up) && Yt(r.fov, e.fov)
	}
	var Li = class {
		constructor() {
			this.name = null, this.mimeType = null, this.buffer = null, this.offset = new Rt(0, 0), this.scale = new Rt(1, 1), this.rotation = 0
		}
		IsValid() {
			return this.name !== null && this.buffer !== null
		}
		HasTransformation() {
			return !so(this.offset, new Rt(0, 0)) || !so(this.scale, new Rt(1, 1)) || !Yt(this.rotation, 0)
		}
		IsEqual(e) {
			return !(this.name !== e.name || this.mimeType !== e.mimeType || !so(this.offset, e.offset) || !so(this.scale, e.scale) || !Yt(this.rotation, e.rotation))
		}
	};

	function zo(r, e) {
		return r === null && e === null ? !0 : r === null || e === null ? !1 : r.IsEqual(e)
	}
	var on = {
			Phong: 1,
			Physical: 2
		},
		Lf = class {
			constructor(e) {
				this.type = e, this.isDefault = !1, this.name = "", this.color = new nt(0, 0, 0), this.vertexColors = !1
			}
			IsEqual(e) {
				return !(this.type !== e.type || this.isDefault !== e.isDefault || this.name !== e.name || !co(this.color, e.color) || this.vertexColors !== e.vertexColors)
			}
		},
		Lc = class extends Lf {
			constructor(e) {
				super(e), this.emissive = new nt(0, 0, 0), this.opacity = 1, this.transparent = !1, this.diffuseMap = null, this.bumpMap = null, this.normalMap = null, this.emissiveMap = null, this.alphaTest = 0, this.multiplyDiffuseMap = !1
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !co(this.emissive, e.emissive) || !Yt(this.opacity, e.opacity) || this.transparent !== e.transparent || !zo(this.diffuseMap, e.diffuseMap) || !zo(this.bumpMap, e.bumpMap) || !zo(this.normalMap, e.normalMap) || !zo(this.emissiveMap, e.emissiveMap) || !Yt(this.alphaTest, e.alphaTest) || this.multiplyDiffuseMap !== e.multiplyDiffuseMap)
			}
		},
		An = class extends Lc {
			constructor() {
				super(on.Phong), this.ambient = new nt(0, 0, 0), this.specular = new nt(0, 0, 0), this.shininess = 0, this.specularMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !co(this.ambient, e.ambient) || !co(this.specular, e.specular) || !Yt(this.shininess, e.shininess) || !zo(this.specularMap, e.specularMap))
			}
		},
		xs = class extends Lc {
			constructor() {
				super(on.Physical), this.metalness = 0, this.roughness = 1, this.metalnessMap = null
			}
			IsEqual(e) {
				return !(!super.IsEqual(e) || !Yt(this.metalness, e.metalness) || !Yt(this.roughness, e.roughness) || !zo(this.metalnessMap, e.metalnessMap))
			}
		};
	var Nf = class {
			constructor() {}
			VertexCount() {
				return 0
			}
			VertexColorCount() {
				return 0
			}
			NormalCount() {
				return 0
			}
			TextureUVCount() {
				return 0
			}
			TriangleCount() {
				return 0
			}
			EnumerateVertices(e) {}
			EnumerateTriangleVertexIndices(e) {}
			EnumerateTriangleVertices(e) {}
		},
		ys = class extends Nf {
			constructor() {
				super(), this.name = "", this.propertyGroups = []
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			PropertyGroupCount() {
				return this.propertyGroups.length
			}
			AddPropertyGroup(e) {
				return this.propertyGroups.push(e), this.propertyGroups.length - 1
			}
			GetPropertyGroup(e) {
				return this.propertyGroups[e]
			}
			CloneProperties(e) {
				for (let t of this.propertyGroups) e.AddPropertyGroup(t.Clone())
			}
		};
	var Qt = class extends ys {
		constructor() {
			super(), this.vertices = [], this.vertexColors = [], this.normals = [], this.uvs = [], this.triangles = []
		}
		VertexCount() {
			return this.vertices.length
		}
		VertexColorCount() {
			return this.vertexColors.length
		}
		NormalCount() {
			return this.normals.length
		}
		TextureUVCount() {
			return this.uvs.length
		}
		TriangleCount() {
			return this.triangles.length
		}
		AddVertex(e) {
			return this.vertices.push(e), this.vertices.length - 1
		}
		SetVertex(e, t) {
			this.vertices[e] = t
		}
		GetVertex(e) {
			return this.vertices[e]
		}
		AddVertexColor(e) {
			return this.vertexColors.push(e), this.vertexColors.length - 1
		}
		SetVertexColor(e, t) {
			this.vertexColors[e] = t
		}
		GetVertexColor(e) {
			return this.vertexColors[e]
		}
		AddNormal(e) {
			return this.normals.push(e), this.normals.length - 1
		}
		SetNormal(e, t) {
			this.normals[e] = t
		}
		GetNormal(e) {
			return this.normals[e]
		}
		AddTextureUV(e) {
			return this.uvs.push(e), this.uvs.length - 1
		}
		SetTextureUV(e, t) {
			this.uvs[e] = t
		}
		GetTextureUV(e) {
			return this.uvs[e]
		}
		AddTriangle(e) {
			return this.triangles.push(e), this.triangles.length - 1
		}
		GetTriangle(e) {
			return this.triangles[e]
		}
		EnumerateVertices(e) {
			for (let t of this.vertices) e(t)
		}
		EnumerateTriangleVertexIndices(e) {
			for (let t of this.triangles) e(t.v0, t.v1, t.v2)
		}
		EnumerateTriangleVertices(e) {
			for (let t of this.triangles) {
				let n = this.vertices[t.v0],
					i = this.vertices[t.v1],
					s = this.vertices[t.v2];
				e(n, i, s)
			}
		}
		Clone() {
			let e = new Qt;
			e.SetName(this.GetName()), this.CloneProperties(e);
			for (let t = 0; t < this.VertexCount(); t++) {
				let n = this.GetVertex(t);
				e.AddVertex(n.Clone())
			}
			for (let t = 0; t < this.VertexColorCount(); t++) {
				let n = this.GetVertexColor(t);
				e.AddVertexColor(n.Clone())
			}
			for (let t = 0; t < this.NormalCount(); t++) {
				let n = this.GetNormal(t);
				e.AddNormal(n.Clone())
			}
			for (let t = 0; t < this.TextureUVCount(); t++) {
				let n = this.GetTextureUV(t);
				e.AddTextureUV(n.Clone())
			}
			for (let t = 0; t < this.TriangleCount(); t++) {
				let n = this.GetTriangle(t);
				e.AddTriangle(n.Clone())
			}
			return e
		}
	};
	var qt = class {
		constructor(e, t, n) {
			this.v0 = e, this.v1 = t, this.v2 = n, this.c0 = null, this.c1 = null, this.c2 = null, this.n0 = null, this.n1 = null, this.n2 = null, this.u0 = null, this.u1 = null, this.u2 = null, this.mat = null, this.curve = null
		}
		HasVertices() {
			return this.v0 !== null && this.v1 !== null && this.v2 !== null
		}
		HasVertexColors() {
			return this.c0 !== null && this.c1 !== null && this.c2 !== null
		}
		HasNormals() {
			return this.n0 !== null && this.n1 !== null && this.n2 !== null
		}
		HasTextureUVs() {
			return this.u0 !== null && this.u1 !== null && this.u2 !== null
		}
		SetVertices(e, t, n) {
			return this.v0 = e, this.v1 = t, this.v2 = n, this
		}
		SetVertexColors(e, t, n) {
			return this.c0 = e, this.c1 = t, this.c2 = n, this
		}
		SetNormals(e, t, n) {
			return this.n0 = e, this.n1 = t, this.n2 = n, this
		}
		SetTextureUVs(e, t, n) {
			return this.u0 = e, this.u1 = t, this.u2 = n, this
		}
		SetMaterial(e) {
			return this.mat = e, this
		}
		SetCurve(e) {
			return this.curve = e, this
		}
		Clone() {
			let e = new qt(this.v0, this.v1, this.v2);
			return e.SetVertexColors(this.c0, this.c1, this.c2), e.SetNormals(this.n0, this.n1, this.n2), e.SetTextureUVs(this.u0, this.u1, this.u2), e.SetMaterial(this.mat), e.SetCurve(this.curve), e
		}
	};
	var qd = "145";
	var wy = 0,
		bg = 1,
		Ty = 2;
	var ev = 1,
		Sy = 2,
		vl = 3,
		_r = 0,
		Rn = 1,
		Bn = 2,
		Is = 0,
		oa = 1,
		Mg = 2,
		wg = 3,
		Tg = 4,
		Ey = 5,
		ia = 100,
		Cy = 101,
		Ay = 102,
		Sg = 103,
		Eg = 104,
		Iy = 200,
		Ry = 201,
		Py = 202,
		Ly = 203,
		tv = 204,
		nv = 205,
		Ny = 206,
		Dy = 207,
		Oy = 208,
		ky = 209,
		Fy = 210,
		Uy = 0,
		By = 1,
		Gy = 2,
		pd = 3,
		Vy = 4,
		zy = 5,
		Hy = 6,
		Wy = 7,
		Eu = 0,
		jy = 1,
		qy = 2,
		Yr = 0,
		Xy = 1,
		Yy = 2,
		Zy = 3,
		Ky = 4,
		Jy = 5,
		iv = 300,
		ua = 301,
		ha = 302,
		Ml = 303,
		md = 304,
		Cu = 306,
		en = 1e3,
		Xt = 1001,
		fa = 1002,
		yn = 1003,
		Cg = 1004;
	var Ag = 1005;
	var pn = 1006,
		$y = 1007;
	var Er = 1008;
	var bo = 1009,
		Qy = 1010,
		e_ = 1011,
		rv = 1012,
		t_ = 1013,
		vo = 1014,
		As = 1015,
		wl = 1016,
		n_ = 1017,
		i_ = 1018,
		aa = 1020,
		r_ = 1021,
		s_ = 1022,
		ir = 1023,
		o_ = 1024,
		a_ = 1025,
		yo = 1026,
		da = 1027,
		l_ = 1028,
		c_ = 1029,
		u_ = 1030,
		h_ = 1031,
		f_ = 1033,
		Df = 33776,
		Of = 33777,
		kf = 33778,
		Ff = 33779,
		Ig = 35840,
		Rg = 35841,
		Pg = 35842,
		Lg = 35843,
		d_ = 36196,
		Ng = 37492,
		Dg = 37496,
		Og = 37808,
		kg = 37809,
		Fg = 37810,
		Ug = 37811,
		Bg = 37812,
		Gg = 37813,
		Vg = 37814,
		zg = 37815,
		Hg = 37816,
		Wg = 37817,
		jg = 37818,
		qg = 37819,
		Xg = 37820,
		Yg = 37821,
		Zg = 36492;
	var cu = 2300,
		uu = 2301,
		Uf = 2302,
		Kg = 2400,
		Jg = 2401,
		$g = 2402,
		p_ = 2500;
	var Mo = 3e3,
		Pt = 3001,
		m_ = 3200,
		g_ = 3201,
		Au = 0,
		v_ = 1;
	var Xr = "srgb",
		xo = "srgb-linear";
	var Bf = 7680;
	var x_ = 519,
		Qg = 35044;
	var e0 = "300 es",
		gd = 1035,
		Rs = class {
			addEventListener(e, t) {
				this._listeners === void 0 && (this._listeners = {});
				let n = this._listeners;
				n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
			}
			hasEventListener(e, t) {
				if (this._listeners === void 0) return !1;
				let n = this._listeners;
				return n[e] !== void 0 && n[e].indexOf(t) !== -1
			}
			removeEventListener(e, t) {
				if (this._listeners === void 0) return;
				let i = this._listeners[e];
				if (i !== void 0) {
					let s = i.indexOf(t);
					s !== -1 && i.splice(s, 1)
				}
			}
			dispatchEvent(e) {
				if (this._listeners === void 0) return;
				let n = this._listeners[e.type];
				if (n !== void 0) {
					e.target = this;
					let i = n.slice(0);
					for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
					e.target = null
				}
			}
		},
		Yn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
		t0 = 1234567,
		la = Math.PI / 180,
		Tl = 180 / Math.PI;

	function Gs() {
		let r = Math.random() * 4294967295 | 0,
			e = Math.random() * 4294967295 | 0,
			t = Math.random() * 4294967295 | 0,
			n = Math.random() * 4294967295 | 0;
		return (Yn[r & 255] + Yn[r >> 8 & 255] + Yn[r >> 16 & 255] + Yn[r >> 24 & 255] + "-" + Yn[e & 255] + Yn[e >> 8 & 255] + "-" + Yn[e >> 16 & 15 | 64] + Yn[e >> 24 & 255] + "-" + Yn[t & 63 | 128] + Yn[t >> 8 & 255] + "-" + Yn[t >> 16 & 255] + Yn[t >> 24 & 255] + Yn[n & 255] + Yn[n >> 8 & 255] + Yn[n >> 16 & 255] + Yn[n >> 24 & 255])
			.toLowerCase()
	}

	function Kn(r, e, t) {
		return Math.max(e, Math.min(t, r))
	}

	function Xd(r, e) {
		return (r % e + e) % e
	}

	function y_(r, e, t, n, i) {
		return n + (r - e) * (i - n) / (t - e)
	}

	function __(r, e, t) {
		return r !== e ? (t - r) / (e - r) : 0
	}

	function _l(r, e, t) {
		return (1 - t) * r + t * e
	}

	function b_(r, e, t, n) {
		return _l(r, e, 1 - Math.exp(-t * n))
	}

	function M_(r, e = 1) {
		return e - Math.abs(Xd(r, e * 2) - e)
	}

	function w_(r, e, t) {
		return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r))
	}

	function T_(r, e, t) {
		return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10))
	}

	function S_(r, e) {
		return r + Math.floor(Math.random() * (e - r + 1))
	}

	function E_(r, e) {
		return r + Math.random() * (e - r)
	}

	function C_(r) {
		return r * (.5 - Math.random())
	}

	function A_(r) {
		r !== void 0 && (t0 = r);
		let e = t0 += 1831565813;
		return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
	}

	function I_(r) {
		return r * la
	}

	function R_(r) {
		return r * Tl
	}

	function vd(r) {
		return (r & r - 1) === 0 && r !== 0
	}

	function sv(r) {
		return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
	}

	function hu(r) {
		return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
	}

	function P_(r, e, t, n, i) {
		let s = Math.cos,
			o = Math.sin,
			a = s(t / 2),
			c = o(t / 2),
			l = s((e + n) / 2),
			u = o((e + n) / 2),
			h = s((e - n) / 2),
			f = o((e - n) / 2),
			p = s((n - e) / 2),
			g = o((n - e) / 2);
		switch (i) {
			case "XYX":
				r.set(a * u, c * h, c * f, a * l);
				break;
			case "YZY":
				r.set(c * f, a * u, c * h, a * l);
				break;
			case "ZXZ":
				r.set(c * h, c * f, a * u, a * l);
				break;
			case "XZX":
				r.set(a * u, c * g, c * p, a * l);
				break;
			case "YXY":
				r.set(c * p, a * u, c * g, a * l);
				break;
			case "ZYZ":
				r.set(c * g, c * p, a * u, a * l);
				break;
			default:
				console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
		}
	}

	function xl(r, e) {
		switch (e.constructor) {
			case Float32Array:
				return r;
			case Uint16Array:
				return r / 65535;
			case Uint8Array:
				return r / 255;
			case Int16Array:
				return Math.max(r / 32767, -1);
			case Int8Array:
				return Math.max(r / 127, -1);
			default:
				throw new Error("Invalid component type.")
		}
	}

	function hi(r, e) {
		switch (e.constructor) {
			case Float32Array:
				return r;
			case Uint16Array:
				return Math.round(r * 65535);
			case Uint8Array:
				return Math.round(r * 255);
			case Int16Array:
				return Math.round(r * 32767);
			case Int8Array:
				return Math.round(r * 127);
			default:
				throw new Error("Invalid component type.")
		}
	}
	var Vn = Object.freeze({
			__proto__: null,
			DEG2RAD: la,
			RAD2DEG: Tl,
			generateUUID: Gs,
			clamp: Kn,
			euclideanModulo: Xd,
			mapLinear: y_,
			inverseLerp: __,
			lerp: _l,
			damp: b_,
			pingpong: M_,
			smoothstep: w_,
			smootherstep: T_,
			randInt: S_,
			randFloat: E_,
			randFloatSpread: C_,
			seededRandom: A_,
			degToRad: I_,
			radToDeg: R_,
			isPowerOfTwo: vd,
			ceilPowerOfTwo: sv,
			floorPowerOfTwo: hu,
			setQuaternionFromProperEuler: P_,
			normalize: hi,
			denormalize: xl
		}),
		st = class {
			constructor(e = 0, t = 0) {
				st.prototype.isVector2 = !0, this.x = e, this.y = t
			}
			get width() {
				return this.x
			}
			set width(e) {
				this.x = e
			}
			get height() {
				return this.y
			}
			set height(e) {
				this.y = e
			}
			set(e, t) {
				return this.x = e, this.y = t, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this
			}
			divide(e) {
				return this.x /= e.x, this.y /= e.y, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			applyMatrix3(e) {
				let t = this.x,
					n = this.y,
					i = e.elements;
				return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1)
					.multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y
			}
			cross(e) {
				return this.x * e.y - this.y * e.x
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			angle() {
				return Math.atan2(-this.y, -this.x) + Math.PI
			}
			distanceTo(e) {
				return Math.sqrt(this.distanceToSquared(e))
			}
			distanceToSquared(e) {
				let t = this.x - e.x,
					n = this.y - e.y;
				return t * t + n * n
			}
			manhattanDistanceTo(e) {
				return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
			}
			setLength(e) {
				return this.normalize()
					.multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this
			}
			rotateAround(e, t) {
				let n = Math.cos(t),
					i = Math.sin(t),
					s = this.x - e.x,
					o = this.y - e.y;
				return this.x = s * n - o * i + e.x, this.y = s * i + o * n + e.y, this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y
			}
		},
		Jn = class {
			constructor() {
				Jn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
			}
			set(e, t, n, i, s, o, a, c, l) {
				let u = this.elements;
				return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = s, u[5] = c, u[6] = n, u[7] = o, u[8] = l, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
			}
			copy(e) {
				let t = this.elements,
					n = e.elements;
				return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
			}
			extractBasis(e, t, n) {
				return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
			}
			setFromMatrix4(e) {
				let t = e.elements;
				return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
			}
			multiply(e) {
				return this.multiplyMatrices(this, e)
			}
			premultiply(e) {
				return this.multiplyMatrices(e, this)
			}
			multiplyMatrices(e, t) {
				let n = e.elements,
					i = t.elements,
					s = this.elements,
					o = n[0],
					a = n[3],
					c = n[6],
					l = n[1],
					u = n[4],
					h = n[7],
					f = n[2],
					p = n[5],
					g = n[8],
					m = i[0],
					d = i[3],
					v = i[6],
					x = i[1],
					_ = i[4],
					y = i[7],
					w = i[2],
					C = i[5],
					S = i[8];
				return s[0] = o * m + a * x + c * w, s[3] = o * d + a * _ + c * C, s[6] = o * v + a * y + c * S, s[1] = l * m + u * x + h * w, s[4] = l * d + u * _ + h * C, s[7] = l * v + u * y + h * S, s[2] = f * m + p * x + g * w, s[5] = f * d + p * _ + g * C, s[8] = f * v + p * y + g * S, this
			}
			multiplyScalar(e) {
				let t = this.elements;
				return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
			}
			determinant() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					c = e[6],
					l = e[7],
					u = e[8];
				return t * o * u - t * a * l - n * s * u + n * a * c + i * s * l - i * o * c
			}
			invert() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					c = e[6],
					l = e[7],
					u = e[8],
					h = u * o - a * l,
					f = a * c - u * s,
					p = l * s - o * c,
					g = t * h + n * f + i * p;
				if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let m = 1 / g;
				return e[0] = h * m, e[1] = (i * l - u * n) * m, e[2] = (a * n - i * o) * m, e[3] = f * m, e[4] = (u * t - i * c) * m, e[5] = (i * s - a * t) * m, e[6] = p * m, e[7] = (n * c - l * t) * m, e[8] = (o * t - n * s) * m, this
			}
			transpose() {
				let e, t = this.elements;
				return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
			}
			getNormalMatrix(e) {
				return this.setFromMatrix4(e)
					.invert()
					.transpose()
			}
			transposeIntoArray(e) {
				let t = this.elements;
				return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
			}
			setUvTransform(e, t, n, i, s, o, a) {
				let c = Math.cos(s),
					l = Math.sin(s);
				return this.set(n * c, n * l, -n * (c * o + l * a) + o + e, -i * l, i * c, -i * (-l * o + c * a) + a + t, 0, 0, 1), this
			}
			scale(e, t) {
				let n = this.elements;
				return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
			}
			rotate(e) {
				let t = Math.cos(e),
					n = Math.sin(e),
					i = this.elements,
					s = i[0],
					o = i[3],
					a = i[6],
					c = i[1],
					l = i[4],
					u = i[7];
				return i[0] = t * s + n * c, i[3] = t * o + n * l, i[6] = t * a + n * u, i[1] = -n * s + t * c, i[4] = -n * o + t * l, i[7] = -n * a + t * u, this
			}
			translate(e, t) {
				let n = this.elements;
				return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
			}
			equals(e) {
				let t = this.elements,
					n = e.elements;
				for (let i = 0; i < 9; i++)
					if (t[i] !== n[i]) return !1;
				return !0
			}
			fromArray(e, t = 0) {
				for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
				return this
			}
			toArray(e = [], t = 0) {
				let n = this.elements;
				return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
			}
			clone() {
				return new this.constructor()
					.fromArray(this.elements)
			}
		};

	function ov(r) {
		for (let e = r.length - 1; e >= 0; --e)
			if (r[e] >= 65535) return !0;
		return !1
	}

	function Sl(r) {
		return document.createElementNS("http://www.w3.org/1999/xhtml", r)
	}

	function _o(r) {
		return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
	}

	function lu(r) {
		return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
	}
	var Gf = {
			[Xr]: {
				[xo]: _o
			},
			[xo]: {
				[Xr]: lu
			}
		},
		$i = {
			legacyMode: !0,
			get workingColorSpace() {
				return xo
			},
			set workingColorSpace(r) {
				console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
			},
			convert: function(r, e, t) {
				if (this.legacyMode || e === t || !e || !t) return r;
				if (Gf[e] && Gf[e][t] !== void 0) {
					let n = Gf[e][t];
					return r.r = n(r.r), r.g = n(r.g), r.b = n(r.b), r
				}
				throw new Error("Unsupported color space conversion.")
			},
			fromWorkingColorSpace: function(r, e) {
				return this.convert(r, this.workingColorSpace, e)
			},
			toWorkingColorSpace: function(r, e) {
				return this.convert(r, e, this.workingColorSpace)
			}
		},
		av = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		},
		xn = {
			r: 0,
			g: 0,
			b: 0
		},
		Qi = {
			h: 0,
			s: 0,
			l: 0
		},
		Nc = {
			h: 0,
			s: 0,
			l: 0
		};

	function Vf(r, e, t) {
		return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
	}

	function Dc(r, e) {
		return e.r = r.r, e.g = r.g, e.b = r.b, e
	}
	var Xe = class {
		constructor(e, t, n) {
			return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
		}
		set(e) {
			return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this
		}
		setScalar(e) {
			return this.r = e, this.g = e, this.b = e, this
		}
		setHex(e, t = Xr) {
			return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, $i.toWorkingColorSpace(this, t), this
		}
		setRGB(e, t, n, i = xo) {
			return this.r = e, this.g = t, this.b = n, $i.toWorkingColorSpace(this, i), this
		}
		setHSL(e, t, n, i = xo) {
			if (e = Xd(e, 1), t = Kn(t, 0, 1), n = Kn(n, 0, 1), t === 0) this.r = this.g = this.b = n;
			else {
				let s = n <= .5 ? n * (1 + t) : n + t - n * t,
					o = 2 * n - s;
				this.r = Vf(o, s, e + 1 / 3), this.g = Vf(o, s, e), this.b = Vf(o, s, e - 1 / 3)
			}
			return $i.toWorkingColorSpace(this, i), this
		}
		setStyle(e, t = Xr) {
			function n(s) {
				s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
			}
			let i;
			if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
				let s, o = i[1],
					a = i[2];
				switch (o) {
					case "rgb":
					case "rgba":
						if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, $i.toWorkingColorSpace(this, t), n(s[4]), this;
						if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, $i.toWorkingColorSpace(this, t), n(s[4]), this;
						break;
					case "hsl":
					case "hsla":
						if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
							let c = parseFloat(s[1]) / 360,
								l = parseFloat(s[2]) / 100,
								u = parseFloat(s[3]) / 100;
							return n(s[4]), this.setHSL(c, l, u, t)
						}
						break
				}
			} else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
				let s = i[1],
					o = s.length;
				if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, $i.toWorkingColorSpace(this, t), this;
				if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, $i.toWorkingColorSpace(this, t), this
			}
			return e && e.length > 0 ? this.setColorName(e, t) : this
		}
		setColorName(e, t = Xr) {
			let n = av[e.toLowerCase()];
			return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
		}
		clone() {
			return new this.constructor(this.r, this.g, this.b)
		}
		copy(e) {
			return this.r = e.r, this.g = e.g, this.b = e.b, this
		}
		copySRGBToLinear(e) {
			return this.r = _o(e.r), this.g = _o(e.g), this.b = _o(e.b), this
		}
		copyLinearToSRGB(e) {
			return this.r = lu(e.r), this.g = lu(e.g), this.b = lu(e.b), this
		}
		convertSRGBToLinear() {
			return this.copySRGBToLinear(this), this
		}
		convertLinearToSRGB() {
			return this.copyLinearToSRGB(this), this
		}
		getHex(e = Xr) {
			return $i.fromWorkingColorSpace(Dc(this, xn), e), Kn(xn.r * 255, 0, 255) << 16 ^ Kn(xn.g * 255, 0, 255) << 8 ^ Kn(xn.b * 255, 0, 255) << 0
		}
		getHexString(e = Xr) {
			return ("000000" + this.getHex(e)
					.toString(16))
				.slice(-6)
		}
		getHSL(e, t = xo) {
			$i.fromWorkingColorSpace(Dc(this, xn), t);
			let n = xn.r,
				i = xn.g,
				s = xn.b,
				o = Math.max(n, i, s),
				a = Math.min(n, i, s),
				c, l, u = (a + o) / 2;
			if (a === o) c = 0, l = 0;
			else {
				let h = o - a;
				switch (l = u <= .5 ? h / (o + a) : h / (2 - o - a), o) {
					case n:
						c = (i - s) / h + (i < s ? 6 : 0);
						break;
					case i:
						c = (s - n) / h + 2;
						break;
					case s:
						c = (n - i) / h + 4;
						break
				}
				c /= 6
			}
			return e.h = c, e.s = l, e.l = u, e
		}
		getRGB(e, t = xo) {
			return $i.fromWorkingColorSpace(Dc(this, xn), t), e.r = xn.r, e.g = xn.g, e.b = xn.b, e
		}
		getStyle(e = Xr) {
			return $i.fromWorkingColorSpace(Dc(this, xn), e), e !== Xr ? `color(${e} ${xn.r} ${xn.g} ${xn.b})` : `rgb(${xn.r*255|0},${xn.g*255|0},${xn.b*255|0})`
		}
		offsetHSL(e, t, n) {
			return this.getHSL(Qi), Qi.h += e, Qi.s += t, Qi.l += n, this.setHSL(Qi.h, Qi.s, Qi.l), this
		}
		add(e) {
			return this.r += e.r, this.g += e.g, this.b += e.b, this
		}
		addColors(e, t) {
			return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
		}
		addScalar(e) {
			return this.r += e, this.g += e, this.b += e, this
		}
		sub(e) {
			return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
		}
		multiply(e) {
			return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
		}
		multiplyScalar(e) {
			return this.r *= e, this.g *= e, this.b *= e, this
		}
		lerp(e, t) {
			return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
		}
		lerpColors(e, t, n) {
			return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
		}
		lerpHSL(e, t) {
			this.getHSL(Qi), e.getHSL(Nc);
			let n = _l(Qi.h, Nc.h, t),
				i = _l(Qi.s, Nc.s, t),
				s = _l(Qi.l, Nc.l, t);
			return this.setHSL(n, i, s), this
		}
		equals(e) {
			return e.r === this.r && e.g === this.g && e.b === this.b
		}
		fromArray(e, t = 0) {
			return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
		}
		toArray(e = [], t = 0) {
			return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
		}
		fromBufferAttribute(e, t) {
			return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
		}
		toJSON() {
			return this.getHex()
		}*[Symbol.iterator]() {
			yield this.r, yield this.g, yield this.b
		}
	};
	Xe.NAMES = av;
	var Ho, wo = class {
			static getDataURL(e) {
				if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
				let t;
				if (e instanceof HTMLCanvasElement) t = e;
				else {
					Ho === void 0 && (Ho = Sl("canvas")), Ho.width = e.width, Ho.height = e.height;
					let n = Ho.getContext("2d");
					e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ho
				}
				return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
			}
			static sRGBToLinear(e) {
				if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
					let t = Sl("canvas");
					t.width = e.width, t.height = e.height;
					let n = t.getContext("2d");
					n.drawImage(e, 0, 0, e.width, e.height);
					let i = n.getImageData(0, 0, e.width, e.height),
						s = i.data;
					for (let o = 0; o < s.length; o++) s[o] = _o(s[o] / 255) * 255;
					return n.putImageData(i, 0, 0), t
				} else if (e.data) {
					let t = e.data.slice(0);
					for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(_o(t[n] / 255) * 255) : t[n] = _o(t[n]);
					return {
						data: t,
						width: e.width,
						height: e.height
					}
				} else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
			}
		},
		fu = class {
			constructor(e = null) {
				this.isSource = !0, this.uuid = Gs(), this.data = e, this.version = 0
			}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
				let n = {
						uuid: this.uuid,
						url: ""
					},
					i = this.data;
				if (i !== null) {
					let s;
					if (Array.isArray(i)) {
						s = [];
						for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? s.push(zf(i[o].image)) : s.push(zf(i[o]))
					} else s = zf(i);
					n.url = s
				}
				return t || (e.images[this.uuid] = n), n
			}
		};

	function zf(r) {
		return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? wo.getDataURL(r) : r.data ? {
			data: Array.from(r.data),
			width: r.width,
			height: r.height,
			type: r.data.constructor.name
		} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
	}
	var L_ = 0,
		Pn = class extends Rs {
			constructor(e = Pn.DEFAULT_IMAGE, t = Pn.DEFAULT_MAPPING, n = Xt, i = Xt, s = pn, o = Er, a = ir, c = bo, l = 1, u = Mo) {
				super(), this.isTexture = !0, Object.defineProperty(this, "id", {
					value: L_++
				}), this.uuid = Gs(), this.name = "", this.source = new fu(e), this.mipmaps = [], this.mapping = t, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = l, this.format = a, this.internalFormat = null, this.type = c, this.offset = new st(0, 0), this.repeat = new st(1, 1), this.center = new st(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Jn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
			}
			get image() {
				return this.source.data
			}
			set image(e) {
				this.source.data = e
			}
			updateMatrix() {
				this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
				let n = {
					metadata: {
						version: 4.5,
						type: "Texture",
						generator: "Texture.toJSON"
					},
					uuid: this.uuid,
					name: this.name,
					image: this.source.toJSON(e)
						.uuid,
					mapping: this.mapping,
					repeat: [this.repeat.x, this.repeat.y],
					offset: [this.offset.x, this.offset.y],
					center: [this.center.x, this.center.y],
					rotation: this.rotation,
					wrap: [this.wrapS, this.wrapT],
					format: this.format,
					type: this.type,
					encoding: this.encoding,
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
					flipY: this.flipY,
					premultiplyAlpha: this.premultiplyAlpha,
					unpackAlignment: this.unpackAlignment
				};
				return JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			transformUv(e) {
				if (this.mapping !== iv) return e;
				if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
					case en:
						e.x = e.x - Math.floor(e.x);
						break;
					case Xt:
						e.x = e.x < 0 ? 0 : 1;
						break;
					case fa:
						Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
						break
				}
				if (e.y < 0 || e.y > 1) switch (this.wrapT) {
					case en:
						e.y = e.y - Math.floor(e.y);
						break;
					case Xt:
						e.y = e.y < 0 ? 0 : 1;
						break;
					case fa:
						Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
						break
				}
				return this.flipY && (e.y = 1 - e.y), e
			}
			set needsUpdate(e) {
				e === !0 && (this.version++, this.source.needsUpdate = !0)
			}
		};
	Pn.DEFAULT_IMAGE = null;
	Pn.DEFAULT_MAPPING = iv;
	var wt = class {
			constructor(e = 0, t = 0, n = 0, i = 1) {
				wt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
			}
			get width() {
				return this.z
			}
			set width(e) {
				this.z = e
			}
			get height() {
				return this.w
			}
			set height(e) {
				this.w = e
			}
			set(e, t, n, i) {
				return this.x = e, this.y = t, this.z = n, this.w = i, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this.z = e, this.w = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setZ(e) {
				return this.z = e, this
			}
			setW(e) {
				return this.w = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					case 2:
						this.z = t;
						break;
					case 3:
						this.w = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					case 3:
						return this.w;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z, this.w)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this.z += e, this.w += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
			}
			applyMatrix4(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = this.w,
					o = e.elements;
				return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			setAxisAngleFromQuaternion(e) {
				this.w = 2 * Math.acos(e.w);
				let t = Math.sqrt(1 - e.w * e.w);
				return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
			}
			setAxisAngleFromRotationMatrix(e) {
				let t, n, i, s, c = e.elements,
					l = c[0],
					u = c[4],
					h = c[8],
					f = c[1],
					p = c[5],
					g = c[9],
					m = c[2],
					d = c[6],
					v = c[10];
				if (Math.abs(u - f) < .01 && Math.abs(h - m) < .01 && Math.abs(g - d) < .01) {
					if (Math.abs(u + f) < .1 && Math.abs(h + m) < .1 && Math.abs(g + d) < .1 && Math.abs(l + p + v - 3) < .1) return this.set(1, 0, 0, 0), this;
					t = Math.PI;
					let _ = (l + 1) / 2,
						y = (p + 1) / 2,
						w = (v + 1) / 2,
						C = (u + f) / 4,
						S = (h + m) / 4,
						b = (g + d) / 4;
					return _ > y && _ > w ? _ < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(_), i = C / n, s = S / n) : y > w ? y < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(y), n = C / i, s = b / i) : w < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(w), n = S / s, i = b / s), this.set(n, i, s, t), this
				}
				let x = Math.sqrt((d - g) * (d - g) + (h - m) * (h - m) + (f - u) * (f - u));
				return Math.abs(x) < .001 && (x = 1), this.x = (d - g) / x, this.y = (h - m) / x, this.z = (f - u) / x, this.w = Math.acos((l + p + v - 1) / 2), this
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1)
					.multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(e) {
				return this.normalize()
					.multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z, yield this.w
			}
		},
		Zr = class extends Rs {
			constructor(e, t, n = {}) {
				super(), this.isWebGLRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new wt(0, 0, e, t), this.scissorTest = !1, this.viewport = new wt(0, 0, e, t);
				let i = {
					width: e,
					height: t,
					depth: 1
				};
				this.texture = new Pn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : pn, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0
			}
			setSize(e, t, n = 1) {
				(this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
				let t = Object.assign({}, e.texture.image);
				return this.texture.source = new fu(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		du = class extends Pn {
			constructor(e = null, t = 1, n = 1, i = 1) {
				super(null), this.isDataArrayTexture = !0, this.image = {
					data: e,
					width: t,
					height: n,
					depth: i
				}, this.magFilter = yn, this.minFilter = yn, this.wrapR = Xt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}
		};
	var xd = class extends Pn {
		constructor(e = null, t = 1, n = 1, i = 1) {
			super(null), this.isData3DTexture = !0, this.image = {
				data: e,
				width: t,
				height: n,
				depth: i
			}, this.magFilter = yn, this.minFilter = yn, this.wrapR = Xt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
		}
	};
	var mn = class {
			constructor(e = 0, t = 0, n = 0, i = 1) {
				this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
			}
			static slerpFlat(e, t, n, i, s, o, a) {
				let c = n[i + 0],
					l = n[i + 1],
					u = n[i + 2],
					h = n[i + 3],
					f = s[o + 0],
					p = s[o + 1],
					g = s[o + 2],
					m = s[o + 3];
				if (a === 0) {
					e[t + 0] = c, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h;
					return
				}
				if (a === 1) {
					e[t + 0] = f, e[t + 1] = p, e[t + 2] = g, e[t + 3] = m;
					return
				}
				if (h !== m || c !== f || l !== p || u !== g) {
					let d = 1 - a,
						v = c * f + l * p + u * g + h * m,
						x = v >= 0 ? 1 : -1,
						_ = 1 - v * v;
					if (_ > Number.EPSILON) {
						let w = Math.sqrt(_),
							C = Math.atan2(w, v * x);
						d = Math.sin(d * C) / w, a = Math.sin(a * C) / w
					}
					let y = a * x;
					if (c = c * d + f * y, l = l * d + p * y, u = u * d + g * y, h = h * d + m * y, d === 1 - a) {
						let w = 1 / Math.sqrt(c * c + l * l + u * u + h * h);
						c *= w, l *= w, u *= w, h *= w
					}
				}
				e[t] = c, e[t + 1] = l, e[t + 2] = u, e[t + 3] = h
			}
			static multiplyQuaternionsFlat(e, t, n, i, s, o) {
				let a = n[i],
					c = n[i + 1],
					l = n[i + 2],
					u = n[i + 3],
					h = s[o],
					f = s[o + 1],
					p = s[o + 2],
					g = s[o + 3];
				return e[t] = a * g + u * h + c * p - l * f, e[t + 1] = c * g + u * f + l * h - a * p, e[t + 2] = l * g + u * p + a * f - c * h, e[t + 3] = u * g - a * h - c * f - l * p, e
			}
			get x() {
				return this._x
			}
			set x(e) {
				this._x = e, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(e) {
				this._y = e, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(e) {
				this._z = e, this._onChangeCallback()
			}
			get w() {
				return this._w
			}
			set w(e) {
				this._w = e, this._onChangeCallback()
			}
			set(e, t, n, i) {
				return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._w)
			}
			copy(e) {
				return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
			}
			setFromEuler(e, t) {
				let n = e._x,
					i = e._y,
					s = e._z,
					o = e._order,
					a = Math.cos,
					c = Math.sin,
					l = a(n / 2),
					u = a(i / 2),
					h = a(s / 2),
					f = c(n / 2),
					p = c(i / 2),
					g = c(s / 2);
				switch (o) {
					case "XYZ":
						this._x = f * u * h + l * p * g, this._y = l * p * h - f * u * g, this._z = l * u * g + f * p * h, this._w = l * u * h - f * p * g;
						break;
					case "YXZ":
						this._x = f * u * h + l * p * g, this._y = l * p * h - f * u * g, this._z = l * u * g - f * p * h, this._w = l * u * h + f * p * g;
						break;
					case "ZXY":
						this._x = f * u * h - l * p * g, this._y = l * p * h + f * u * g, this._z = l * u * g + f * p * h, this._w = l * u * h - f * p * g;
						break;
					case "ZYX":
						this._x = f * u * h - l * p * g, this._y = l * p * h + f * u * g, this._z = l * u * g - f * p * h, this._w = l * u * h + f * p * g;
						break;
					case "YZX":
						this._x = f * u * h + l * p * g, this._y = l * p * h + f * u * g, this._z = l * u * g - f * p * h, this._w = l * u * h - f * p * g;
						break;
					case "XZY":
						this._x = f * u * h - l * p * g, this._y = l * p * h - f * u * g, this._z = l * u * g + f * p * h, this._w = l * u * h + f * p * g;
						break;
					default:
						console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
				}
				return t !== !1 && this._onChangeCallback(), this
			}
			setFromAxisAngle(e, t) {
				let n = t / 2,
					i = Math.sin(n);
				return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
			}
			setFromRotationMatrix(e) {
				let t = e.elements,
					n = t[0],
					i = t[4],
					s = t[8],
					o = t[1],
					a = t[5],
					c = t[9],
					l = t[2],
					u = t[6],
					h = t[10],
					f = n + a + h;
				if (f > 0) {
					let p = .5 / Math.sqrt(f + 1);
					this._w = .25 / p, this._x = (u - c) * p, this._y = (s - l) * p, this._z = (o - i) * p
				} else if (n > a && n > h) {
					let p = 2 * Math.sqrt(1 + n - a - h);
					this._w = (u - c) / p, this._x = .25 * p, this._y = (i + o) / p, this._z = (s + l) / p
				} else if (a > h) {
					let p = 2 * Math.sqrt(1 + a - n - h);
					this._w = (s - l) / p, this._x = (i + o) / p, this._y = .25 * p, this._z = (c + u) / p
				} else {
					let p = 2 * Math.sqrt(1 + h - n - a);
					this._w = (o - i) / p, this._x = (s + l) / p, this._y = (c + u) / p, this._z = .25 * p
				}
				return this._onChangeCallback(), this
			}
			setFromUnitVectors(e, t) {
				let n = e.dot(t) + 1;
				return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
			}
			angleTo(e) {
				return 2 * Math.acos(Math.abs(Kn(this.dot(e), -1, 1)))
			}
			rotateTowards(e, t) {
				let n = this.angleTo(e);
				if (n === 0) return this;
				let i = Math.min(1, t / n);
				return this.slerp(e, i), this
			}
			identity() {
				return this.set(0, 0, 0, 1)
			}
			invert() {
				return this.conjugate()
			}
			conjugate() {
				return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
			}
			dot(e) {
				return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
			}
			lengthSq() {
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
			}
			length() {
				return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
			}
			normalize() {
				let e = this.length();
				return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
			}
			multiply(e) {
				return this.multiplyQuaternions(this, e)
			}
			premultiply(e) {
				return this.multiplyQuaternions(e, this)
			}
			multiplyQuaternions(e, t) {
				let n = e._x,
					i = e._y,
					s = e._z,
					o = e._w,
					a = t._x,
					c = t._y,
					l = t._z,
					u = t._w;
				return this._x = n * u + o * a + i * l - s * c, this._y = i * u + o * c + s * a - n * l, this._z = s * u + o * l + n * c - i * a, this._w = o * u - n * a - i * c - s * l, this._onChangeCallback(), this
			}
			slerp(e, t) {
				if (t === 0) return this;
				if (t === 1) return this.copy(e);
				let n = this._x,
					i = this._y,
					s = this._z,
					o = this._w,
					a = o * e._w + n * e._x + i * e._y + s * e._z;
				if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = s, this;
				let c = 1 - a * a;
				if (c <= Number.EPSILON) {
					let p = 1 - t;
					return this._w = p * o + t * this._w, this._x = p * n + t * this._x, this._y = p * i + t * this._y, this._z = p * s + t * this._z, this.normalize(), this._onChangeCallback(), this
				}
				let l = Math.sqrt(c),
					u = Math.atan2(l, a),
					h = Math.sin((1 - t) * u) / l,
					f = Math.sin(t * u) / l;
				return this._w = o * h + this._w * f, this._x = n * h + this._x * f, this._y = i * h + this._y * f, this._z = s * h + this._z * f, this._onChangeCallback(), this
			}
			slerpQuaternions(e, t, n) {
				return this.copy(e)
					.slerp(t, n)
			}
			random() {
				let e = Math.random(),
					t = Math.sqrt(1 - e),
					n = Math.sqrt(e),
					i = 2 * Math.PI * Math.random(),
					s = 2 * Math.PI * Math.random();
				return this.set(t * Math.cos(i), n * Math.sin(s), n * Math.cos(s), t * Math.sin(i))
			}
			equals(e) {
				return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
			}
			fromArray(e, t = 0) {
				return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
			}
			toArray(e = [], t = 0) {
				return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
			}
			fromBufferAttribute(e, t) {
				return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
			}
			_onChange(e) {
				return this._onChangeCallback = e, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._w
			}
		},
		ne = class {
			constructor(e = 0, t = 0, n = 0) {
				ne.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
			}
			set(e, t, n) {
				return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
			}
			setScalar(e) {
				return this.x = e, this.y = e, this.z = e, this
			}
			setX(e) {
				return this.x = e, this
			}
			setY(e) {
				return this.y = e, this
			}
			setZ(e) {
				return this.z = e, this
			}
			setComponent(e, t) {
				switch (e) {
					case 0:
						this.x = t;
						break;
					case 1:
						this.y = t;
						break;
					case 2:
						this.z = t;
						break;
					default:
						throw new Error("index is out of range: " + e)
				}
				return this
			}
			getComponent(e) {
				switch (e) {
					case 0:
						return this.x;
					case 1:
						return this.y;
					case 2:
						return this.z;
					default:
						throw new Error("index is out of range: " + e)
				}
			}
			clone() {
				return new this.constructor(this.x, this.y, this.z)
			}
			copy(e) {
				return this.x = e.x, this.y = e.y, this.z = e.z, this
			}
			add(e) {
				return this.x += e.x, this.y += e.y, this.z += e.z, this
			}
			addScalar(e) {
				return this.x += e, this.y += e, this.z += e, this
			}
			addVectors(e, t) {
				return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
			}
			addScaledVector(e, t) {
				return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
			}
			sub(e) {
				return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
			}
			subScalar(e) {
				return this.x -= e, this.y -= e, this.z -= e, this
			}
			subVectors(e, t) {
				return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
			}
			multiply(e) {
				return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
			}
			multiplyScalar(e) {
				return this.x *= e, this.y *= e, this.z *= e, this
			}
			multiplyVectors(e, t) {
				return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
			}
			applyEuler(e) {
				return this.applyQuaternion(n0.setFromEuler(e))
			}
			applyAxisAngle(e, t) {
				return this.applyQuaternion(n0.setFromAxisAngle(e, t))
			}
			applyMatrix3(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements;
				return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this
			}
			applyNormalMatrix(e) {
				return this.applyMatrix3(e)
					.normalize()
			}
			applyMatrix4(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements,
					o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
				return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o, this
			}
			applyQuaternion(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.x,
					o = e.y,
					a = e.z,
					c = e.w,
					l = c * t + o * i - a * n,
					u = c * n + a * t - s * i,
					h = c * i + s * n - o * t,
					f = -s * t - o * n - a * i;
				return this.x = l * c + f * -s + u * -a - h * -o, this.y = u * c + f * -o + h * -s - l * -a, this.z = h * c + f * -a + l * -o - u * -s, this
			}
			project(e) {
				return this.applyMatrix4(e.matrixWorldInverse)
					.applyMatrix4(e.projectionMatrix)
			}
			unproject(e) {
				return this.applyMatrix4(e.projectionMatrixInverse)
					.applyMatrix4(e.matrixWorld)
			}
			transformDirection(e) {
				let t = this.x,
					n = this.y,
					i = this.z,
					s = e.elements;
				return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize()
			}
			divide(e) {
				return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
			}
			divideScalar(e) {
				return this.multiplyScalar(1 / e)
			}
			min(e) {
				return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
			}
			max(e) {
				return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
			}
			clamp(e, t) {
				return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
			}
			clampScalar(e, t) {
				return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
			}
			clampLength(e, t) {
				let n = this.length();
				return this.divideScalar(n || 1)
					.multiplyScalar(Math.max(e, Math.min(t, n)))
			}
			floor() {
				return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
			}
			ceil() {
				return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
			}
			round() {
				return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
			}
			roundToZero() {
				return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
			}
			negate() {
				return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
			}
			dot(e) {
				return this.x * e.x + this.y * e.y + this.z * e.z
			}
			lengthSq() {
				return this.x * this.x + this.y * this.y + this.z * this.z
			}
			length() {
				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
			}
			manhattanLength() {
				return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
			}
			normalize() {
				return this.divideScalar(this.length() || 1)
			}
			setLength(e) {
				return this.normalize()
					.multiplyScalar(e)
			}
			lerp(e, t) {
				return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
			}
			lerpVectors(e, t, n) {
				return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
			}
			cross(e) {
				return this.crossVectors(this, e)
			}
			crossVectors(e, t) {
				let n = e.x,
					i = e.y,
					s = e.z,
					o = t.x,
					a = t.y,
					c = t.z;
				return this.x = i * c - s * a, this.y = s * o - n * c, this.z = n * a - i * o, this
			}
			projectOnVector(e) {
				let t = e.lengthSq();
				if (t === 0) return this.set(0, 0, 0);
				let n = e.dot(this) / t;
				return this.copy(e)
					.multiplyScalar(n)
			}
			projectOnPlane(e) {
				return Hf.copy(this)
					.projectOnVector(e), this.sub(Hf)
			}
			reflect(e) {
				return this.sub(Hf.copy(e)
					.multiplyScalar(2 * this.dot(e)))
			}
			angleTo(e) {
				let t = Math.sqrt(this.lengthSq() * e.lengthSq());
				if (t === 0) return Math.PI / 2;
				let n = this.dot(e) / t;
				return Math.acos(Kn(n, -1, 1))
			}
			distanceTo(e) {
				return Math.sqrt(this.distanceToSquared(e))
			}
			distanceToSquared(e) {
				let t = this.x - e.x,
					n = this.y - e.y,
					i = this.z - e.z;
				return t * t + n * n + i * i
			}
			manhattanDistanceTo(e) {
				return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
			}
			setFromSpherical(e) {
				return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
			}
			setFromSphericalCoords(e, t, n) {
				let i = Math.sin(t) * e;
				return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
			}
			setFromCylindrical(e) {
				return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
			}
			setFromCylindricalCoords(e, t, n) {
				return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
			}
			setFromMatrixPosition(e) {
				let t = e.elements;
				return this.x = t[12], this.y = t[13], this.z = t[14], this
			}
			setFromMatrixScale(e) {
				let t = this.setFromMatrixColumn(e, 0)
					.length(),
					n = this.setFromMatrixColumn(e, 1)
					.length(),
					i = this.setFromMatrixColumn(e, 2)
					.length();
				return this.x = t, this.y = n, this.z = i, this
			}
			setFromMatrixColumn(e, t) {
				return this.fromArray(e.elements, t * 4)
			}
			setFromMatrix3Column(e, t) {
				return this.fromArray(e.elements, t * 3)
			}
			setFromEuler(e) {
				return this.x = e._x, this.y = e._y, this.z = e._z, this
			}
			equals(e) {
				return e.x === this.x && e.y === this.y && e.z === this.z
			}
			fromArray(e, t = 0) {
				return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
			}
			toArray(e = [], t = 0) {
				return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
			}
			fromBufferAttribute(e, t) {
				return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
			}
			random() {
				return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
			}
			randomDirection() {
				let e = (Math.random() - .5) * 2,
					t = Math.random() * Math.PI * 2,
					n = Math.sqrt(1 - e ** 2);
				return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
			}*[Symbol.iterator]() {
				yield this.x, yield this.y, yield this.z
			}
		},
		Hf = new ne,
		n0 = new mn,
		br = class {
			constructor(e = new ne(1 / 0, 1 / 0, 1 / 0), t = new ne(-1 / 0, -1 / 0, -1 / 0)) {
				this.isBox3 = !0, this.min = e, this.max = t
			}
			set(e, t) {
				return this.min.copy(e), this.max.copy(t), this
			}
			setFromArray(e) {
				let t = 1 / 0,
					n = 1 / 0,
					i = 1 / 0,
					s = -1 / 0,
					o = -1 / 0,
					a = -1 / 0;
				for (let c = 0, l = e.length; c < l; c += 3) {
					let u = e[c],
						h = e[c + 1],
						f = e[c + 2];
					u < t && (t = u), h < n && (n = h), f < i && (i = f), u > s && (s = u), h > o && (o = h), f > a && (a = f)
				}
				return this.min.set(t, n, i), this.max.set(s, o, a), this
			}
			setFromBufferAttribute(e) {
				let t = 1 / 0,
					n = 1 / 0,
					i = 1 / 0,
					s = -1 / 0,
					o = -1 / 0,
					a = -1 / 0;
				for (let c = 0, l = e.count; c < l; c++) {
					let u = e.getX(c),
						h = e.getY(c),
						f = e.getZ(c);
					u < t && (t = u), h < n && (n = h), f < i && (i = f), u > s && (s = u), h > o && (o = h), f > a && (a = f)
				}
				return this.min.set(t, n, i), this.max.set(s, o, a), this
			}
			setFromPoints(e) {
				this.makeEmpty();
				for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
				return this
			}
			setFromCenterAndSize(e, t) {
				let n = ho.copy(t)
					.multiplyScalar(.5);
				return this.min.copy(e)
					.sub(n), this.max.copy(e)
					.add(n), this
			}
			setFromObject(e, t = !1) {
				return this.makeEmpty(), this.expandByObject(e, t)
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				return this.min.copy(e.min), this.max.copy(e.max), this
			}
			makeEmpty() {
				return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
			}
			isEmpty() {
				return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
			}
			getCenter(e) {
				return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max)
					.multiplyScalar(.5)
			}
			getSize(e) {
				return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
			}
			expandByPoint(e) {
				return this.min.min(e), this.max.max(e), this
			}
			expandByVector(e) {
				return this.min.sub(e), this.max.add(e), this
			}
			expandByScalar(e) {
				return this.min.addScalar(-e), this.max.addScalar(e), this
			}
			expandByObject(e, t = !1) {
				e.updateWorldMatrix(!1, !1);
				let n = e.geometry;
				if (n !== void 0)
					if (t && n.attributes != null && n.attributes.position !== void 0) {
						let s = n.attributes.position;
						for (let o = 0, a = s.count; o < a; o++) ho.fromBufferAttribute(s, o)
							.applyMatrix4(e.matrixWorld), this.expandByPoint(ho)
					} else n.boundingBox === null && n.computeBoundingBox(), Wf.copy(n.boundingBox), Wf.applyMatrix4(e.matrixWorld), this.union(Wf);
				let i = e.children;
				for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], t);
				return this
			}
			containsPoint(e) {
				return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
			}
			containsBox(e) {
				return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
			}
			getParameter(e, t) {
				return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
			}
			intersectsBox(e) {
				return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
			}
			intersectsSphere(e) {
				return this.clampPoint(e.center, ho), ho.distanceToSquared(e.center) <= e.radius * e.radius
			}
			intersectsPlane(e) {
				let t, n;
				return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
			}
			intersectsTriangle(e) {
				if (this.isEmpty()) return !1;
				this.getCenter(dl), Oc.subVectors(this.max, dl), Wo.subVectors(e.a, dl), jo.subVectors(e.b, dl), qo.subVectors(e.c, dl), _s.subVectors(jo, Wo), bs.subVectors(qo, jo), fo.subVectors(Wo, qo);
				let t = [0, -_s.z, _s.y, 0, -bs.z, bs.y, 0, -fo.z, fo.y, _s.z, 0, -_s.x, bs.z, 0, -bs.x, fo.z, 0, -fo.x, -_s.y, _s.x, 0, -bs.y, bs.x, 0, -fo.y, fo.x, 0];
				return !jf(t, Wo, jo, qo, Oc) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !jf(t, Wo, jo, qo, Oc)) ? !1 : (kc.crossVectors(_s, bs), t = [kc.x, kc.y, kc.z], jf(t, Wo, jo, qo, Oc))
			}
			clampPoint(e, t) {
				return t.copy(e)
					.clamp(this.min, this.max)
			}
			distanceToPoint(e) {
				return ho.copy(e)
					.clamp(this.min, this.max)
					.sub(e)
					.length()
			}
			getBoundingSphere(e) {
				return this.getCenter(e.center), e.radius = this.getSize(ho)
					.length() * .5, e
			}
			intersect(e) {
				return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
			}
			union(e) {
				return this.min.min(e.min), this.max.max(e.max), this
			}
			applyMatrix4(e) {
				return this.isEmpty() ? this : (Vr[0].set(this.min.x, this.min.y, this.min.z)
					.applyMatrix4(e), Vr[1].set(this.min.x, this.min.y, this.max.z)
					.applyMatrix4(e), Vr[2].set(this.min.x, this.max.y, this.min.z)
					.applyMatrix4(e), Vr[3].set(this.min.x, this.max.y, this.max.z)
					.applyMatrix4(e), Vr[4].set(this.max.x, this.min.y, this.min.z)
					.applyMatrix4(e), Vr[5].set(this.max.x, this.min.y, this.max.z)
					.applyMatrix4(e), Vr[6].set(this.max.x, this.max.y, this.min.z)
					.applyMatrix4(e), Vr[7].set(this.max.x, this.max.y, this.max.z)
					.applyMatrix4(e), this.setFromPoints(Vr), this)
			}
			translate(e) {
				return this.min.add(e), this.max.add(e), this
			}
			equals(e) {
				return e.min.equals(this.min) && e.max.equals(this.max)
			}
		},
		Vr = [new ne, new ne, new ne, new ne, new ne, new ne, new ne, new ne],
		ho = new ne,
		Wf = new br,
		Wo = new ne,
		jo = new ne,
		qo = new ne,
		_s = new ne,
		bs = new ne,
		fo = new ne,
		dl = new ne,
		Oc = new ne,
		kc = new ne,
		po = new ne;

	function jf(r, e, t, n, i) {
		for (let s = 0, o = r.length - 3; s <= o; s += 3) {
			po.fromArray(r, s);
			let a = i.x * Math.abs(po.x) + i.y * Math.abs(po.y) + i.z * Math.abs(po.z),
				c = e.dot(po),
				l = t.dot(po),
				u = n.dot(po);
			if (Math.max(-Math.max(c, l, u), Math.min(c, l, u)) > a) return !1
		}
		return !0
	}
	var N_ = new br,
		i0 = new ne,
		Fc = new ne,
		qf = new ne,
		Kr = class {
			constructor(e = new ne, t = -1) {
				this.center = e, this.radius = t
			}
			set(e, t) {
				return this.center.copy(e), this.radius = t, this
			}
			setFromPoints(e, t) {
				let n = this.center;
				t !== void 0 ? n.copy(t) : N_.setFromPoints(e)
					.getCenter(n);
				let i = 0;
				for (let s = 0, o = e.length; s < o; s++) i = Math.max(i, n.distanceToSquared(e[s]));
				return this.radius = Math.sqrt(i), this
			}
			copy(e) {
				return this.center.copy(e.center), this.radius = e.radius, this
			}
			isEmpty() {
				return this.radius < 0
			}
			makeEmpty() {
				return this.center.set(0, 0, 0), this.radius = -1, this
			}
			containsPoint(e) {
				return e.distanceToSquared(this.center) <= this.radius * this.radius
			}
			distanceToPoint(e) {
				return e.distanceTo(this.center) - this.radius
			}
			intersectsSphere(e) {
				let t = this.radius + e.radius;
				return e.center.distanceToSquared(this.center) <= t * t
			}
			intersectsBox(e) {
				return e.intersectsSphere(this)
			}
			intersectsPlane(e) {
				return Math.abs(e.distanceToPoint(this.center)) <= this.radius
			}
			clampPoint(e, t) {
				let n = this.center.distanceToSquared(e);
				return t.copy(e), n > this.radius * this.radius && (t.sub(this.center)
					.normalize(), t.multiplyScalar(this.radius)
					.add(this.center)), t
			}
			getBoundingBox(e) {
				return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
			}
			applyMatrix4(e) {
				return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
			}
			translate(e) {
				return this.center.add(e), this
			}
			expandByPoint(e) {
				if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
				qf.subVectors(e, this.center);
				let t = qf.lengthSq();
				if (t > this.radius * this.radius) {
					let n = Math.sqrt(t),
						i = (n - this.radius) * .5;
					this.center.add(qf.multiplyScalar(i / n)), this.radius += i
				}
				return this
			}
			union(e) {
				return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? Fc.set(0, 0, 1)
					.multiplyScalar(e.radius) : Fc.subVectors(e.center, this.center)
					.normalize()
					.multiplyScalar(e.radius), this.expandByPoint(i0.copy(e.center)
						.add(Fc)), this.expandByPoint(i0.copy(e.center)
						.sub(Fc)), this)
			}
			equals(e) {
				return e.center.equals(this.center) && e.radius === this.radius
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
		},
		zr = new ne,
		Xf = new ne,
		Uc = new ne,
		Ms = new ne,
		Yf = new ne,
		Bc = new ne,
		Zf = new ne,
		pa = class {
			constructor(e = new ne, t = new ne(0, 0, -1)) {
				this.origin = e, this.direction = t
			}
			set(e, t) {
				return this.origin.copy(e), this.direction.copy(t), this
			}
			copy(e) {
				return this.origin.copy(e.origin), this.direction.copy(e.direction), this
			}
			at(e, t) {
				return t.copy(this.direction)
					.multiplyScalar(e)
					.add(this.origin)
			}
			lookAt(e) {
				return this.direction.copy(e)
					.sub(this.origin)
					.normalize(), this
			}
			recast(e) {
				return this.origin.copy(this.at(e, zr)), this
			}
			closestPointToPoint(e, t) {
				t.subVectors(e, this.origin);
				let n = t.dot(this.direction);
				return n < 0 ? t.copy(this.origin) : t.copy(this.direction)
					.multiplyScalar(n)
					.add(this.origin)
			}
			distanceToPoint(e) {
				return Math.sqrt(this.distanceSqToPoint(e))
			}
			distanceSqToPoint(e) {
				let t = zr.subVectors(e, this.origin)
					.dot(this.direction);
				return t < 0 ? this.origin.distanceToSquared(e) : (zr.copy(this.direction)
					.multiplyScalar(t)
					.add(this.origin), zr.distanceToSquared(e))
			}
			distanceSqToSegment(e, t, n, i) {
				Xf.copy(e)
					.add(t)
					.multiplyScalar(.5), Uc.copy(t)
					.sub(e)
					.normalize(), Ms.copy(this.origin)
					.sub(Xf);
				let s = e.distanceTo(t) * .5,
					o = -this.direction.dot(Uc),
					a = Ms.dot(this.direction),
					c = -Ms.dot(Uc),
					l = Ms.lengthSq(),
					u = Math.abs(1 - o * o),
					h, f, p, g;
				if (u > 0)
					if (h = o * c - a, f = o * a - c, g = s * u, h >= 0)
						if (f >= -g)
							if (f <= g) {
								let m = 1 / u;
								h *= m, f *= m, p = h * (h + o * f + 2 * a) + f * (o * h + f + 2 * c) + l
							} else f = s, h = Math.max(0, -(o * f + a)), p = -h * h + f * (f + 2 * c) + l;
				else f = -s, h = Math.max(0, -(o * f + a)), p = -h * h + f * (f + 2 * c) + l;
				else f <= -g ? (h = Math.max(0, -(-o * s + a)), f = h > 0 ? -s : Math.min(Math.max(-s, -c), s), p = -h * h + f * (f + 2 * c) + l) : f <= g ? (h = 0, f = Math.min(Math.max(-s, -c), s), p = f * (f + 2 * c) + l) : (h = Math.max(0, -(o * s + a)), f = h > 0 ? s : Math.min(Math.max(-s, -c), s), p = -h * h + f * (f + 2 * c) + l);
				else f = o > 0 ? -s : s, h = Math.max(0, -(o * f + a)), p = -h * h + f * (f + 2 * c) + l;
				return n && n.copy(this.direction)
					.multiplyScalar(h)
					.add(this.origin), i && i.copy(Uc)
					.multiplyScalar(f)
					.add(Xf), p
			}
			intersectSphere(e, t) {
				zr.subVectors(e.center, this.origin);
				let n = zr.dot(this.direction),
					i = zr.dot(zr) - n * n,
					s = e.radius * e.radius;
				if (i > s) return null;
				let o = Math.sqrt(s - i),
					a = n - o,
					c = n + o;
				return a < 0 && c < 0 ? null : a < 0 ? this.at(c, t) : this.at(a, t)
			}
			intersectsSphere(e) {
				return this.distanceSqToPoint(e.center) <= e.radius * e.radius
			}
			distanceToPlane(e) {
				let t = e.normal.dot(this.direction);
				if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
				let n = -(this.origin.dot(e.normal) + e.constant) / t;
				return n >= 0 ? n : null
			}
			intersectPlane(e, t) {
				let n = this.distanceToPlane(e);
				return n === null ? null : this.at(n, t)
			}
			intersectsPlane(e) {
				let t = e.distanceToPoint(this.origin);
				return t === 0 || e.normal.dot(this.direction) * t < 0
			}
			intersectBox(e, t) {
				let n, i, s, o, a, c, l = 1 / this.direction.x,
					u = 1 / this.direction.y,
					h = 1 / this.direction.z,
					f = this.origin;
				return l >= 0 ? (n = (e.min.x - f.x) * l, i = (e.max.x - f.x) * l) : (n = (e.max.x - f.x) * l, i = (e.min.x - f.x) * l), u >= 0 ? (s = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (s = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), n > o || s > i || ((s > n || n !== n) && (n = s), (o < i || i !== i) && (i = o), h >= 0 ? (a = (e.min.z - f.z) * h, c = (e.max.z - f.z) * h) : (a = (e.max.z - f.z) * h, c = (e.min.z - f.z) * h), n > c || a > i) || ((a > n || n !== n) && (n = a), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, t)
			}
			intersectsBox(e) {
				return this.intersectBox(e, zr) !== null
			}
			intersectTriangle(e, t, n, i, s) {
				Yf.subVectors(t, e), Bc.subVectors(n, e), Zf.crossVectors(Yf, Bc);
				let o = this.direction.dot(Zf),
					a;
				if (o > 0) {
					if (i) return null;
					a = 1
				} else if (o < 0) a = -1, o = -o;
				else return null;
				Ms.subVectors(this.origin, e);
				let c = a * this.direction.dot(Bc.crossVectors(Ms, Bc));
				if (c < 0) return null;
				let l = a * this.direction.dot(Yf.cross(Ms));
				if (l < 0 || c + l > o) return null;
				let u = -a * Ms.dot(Zf);
				return u < 0 ? null : this.at(u / o, s)
			}
			applyMatrix4(e) {
				return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
			}
			equals(e) {
				return e.origin.equals(this.origin) && e.direction.equals(this.direction)
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
		},
		ke = class {
			constructor() {
				ke.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
			}
			set(e, t, n, i, s, o, a, c, l, u, h, f, p, g, m, d) {
				let v = this.elements;
				return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = s, v[5] = o, v[9] = a, v[13] = c, v[2] = l, v[6] = u, v[10] = h, v[14] = f, v[3] = p, v[7] = g, v[11] = m, v[15] = d, this
			}
			identity() {
				return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			clone() {
				return new ke()
					.fromArray(this.elements)
			}
			copy(e) {
				let t = this.elements,
					n = e.elements;
				return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
			}
			copyPosition(e) {
				let t = this.elements,
					n = e.elements;
				return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
			}
			setFromMatrix3(e) {
				let t = e.elements;
				return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
			}
			extractBasis(e, t, n) {
				return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
			}
			makeBasis(e, t, n) {
				return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
			}
			extractRotation(e) {
				let t = this.elements,
					n = e.elements,
					i = 1 / Xo.setFromMatrixColumn(e, 0)
					.length(),
					s = 1 / Xo.setFromMatrixColumn(e, 1)
					.length(),
					o = 1 / Xo.setFromMatrixColumn(e, 2)
					.length();
				return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
			}
			makeRotationFromEuler(e) {
				let t = this.elements,
					n = e.x,
					i = e.y,
					s = e.z,
					o = Math.cos(n),
					a = Math.sin(n),
					c = Math.cos(i),
					l = Math.sin(i),
					u = Math.cos(s),
					h = Math.sin(s);
				if (e.order === "XYZ") {
					let f = o * u,
						p = o * h,
						g = a * u,
						m = a * h;
					t[0] = c * u, t[4] = -c * h, t[8] = l, t[1] = p + g * l, t[5] = f - m * l, t[9] = -a * c, t[2] = m - f * l, t[6] = g + p * l, t[10] = o * c
				} else if (e.order === "YXZ") {
					let f = c * u,
						p = c * h,
						g = l * u,
						m = l * h;
					t[0] = f + m * a, t[4] = g * a - p, t[8] = o * l, t[1] = o * h, t[5] = o * u, t[9] = -a, t[2] = p * a - g, t[6] = m + f * a, t[10] = o * c
				} else if (e.order === "ZXY") {
					let f = c * u,
						p = c * h,
						g = l * u,
						m = l * h;
					t[0] = f - m * a, t[4] = -o * h, t[8] = g + p * a, t[1] = p + g * a, t[5] = o * u, t[9] = m - f * a, t[2] = -o * l, t[6] = a, t[10] = o * c
				} else if (e.order === "ZYX") {
					let f = o * u,
						p = o * h,
						g = a * u,
						m = a * h;
					t[0] = c * u, t[4] = g * l - p, t[8] = f * l + m, t[1] = c * h, t[5] = m * l + f, t[9] = p * l - g, t[2] = -l, t[6] = a * c, t[10] = o * c
				} else if (e.order === "YZX") {
					let f = o * c,
						p = o * l,
						g = a * c,
						m = a * l;
					t[0] = c * u, t[4] = m - f * h, t[8] = g * h + p, t[1] = h, t[5] = o * u, t[9] = -a * u, t[2] = -l * u, t[6] = p * h + g, t[10] = f - m * h
				} else if (e.order === "XZY") {
					let f = o * c,
						p = o * l,
						g = a * c,
						m = a * l;
					t[0] = c * u, t[4] = -h, t[8] = l * u, t[1] = f * h + m, t[5] = o * u, t[9] = p * h - g, t[2] = g * h - p, t[6] = a * u, t[10] = m * h + f
				}
				return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
			}
			makeRotationFromQuaternion(e) {
				return this.compose(D_, e, O_)
			}
			lookAt(e, t, n) {
				let i = this.elements;
				return wi.subVectors(e, t), wi.lengthSq() === 0 && (wi.z = 1), wi.normalize(), ws.crossVectors(n, wi), ws.lengthSq() === 0 && (Math.abs(n.z) === 1 ? wi.x += 1e-4 : wi.z += 1e-4, wi.normalize(), ws.crossVectors(n, wi)), ws.normalize(), Gc.crossVectors(wi, ws), i[0] = ws.x, i[4] = Gc.x, i[8] = wi.x, i[1] = ws.y, i[5] = Gc.y, i[9] = wi.y, i[2] = ws.z, i[6] = Gc.z, i[10] = wi.z, this
			}
			multiply(e) {
				return this.multiplyMatrices(this, e)
			}
			premultiply(e) {
				return this.multiplyMatrices(e, this)
			}
			multiplyMatrices(e, t) {
				let n = e.elements,
					i = t.elements,
					s = this.elements,
					o = n[0],
					a = n[4],
					c = n[8],
					l = n[12],
					u = n[1],
					h = n[5],
					f = n[9],
					p = n[13],
					g = n[2],
					m = n[6],
					d = n[10],
					v = n[14],
					x = n[3],
					_ = n[7],
					y = n[11],
					w = n[15],
					C = i[0],
					S = i[4],
					b = i[8],
					T = i[12],
					N = i[1],
					V = i[5],
					O = i[9],
					k = i[13],
					I = i[2],
					q = i[6],
					B = i[10],
					Y = i[14],
					J = i[3],
					H = i[7],
					$ = i[11],
					ae = i[15];
				return s[0] = o * C + a * N + c * I + l * J, s[4] = o * S + a * V + c * q + l * H, s[8] = o * b + a * O + c * B + l * $, s[12] = o * T + a * k + c * Y + l * ae, s[1] = u * C + h * N + f * I + p * J, s[5] = u * S + h * V + f * q + p * H, s[9] = u * b + h * O + f * B + p * $, s[13] = u * T + h * k + f * Y + p * ae, s[2] = g * C + m * N + d * I + v * J, s[6] = g * S + m * V + d * q + v * H, s[10] = g * b + m * O + d * B + v * $, s[14] = g * T + m * k + d * Y + v * ae, s[3] = x * C + _ * N + y * I + w * J, s[7] = x * S + _ * V + y * q + w * H, s[11] = x * b + _ * O + y * B + w * $, s[15] = x * T + _ * k + y * Y + w * ae, this
			}
			multiplyScalar(e) {
				let t = this.elements;
				return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
			}
			determinant() {
				let e = this.elements,
					t = e[0],
					n = e[4],
					i = e[8],
					s = e[12],
					o = e[1],
					a = e[5],
					c = e[9],
					l = e[13],
					u = e[2],
					h = e[6],
					f = e[10],
					p = e[14],
					g = e[3],
					m = e[7],
					d = e[11],
					v = e[15];
				return g * (+s * c * h - i * l * h - s * a * f + n * l * f + i * a * p - n * c * p) + m * (+t * c * p - t * l * f + s * o * f - i * o * p + i * l * u - s * c * u) + d * (+t * l * h - t * a * p - s * o * h + n * o * p + s * a * u - n * l * u) + v * (-i * a * u - t * c * h + t * a * f + i * o * h - n * o * f + n * c * u)
			}
			transpose() {
				let e = this.elements,
					t;
				return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
			}
			setPosition(e, t, n) {
				let i = this.elements;
				return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
			}
			invert() {
				let e = this.elements,
					t = e[0],
					n = e[1],
					i = e[2],
					s = e[3],
					o = e[4],
					a = e[5],
					c = e[6],
					l = e[7],
					u = e[8],
					h = e[9],
					f = e[10],
					p = e[11],
					g = e[12],
					m = e[13],
					d = e[14],
					v = e[15],
					x = h * d * l - m * f * l + m * c * p - a * d * p - h * c * v + a * f * v,
					_ = g * f * l - u * d * l - g * c * p + o * d * p + u * c * v - o * f * v,
					y = u * m * l - g * h * l + g * a * p - o * m * p - u * a * v + o * h * v,
					w = g * h * c - u * m * c - g * a * f + o * m * f + u * a * d - o * h * d,
					C = t * x + n * _ + i * y + s * w;
				if (C === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				let S = 1 / C;
				return e[0] = x * S, e[1] = (m * f * s - h * d * s - m * i * p + n * d * p + h * i * v - n * f * v) * S, e[2] = (a * d * s - m * c * s + m * i * l - n * d * l - a * i * v + n * c * v) * S, e[3] = (h * c * s - a * f * s - h * i * l + n * f * l + a * i * p - n * c * p) * S, e[4] = _ * S, e[5] = (u * d * s - g * f * s + g * i * p - t * d * p - u * i * v + t * f * v) * S, e[6] = (g * c * s - o * d * s - g * i * l + t * d * l + o * i * v - t * c * v) * S, e[7] = (o * f * s - u * c * s + u * i * l - t * f * l - o * i * p + t * c * p) * S, e[8] = y * S, e[9] = (g * h * s - u * m * s - g * n * p + t * m * p + u * n * v - t * h * v) * S, e[10] = (o * m * s - g * a * s + g * n * l - t * m * l - o * n * v + t * a * v) * S, e[11] = (u * a * s - o * h * s - u * n * l + t * h * l + o * n * p - t * a * p) * S, e[12] = w * S, e[13] = (u * m * i - g * h * i + g * n * f - t * m * f - u * n * d + t * h * d) * S, e[14] = (g * a * i - o * m * i - g * n * c + t * m * c + o * n * d - t * a * d) * S, e[15] = (o * h * i - u * a * i + u * n * c - t * h * c - o * n * f + t * a * f) * S, this
			}
			scale(e) {
				let t = this.elements,
					n = e.x,
					i = e.y,
					s = e.z;
				return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this
			}
			getMaxScaleOnAxis() {
				let e = this.elements,
					t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
					n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
					i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
				return Math.sqrt(Math.max(t, n, i))
			}
			makeTranslation(e, t, n) {
				return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
			}
			makeRotationX(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
			}
			makeRotationY(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
			}
			makeRotationZ(e) {
				let t = Math.cos(e),
					n = Math.sin(e);
				return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
			}
			makeRotationAxis(e, t) {
				let n = Math.cos(t),
					i = Math.sin(t),
					s = 1 - n,
					o = e.x,
					a = e.y,
					c = e.z,
					l = s * o,
					u = s * a;
				return this.set(l * o + n, l * a - i * c, l * c + i * a, 0, l * a + i * c, u * a + n, u * c - i * o, 0, l * c - i * a, u * c + i * o, s * c * c + n, 0, 0, 0, 0, 1), this
			}
			makeScale(e, t, n) {
				return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
			}
			makeShear(e, t, n, i, s, o) {
				return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this
			}
			compose(e, t, n) {
				let i = this.elements,
					s = t._x,
					o = t._y,
					a = t._z,
					c = t._w,
					l = s + s,
					u = o + o,
					h = a + a,
					f = s * l,
					p = s * u,
					g = s * h,
					m = o * u,
					d = o * h,
					v = a * h,
					x = c * l,
					_ = c * u,
					y = c * h,
					w = n.x,
					C = n.y,
					S = n.z;
				return i[0] = (1 - (m + v)) * w, i[1] = (p + y) * w, i[2] = (g - _) * w, i[3] = 0, i[4] = (p - y) * C, i[5] = (1 - (f + v)) * C, i[6] = (d + x) * C, i[7] = 0, i[8] = (g + _) * S, i[9] = (d - x) * S, i[10] = (1 - (f + m)) * S, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
			}
			decompose(e, t, n) {
				let i = this.elements,
					s = Xo.set(i[0], i[1], i[2])
					.length(),
					o = Xo.set(i[4], i[5], i[6])
					.length(),
					a = Xo.set(i[8], i[9], i[10])
					.length();
				this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], er.copy(this);
				let l = 1 / s,
					u = 1 / o,
					h = 1 / a;
				return er.elements[0] *= l, er.elements[1] *= l, er.elements[2] *= l, er.elements[4] *= u, er.elements[5] *= u, er.elements[6] *= u, er.elements[8] *= h, er.elements[9] *= h, er.elements[10] *= h, t.setFromRotationMatrix(er), n.x = s, n.y = o, n.z = a, this
			}
			makePerspective(e, t, n, i, s, o) {
				let a = this.elements,
					c = 2 * s / (t - e),
					l = 2 * s / (n - i),
					u = (t + e) / (t - e),
					h = (n + i) / (n - i),
					f = -(o + s) / (o - s),
					p = -2 * o * s / (o - s);
				return a[0] = c, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = f, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
			}
			makeOrthographic(e, t, n, i, s, o) {
				let a = this.elements,
					c = 1 / (t - e),
					l = 1 / (n - i),
					u = 1 / (o - s),
					h = (t + e) * c,
					f = (n + i) * l,
					p = (o + s) * u;
				return a[0] = 2 * c, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -f, a[2] = 0, a[6] = 0, a[10] = -2 * u, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
			}
			equals(e) {
				let t = this.elements,
					n = e.elements;
				for (let i = 0; i < 16; i++)
					if (t[i] !== n[i]) return !1;
				return !0
			}
			fromArray(e, t = 0) {
				for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
				return this
			}
			toArray(e = [], t = 0) {
				let n = this.elements;
				return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
			}
		},
		Xo = new ne,
		er = new ke,
		D_ = new ne(0, 0, 0),
		O_ = new ne(1, 1, 1),
		ws = new ne,
		Gc = new ne,
		wi = new ne,
		r0 = new ke,
		s0 = new mn,
		Ln = class {
			constructor(e = 0, t = 0, n = 0, i = Ln.DefaultOrder) {
				this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
			}
			get x() {
				return this._x
			}
			set x(e) {
				this._x = e, this._onChangeCallback()
			}
			get y() {
				return this._y
			}
			set y(e) {
				this._y = e, this._onChangeCallback()
			}
			get z() {
				return this._z
			}
			set z(e) {
				this._z = e, this._onChangeCallback()
			}
			get order() {
				return this._order
			}
			set order(e) {
				this._order = e, this._onChangeCallback()
			}
			set(e, t, n, i = this._order) {
				return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
			}
			clone() {
				return new this.constructor(this._x, this._y, this._z, this._order)
			}
			copy(e) {
				return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
			}
			setFromRotationMatrix(e, t = this._order, n = !0) {
				let i = e.elements,
					s = i[0],
					o = i[4],
					a = i[8],
					c = i[1],
					l = i[5],
					u = i[9],
					h = i[2],
					f = i[6],
					p = i[10];
				switch (t) {
					case "XYZ":
						this._y = Math.asin(Kn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(f, l), this._z = 0);
						break;
					case "YXZ":
						this._x = Math.asin(-Kn(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, s), this._z = 0);
						break;
					case "ZXY":
						this._x = Math.asin(Kn(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(c, s));
						break;
					case "ZYX":
						this._y = Math.asin(-Kn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(f, p), this._z = Math.atan2(c, s)) : (this._x = 0, this._z = Math.atan2(-o, l));
						break;
					case "YZX":
						this._z = Math.asin(Kn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, p));
						break;
					case "XZY":
						this._z = Math.asin(-Kn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(f, l), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, p), this._y = 0);
						break;
					default:
						console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
				}
				return this._order = t, n === !0 && this._onChangeCallback(), this
			}
			setFromQuaternion(e, t, n) {
				return r0.makeRotationFromQuaternion(e), this.setFromRotationMatrix(r0, t, n)
			}
			setFromVector3(e, t = this._order) {
				return this.set(e.x, e.y, e.z, t)
			}
			reorder(e) {
				return s0.setFromEuler(this), this.setFromQuaternion(s0, e)
			}
			equals(e) {
				return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
			}
			fromArray(e) {
				return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
			}
			toArray(e = [], t = 0) {
				return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
			}
			_onChange(e) {
				return this._onChangeCallback = e, this
			}
			_onChangeCallback() {}*[Symbol.iterator]() {
				yield this._x, yield this._y, yield this._z, yield this._order
			}
			toVector3() {
				console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
			}
		};
	Ln.DefaultOrder = "XYZ";
	Ln.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
	var El = class {
			constructor() {
				this.mask = 1
			}
			set(e) {
				this.mask = (1 << e | 0) >>> 0
			}
			enable(e) {
				this.mask |= 1 << e | 0
			}
			enableAll() {
				this.mask = -1
			}
			toggle(e) {
				this.mask ^= 1 << e | 0
			}
			disable(e) {
				this.mask &= ~(1 << e | 0)
			}
			disableAll() {
				this.mask = 0
			}
			test(e) {
				return (this.mask & e.mask) !== 0
			}
			isEnabled(e) {
				return (this.mask & (1 << e | 0)) !== 0
			}
		},
		k_ = 0,
		o0 = new ne,
		Yo = new mn,
		Hr = new ke,
		Vc = new ne,
		pl = new ne,
		F_ = new ne,
		U_ = new mn,
		a0 = new ne(1, 0, 0),
		l0 = new ne(0, 1, 0),
		c0 = new ne(0, 0, 1),
		B_ = {
			type: "added"
		},
		u0 = {
			type: "removed"
		},
		yt = class extends Rs {
			constructor() {
				super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
					value: k_++
				}), this.uuid = Gs(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = yt.DefaultUp.clone();
				let e = new ne,
					t = new Ln,
					n = new mn,
					i = new ne(1, 1, 1);

				function s() {
					n.setFromEuler(t, !1)
				}

				function o() {
					t.setFromQuaternion(n, void 0, !1)
				}
				t._onChange(s), n._onChange(o), Object.defineProperties(this, {
					position: {
						configurable: !0,
						enumerable: !0,
						value: e
					},
					rotation: {
						configurable: !0,
						enumerable: !0,
						value: t
					},
					quaternion: {
						configurable: !0,
						enumerable: !0,
						value: n
					},
					scale: {
						configurable: !0,
						enumerable: !0,
						value: i
					},
					modelViewMatrix: {
						value: new ke
					},
					normalMatrix: {
						value: new Jn
					}
				}), this.matrix = new ke, this.matrixWorld = new ke, this.matrixAutoUpdate = yt.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = yt.DefaultMatrixWorldAutoUpdate, this.layers = new El, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
			}
			onBeforeRender() {}
			onAfterRender() {}
			applyMatrix4(e) {
				this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
			}
			applyQuaternion(e) {
				return this.quaternion.premultiply(e), this
			}
			setRotationFromAxisAngle(e, t) {
				this.quaternion.setFromAxisAngle(e, t)
			}
			setRotationFromEuler(e) {
				this.quaternion.setFromEuler(e, !0)
			}
			setRotationFromMatrix(e) {
				this.quaternion.setFromRotationMatrix(e)
			}
			setRotationFromQuaternion(e) {
				this.quaternion.copy(e)
			}
			rotateOnAxis(e, t) {
				return Yo.setFromAxisAngle(e, t), this.quaternion.multiply(Yo), this
			}
			rotateOnWorldAxis(e, t) {
				return Yo.setFromAxisAngle(e, t), this.quaternion.premultiply(Yo), this
			}
			rotateX(e) {
				return this.rotateOnAxis(a0, e)
			}
			rotateY(e) {
				return this.rotateOnAxis(l0, e)
			}
			rotateZ(e) {
				return this.rotateOnAxis(c0, e)
			}
			translateOnAxis(e, t) {
				return o0.copy(e)
					.applyQuaternion(this.quaternion), this.position.add(o0.multiplyScalar(t)), this
			}
			translateX(e) {
				return this.translateOnAxis(a0, e)
			}
			translateY(e) {
				return this.translateOnAxis(l0, e)
			}
			translateZ(e) {
				return this.translateOnAxis(c0, e)
			}
			localToWorld(e) {
				return e.applyMatrix4(this.matrixWorld)
			}
			worldToLocal(e) {
				return e.applyMatrix4(Hr.copy(this.matrixWorld)
					.invert())
			}
			lookAt(e, t, n) {
				e.isVector3 ? Vc.copy(e) : Vc.set(e, t, n);
				let i = this.parent;
				this.updateWorldMatrix(!0, !1), pl.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Hr.lookAt(pl, Vc, this.up) : Hr.lookAt(Vc, pl, this.up), this.quaternion.setFromRotationMatrix(Hr), i && (Hr.extractRotation(i.matrixWorld), Yo.setFromRotationMatrix(Hr), this.quaternion.premultiply(Yo.invert()))
			}
			add(e) {
				if (arguments.length > 1) {
					for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
					return this
				}
				return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(B_)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
			}
			remove(e) {
				if (arguments.length > 1) {
					for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
					return this
				}
				let t = this.children.indexOf(e);
				return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(u0)), this
			}
			removeFromParent() {
				let e = this.parent;
				return e !== null && e.remove(this), this
			}
			clear() {
				for (let e = 0; e < this.children.length; e++) {
					let t = this.children[e];
					t.parent = null, t.dispatchEvent(u0)
				}
				return this.children.length = 0, this
			}
			attach(e) {
				return this.updateWorldMatrix(!0, !1), Hr.copy(this.matrixWorld)
					.invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Hr.multiply(e.parent.matrixWorld)), e.applyMatrix4(Hr), this.add(e), e.updateWorldMatrix(!1, !0), this
			}
			getObjectById(e) {
				return this.getObjectByProperty("id", e)
			}
			getObjectByName(e) {
				return this.getObjectByProperty("name", e)
			}
			getObjectByProperty(e, t) {
				if (this[e] === t) return this;
				for (let n = 0, i = this.children.length; n < i; n++) {
					let o = this.children[n].getObjectByProperty(e, t);
					if (o !== void 0) return o
				}
			}
			getWorldPosition(e) {
				return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
			}
			getWorldQuaternion(e) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pl, e, F_), e
			}
			getWorldScale(e) {
				return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(pl, U_, e), e
			}
			getWorldDirection(e) {
				this.updateWorldMatrix(!0, !1);
				let t = this.matrixWorld.elements;
				return e.set(t[8], t[9], t[10])
					.normalize()
			}
			raycast() {}
			traverse(e) {
				e(this);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
			}
			traverseVisible(e) {
				if (this.visible === !1) return;
				e(this);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
			}
			traverseAncestors(e) {
				let t = this.parent;
				t !== null && (e(t), t.traverseAncestors(e))
			}
			updateMatrix() {
				this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
			}
			updateMatrixWorld(e) {
				this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
				let t = this.children;
				for (let n = 0, i = t.length; n < i; n++) {
					let s = t[n];
					(s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e)
				}
			}
			updateWorldMatrix(e, t) {
				let n = this.parent;
				if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
					let i = this.children;
					for (let s = 0, o = i.length; s < o; s++) {
						let a = i[s];
						a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0)
					}
				}
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string",
					n = {};
				t && (e = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {},
					nodes: {}
				}, n.metadata = {
					version: 4.5,
					type: "Object",
					generator: "Object3D.toJSON"
				});
				let i = {};
				i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON()));

				function s(a, c) {
					return a[c.uuid] === void 0 && (a[c.uuid] = c.toJSON(e)), c.uuid
				}
				if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e)
					.uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e)
					.uuid);
				else if (this.isMesh || this.isLine || this.isPoints) {
					i.geometry = s(e.geometries, this.geometry);
					let a = this.geometry.parameters;
					if (a !== void 0 && a.shapes !== void 0) {
						let c = a.shapes;
						if (Array.isArray(c))
							for (let l = 0, u = c.length; l < u; l++) {
								let h = c[l];
								s(e.shapes, h)
							} else s(e.shapes, c)
					}
				}
				if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
					if (Array.isArray(this.material)) {
						let a = [];
						for (let c = 0, l = this.material.length; c < l; c++) a.push(s(e.materials, this.material[c]));
						i.material = a
					} else i.material = s(e.materials, this.material);
				if (this.children.length > 0) {
					i.children = [];
					for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e)
						.object)
				}
				if (this.animations.length > 0) {
					i.animations = [];
					for (let a = 0; a < this.animations.length; a++) {
						let c = this.animations[a];
						i.animations.push(s(e.animations, c))
					}
				}
				if (t) {
					let a = o(e.geometries),
						c = o(e.materials),
						l = o(e.textures),
						u = o(e.images),
						h = o(e.shapes),
						f = o(e.skeletons),
						p = o(e.animations),
						g = o(e.nodes);
					a.length > 0 && (n.geometries = a), c.length > 0 && (n.materials = c), l.length > 0 && (n.textures = l), u.length > 0 && (n.images = u), h.length > 0 && (n.shapes = h), f.length > 0 && (n.skeletons = f), p.length > 0 && (n.animations = p), g.length > 0 && (n.nodes = g)
				}
				return n.object = i, n;

				function o(a) {
					let c = [];
					for (let l in a) {
						let u = a[l];
						delete u.metadata, c.push(u)
					}
					return c
				}
			}
			clone(e) {
				return new this.constructor()
					.copy(this, e)
			}
			copy(e, t = !0) {
				if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
					for (let n = 0; n < e.children.length; n++) {
						let i = e.children[n];
						this.add(i.clone())
					}
				return this
			}
		};
	yt.DefaultUp = new ne(0, 1, 0);
	yt.DefaultMatrixAutoUpdate = !0;
	yt.DefaultMatrixWorldAutoUpdate = !0;
	var tr = new ne,
		Wr = new ne,
		Kf = new ne,
		jr = new ne,
		Zo = new ne,
		Ko = new ne,
		h0 = new ne,
		Jf = new ne,
		$f = new ne,
		Qf = new ne,
		Di = class {
			constructor(e = new ne, t = new ne, n = new ne) {
				this.a = e, this.b = t, this.c = n
			}
			static getNormal(e, t, n, i) {
				i.subVectors(n, t), tr.subVectors(e, t), i.cross(tr);
				let s = i.lengthSq();
				return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
			}
			static getBarycoord(e, t, n, i, s) {
				tr.subVectors(i, t), Wr.subVectors(n, t), Kf.subVectors(e, t);
				let o = tr.dot(tr),
					a = tr.dot(Wr),
					c = tr.dot(Kf),
					l = Wr.dot(Wr),
					u = Wr.dot(Kf),
					h = o * l - a * a;
				if (h === 0) return s.set(-2, -1, -1);
				let f = 1 / h,
					p = (l * c - a * u) * f,
					g = (o * u - a * c) * f;
				return s.set(1 - p - g, g, p)
			}
			static containsPoint(e, t, n, i) {
				return this.getBarycoord(e, t, n, i, jr), jr.x >= 0 && jr.y >= 0 && jr.x + jr.y <= 1
			}
			static getUV(e, t, n, i, s, o, a, c) {
				return this.getBarycoord(e, t, n, i, jr), c.set(0, 0), c.addScaledVector(s, jr.x), c.addScaledVector(o, jr.y), c.addScaledVector(a, jr.z), c
			}
			static isFrontFacing(e, t, n, i) {
				return tr.subVectors(n, t), Wr.subVectors(e, t), tr.cross(Wr)
					.dot(i) < 0
			}
			set(e, t, n) {
				return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
			}
			setFromPointsAndIndices(e, t, n, i) {
				return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
			}
			setFromAttributeAndIndices(e, t, n, i) {
				return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
			}
			getArea() {
				return tr.subVectors(this.c, this.b), Wr.subVectors(this.a, this.b), tr.cross(Wr)
					.length() * .5
			}
			getMidpoint(e) {
				return e.addVectors(this.a, this.b)
					.add(this.c)
					.multiplyScalar(1 / 3)
			}
			getNormal(e) {
				return Di.getNormal(this.a, this.b, this.c, e)
			}
			getPlane(e) {
				return e.setFromCoplanarPoints(this.a, this.b, this.c)
			}
			getBarycoord(e, t) {
				return Di.getBarycoord(e, this.a, this.b, this.c, t)
			}
			getUV(e, t, n, i, s) {
				return Di.getUV(e, this.a, this.b, this.c, t, n, i, s)
			}
			containsPoint(e) {
				return Di.containsPoint(e, this.a, this.b, this.c)
			}
			isFrontFacing(e) {
				return Di.isFrontFacing(this.a, this.b, this.c, e)
			}
			intersectsBox(e) {
				return e.intersectsTriangle(this)
			}
			closestPointToPoint(e, t) {
				let n = this.a,
					i = this.b,
					s = this.c,
					o, a;
				Zo.subVectors(i, n), Ko.subVectors(s, n), Jf.subVectors(e, n);
				let c = Zo.dot(Jf),
					l = Ko.dot(Jf);
				if (c <= 0 && l <= 0) return t.copy(n);
				$f.subVectors(e, i);
				let u = Zo.dot($f),
					h = Ko.dot($f);
				if (u >= 0 && h <= u) return t.copy(i);
				let f = c * h - u * l;
				if (f <= 0 && c >= 0 && u <= 0) return o = c / (c - u), t.copy(n)
					.addScaledVector(Zo, o);
				Qf.subVectors(e, s);
				let p = Zo.dot(Qf),
					g = Ko.dot(Qf);
				if (g >= 0 && p <= g) return t.copy(s);
				let m = p * l - c * g;
				if (m <= 0 && l >= 0 && g <= 0) return a = l / (l - g), t.copy(n)
					.addScaledVector(Ko, a);
				let d = u * g - p * h;
				if (d <= 0 && h - u >= 0 && p - g >= 0) return h0.subVectors(s, i), a = (h - u) / (h - u + (p - g)), t.copy(i)
					.addScaledVector(h0, a);
				let v = 1 / (d + m + f);
				return o = m * v, a = f * v, t.copy(n)
					.addScaledVector(Zo, o)
					.addScaledVector(Ko, a)
			}
			equals(e) {
				return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
			}
		},
		G_ = 0,
		rr = class extends Rs {
			constructor() {
				super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
					value: G_++
				}), this.uuid = Gs(), this.name = "", this.type = "Material", this.blending = oa, this.side = _r, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = tv, this.blendDst = nv, this.blendEquation = ia, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = pd, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = x_, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Bf, this.stencilZFail = Bf, this.stencilZPass = Bf, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
			}
			get alphaTest() {
				return this._alphaTest
			}
			set alphaTest(e) {
				this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
			}
			onBuild() {}
			onBeforeRender() {}
			onBeforeCompile() {}
			customProgramCacheKey() {
				return this.onBeforeCompile.toString()
			}
			setValues(e) {
				if (e !== void 0)
					for (let t in e) {
						let n = e[t];
						if (n === void 0) {
							console.warn("THREE.Material: '" + t + "' parameter is undefined.");
							continue
						}
						let i = this[t];
						if (i === void 0) {
							console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
							continue
						}
						i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
					}
			}
			toJSON(e) {
				let t = e === void 0 || typeof e == "string";
				t && (e = {
					textures: {},
					images: {}
				});
				let n = {
					metadata: {
						version: 4.5,
						type: "Material",
						generator: "Material.toJSON"
					}
				};
				n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e)
					.uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e)
					.uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e)
					.uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e)
					.uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e)
					.uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e)
					.uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e)
					.uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e)
					.uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e)
					.uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e)
					.uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e)
					.uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e)
					.uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e)
					.uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e)
					.uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e)
					.uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e)
					.uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e)
					.uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e)
					.uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e)
					.uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e)
					.uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e)
					.uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e)
					.uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e)
					.uuid), this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== oa && (n.blending = this.blending), this.side !== _r && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);

				function i(s) {
					let o = [];
					for (let a in s) {
						let c = s[a];
						delete c.metadata, o.push(c)
					}
					return o
				}
				if (t) {
					let s = i(e.textures),
						o = i(e.images);
					s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o)
				}
				return n
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
				let t = e.clippingPlanes,
					n = null;
				if (t !== null) {
					let i = t.length;
					n = new Array(i);
					for (let s = 0; s !== i; ++s) n[s] = t[s].clone()
				}
				return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
		},
		Oi = class extends rr {
			constructor(e) {
				super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Eu, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
			}
		},
		dn = new ne,
		zc = new st,
		Gn = class {
			constructor(e, t, n) {
				if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
				this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n === !0, this.usage = Qg, this.updateRange = {
					offset: 0,
					count: -1
				}, this.version = 0
			}
			onUploadCallback() {}
			set needsUpdate(e) {
				e === !0 && this.version++
			}
			setUsage(e) {
				return this.usage = e, this
			}
			copy(e) {
				return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this
			}
			copyAt(e, t, n) {
				e *= this.itemSize, n *= t.itemSize;
				for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
				return this
			}
			copyArray(e) {
				return this.array.set(e), this
			}
			applyMatrix3(e) {
				if (this.itemSize === 2)
					for (let t = 0, n = this.count; t < n; t++) zc.fromBufferAttribute(this, t), zc.applyMatrix3(e), this.setXY(t, zc.x, zc.y);
				else if (this.itemSize === 3)
					for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyMatrix3(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			applyMatrix4(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyMatrix4(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			applyNormalMatrix(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.applyNormalMatrix(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			transformDirection(e) {
				for (let t = 0, n = this.count; t < n; t++) dn.fromBufferAttribute(this, t), dn.transformDirection(e), this.setXYZ(t, dn.x, dn.y, dn.z);
				return this
			}
			set(e, t = 0) {
				return this.array.set(e, t), this
			}
			getX(e) {
				let t = this.array[e * this.itemSize];
				return this.normalized && (t = xl(t, this.array)), t
			}
			setX(e, t) {
				return this.normalized && (t = hi(t, this.array)), this.array[e * this.itemSize] = t, this
			}
			getY(e) {
				let t = this.array[e * this.itemSize + 1];
				return this.normalized && (t = xl(t, this.array)), t
			}
			setY(e, t) {
				return this.normalized && (t = hi(t, this.array)), this.array[e * this.itemSize + 1] = t, this
			}
			getZ(e) {
				let t = this.array[e * this.itemSize + 2];
				return this.normalized && (t = xl(t, this.array)), t
			}
			setZ(e, t) {
				return this.normalized && (t = hi(t, this.array)), this.array[e * this.itemSize + 2] = t, this
			}
			getW(e) {
				let t = this.array[e * this.itemSize + 3];
				return this.normalized && (t = xl(t, this.array)), t
			}
			setW(e, t) {
				return this.normalized && (t = hi(t, this.array)), this.array[e * this.itemSize + 3] = t, this
			}
			setXY(e, t, n) {
				return e *= this.itemSize, this.normalized && (t = hi(t, this.array), n = hi(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
			}
			setXYZ(e, t, n, i) {
				return e *= this.itemSize, this.normalized && (t = hi(t, this.array), n = hi(n, this.array), i = hi(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
			}
			setXYZW(e, t, n, i, s) {
				return e *= this.itemSize, this.normalized && (t = hi(t, this.array), n = hi(n, this.array), i = hi(i, this.array), s = hi(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this
			}
			onUpload(e) {
				return this.onUploadCallback = e, this
			}
			clone() {
				return new this.constructor(this.array, this.itemSize)
					.copy(this)
			}
			toJSON() {
				let e = {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: Array.from(this.array),
					normalized: this.normalized
				};
				return this.name !== "" && (e.name = this.name), this.usage !== Qg && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e
			}
			copyColorsArray() {
				console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
			}
			copyVector2sArray() {
				console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
			}
			copyVector3sArray() {
				console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
			}
			copyVector4sArray() {
				console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
			}
		};
	var ma = class extends Gn {
		constructor(e, t, n) {
			super(new Uint16Array(e), t, n)
		}
	};
	var pu = class extends Gn {
		constructor(e, t, n) {
			super(new Uint32Array(e), t, n)
		}
	};
	var ze = class extends Gn {
		constructor(e, t, n) {
			super(new Float32Array(e), t, n)
		}
	};
	var V_ = 0,
		Ni = new ke,
		ed = new yt,
		Jo = new ne,
		Ti = new br,
		ml = new br,
		In = new ne,
		bt = class extends Rs {
			constructor() {
				super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
					value: V_++
				}), this.uuid = Gs(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
					start: 0,
					count: 1 / 0
				}, this.userData = {}
			}
			getIndex() {
				return this.index
			}
			setIndex(e) {
				return Array.isArray(e) ? this.index = new(ov(e) ? pu : ma)(e, 1) : this.index = e, this
			}
			getAttribute(e) {
				return this.attributes[e]
			}
			setAttribute(e, t) {
				return this.attributes[e] = t, this
			}
			deleteAttribute(e) {
				return delete this.attributes[e], this
			}
			hasAttribute(e) {
				return this.attributes[e] !== void 0
			}
			addGroup(e, t, n = 0) {
				this.groups.push({
					start: e,
					count: t,
					materialIndex: n
				})
			}
			clearGroups() {
				this.groups = []
			}
			setDrawRange(e, t) {
				this.drawRange.start = e, this.drawRange.count = t
			}
			applyMatrix4(e) {
				let t = this.attributes.position;
				t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
				let n = this.attributes.normal;
				if (n !== void 0) {
					let s = new Jn()
						.getNormalMatrix(e);
					n.applyNormalMatrix(s), n.needsUpdate = !0
				}
				let i = this.attributes.tangent;
				return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
			}
			applyQuaternion(e) {
				return Ni.makeRotationFromQuaternion(e), this.applyMatrix4(Ni), this
			}
			rotateX(e) {
				return Ni.makeRotationX(e), this.applyMatrix4(Ni), this
			}
			rotateY(e) {
				return Ni.makeRotationY(e), this.applyMatrix4(Ni), this
			}
			rotateZ(e) {
				return Ni.makeRotationZ(e), this.applyMatrix4(Ni), this
			}
			translate(e, t, n) {
				return Ni.makeTranslation(e, t, n), this.applyMatrix4(Ni), this
			}
			scale(e, t, n) {
				return Ni.makeScale(e, t, n), this.applyMatrix4(Ni), this
			}
			lookAt(e) {
				return ed.lookAt(e), ed.updateMatrix(), this.applyMatrix4(ed.matrix), this
			}
			center() {
				return this.computeBoundingBox(), this.boundingBox.getCenter(Jo)
					.negate(), this.translate(Jo.x, Jo.y, Jo.z), this
			}
			setFromPoints(e) {
				let t = [];
				for (let n = 0, i = e.length; n < i; n++) {
					let s = e[n];
					t.push(s.x, s.y, s.z || 0)
				}
				return this.setAttribute("position", new ze(t, 3)), this
			}
			computeBoundingBox() {
				this.boundingBox === null && (this.boundingBox = new br);
				let e = this.attributes.position,
					t = this.morphAttributes.position;
				if (e && e.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new ne(-1 / 0, -1 / 0, -1 / 0), new ne(1 / 0, 1 / 0, 1 / 0));
					return
				}
				if (e !== void 0) {
					if (this.boundingBox.setFromBufferAttribute(e), t)
						for (let n = 0, i = t.length; n < i; n++) {
							let s = t[n];
							Ti.setFromBufferAttribute(s), this.morphTargetsRelative ? (In.addVectors(this.boundingBox.min, Ti.min), this.boundingBox.expandByPoint(In), In.addVectors(this.boundingBox.max, Ti.max), this.boundingBox.expandByPoint(In)) : (this.boundingBox.expandByPoint(Ti.min), this.boundingBox.expandByPoint(Ti.max))
						}
				} else this.boundingBox.makeEmpty();
				(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
			}
			computeBoundingSphere() {
				this.boundingSphere === null && (this.boundingSphere = new Kr);
				let e = this.attributes.position,
					t = this.morphAttributes.position;
				if (e && e.isGLBufferAttribute) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new ne, 1 / 0);
					return
				}
				if (e) {
					let n = this.boundingSphere.center;
					if (Ti.setFromBufferAttribute(e), t)
						for (let s = 0, o = t.length; s < o; s++) {
							let a = t[s];
							ml.setFromBufferAttribute(a), this.morphTargetsRelative ? (In.addVectors(Ti.min, ml.min), Ti.expandByPoint(In), In.addVectors(Ti.max, ml.max), Ti.expandByPoint(In)) : (Ti.expandByPoint(ml.min), Ti.expandByPoint(ml.max))
						}
					Ti.getCenter(n);
					let i = 0;
					for (let s = 0, o = e.count; s < o; s++) In.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(In));
					if (t)
						for (let s = 0, o = t.length; s < o; s++) {
							let a = t[s],
								c = this.morphTargetsRelative;
							for (let l = 0, u = a.count; l < u; l++) In.fromBufferAttribute(a, l), c && (Jo.fromBufferAttribute(e, l), In.add(Jo)), i = Math.max(i, n.distanceToSquared(In))
						}
					this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
				}
			}
			computeTangents() {
				let e = this.index,
					t = this.attributes;
				if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
					console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
					return
				}
				let n = e.array,
					i = t.position.array,
					s = t.normal.array,
					o = t.uv.array,
					a = i.length / 3;
				this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Gn(new Float32Array(4 * a), 4));
				let c = this.getAttribute("tangent")
					.array,
					l = [],
					u = [];
				for (let N = 0; N < a; N++) l[N] = new ne, u[N] = new ne;
				let h = new ne,
					f = new ne,
					p = new ne,
					g = new st,
					m = new st,
					d = new st,
					v = new ne,
					x = new ne;

				function _(N, V, O) {
					h.fromArray(i, N * 3), f.fromArray(i, V * 3), p.fromArray(i, O * 3), g.fromArray(o, N * 2), m.fromArray(o, V * 2), d.fromArray(o, O * 2), f.sub(h), p.sub(h), m.sub(g), d.sub(g);
					let k = 1 / (m.x * d.y - d.x * m.y);
					!isFinite(k) || (v.copy(f)
						.multiplyScalar(d.y)
						.addScaledVector(p, -m.y)
						.multiplyScalar(k), x.copy(p)
						.multiplyScalar(m.x)
						.addScaledVector(f, -d.x)
						.multiplyScalar(k), l[N].add(v), l[V].add(v), l[O].add(v), u[N].add(x), u[V].add(x), u[O].add(x))
				}
				let y = this.groups;
				y.length === 0 && (y = [{
					start: 0,
					count: n.length
				}]);
				for (let N = 0, V = y.length; N < V; ++N) {
					let O = y[N],
						k = O.start,
						I = O.count;
					for (let q = k, B = k + I; q < B; q += 3) _(n[q + 0], n[q + 1], n[q + 2])
				}
				let w = new ne,
					C = new ne,
					S = new ne,
					b = new ne;

				function T(N) {
					S.fromArray(s, N * 3), b.copy(S);
					let V = l[N];
					w.copy(V), w.sub(S.multiplyScalar(S.dot(V)))
						.normalize(), C.crossVectors(b, V);
					let k = C.dot(u[N]) < 0 ? -1 : 1;
					c[N * 4] = w.x, c[N * 4 + 1] = w.y, c[N * 4 + 2] = w.z, c[N * 4 + 3] = k
				}
				for (let N = 0, V = y.length; N < V; ++N) {
					let O = y[N],
						k = O.start,
						I = O.count;
					for (let q = k, B = k + I; q < B; q += 3) T(n[q + 0]), T(n[q + 1]), T(n[q + 2])
				}
			}
			computeVertexNormals() {
				let e = this.index,
					t = this.getAttribute("position");
				if (t !== void 0) {
					let n = this.getAttribute("normal");
					if (n === void 0) n = new Gn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
					else
						for (let f = 0, p = n.count; f < p; f++) n.setXYZ(f, 0, 0, 0);
					let i = new ne,
						s = new ne,
						o = new ne,
						a = new ne,
						c = new ne,
						l = new ne,
						u = new ne,
						h = new ne;
					if (e)
						for (let f = 0, p = e.count; f < p; f += 3) {
							let g = e.getX(f + 0),
								m = e.getX(f + 1),
								d = e.getX(f + 2);
							i.fromBufferAttribute(t, g), s.fromBufferAttribute(t, m), o.fromBufferAttribute(t, d), u.subVectors(o, s), h.subVectors(i, s), u.cross(h), a.fromBufferAttribute(n, g), c.fromBufferAttribute(n, m), l.fromBufferAttribute(n, d), a.add(u), c.add(u), l.add(u), n.setXYZ(g, a.x, a.y, a.z), n.setXYZ(m, c.x, c.y, c.z), n.setXYZ(d, l.x, l.y, l.z)
						} else
							for (let f = 0, p = t.count; f < p; f += 3) i.fromBufferAttribute(t, f + 0), s.fromBufferAttribute(t, f + 1), o.fromBufferAttribute(t, f + 2), u.subVectors(o, s), h.subVectors(i, s), u.cross(h), n.setXYZ(f + 0, u.x, u.y, u.z), n.setXYZ(f + 1, u.x, u.y, u.z), n.setXYZ(f + 2, u.x, u.y, u.z);
					this.normalizeNormals(), n.needsUpdate = !0
				}
			}
			merge() {
				return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this
			}
			normalizeNormals() {
				let e = this.attributes.normal;
				for (let t = 0, n = e.count; t < n; t++) In.fromBufferAttribute(e, t), In.normalize(), e.setXYZ(t, In.x, In.y, In.z)
			}
			toNonIndexed() {
				function e(a, c) {
					let l = a.array,
						u = a.itemSize,
						h = a.normalized,
						f = new l.constructor(c.length * u),
						p = 0,
						g = 0;
					for (let m = 0, d = c.length; m < d; m++) {
						a.isInterleavedBufferAttribute ? p = c[m] * a.data.stride + a.offset : p = c[m] * u;
						for (let v = 0; v < u; v++) f[g++] = l[p++]
					}
					return new Gn(f, u, h)
				}
				if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
				let t = new bt,
					n = this.index.array,
					i = this.attributes;
				for (let a in i) {
					let c = i[a],
						l = e(c, n);
					t.setAttribute(a, l)
				}
				let s = this.morphAttributes;
				for (let a in s) {
					let c = [],
						l = s[a];
					for (let u = 0, h = l.length; u < h; u++) {
						let f = l[u],
							p = e(f, n);
						c.push(p)
					}
					t.morphAttributes[a] = c
				}
				t.morphTargetsRelative = this.morphTargetsRelative;
				let o = this.groups;
				for (let a = 0, c = o.length; a < c; a++) {
					let l = o[a];
					t.addGroup(l.start, l.count, l.materialIndex)
				}
				return t
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.5,
						type: "BufferGeometry",
						generator: "BufferGeometry.toJSON"
					}
				};
				if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData)
					.length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
					let c = this.parameters;
					for (let l in c) c[l] !== void 0 && (e[l] = c[l]);
					return e
				}
				e.data = {
					attributes: {}
				};
				let t = this.index;
				t !== null && (e.data.index = {
					type: t.array.constructor.name,
					array: Array.prototype.slice.call(t.array)
				});
				let n = this.attributes;
				for (let c in n) {
					let l = n[c];
					e.data.attributes[c] = l.toJSON(e.data)
				}
				let i = {},
					s = !1;
				for (let c in this.morphAttributes) {
					let l = this.morphAttributes[c],
						u = [];
					for (let h = 0, f = l.length; h < f; h++) {
						let p = l[h];
						u.push(p.toJSON(e.data))
					}
					u.length > 0 && (i[c] = u, s = !0)
				}
				s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
				let o = this.groups;
				o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
				let a = this.boundingSphere;
				return a !== null && (e.data.boundingSphere = {
					center: a.center.toArray(),
					radius: a.radius
				}), e
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
				let t = {};
				this.name = e.name;
				let n = e.index;
				n !== null && this.setIndex(n.clone(t));
				let i = e.attributes;
				for (let l in i) {
					let u = i[l];
					this.setAttribute(l, u.clone(t))
				}
				let s = e.morphAttributes;
				for (let l in s) {
					let u = [],
						h = s[l];
					for (let f = 0, p = h.length; f < p; f++) u.push(h[f].clone(t));
					this.morphAttributes[l] = u
				}
				this.morphTargetsRelative = e.morphTargetsRelative;
				let o = e.groups;
				for (let l = 0, u = o.length; l < u; l++) {
					let h = o[l];
					this.addGroup(h.start, h.count, h.materialIndex)
				}
				let a = e.boundingBox;
				a !== null && (this.boundingBox = a.clone());
				let c = e.boundingSphere;
				return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this
			}
			dispose() {
				this.dispatchEvent({
					type: "dispose"
				})
			}
		},
		f0 = new ke,
		$o = new pa,
		td = new Kr,
		Ts = new ne,
		Ss = new ne,
		Es = new ne,
		nd = new ne,
		id = new ne,
		rd = new ne,
		Hc = new ne,
		Wc = new ne,
		jc = new ne,
		qc = new st,
		Xc = new st,
		Yc = new st,
		sd = new ne,
		Zc = new ne,
		zt = class extends yt {
			constructor(e = new bt, t = new Oi) {
				super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.material,
					s = this.matrixWorld;
				if (i === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), td.copy(n.boundingSphere), td.applyMatrix4(s), e.ray.intersectsSphere(td) === !1) || (f0.copy(s)
					.invert(), $o.copy(e.ray)
					.applyMatrix4(f0), n.boundingBox !== null && $o.intersectsBox(n.boundingBox) === !1)) return;
				let o, a = n.index,
					c = n.attributes.position,
					l = n.morphAttributes.position,
					u = n.morphTargetsRelative,
					h = n.attributes.uv,
					f = n.attributes.uv2,
					p = n.groups,
					g = n.drawRange;
				if (a !== null)
					if (Array.isArray(i))
						for (let m = 0, d = p.length; m < d; m++) {
							let v = p[m],
								x = i[v.materialIndex],
								_ = Math.max(v.start, g.start),
								y = Math.min(a.count, Math.min(v.start + v.count, g.start + g.count));
							for (let w = _, C = y; w < C; w += 3) {
								let S = a.getX(w),
									b = a.getX(w + 1),
									T = a.getX(w + 2);
								o = Kc(this, x, e, $o, c, l, u, h, f, S, b, T), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = v.materialIndex, t.push(o))
							}
						} else {
							let m = Math.max(0, g.start),
								d = Math.min(a.count, g.start + g.count);
							for (let v = m, x = d; v < x; v += 3) {
								let _ = a.getX(v),
									y = a.getX(v + 1),
									w = a.getX(v + 2);
								o = Kc(this, i, e, $o, c, l, u, h, f, _, y, w), o && (o.faceIndex = Math.floor(v / 3), t.push(o))
							}
						} else if (c !== void 0)
							if (Array.isArray(i))
								for (let m = 0, d = p.length; m < d; m++) {
									let v = p[m],
										x = i[v.materialIndex],
										_ = Math.max(v.start, g.start),
										y = Math.min(c.count, Math.min(v.start + v.count, g.start + g.count));
									for (let w = _, C = y; w < C; w += 3) {
										let S = w,
											b = w + 1,
											T = w + 2;
										o = Kc(this, x, e, $o, c, l, u, h, f, S, b, T), o && (o.faceIndex = Math.floor(w / 3), o.face.materialIndex = v.materialIndex, t.push(o))
									}
								} else {
									let m = Math.max(0, g.start),
										d = Math.min(c.count, g.start + g.count);
									for (let v = m, x = d; v < x; v += 3) {
										let _ = v,
											y = v + 1,
											w = v + 2;
										o = Kc(this, i, e, $o, c, l, u, h, f, _, y, w), o && (o.faceIndex = Math.floor(v / 3), t.push(o))
									}
								}
			}
		};

	function z_(r, e, t, n, i, s, o, a) {
		let c;
		if (e.side === Rn ? c = n.intersectTriangle(o, s, i, !0, a) : c = n.intersectTriangle(i, s, o, e.side !== Bn, a), c === null) return null;
		Zc.copy(a), Zc.applyMatrix4(r.matrixWorld);
		let l = t.ray.origin.distanceTo(Zc);
		return l < t.near || l > t.far ? null : {
			distance: l,
			point: Zc.clone(),
			object: r
		}
	}

	function Kc(r, e, t, n, i, s, o, a, c, l, u, h) {
		Ts.fromBufferAttribute(i, l), Ss.fromBufferAttribute(i, u), Es.fromBufferAttribute(i, h);
		let f = r.morphTargetInfluences;
		if (s && f) {
			Hc.set(0, 0, 0), Wc.set(0, 0, 0), jc.set(0, 0, 0);
			for (let g = 0, m = s.length; g < m; g++) {
				let d = f[g],
					v = s[g];
				d !== 0 && (nd.fromBufferAttribute(v, l), id.fromBufferAttribute(v, u), rd.fromBufferAttribute(v, h), o ? (Hc.addScaledVector(nd, d), Wc.addScaledVector(id, d), jc.addScaledVector(rd, d)) : (Hc.addScaledVector(nd.sub(Ts), d), Wc.addScaledVector(id.sub(Ss), d), jc.addScaledVector(rd.sub(Es), d)))
			}
			Ts.add(Hc), Ss.add(Wc), Es.add(jc)
		}
		r.isSkinnedMesh && (r.boneTransform(l, Ts), r.boneTransform(u, Ss), r.boneTransform(h, Es));
		let p = z_(r, e, t, n, Ts, Ss, Es, sd);
		if (p) {
			a && (qc.fromBufferAttribute(a, l), Xc.fromBufferAttribute(a, u), Yc.fromBufferAttribute(a, h), p.uv = Di.getUV(sd, Ts, Ss, Es, qc, Xc, Yc, new st)), c && (qc.fromBufferAttribute(c, l), Xc.fromBufferAttribute(c, u), Yc.fromBufferAttribute(c, h), p.uv2 = Di.getUV(sd, Ts, Ss, Es, qc, Xc, Yc, new st));
			let g = {
				a: l,
				b: u,
				c: h,
				normal: new ne,
				materialIndex: 0
			};
			Di.getNormal(Ts, Ss, Es, g.normal), p.face = g
		}
		return p
	}
	var Jr = class extends bt {
		constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
			super(), this.type = "BoxGeometry", this.parameters = {
				width: e,
				height: t,
				depth: n,
				widthSegments: i,
				heightSegments: s,
				depthSegments: o
			};
			let a = this;
			i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
			let c = [],
				l = [],
				u = [],
				h = [],
				f = 0,
				p = 0;
			g("z", "y", "x", -1, -1, n, t, e, o, s, 0), g("z", "y", "x", 1, -1, n, t, -e, o, s, 1), g("x", "z", "y", 1, 1, e, n, t, i, o, 2), g("x", "z", "y", 1, -1, e, n, -t, i, o, 3), g("x", "y", "z", 1, -1, e, t, n, i, s, 4), g("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(c), this.setAttribute("position", new ze(l, 3)), this.setAttribute("normal", new ze(u, 3)), this.setAttribute("uv", new ze(h, 2));

			function g(m, d, v, x, _, y, w, C, S, b, T) {
				let N = y / S,
					V = w / b,
					O = y / 2,
					k = w / 2,
					I = C / 2,
					q = S + 1,
					B = b + 1,
					Y = 0,
					J = 0,
					H = new ne;
				for (let $ = 0; $ < B; $++) {
					let ae = $ * V - k;
					for (let oe = 0; oe < q; oe++) {
						let ie = oe * N - O;
						H[m] = ie * x, H[d] = ae * _, H[v] = I, l.push(H.x, H.y, H.z), H[m] = 0, H[d] = 0, H[v] = C > 0 ? 1 : -1, u.push(H.x, H.y, H.z), h.push(oe / S), h.push(1 - $ / b), Y += 1
					}
				}
				for (let $ = 0; $ < b; $++)
					for (let ae = 0; ae < S; ae++) {
						let oe = f + ae + q * $,
							ie = f + ae + q * ($ + 1),
							U = f + (ae + 1) + q * ($ + 1),
							A = f + (ae + 1) + q * $;
						c.push(oe, ie, A), c.push(ie, U, A), J += 6
					}
				a.addGroup(p, J, T), p += J, f += Y
			}
		}
		static fromJSON(e) {
			return new Jr(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
		}
	};

	function ga(r) {
		let e = {};
		for (let t in r) {
			e[t] = {};
			for (let n in r[t]) {
				let i = r[t][n];
				i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
			}
		}
		return e
	}

	function Zn(r) {
		let e = {};
		for (let t = 0; t < r.length; t++) {
			let n = ga(r[t]);
			for (let i in n) e[i] = n[i]
		}
		return e
	}

	function H_(r) {
		let e = [];
		for (let t = 0; t < r.length; t++) e.push(r[t].clone());
		return e
	}
	var W_ = {
			clone: ga,
			merge: Zn
		},
		j_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
		q_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
		$r = class extends rr {
			constructor(e) {
				super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = j_, this.fragmentShader = q_, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
					derivatives: !1,
					fragDepth: !1,
					drawBuffers: !1,
					shaderTextureLOD: !1
				}, this.defaultAttributeValues = {
					color: [1, 1, 1],
					uv: [0, 0],
					uv2: [0, 0]
				}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ga(e.uniforms), this.uniformsGroups = H_(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
			}
			toJSON(e) {
				let t = super.toJSON(e);
				t.glslVersion = this.glslVersion, t.uniforms = {};
				for (let i in this.uniforms) {
					let o = this.uniforms[i].value;
					o && o.isTexture ? t.uniforms[i] = {
						type: "t",
						value: o.toJSON(e)
							.uuid
					} : o && o.isColor ? t.uniforms[i] = {
						type: "c",
						value: o.getHex()
					} : o && o.isVector2 ? t.uniforms[i] = {
						type: "v2",
						value: o.toArray()
					} : o && o.isVector3 ? t.uniforms[i] = {
						type: "v3",
						value: o.toArray()
					} : o && o.isVector4 ? t.uniforms[i] = {
						type: "v4",
						value: o.toArray()
					} : o && o.isMatrix3 ? t.uniforms[i] = {
						type: "m3",
						value: o.toArray()
					} : o && o.isMatrix4 ? t.uniforms[i] = {
						type: "m4",
						value: o.toArray()
					} : t.uniforms[i] = {
						value: o
					}
				}
				Object.keys(this.defines)
					.length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
				let n = {};
				for (let i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
				return Object.keys(n)
					.length > 0 && (t.extensions = n), t
			}
		},
		mu = class extends yt {
			constructor() {
				super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ke, this.projectionMatrix = new ke, this.projectionMatrixInverse = new ke
			}
			copy(e, t) {
				return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
			}
			getWorldDirection(e) {
				this.updateWorldMatrix(!0, !1);
				let t = this.matrixWorld.elements;
				return e.set(-t[8], -t[9], -t[10])
					.normalize()
			}
			updateMatrixWorld(e) {
				super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld)
					.invert()
			}
			updateWorldMatrix(e, t) {
				super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld)
					.invert()
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
		},
		Kt = class extends mu {
			constructor(e = 50, t = 1, n = .1, i = 2e3) {
				super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
			}
			copy(e, t) {
				return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
			}
			setFocalLength(e) {
				let t = .5 * this.getFilmHeight() / e;
				this.fov = Tl * 2 * Math.atan(t), this.updateProjectionMatrix()
			}
			getFocalLength() {
				let e = Math.tan(la * .5 * this.fov);
				return .5 * this.getFilmHeight() / e
			}
			getEffectiveFOV() {
				return Tl * 2 * Math.atan(Math.tan(la * .5 * this.fov) / this.zoom)
			}
			getFilmWidth() {
				return this.filmGauge * Math.min(this.aspect, 1)
			}
			getFilmHeight() {
				return this.filmGauge / Math.max(this.aspect, 1)
			}
			setViewOffset(e, t, n, i, s, o) {
				this.aspect = e / t, this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let e = this.near,
					t = e * Math.tan(la * .5 * this.fov) / this.zoom,
					n = 2 * t,
					i = this.aspect * n,
					s = -.5 * i,
					o = this.view;
				if (this.view !== null && this.view.enabled) {
					let c = o.fullWidth,
						l = o.fullHeight;
					s += o.offsetX * i / c, t -= o.offsetY * n / l, i *= o.width / c, n *= o.height / l
				}
				let a = this.filmOffset;
				a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix)
					.invert()
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
			}
		},
		Qo = 90,
		ea = 1,
		yd = class extends yt {
			constructor(e, t, n) {
				super(), this.type = "CubeCamera", this.renderTarget = n;
				let i = new Kt(Qo, ea, e, t);
				i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new ne(1, 0, 0)), this.add(i);
				let s = new Kt(Qo, ea, e, t);
				s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new ne(-1, 0, 0)), this.add(s);
				let o = new Kt(Qo, ea, e, t);
				o.layers = this.layers, o.up.set(0, 0, 1), o.lookAt(new ne(0, 1, 0)), this.add(o);
				let a = new Kt(Qo, ea, e, t);
				a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new ne(0, -1, 0)), this.add(a);
				let c = new Kt(Qo, ea, e, t);
				c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new ne(0, 0, 1)), this.add(c);
				let l = new Kt(Qo, ea, e, t);
				l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new ne(0, 0, -1)), this.add(l)
			}
			update(e, t) {
				this.parent === null && this.updateMatrixWorld();
				let n = this.renderTarget,
					[i, s, o, a, c, l] = this.children,
					u = e.getRenderTarget(),
					h = e.toneMapping,
					f = e.xr.enabled;
				e.toneMapping = Yr, e.xr.enabled = !1;
				let p = n.texture.generateMipmaps;
				n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, s), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, a), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = p, e.setRenderTarget(n, 5), e.render(t, l), e.setRenderTarget(u), e.toneMapping = h, e.xr.enabled = f, n.texture.needsPMREMUpdate = !0
			}
		},
		Cl = class extends Pn {
			constructor(e, t, n, i, s, o, a, c, l, u) {
				e = e !== void 0 ? e : [], t = t !== void 0 ? t : ua, super(e, t, n, i, s, o, a, c, l, u), this.isCubeTexture = !0, this.flipY = !1
			}
			get images() {
				return this.image
			}
			set images(e) {
				this.image = e
			}
		},
		_d = class extends Zr {
			constructor(e, t = {}) {
				super(e, e, t), this.isWebGLCubeRenderTarget = !0;
				let n = {
						width: e,
						height: e,
						depth: 1
					},
					i = [n, n, n, n, n, n];
				this.texture = new Cl(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : pn
			}
			fromEquirectangularTexture(e, t) {
				this.texture.type = t.type, this.texture.encoding = t.encoding, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
				let n = {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
						fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
					},
					i = new Jr(5, 5, 5),
					s = new $r({
						name: "CubemapFromEquirect",
						uniforms: ga(n.uniforms),
						vertexShader: n.vertexShader,
						fragmentShader: n.fragmentShader,
						side: Rn,
						blending: Is
					});
				s.uniforms.tEquirect.value = t;
				let o = new zt(i, s),
					a = t.minFilter;
				return t.minFilter === Er && (t.minFilter = pn), new yd(1, 10, this)
					.update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
			}
			clear(e, t, n, i) {
				let s = e.getRenderTarget();
				for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
				e.setRenderTarget(s)
			}
		},
		od = new ne,
		X_ = new ne,
		Y_ = new Jn,
		nr = class {
			constructor(e = new ne(1, 0, 0), t = 0) {
				this.isPlane = !0, this.normal = e, this.constant = t
			}
			set(e, t) {
				return this.normal.copy(e), this.constant = t, this
			}
			setComponents(e, t, n, i) {
				return this.normal.set(e, t, n), this.constant = i, this
			}
			setFromNormalAndCoplanarPoint(e, t) {
				return this.normal.copy(e), this.constant = -t.dot(this.normal), this
			}
			setFromCoplanarPoints(e, t, n) {
				let i = od.subVectors(n, t)
					.cross(X_.subVectors(e, t))
					.normalize();
				return this.setFromNormalAndCoplanarPoint(i, e), this
			}
			copy(e) {
				return this.normal.copy(e.normal), this.constant = e.constant, this
			}
			normalize() {
				let e = 1 / this.normal.length();
				return this.normal.multiplyScalar(e), this.constant *= e, this
			}
			negate() {
				return this.constant *= -1, this.normal.negate(), this
			}
			distanceToPoint(e) {
				return this.normal.dot(e) + this.constant
			}
			distanceToSphere(e) {
				return this.distanceToPoint(e.center) - e.radius
			}
			projectPoint(e, t) {
				return t.copy(this.normal)
					.multiplyScalar(-this.distanceToPoint(e))
					.add(e)
			}
			intersectLine(e, t) {
				let n = e.delta(od),
					i = this.normal.dot(n);
				if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
				let s = -(e.start.dot(this.normal) + this.constant) / i;
				return s < 0 || s > 1 ? null : t.copy(n)
					.multiplyScalar(s)
					.add(e.start)
			}
			intersectsLine(e) {
				let t = this.distanceToPoint(e.start),
					n = this.distanceToPoint(e.end);
				return t < 0 && n > 0 || n < 0 && t > 0
			}
			intersectsBox(e) {
				return e.intersectsPlane(this)
			}
			intersectsSphere(e) {
				return e.intersectsPlane(this)
			}
			coplanarPoint(e) {
				return e.copy(this.normal)
					.multiplyScalar(-this.constant)
			}
			applyMatrix4(e, t) {
				let n = t || Y_.getNormalMatrix(e),
					i = this.coplanarPoint(od)
					.applyMatrix4(e),
					s = this.normal.applyMatrix3(n)
					.normalize();
				return this.constant = -i.dot(s), this
			}
			translate(e) {
				return this.constant -= e.dot(this.normal), this
			}
			equals(e) {
				return e.normal.equals(this.normal) && e.constant === this.constant
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
		},
		ta = new Kr,
		Jc = new ne,
		Al = class {
			constructor(e = new nr, t = new nr, n = new nr, i = new nr, s = new nr, o = new nr) {
				this.planes = [e, t, n, i, s, o]
			}
			set(e, t, n, i, s, o) {
				let a = this.planes;
				return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
			}
			copy(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
				return this
			}
			setFromProjectionMatrix(e) {
				let t = this.planes,
					n = e.elements,
					i = n[0],
					s = n[1],
					o = n[2],
					a = n[3],
					c = n[4],
					l = n[5],
					u = n[6],
					h = n[7],
					f = n[8],
					p = n[9],
					g = n[10],
					m = n[11],
					d = n[12],
					v = n[13],
					x = n[14],
					_ = n[15];
				return t[0].setComponents(a - i, h - c, m - f, _ - d)
					.normalize(), t[1].setComponents(a + i, h + c, m + f, _ + d)
					.normalize(), t[2].setComponents(a + s, h + l, m + p, _ + v)
					.normalize(), t[3].setComponents(a - s, h - l, m - p, _ - v)
					.normalize(), t[4].setComponents(a - o, h - u, m - g, _ - x)
					.normalize(), t[5].setComponents(a + o, h + u, m + g, _ + x)
					.normalize(), this
			}
			intersectsObject(e) {
				let t = e.geometry;
				return t.boundingSphere === null && t.computeBoundingSphere(), ta.copy(t.boundingSphere)
					.applyMatrix4(e.matrixWorld), this.intersectsSphere(ta)
			}
			intersectsSprite(e) {
				return ta.center.set(0, 0, 0), ta.radius = .7071067811865476, ta.applyMatrix4(e.matrixWorld), this.intersectsSphere(ta)
			}
			intersectsSphere(e) {
				let t = this.planes,
					n = e.center,
					i = -e.radius;
				for (let s = 0; s < 6; s++)
					if (t[s].distanceToPoint(n) < i) return !1;
				return !0
			}
			intersectsBox(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++) {
					let i = t[n];
					if (Jc.x = i.normal.x > 0 ? e.max.x : e.min.x, Jc.y = i.normal.y > 0 ? e.max.y : e.min.y, Jc.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Jc) < 0) return !1
				}
				return !0
			}
			containsPoint(e) {
				let t = this.planes;
				for (let n = 0; n < 6; n++)
					if (t[n].distanceToPoint(e) < 0) return !1;
				return !0
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
		};

	function lv() {
		let r = null,
			e = !1,
			t = null,
			n = null;

		function i(s, o) {
			t(s, o), n = r.requestAnimationFrame(i)
		}
		return {
			start: function() {
				e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0)
			},
			stop: function() {
				r.cancelAnimationFrame(n), e = !1
			},
			setAnimationLoop: function(s) {
				t = s
			},
			setContext: function(s) {
				r = s
			}
		}
	}

	function Z_(r, e) {
		let t = e.isWebGL2,
			n = new WeakMap;

		function i(l, u) {
			let h = l.array,
				f = l.usage,
				p = r.createBuffer();
			r.bindBuffer(u, p), r.bufferData(u, h, f), l.onUploadCallback();
			let g;
			if (h instanceof Float32Array) g = 5126;
			else if (h instanceof Uint16Array)
				if (l.isFloat16BufferAttribute)
					if (t) g = 5131;
					else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
			else g = 5123;
			else if (h instanceof Int16Array) g = 5122;
			else if (h instanceof Uint32Array) g = 5125;
			else if (h instanceof Int32Array) g = 5124;
			else if (h instanceof Int8Array) g = 5120;
			else if (h instanceof Uint8Array) g = 5121;
			else if (h instanceof Uint8ClampedArray) g = 5121;
			else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
			return {
				buffer: p,
				type: g,
				bytesPerElement: h.BYTES_PER_ELEMENT,
				version: l.version
			}
		}

		function s(l, u, h) {
			let f = u.array,
				p = u.updateRange;
			r.bindBuffer(h, l), p.count === -1 ? r.bufferSubData(h, 0, f) : (t ? r.bufferSubData(h, p.offset * f.BYTES_PER_ELEMENT, f, p.offset, p.count) : r.bufferSubData(h, p.offset * f.BYTES_PER_ELEMENT, f.subarray(p.offset, p.offset + p.count)), p.count = -1)
		}

		function o(l) {
			return l.isInterleavedBufferAttribute && (l = l.data), n.get(l)
		}

		function a(l) {
			l.isInterleavedBufferAttribute && (l = l.data);
			let u = n.get(l);
			u && (r.deleteBuffer(u.buffer), n.delete(l))
		}

		function c(l, u) {
			if (l.isGLBufferAttribute) {
				let f = n.get(l);
				(!f || f.version < l.version) && n.set(l, {
					buffer: l.buffer,
					type: l.type,
					bytesPerElement: l.elementSize,
					version: l.version
				});
				return
			}
			l.isInterleavedBufferAttribute && (l = l.data);
			let h = n.get(l);
			h === void 0 ? n.set(l, i(l, u)) : h.version < l.version && (s(h.buffer, l, u), h.version = l.version)
		}
		return {
			get: o,
			remove: a,
			update: c
		}
	}
	var To = class extends bt {
			constructor(e = 1, t = 1, n = 1, i = 1) {
				super(), this.type = "PlaneGeometry", this.parameters = {
					width: e,
					height: t,
					widthSegments: n,
					heightSegments: i
				};
				let s = e / 2,
					o = t / 2,
					a = Math.floor(n),
					c = Math.floor(i),
					l = a + 1,
					u = c + 1,
					h = e / a,
					f = t / c,
					p = [],
					g = [],
					m = [],
					d = [];
				for (let v = 0; v < u; v++) {
					let x = v * f - o;
					for (let _ = 0; _ < l; _++) {
						let y = _ * h - s;
						g.push(y, -x, 0), m.push(0, 0, 1), d.push(_ / a), d.push(1 - v / c)
					}
				}
				for (let v = 0; v < c; v++)
					for (let x = 0; x < a; x++) {
						let _ = x + l * v,
							y = x + l * (v + 1),
							w = x + 1 + l * (v + 1),
							C = x + 1 + l * v;
						p.push(_, y, C), p.push(y, w, C)
					}
				this.setIndex(p), this.setAttribute("position", new ze(g, 3)), this.setAttribute("normal", new ze(m, 3)), this.setAttribute("uv", new ze(d, 2))
			}
			static fromJSON(e) {
				return new To(e.width, e.height, e.widthSegments, e.heightSegments)
			}
		},
		K_ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
		J_ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		$_ = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
		Q_ = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
		eb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
		tb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
		nb = "vec3 transformed = vec3( position );",
		ib = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
		rb = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
		sb = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
		ob = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
		ab = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
		lb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
		cb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
		ub = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
		hb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
		fb = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
		db = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
		pb = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
		mb = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
		gb = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
		vb = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
		xb = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
		yb = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
		_b = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
		bb = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
		Mb = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
		wb = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
		Tb = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
		Sb = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
		Eb = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
		Cb = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
		Ab = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
		Ib = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
		Rb = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
		Pb = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
		Lb = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
		Nb = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
		Db = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
		Ob = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
		kb = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
		Fb = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
#define Material_LightProbeLOD( material )	(0)`,
		Ub = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
		Bb = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
		Gb = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
		Vb = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
		zb = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
		Hb = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
		Wb = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
		jb = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
		qb = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
		Xb = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
		Yb = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
		Zb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
		Kb = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
		Jb = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
		$b = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
		Qb = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
		eM = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
		tM = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
		nM = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
		iM = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
		rM = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
		sM = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
		oM = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
		aM = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
		lM = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
		cM = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
		uM = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
		hM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		fM = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
		dM = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
		pM = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
		mM = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
		gM = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
		vM = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
		xM = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
		yM = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
		_M = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
		bM = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
		MM = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
		wM = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
		TM = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
		SM = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
		EM = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
		CM = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
		AM = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
		IM = `#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
		RM = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
		PM = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
		LM = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
		NM = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
		DM = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
		OM = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
		kM = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
		FM = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
		UM = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
		BM = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
		GM = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
		VM = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
		zM = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
		HM = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
		WM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
		jM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
		qM = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
		XM = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
		YM = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
		ZM = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		KM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
		JM = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		$M = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
		QM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
		ew = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
		tw = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
		nw = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
		iw = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
		rw = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		sw = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		ow = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
		aw = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		lw = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		cw = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		uw = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
		hw = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		fw = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
		dw = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
		pw = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		mw = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		gw = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
		vw = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		xw = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		yw = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
		_w = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
		bw = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
		Mw = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
		ww = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
		Tw = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
		Sw = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
		_t = {
			alphamap_fragment: K_,
			alphamap_pars_fragment: J_,
			alphatest_fragment: $_,
			alphatest_pars_fragment: Q_,
			aomap_fragment: eb,
			aomap_pars_fragment: tb,
			begin_vertex: nb,
			beginnormal_vertex: ib,
			bsdfs: rb,
			iridescence_fragment: sb,
			bumpmap_pars_fragment: ob,
			clipping_planes_fragment: ab,
			clipping_planes_pars_fragment: lb,
			clipping_planes_pars_vertex: cb,
			clipping_planes_vertex: ub,
			color_fragment: hb,
			color_pars_fragment: fb,
			color_pars_vertex: db,
			color_vertex: pb,
			common: mb,
			cube_uv_reflection_fragment: gb,
			defaultnormal_vertex: vb,
			displacementmap_pars_vertex: xb,
			displacementmap_vertex: yb,
			emissivemap_fragment: _b,
			emissivemap_pars_fragment: bb,
			encodings_fragment: Mb,
			encodings_pars_fragment: wb,
			envmap_fragment: Tb,
			envmap_common_pars_fragment: Sb,
			envmap_pars_fragment: Eb,
			envmap_pars_vertex: Cb,
			envmap_physical_pars_fragment: Bb,
			envmap_vertex: Ab,
			fog_vertex: Ib,
			fog_pars_vertex: Rb,
			fog_fragment: Pb,
			fog_pars_fragment: Lb,
			gradientmap_pars_fragment: Nb,
			lightmap_fragment: Db,
			lightmap_pars_fragment: Ob,
			lights_lambert_fragment: kb,
			lights_lambert_pars_fragment: Fb,
			lights_pars_begin: Ub,
			lights_toon_fragment: Gb,
			lights_toon_pars_fragment: Vb,
			lights_phong_fragment: zb,
			lights_phong_pars_fragment: Hb,
			lights_physical_fragment: Wb,
			lights_physical_pars_fragment: jb,
			lights_fragment_begin: qb,
			lights_fragment_maps: Xb,
			lights_fragment_end: Yb,
			logdepthbuf_fragment: Zb,
			logdepthbuf_pars_fragment: Kb,
			logdepthbuf_pars_vertex: Jb,
			logdepthbuf_vertex: $b,
			map_fragment: Qb,
			map_pars_fragment: eM,
			map_particle_fragment: tM,
			map_particle_pars_fragment: nM,
			metalnessmap_fragment: iM,
			metalnessmap_pars_fragment: rM,
			morphcolor_vertex: sM,
			morphnormal_vertex: oM,
			morphtarget_pars_vertex: aM,
			morphtarget_vertex: lM,
			normal_fragment_begin: cM,
			normal_fragment_maps: uM,
			normal_pars_fragment: hM,
			normal_pars_vertex: fM,
			normal_vertex: dM,
			normalmap_pars_fragment: pM,
			clearcoat_normal_fragment_begin: mM,
			clearcoat_normal_fragment_maps: gM,
			clearcoat_pars_fragment: vM,
			iridescence_pars_fragment: xM,
			output_fragment: yM,
			packing: _M,
			premultiplied_alpha_fragment: bM,
			project_vertex: MM,
			dithering_fragment: wM,
			dithering_pars_fragment: TM,
			roughnessmap_fragment: SM,
			roughnessmap_pars_fragment: EM,
			shadowmap_pars_fragment: CM,
			shadowmap_pars_vertex: AM,
			shadowmap_vertex: IM,
			shadowmask_pars_fragment: RM,
			skinbase_vertex: PM,
			skinning_pars_vertex: LM,
			skinning_vertex: NM,
			skinnormal_vertex: DM,
			specularmap_fragment: OM,
			specularmap_pars_fragment: kM,
			tonemapping_fragment: FM,
			tonemapping_pars_fragment: UM,
			transmission_fragment: BM,
			transmission_pars_fragment: GM,
			uv_pars_fragment: VM,
			uv_pars_vertex: zM,
			uv_vertex: HM,
			uv2_pars_fragment: WM,
			uv2_pars_vertex: jM,
			uv2_vertex: qM,
			worldpos_vertex: XM,
			background_vert: YM,
			background_frag: ZM,
			cube_vert: KM,
			cube_frag: JM,
			depth_vert: $M,
			depth_frag: QM,
			distanceRGBA_vert: ew,
			distanceRGBA_frag: tw,
			equirect_vert: nw,
			equirect_frag: iw,
			linedashed_vert: rw,
			linedashed_frag: sw,
			meshbasic_vert: ow,
			meshbasic_frag: aw,
			meshlambert_vert: lw,
			meshlambert_frag: cw,
			meshmatcap_vert: uw,
			meshmatcap_frag: hw,
			meshnormal_vert: fw,
			meshnormal_frag: dw,
			meshphong_vert: pw,
			meshphong_frag: mw,
			meshphysical_vert: gw,
			meshphysical_frag: vw,
			meshtoon_vert: xw,
			meshtoon_frag: yw,
			points_vert: _w,
			points_frag: bw,
			shadow_vert: Mw,
			shadow_frag: ww,
			sprite_vert: Tw,
			sprite_frag: Sw
		},
		Ne = {
			common: {
				diffuse: {
					value: new Xe(16777215)
				},
				opacity: {
					value: 1
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new Jn
				},
				uv2Transform: {
					value: new Jn
				},
				alphaMap: {
					value: null
				},
				alphaTest: {
					value: 0
				}
			},
			specularmap: {
				specularMap: {
					value: null
				}
			},
			envmap: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				reflectivity: {
					value: 1
				},
				ior: {
					value: 1.5
				},
				refractionRatio: {
					value: .98
				}
			},
			aomap: {
				aoMap: {
					value: null
				},
				aoMapIntensity: {
					value: 1
				}
			},
			lightmap: {
				lightMap: {
					value: null
				},
				lightMapIntensity: {
					value: 1
				}
			},
			emissivemap: {
				emissiveMap: {
					value: null
				}
			},
			bumpmap: {
				bumpMap: {
					value: null
				},
				bumpScale: {
					value: 1
				}
			},
			normalmap: {
				normalMap: {
					value: null
				},
				normalScale: {
					value: new st(1, 1)
				}
			},
			displacementmap: {
				displacementMap: {
					value: null
				},
				displacementScale: {
					value: 1
				},
				displacementBias: {
					value: 0
				}
			},
			roughnessmap: {
				roughnessMap: {
					value: null
				}
			},
			metalnessmap: {
				metalnessMap: {
					value: null
				}
			},
			gradientmap: {
				gradientMap: {
					value: null
				}
			},
			fog: {
				fogDensity: {
					value: 25e-5
				},
				fogNear: {
					value: 1
				},
				fogFar: {
					value: 2e3
				},
				fogColor: {
					value: new Xe(16777215)
				}
			},
			lights: {
				ambientLightColor: {
					value: []
				},
				lightProbe: {
					value: []
				},
				directionalLights: {
					value: [],
					properties: {
						direction: {},
						color: {}
					}
				},
				directionalLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				directionalShadowMap: {
					value: []
				},
				directionalShadowMatrix: {
					value: []
				},
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {}
					}
				},
				spotLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				spotLightMap: {
					value: []
				},
				spotShadowMap: {
					value: []
				},
				spotLightMatrix: {
					value: []
				},
				pointLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						decay: {},
						distance: {}
					}
				},
				pointLightShadows: {
					value: [],
					properties: {
						shadowBias: {},
						shadowNormalBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					}
				},
				pointShadowMap: {
					value: []
				},
				pointShadowMatrix: {
					value: []
				},
				hemisphereLights: {
					value: [],
					properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					}
				},
				rectAreaLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					}
				},
				ltc_1: {
					value: null
				},
				ltc_2: {
					value: null
				}
			},
			points: {
				diffuse: {
					value: new Xe(16777215)
				},
				opacity: {
					value: 1
				},
				size: {
					value: 1
				},
				scale: {
					value: 1
				},
				map: {
					value: null
				},
				alphaMap: {
					value: null
				},
				alphaTest: {
					value: 0
				},
				uvTransform: {
					value: new Jn
				}
			},
			sprite: {
				diffuse: {
					value: new Xe(16777215)
				},
				opacity: {
					value: 1
				},
				center: {
					value: new st(.5, .5)
				},
				rotation: {
					value: 0
				},
				map: {
					value: null
				},
				alphaMap: {
					value: null
				},
				alphaTest: {
					value: 0
				},
				uvTransform: {
					value: new Jn
				}
			}
		},
		yr = {
			basic: {
				uniforms: Zn([Ne.common, Ne.specularmap, Ne.envmap, Ne.aomap, Ne.lightmap, Ne.fog]),
				vertexShader: _t.meshbasic_vert,
				fragmentShader: _t.meshbasic_frag
			},
			lambert: {
				uniforms: Zn([Ne.common, Ne.specularmap, Ne.envmap, Ne.aomap, Ne.lightmap, Ne.emissivemap, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, Ne.fog, Ne.lights, {
					emissive: {
						value: new Xe(0)
					}
				}]),
				vertexShader: _t.meshlambert_vert,
				fragmentShader: _t.meshlambert_frag
			},
			phong: {
				uniforms: Zn([Ne.common, Ne.specularmap, Ne.envmap, Ne.aomap, Ne.lightmap, Ne.emissivemap, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, Ne.fog, Ne.lights, {
					emissive: {
						value: new Xe(0)
					},
					specular: {
						value: new Xe(1118481)
					},
					shininess: {
						value: 30
					}
				}]),
				vertexShader: _t.meshphong_vert,
				fragmentShader: _t.meshphong_frag
			},
			standard: {
				uniforms: Zn([Ne.common, Ne.envmap, Ne.aomap, Ne.lightmap, Ne.emissivemap, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, Ne.roughnessmap, Ne.metalnessmap, Ne.fog, Ne.lights, {
					emissive: {
						value: new Xe(0)
					},
					roughness: {
						value: 1
					},
					metalness: {
						value: 0
					},
					envMapIntensity: {
						value: 1
					}
				}]),
				vertexShader: _t.meshphysical_vert,
				fragmentShader: _t.meshphysical_frag
			},
			toon: {
				uniforms: Zn([Ne.common, Ne.aomap, Ne.lightmap, Ne.emissivemap, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, Ne.gradientmap, Ne.fog, Ne.lights, {
					emissive: {
						value: new Xe(0)
					}
				}]),
				vertexShader: _t.meshtoon_vert,
				fragmentShader: _t.meshtoon_frag
			},
			matcap: {
				uniforms: Zn([Ne.common, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, Ne.fog, {
					matcap: {
						value: null
					}
				}]),
				vertexShader: _t.meshmatcap_vert,
				fragmentShader: _t.meshmatcap_frag
			},
			points: {
				uniforms: Zn([Ne.points, Ne.fog]),
				vertexShader: _t.points_vert,
				fragmentShader: _t.points_frag
			},
			dashed: {
				uniforms: Zn([Ne.common, Ne.fog, {
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}]),
				vertexShader: _t.linedashed_vert,
				fragmentShader: _t.linedashed_frag
			},
			depth: {
				uniforms: Zn([Ne.common, Ne.displacementmap]),
				vertexShader: _t.depth_vert,
				fragmentShader: _t.depth_frag
			},
			normal: {
				uniforms: Zn([Ne.common, Ne.bumpmap, Ne.normalmap, Ne.displacementmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: _t.meshnormal_vert,
				fragmentShader: _t.meshnormal_frag
			},
			sprite: {
				uniforms: Zn([Ne.sprite, Ne.fog]),
				vertexShader: _t.sprite_vert,
				fragmentShader: _t.sprite_frag
			},
			background: {
				uniforms: {
					uvTransform: {
						value: new Jn
					},
					t2D: {
						value: null
					}
				},
				vertexShader: _t.background_vert,
				fragmentShader: _t.background_frag
			},
			cube: {
				uniforms: Zn([Ne.envmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: _t.cube_vert,
				fragmentShader: _t.cube_frag
			},
			equirect: {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: _t.equirect_vert,
				fragmentShader: _t.equirect_frag
			},
			distanceRGBA: {
				uniforms: Zn([Ne.common, Ne.displacementmap, {
					referencePosition: {
						value: new ne
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1e3
					}
				}]),
				vertexShader: _t.distanceRGBA_vert,
				fragmentShader: _t.distanceRGBA_frag
			},
			shadow: {
				uniforms: Zn([Ne.lights, Ne.fog, {
					color: {
						value: new Xe(0)
					},
					opacity: {
						value: 1
					}
				}]),
				vertexShader: _t.shadow_vert,
				fragmentShader: _t.shadow_frag
			}
		};
	yr.physical = {
		uniforms: Zn([yr.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new st(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			iridescence: {
				value: 0
			},
			iridescenceMap: {
				value: null
			},
			iridescenceIOR: {
				value: 1.3
			},
			iridescenceThicknessMinimum: {
				value: 100
			},
			iridescenceThicknessMaximum: {
				value: 400
			},
			iridescenceThicknessMap: {
				value: null
			},
			sheen: {
				value: 0
			},
			sheenColor: {
				value: new Xe(0)
			},
			sheenColorMap: {
				value: null
			},
			sheenRoughness: {
				value: 1
			},
			sheenRoughnessMap: {
				value: null
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionSamplerSize: {
				value: new st
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			attenuationDistance: {
				value: 0
			},
			attenuationColor: {
				value: new Xe(0)
			},
			specularIntensity: {
				value: 1
			},
			specularIntensityMap: {
				value: null
			},
			specularColor: {
				value: new Xe(1, 1, 1)
			},
			specularColorMap: {
				value: null
			}
		}]),
		vertexShader: _t.meshphysical_vert,
		fragmentShader: _t.meshphysical_frag
	};

	function Ew(r, e, t, n, i, s) {
		let o = new Xe(0),
			a = i === !0 ? 0 : 1,
			c, l, u = null,
			h = 0,
			f = null;

		function p(m, d) {
			let v = !1,
				x = d.isScene === !0 ? d.background : null;
			x && x.isTexture && (x = e.get(x));
			let _ = r.xr,
				y = _.getSession && _.getSession();
			y && y.environmentBlendMode === "additive" && (x = null), x === null ? g(o, a) : x && x.isColor && (g(x, 1), v = !0), (r.autoClear || v) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil), x && (x.isCubeTexture || x.mapping === Cu) ? (l === void 0 && (l = new zt(new Jr(1, 1, 1), new $r({
				name: "BackgroundCubeMaterial",
				uniforms: ga(yr.cube.uniforms),
				vertexShader: yr.cube.vertexShader,
				fragmentShader: yr.cube.fragmentShader,
				side: Rn,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(w, C, S) {
				this.matrixWorld.copyPosition(S.matrixWorld)
			}, Object.defineProperty(l.material, "envMap", {
				get: function() {
					return this.uniforms.envMap.value
				}
			}), n.update(l)), l.material.uniforms.envMap.value = x, l.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, (u !== x || h !== x.version || f !== r.toneMapping) && (l.material.needsUpdate = !0, u = x, h = x.version, f = r.toneMapping), l.layers.enableAll(), m.unshift(l, l.geometry, l.material, 0, 0, null)) : x && x.isTexture && (c === void 0 && (c = new zt(new To(2, 2), new $r({
				name: "BackgroundMaterial",
				uniforms: ga(yr.background.uniforms),
				vertexShader: yr.background.vertexShader,
				fragmentShader: yr.background.fragmentShader,
				side: _r,
				depthTest: !1,
				depthWrite: !1,
				fog: !1
			})), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
				get: function() {
					return this.uniforms.t2D.value
				}
			}), n.update(c)), c.material.uniforms.t2D.value = x, x.matrixAutoUpdate === !0 && x.updateMatrix(), c.material.uniforms.uvTransform.value.copy(x.matrix), (u !== x || h !== x.version || f !== r.toneMapping) && (c.material.needsUpdate = !0, u = x, h = x.version, f = r.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null))
		}

		function g(m, d) {
			t.buffers.color.setClear(m.r, m.g, m.b, d, s)
		}
		return {
			getClearColor: function() {
				return o
			},
			setClearColor: function(m, d = 1) {
				o.set(m), a = d, g(o, a)
			},
			getClearAlpha: function() {
				return a
			},
			setClearAlpha: function(m) {
				a = m, g(o, a)
			},
			render: p
		}
	}

	function Cw(r, e, t, n) {
		let i = r.getParameter(34921),
			s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
			o = n.isWebGL2 || s !== null,
			a = {},
			c = d(null),
			l = c,
			u = !1;

		function h(I, q, B, Y, J) {
			let H = !1;
			if (o) {
				let $ = m(Y, B, q);
				l !== $ && (l = $, p(l.object)), H = v(I, Y, B, J), H && x(I, Y, B, J)
			} else {
				let $ = q.wireframe === !0;
				(l.geometry !== Y.id || l.program !== B.id || l.wireframe !== $) && (l.geometry = Y.id, l.program = B.id, l.wireframe = $, H = !0)
			}
			J !== null && t.update(J, 34963), (H || u) && (u = !1, b(I, q, B, Y), J !== null && r.bindBuffer(34963, t.get(J)
				.buffer))
		}

		function f() {
			return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES()
		}

		function p(I) {
			return n.isWebGL2 ? r.bindVertexArray(I) : s.bindVertexArrayOES(I)
		}

		function g(I) {
			return n.isWebGL2 ? r.deleteVertexArray(I) : s.deleteVertexArrayOES(I)
		}

		function m(I, q, B) {
			let Y = B.wireframe === !0,
				J = a[I.id];
			J === void 0 && (J = {}, a[I.id] = J);
			let H = J[q.id];
			H === void 0 && (H = {}, J[q.id] = H);
			let $ = H[Y];
			return $ === void 0 && ($ = d(f()), H[Y] = $), $
		}

		function d(I) {
			let q = [],
				B = [],
				Y = [];
			for (let J = 0; J < i; J++) q[J] = 0, B[J] = 0, Y[J] = 0;
			return {
				geometry: null,
				program: null,
				wireframe: !1,
				newAttributes: q,
				enabledAttributes: B,
				attributeDivisors: Y,
				object: I,
				attributes: {},
				index: null
			}
		}

		function v(I, q, B, Y) {
			let J = l.attributes,
				H = q.attributes,
				$ = 0,
				ae = B.getAttributes();
			for (let oe in ae)
				if (ae[oe].location >= 0) {
					let U = J[oe],
						A = H[oe];
					if (A === void 0 && (oe === "instanceMatrix" && I.instanceMatrix && (A = I.instanceMatrix), oe === "instanceColor" && I.instanceColor && (A = I.instanceColor)), U === void 0 || U.attribute !== A || A && U.data !== A.data) return !0;
					$++
				} return l.attributesNum !== $ || l.index !== Y
		}

		function x(I, q, B, Y) {
			let J = {},
				H = q.attributes,
				$ = 0,
				ae = B.getAttributes();
			for (let oe in ae)
				if (ae[oe].location >= 0) {
					let U = H[oe];
					U === void 0 && (oe === "instanceMatrix" && I.instanceMatrix && (U = I.instanceMatrix), oe === "instanceColor" && I.instanceColor && (U = I.instanceColor));
					let A = {};
					A.attribute = U, U && U.data && (A.data = U.data), J[oe] = A, $++
				} l.attributes = J, l.attributesNum = $, l.index = Y
		}

		function _() {
			let I = l.newAttributes;
			for (let q = 0, B = I.length; q < B; q++) I[q] = 0
		}

		function y(I) {
			w(I, 0)
		}

		function w(I, q) {
			let B = l.newAttributes,
				Y = l.enabledAttributes,
				J = l.attributeDivisors;
			B[I] = 1, Y[I] === 0 && (r.enableVertexAttribArray(I), Y[I] = 1), J[I] !== q && ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](I, q), J[I] = q)
		}

		function C() {
			let I = l.newAttributes,
				q = l.enabledAttributes;
			for (let B = 0, Y = q.length; B < Y; B++) q[B] !== I[B] && (r.disableVertexAttribArray(B), q[B] = 0)
		}

		function S(I, q, B, Y, J, H) {
			n.isWebGL2 === !0 && (B === 5124 || B === 5125) ? r.vertexAttribIPointer(I, q, B, J, H) : r.vertexAttribPointer(I, q, B, Y, J, H)
		}

		function b(I, q, B, Y) {
			if (n.isWebGL2 === !1 && (I.isInstancedMesh || Y.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
			_();
			let J = Y.attributes,
				H = B.getAttributes(),
				$ = q.defaultAttributeValues;
			for (let ae in H) {
				let oe = H[ae];
				if (oe.location >= 0) {
					let ie = J[ae];
					if (ie === void 0 && (ae === "instanceMatrix" && I.instanceMatrix && (ie = I.instanceMatrix), ae === "instanceColor" && I.instanceColor && (ie = I.instanceColor)), ie !== void 0) {
						let U = ie.normalized,
							A = ie.itemSize,
							L = t.get(ie);
						if (L === void 0) continue;
						let j = L.buffer,
							K = L.type,
							Q = L.bytesPerElement;
						if (ie.isInterleavedBufferAttribute) {
							let se = ie.data,
								de = se.stride,
								ue = ie.offset;
							if (se.isInstancedInterleavedBuffer) {
								for (let xe = 0; xe < oe.locationSize; xe++) w(oe.location + xe, se.meshPerAttribute);
								I.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = se.meshPerAttribute * se.count)
							} else
								for (let xe = 0; xe < oe.locationSize; xe++) y(oe.location + xe);
							r.bindBuffer(34962, j);
							for (let xe = 0; xe < oe.locationSize; xe++) S(oe.location + xe, A / oe.locationSize, K, U, de * Q, (ue + A / oe.locationSize * xe) * Q)
						} else {
							if (ie.isInstancedBufferAttribute) {
								for (let se = 0; se < oe.locationSize; se++) w(oe.location + se, ie.meshPerAttribute);
								I.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = ie.meshPerAttribute * ie.count)
							} else
								for (let se = 0; se < oe.locationSize; se++) y(oe.location + se);
							r.bindBuffer(34962, j);
							for (let se = 0; se < oe.locationSize; se++) S(oe.location + se, A / oe.locationSize, K, U, A * Q, A / oe.locationSize * se * Q)
						}
					} else if ($ !== void 0) {
						let U = $[ae];
						if (U !== void 0) switch (U.length) {
							case 2:
								r.vertexAttrib2fv(oe.location, U);
								break;
							case 3:
								r.vertexAttrib3fv(oe.location, U);
								break;
							case 4:
								r.vertexAttrib4fv(oe.location, U);
								break;
							default:
								r.vertexAttrib1fv(oe.location, U)
						}
					}
				}
			}
			C()
		}

		function T() {
			O();
			for (let I in a) {
				let q = a[I];
				for (let B in q) {
					let Y = q[B];
					for (let J in Y) g(Y[J].object), delete Y[J];
					delete q[B]
				}
				delete a[I]
			}
		}

		function N(I) {
			if (a[I.id] === void 0) return;
			let q = a[I.id];
			for (let B in q) {
				let Y = q[B];
				for (let J in Y) g(Y[J].object), delete Y[J];
				delete q[B]
			}
			delete a[I.id]
		}

		function V(I) {
			for (let q in a) {
				let B = a[q];
				if (B[I.id] === void 0) continue;
				let Y = B[I.id];
				for (let J in Y) g(Y[J].object), delete Y[J];
				delete B[I.id]
			}
		}

		function O() {
			k(), u = !0, l !== c && (l = c, p(l.object))
		}

		function k() {
			c.geometry = null, c.program = null, c.wireframe = !1
		}
		return {
			setup: h,
			reset: O,
			resetDefaultState: k,
			dispose: T,
			releaseStatesOfGeometry: N,
			releaseStatesOfProgram: V,
			initAttributes: _,
			enableAttribute: y,
			disableUnusedAttributes: C
		}
	}

	function Aw(r, e, t, n) {
		let i = n.isWebGL2,
			s;

		function o(l) {
			s = l
		}

		function a(l, u) {
			r.drawArrays(s, l, u), t.update(u, s, 1)
		}

		function c(l, u, h) {
			if (h === 0) return;
			let f, p;
			if (i) f = r, p = "drawArraysInstanced";
			else if (f = e.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", f === null) {
				console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			f[p](s, l, u, h), t.update(u, s, h)
		}
		this.setMode = o, this.render = a, this.renderInstances = c
	}

	function Iw(r, e, t) {
		let n;

		function i() {
			if (n !== void 0) return n;
			if (e.has("EXT_texture_filter_anisotropic") === !0) {
				let S = e.get("EXT_texture_filter_anisotropic");
				n = r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
			} else n = 0;
			return n
		}

		function s(S) {
			if (S === "highp") {
				if (r.getShaderPrecisionFormat(35633, 36338)
					.precision > 0 && r.getShaderPrecisionFormat(35632, 36338)
					.precision > 0) return "highp";
				S = "mediump"
			}
			return S === "mediump" && r.getShaderPrecisionFormat(35633, 36337)
				.precision > 0 && r.getShaderPrecisionFormat(35632, 36337)
				.precision > 0 ? "mediump" : "lowp"
		}
		let o = typeof WebGL2RenderingContext < "u" && r instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && r instanceof WebGL2ComputeRenderingContext,
			a = t.precision !== void 0 ? t.precision : "highp",
			c = s(a);
		c !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", c, "instead."), a = c);
		let l = o || e.has("WEBGL_draw_buffers"),
			u = t.logarithmicDepthBuffer === !0,
			h = r.getParameter(34930),
			f = r.getParameter(35660),
			p = r.getParameter(3379),
			g = r.getParameter(34076),
			m = r.getParameter(34921),
			d = r.getParameter(36347),
			v = r.getParameter(36348),
			x = r.getParameter(36349),
			_ = f > 0,
			y = o || e.has("OES_texture_float"),
			w = _ && y,
			C = o ? r.getParameter(36183) : 0;
		return {
			isWebGL2: o,
			drawBuffers: l,
			getMaxAnisotropy: i,
			getMaxPrecision: s,
			precision: a,
			logarithmicDepthBuffer: u,
			maxTextures: h,
			maxVertexTextures: f,
			maxTextureSize: p,
			maxCubemapSize: g,
			maxAttributes: m,
			maxVertexUniforms: d,
			maxVaryings: v,
			maxFragmentUniforms: x,
			vertexTextures: _,
			floatFragmentTextures: y,
			floatVertexTextures: w,
			maxSamples: C
		}
	}

	function Rw(r) {
		let e = this,
			t = null,
			n = 0,
			i = !1,
			s = !1,
			o = new nr,
			a = new Jn,
			c = {
				value: null,
				needsUpdate: !1
			};
		this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, f, p) {
			let g = h.length !== 0 || f || n !== 0 || i;
			return i = f, t = u(h, p, 0), n = h.length, g
		}, this.beginShadows = function() {
			s = !0, u(null)
		}, this.endShadows = function() {
			s = !1, l()
		}, this.setState = function(h, f, p) {
			let g = h.clippingPlanes,
				m = h.clipIntersection,
				d = h.clipShadows,
				v = r.get(h);
			if (!i || g === null || g.length === 0 || s && !d) s ? u(null) : l();
			else {
				let x = s ? 0 : n,
					_ = x * 4,
					y = v.clippingState || null;
				c.value = y, y = u(g, f, _, p);
				for (let w = 0; w !== _; ++w) y[w] = t[w];
				v.clippingState = y, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += x
			}
		};

		function l() {
			c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
		}

		function u(h, f, p, g) {
			let m = h !== null ? h.length : 0,
				d = null;
			if (m !== 0) {
				if (d = c.value, g !== !0 || d === null) {
					let v = p + m * 4,
						x = f.matrixWorldInverse;
					a.getNormalMatrix(x), (d === null || d.length < v) && (d = new Float32Array(v));
					for (let _ = 0, y = p; _ !== m; ++_, y += 4) o.copy(h[_])
						.applyMatrix4(x, a), o.normal.toArray(d, y), d[y + 3] = o.constant
				}
				c.value = d, c.needsUpdate = !0
			}
			return e.numPlanes = m, e.numIntersection = 0, d
		}
	}

	function Pw(r) {
		let e = new WeakMap;

		function t(o, a) {
			return a === Ml ? o.mapping = ua : a === md && (o.mapping = ha), o
		}

		function n(o) {
			if (o && o.isTexture && o.isRenderTargetTexture === !1) {
				let a = o.mapping;
				if (a === Ml || a === md)
					if (e.has(o)) {
						let c = e.get(o)
							.texture;
						return t(c, o.mapping)
					} else {
						let c = o.image;
						if (c && c.height > 0) {
							let l = new _d(c.height / 2);
							return l.fromEquirectangularTexture(r, o), e.set(o, l), o.addEventListener("dispose", i), t(l.texture, o.mapping)
						} else return null
					}
			}
			return o
		}

		function i(o) {
			let a = o.target;
			a.removeEventListener("dispose", i);
			let c = e.get(a);
			c !== void 0 && (e.delete(a), c.dispose())
		}

		function s() {
			e = new WeakMap
		}
		return {
			get: n,
			dispose: s
		}
	}
	var Mr = class extends mu {
			constructor(e = -1, t = 1, n = 1, i = -1, s = .1, o = 2e3) {
				super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix()
			}
			copy(e, t) {
				return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
			}
			setViewOffset(e, t, n, i, s, o) {
				this.view === null && (this.view = {
					enabled: !0,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				}), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
			}
			clearViewOffset() {
				this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
			}
			updateProjectionMatrix() {
				let e = (this.right - this.left) / (2 * this.zoom),
					t = (this.top - this.bottom) / (2 * this.zoom),
					n = (this.right + this.left) / 2,
					i = (this.top + this.bottom) / 2,
					s = n - e,
					o = n + e,
					a = i + t,
					c = i - t;
				if (this.view !== null && this.view.enabled) {
					let l = (this.right - this.left) / this.view.fullWidth / this.zoom,
						u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
					s += l * this.view.offsetX, o = s + l * this.view.width, a -= u * this.view.offsetY, c = a - u * this.view.height
				}
				this.projectionMatrix.makeOrthographic(s, o, a, c, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix)
					.invert()
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
			}
		},
		ra = 4,
		d0 = [.125, .215, .35, .446, .526, .582],
		go = 20,
		ad = new Mr,
		p0 = new Xe,
		ld = null,
		mo = (1 + Math.sqrt(5)) / 2,
		na = 1 / mo,
		m0 = [new ne(1, 1, 1), new ne(-1, 1, 1), new ne(1, 1, -1), new ne(-1, 1, -1), new ne(0, mo, na), new ne(0, mo, -na), new ne(na, 0, mo), new ne(-na, 0, mo), new ne(mo, na, 0), new ne(-mo, na, 0)],
		gu = class {
			constructor(e) {
				this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
			}
			fromScene(e, t = 0, n = .1, i = 100) {
				ld = this._renderer.getRenderTarget(), this._setSize(256);
				let s = this._allocateTargets();
				return s.depthBuffer = !0, this._sceneToCubeUV(e, n, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
			}
			fromEquirectangular(e, t = null) {
				return this._fromTexture(e, t)
			}
			fromCubemap(e, t = null) {
				return this._fromTexture(e, t)
			}
			compileCubemapShader() {
				this._cubemapMaterial === null && (this._cubemapMaterial = x0(), this._compileMaterial(this._cubemapMaterial))
			}
			compileEquirectangularShader() {
				this._equirectMaterial === null && (this._equirectMaterial = v0(), this._compileMaterial(this._equirectMaterial))
			}
			dispose() {
				this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
			}
			_setSize(e) {
				this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
			}
			_dispose() {
				this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
				for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
			}
			_cleanup(e) {
				this._renderer.setRenderTarget(ld), e.scissorTest = !1, $c(e, 0, 0, e.width, e.height)
			}
			_fromTexture(e, t) {
				e.mapping === ua || e.mapping === ha ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ld = this._renderer.getRenderTarget();
				let n = t || this._allocateTargets();
				return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
			}
			_allocateTargets() {
				let e = 3 * Math.max(this._cubeSize, 112),
					t = 4 * this._cubeSize,
					n = {
						magFilter: pn,
						minFilter: pn,
						generateMipmaps: !1,
						type: wl,
						format: ir,
						encoding: Mo,
						depthBuffer: !1
					},
					i = g0(e, t, n);
				if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
					this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = g0(e, t, n);
					let {
						_lodMax: s
					} = this;
					({
						sizeLods: this._sizeLods,
						lodPlanes: this._lodPlanes,
						sigmas: this._sigmas
					} = Lw(s)), this._blurMaterial = Nw(s, e, t)
				}
				return i
			}
			_compileMaterial(e) {
				let t = new zt(this._lodPlanes[0], e);
				this._renderer.compile(t, ad)
			}
			_sceneToCubeUV(e, t, n, i) {
				let a = new Kt(90, 1, t, n),
					c = [1, -1, 1, 1, 1, 1],
					l = [1, 1, 1, -1, -1, -1],
					u = this._renderer,
					h = u.autoClear,
					f = u.toneMapping;
				u.getClearColor(p0), u.toneMapping = Yr, u.autoClear = !1;
				let p = new Oi({
						name: "PMREM.Background",
						side: Rn,
						depthWrite: !1,
						depthTest: !1
					}),
					g = new zt(new Jr, p),
					m = !1,
					d = e.background;
				d ? d.isColor && (p.color.copy(d), e.background = null, m = !0) : (p.color.copy(p0), m = !0);
				for (let v = 0; v < 6; v++) {
					let x = v % 3;
					x === 0 ? (a.up.set(0, c[v], 0), a.lookAt(l[v], 0, 0)) : x === 1 ? (a.up.set(0, 0, c[v]), a.lookAt(0, l[v], 0)) : (a.up.set(0, c[v], 0), a.lookAt(0, 0, l[v]));
					let _ = this._cubeSize;
					$c(i, x * _, v > 2 ? _ : 0, _, _), u.setRenderTarget(i), m && u.render(g, a), u.render(e, a)
				}
				g.geometry.dispose(), g.material.dispose(), u.toneMapping = f, u.autoClear = h, e.background = d
			}
			_textureToCubeUV(e, t) {
				let n = this._renderer,
					i = e.mapping === ua || e.mapping === ha;
				i ? (this._cubemapMaterial === null && (this._cubemapMaterial = x0()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = v0());
				let s = i ? this._cubemapMaterial : this._equirectMaterial,
					o = new zt(this._lodPlanes[0], s),
					a = s.uniforms;
				a.envMap.value = e;
				let c = this._cubeSize;
				$c(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(o, ad)
			}
			_applyPMREM(e) {
				let t = this._renderer,
					n = t.autoClear;
				t.autoClear = !1;
				for (let i = 1; i < this._lodPlanes.length; i++) {
					let s = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
						o = m0[(i - 1) % m0.length];
					this._blur(e, i - 1, i, s, o)
				}
				t.autoClear = n
			}
			_blur(e, t, n, i, s) {
				let o = this._pingPongRenderTarget;
				this._halfBlur(e, o, t, n, i, "latitudinal", s), this._halfBlur(o, e, n, n, i, "longitudinal", s)
			}
			_halfBlur(e, t, n, i, s, o, a) {
				let c = this._renderer,
					l = this._blurMaterial;
				o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
				let u = 3,
					h = new zt(this._lodPlanes[i], l),
					f = l.uniforms,
					p = this._sizeLods[n] - 1,
					g = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * go - 1),
					m = s / g,
					d = isFinite(s) ? 1 + Math.floor(u * m) : go;
				d > go && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${d} samples when the maximum is set to ${go}`);
				let v = [],
					x = 0;
				for (let S = 0; S < go; ++S) {
					let b = S / m,
						T = Math.exp(-b * b / 2);
					v.push(T), S === 0 ? x += T : S < d && (x += 2 * T)
				}
				for (let S = 0; S < v.length; S++) v[S] = v[S] / x;
				f.envMap.value = e.texture, f.samples.value = d, f.weights.value = v, f.latitudinal.value = o === "latitudinal", a && (f.poleAxis.value = a);
				let {
					_lodMax: _
				} = this;
				f.dTheta.value = g, f.mipInt.value = _ - n;
				let y = this._sizeLods[i],
					w = 3 * y * (i > _ - ra ? i - _ + ra : 0),
					C = 4 * (this._cubeSize - y);
				$c(t, w, C, 3 * y, 2 * y), c.setRenderTarget(t), c.render(h, ad)
			}
		};

	function Lw(r) {
		let e = [],
			t = [],
			n = [],
			i = r,
			s = r - ra + 1 + d0.length;
		for (let o = 0; o < s; o++) {
			let a = Math.pow(2, i);
			t.push(a);
			let c = 1 / a;
			o > r - ra ? c = d0[o - r + ra - 1] : o === 0 && (c = 0), n.push(c);
			let l = 1 / (a - 2),
				u = -l,
				h = 1 + l,
				f = [u, u, h, u, h, h, u, u, h, h, u, h],
				p = 6,
				g = 6,
				m = 3,
				d = 2,
				v = 1,
				x = new Float32Array(m * g * p),
				_ = new Float32Array(d * g * p),
				y = new Float32Array(v * g * p);
			for (let C = 0; C < p; C++) {
				let S = C % 3 * 2 / 3 - 1,
					b = C > 2 ? 0 : -1,
					T = [S, b, 0, S + 2 / 3, b, 0, S + 2 / 3, b + 1, 0, S, b, 0, S + 2 / 3, b + 1, 0, S, b + 1, 0];
				x.set(T, m * g * C), _.set(f, d * g * C);
				let N = [C, C, C, C, C, C];
				y.set(N, v * g * C)
			}
			let w = new bt;
			w.setAttribute("position", new Gn(x, m)), w.setAttribute("uv", new Gn(_, d)), w.setAttribute("faceIndex", new Gn(y, v)), e.push(w), i > ra && i--
		}
		return {
			lodPlanes: e,
			sizeLods: t,
			sigmas: n
		}
	}

	function g0(r, e, t) {
		let n = new Zr(r, e, t);
		return n.texture.mapping = Cu, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
	}

	function $c(r, e, t, n, i) {
		r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i)
	}

	function Nw(r, e, t) {
		let n = new Float32Array(go),
			i = new ne(0, 1, 0);
		return new $r({
			name: "SphericalGaussianBlur",
			defines: {
				n: go,
				CUBEUV_TEXEL_WIDTH: 1 / e,
				CUBEUV_TEXEL_HEIGHT: 1 / t,
				CUBEUV_MAX_MIP: `${r}.0`
			},
			uniforms: {
				envMap: {
					value: null
				},
				samples: {
					value: 1
				},
				weights: {
					value: n
				},
				latitudinal: {
					value: !1
				},
				dTheta: {
					value: 0
				},
				mipInt: {
					value: 0
				},
				poleAxis: {
					value: i
				}
			},
			vertexShader: Yd(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
			blending: Is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function v0() {
		return new $r({
			name: "EquirectangularToCubeUV",
			uniforms: {
				envMap: {
					value: null
				}
			},
			vertexShader: Yd(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
			blending: Is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function x0() {
		return new $r({
			name: "CubemapToCubeUV",
			uniforms: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				}
			},
			vertexShader: Yd(),
			fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
			blending: Is,
			depthTest: !1,
			depthWrite: !1
		})
	}

	function Yd() {
		return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
	}

	function Dw(r) {
		let e = new WeakMap,
			t = null;

		function n(a) {
			if (a && a.isTexture) {
				let c = a.mapping,
					l = c === Ml || c === md,
					u = c === ua || c === ha;
				if (l || u)
					if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
						a.needsPMREMUpdate = !1;
						let h = e.get(a);
						return t === null && (t = new gu(r)), h = l ? t.fromEquirectangular(a, h) : t.fromCubemap(a, h), e.set(a, h), h.texture
					} else {
						if (e.has(a)) return e.get(a)
							.texture; {
							let h = a.image;
							if (l && h && h.height > 0 || u && h && i(h)) {
								t === null && (t = new gu(r));
								let f = l ? t.fromEquirectangular(a) : t.fromCubemap(a);
								return e.set(a, f), a.addEventListener("dispose", s), f.texture
							} else return null
						}
					}
			}
			return a
		}

		function i(a) {
			let c = 0,
				l = 6;
			for (let u = 0; u < l; u++) a[u] !== void 0 && c++;
			return c === l
		}

		function s(a) {
			let c = a.target;
			c.removeEventListener("dispose", s);
			let l = e.get(c);
			l !== void 0 && (e.delete(c), l.dispose())
		}

		function o() {
			e = new WeakMap, t !== null && (t.dispose(), t = null)
		}
		return {
			get: n,
			dispose: o
		}
	}

	function Ow(r) {
		let e = {};

		function t(n) {
			if (e[n] !== void 0) return e[n];
			let i;
			switch (n) {
				case "WEBGL_depth_texture":
					i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
					break;
				case "EXT_texture_filter_anisotropic":
					i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
					break;
				case "WEBGL_compressed_texture_s3tc":
					i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
					break;
				case "WEBGL_compressed_texture_pvrtc":
					i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
					break;
				default:
					i = r.getExtension(n)
			}
			return e[n] = i, i
		}
		return {
			has: function(n) {
				return t(n) !== null
			},
			init: function(n) {
				n.isWebGL2 ? t("EXT_color_buffer_float") : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture")
			},
			get: function(n) {
				let i = t(n);
				return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i
			}
		}
	}

	function kw(r, e, t, n) {
		let i = {},
			s = new WeakMap;

		function o(h) {
			let f = h.target;
			f.index !== null && e.remove(f.index);
			for (let g in f.attributes) e.remove(f.attributes[g]);
			f.removeEventListener("dispose", o), delete i[f.id];
			let p = s.get(f);
			p && (e.remove(p), s.delete(f)), n.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--
		}

		function a(h, f) {
			return i[f.id] === !0 || (f.addEventListener("dispose", o), i[f.id] = !0, t.memory.geometries++), f
		}

		function c(h) {
			let f = h.attributes;
			for (let g in f) e.update(f[g], 34962);
			let p = h.morphAttributes;
			for (let g in p) {
				let m = p[g];
				for (let d = 0, v = m.length; d < v; d++) e.update(m[d], 34962)
			}
		}

		function l(h) {
			let f = [],
				p = h.index,
				g = h.attributes.position,
				m = 0;
			if (p !== null) {
				let x = p.array;
				m = p.version;
				for (let _ = 0, y = x.length; _ < y; _ += 3) {
					let w = x[_ + 0],
						C = x[_ + 1],
						S = x[_ + 2];
					f.push(w, C, C, S, S, w)
				}
			} else {
				let x = g.array;
				m = g.version;
				for (let _ = 0, y = x.length / 3 - 1; _ < y; _ += 3) {
					let w = _ + 0,
						C = _ + 1,
						S = _ + 2;
					f.push(w, C, C, S, S, w)
				}
			}
			let d = new(ov(f) ? pu : ma)(f, 1);
			d.version = m;
			let v = s.get(h);
			v && e.remove(v), s.set(h, d)
		}

		function u(h) {
			let f = s.get(h);
			if (f) {
				let p = h.index;
				p !== null && f.version < p.version && l(h)
			} else l(h);
			return s.get(h)
		}
		return {
			get: a,
			update: c,
			getWireframeAttribute: u
		}
	}

	function Fw(r, e, t, n) {
		let i = n.isWebGL2,
			s;

		function o(f) {
			s = f
		}
		let a, c;

		function l(f) {
			a = f.type, c = f.bytesPerElement
		}

		function u(f, p) {
			r.drawElements(s, p, a, f * c), t.update(p, s, 1)
		}

		function h(f, p, g) {
			if (g === 0) return;
			let m, d;
			if (i) m = r, d = "drawElementsInstanced";
			else if (m = e.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", m === null) {
				console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
				return
			}
			m[d](s, p, a, f * c, g), t.update(p, s, g)
		}
		this.setMode = o, this.setIndex = l, this.render = u, this.renderInstances = h
	}

	function Uw(r) {
		let e = {
				geometries: 0,
				textures: 0
			},
			t = {
				frame: 0,
				calls: 0,
				triangles: 0,
				points: 0,
				lines: 0
			};

		function n(s, o, a) {
			switch (t.calls++, o) {
				case 4:
					t.triangles += a * (s / 3);
					break;
				case 1:
					t.lines += a * (s / 2);
					break;
				case 3:
					t.lines += a * (s - 1);
					break;
				case 2:
					t.lines += a * s;
					break;
				case 0:
					t.points += a * s;
					break;
				default:
					console.error("THREE.WebGLInfo: Unknown draw mode:", o);
					break
			}
		}

		function i() {
			t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
		}
		return {
			memory: e,
			render: t,
			programs: null,
			autoReset: !0,
			reset: i,
			update: n
		}
	}

	function Bw(r, e) {
		return r[0] - e[0]
	}

	function Gw(r, e) {
		return Math.abs(e[1]) - Math.abs(r[1])
	}

	function Vw(r, e, t) {
		let n = {},
			i = new Float32Array(8),
			s = new WeakMap,
			o = new wt,
			a = [];
		for (let l = 0; l < 8; l++) a[l] = [l, 0];

		function c(l, u, h, f) {
			let p = l.morphTargetInfluences;
			if (e.isWebGL2 === !0) {
				let g = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
					m = g !== void 0 ? g.length : 0,
					d = s.get(u);
				if (d === void 0 || d.count !== m) {
					let q = function() {
						k.dispose(), s.delete(u), u.removeEventListener("dispose", q)
					};
					d !== void 0 && d.texture.dispose();
					let _ = u.morphAttributes.position !== void 0,
						y = u.morphAttributes.normal !== void 0,
						w = u.morphAttributes.color !== void 0,
						C = u.morphAttributes.position || [],
						S = u.morphAttributes.normal || [],
						b = u.morphAttributes.color || [],
						T = 0;
					_ === !0 && (T = 1), y === !0 && (T = 2), w === !0 && (T = 3);
					let N = u.attributes.position.count * T,
						V = 1;
					N > e.maxTextureSize && (V = Math.ceil(N / e.maxTextureSize), N = e.maxTextureSize);
					let O = new Float32Array(N * V * 4 * m),
						k = new du(O, N, V, m);
					k.type = As, k.needsUpdate = !0;
					let I = T * 4;
					for (let B = 0; B < m; B++) {
						let Y = C[B],
							J = S[B],
							H = b[B],
							$ = N * V * 4 * B;
						for (let ae = 0; ae < Y.count; ae++) {
							let oe = ae * I;
							_ === !0 && (o.fromBufferAttribute(Y, ae), O[$ + oe + 0] = o.x, O[$ + oe + 1] = o.y, O[$ + oe + 2] = o.z, O[$ + oe + 3] = 0), y === !0 && (o.fromBufferAttribute(J, ae), O[$ + oe + 4] = o.x, O[$ + oe + 5] = o.y, O[$ + oe + 6] = o.z, O[$ + oe + 7] = 0), w === !0 && (o.fromBufferAttribute(H, ae), O[$ + oe + 8] = o.x, O[$ + oe + 9] = o.y, O[$ + oe + 10] = o.z, O[$ + oe + 11] = H.itemSize === 4 ? o.w : 1)
						}
					}
					d = {
						count: m,
						texture: k,
						size: new st(N, V)
					}, s.set(u, d), u.addEventListener("dispose", q)
				}
				let v = 0;
				for (let _ = 0; _ < p.length; _++) v += p[_];
				let x = u.morphTargetsRelative ? 1 : 1 - v;
				f.getUniforms()
					.setValue(r, "morphTargetBaseInfluence", x), f.getUniforms()
					.setValue(r, "morphTargetInfluences", p), f.getUniforms()
					.setValue(r, "morphTargetsTexture", d.texture, t), f.getUniforms()
					.setValue(r, "morphTargetsTextureSize", d.size)
			} else {
				let g = p === void 0 ? 0 : p.length,
					m = n[u.id];
				if (m === void 0 || m.length !== g) {
					m = [];
					for (let y = 0; y < g; y++) m[y] = [y, 0];
					n[u.id] = m
				}
				for (let y = 0; y < g; y++) {
					let w = m[y];
					w[0] = y, w[1] = p[y]
				}
				m.sort(Gw);
				for (let y = 0; y < 8; y++) y < g && m[y][1] ? (a[y][0] = m[y][0], a[y][1] = m[y][1]) : (a[y][0] = Number.MAX_SAFE_INTEGER, a[y][1] = 0);
				a.sort(Bw);
				let d = u.morphAttributes.position,
					v = u.morphAttributes.normal,
					x = 0;
				for (let y = 0; y < 8; y++) {
					let w = a[y],
						C = w[0],
						S = w[1];
					C !== Number.MAX_SAFE_INTEGER && S ? (d && u.getAttribute("morphTarget" + y) !== d[C] && u.setAttribute("morphTarget" + y, d[C]), v && u.getAttribute("morphNormal" + y) !== v[C] && u.setAttribute("morphNormal" + y, v[C]), i[y] = S, x += S) : (d && u.hasAttribute("morphTarget" + y) === !0 && u.deleteAttribute("morphTarget" + y), v && u.hasAttribute("morphNormal" + y) === !0 && u.deleteAttribute("morphNormal" + y), i[y] = 0)
				}
				let _ = u.morphTargetsRelative ? 1 : 1 - x;
				f.getUniforms()
					.setValue(r, "morphTargetBaseInfluence", _), f.getUniforms()
					.setValue(r, "morphTargetInfluences", i)
			}
		}
		return {
			update: c
		}
	}

	function zw(r, e, t, n) {
		let i = new WeakMap;

		function s(c) {
			let l = n.render.frame,
				u = c.geometry,
				h = e.get(c, u);
			return i.get(h) !== l && (e.update(h), i.set(h, l)), c.isInstancedMesh && (c.hasEventListener("dispose", a) === !1 && c.addEventListener("dispose", a), t.update(c.instanceMatrix, 34962), c.instanceColor !== null && t.update(c.instanceColor, 34962)), h
		}

		function o() {
			i = new WeakMap
		}

		function a(c) {
			let l = c.target;
			l.removeEventListener("dispose", a), t.remove(l.instanceMatrix), l.instanceColor !== null && t.remove(l.instanceColor)
		}
		return {
			update: s,
			dispose: o
		}
	}
	var cv = new Pn,
		uv = new du,
		hv = new xd,
		fv = new Cl,
		y0 = [],
		_0 = [],
		b0 = new Float32Array(16),
		M0 = new Float32Array(9),
		w0 = new Float32Array(4);

	function Sa(r, e, t) {
		let n = r[0];
		if (n <= 0 || n > 0) return r;
		let i = e * t,
			s = y0[i];
		if (s === void 0 && (s = new Float32Array(i), y0[i] = s), e !== 0) {
			n.toArray(s, 0);
			for (let o = 1, a = 0; o !== e; ++o) a += t, r[o].toArray(s, a)
		}
		return s
	}

	function bn(r, e) {
		if (r.length !== e.length) return !1;
		for (let t = 0, n = r.length; t < n; t++)
			if (r[t] !== e[t]) return !1;
		return !0
	}

	function Mn(r, e) {
		for (let t = 0, n = e.length; t < n; t++) r[t] = e[t]
	}

	function Iu(r, e) {
		let t = _0[e];
		t === void 0 && (t = new Int32Array(e), _0[e] = t);
		for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
		return t
	}

	function Hw(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e)
	}

	function Ww(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
		else {
			if (bn(t, e)) return;
			r.uniform2fv(this.addr, e), Mn(t, e)
		}
	}

	function jw(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
		else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
		else {
			if (bn(t, e)) return;
			r.uniform3fv(this.addr, e), Mn(t, e)
		}
	}

	function qw(r, e) {
		let t = this.cache;
		if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
		else {
			if (bn(t, e)) return;
			r.uniform4fv(this.addr, e), Mn(t, e)
		}
	}

	function Xw(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (bn(t, e)) return;
			r.uniformMatrix2fv(this.addr, !1, e), Mn(t, e)
		} else {
			if (bn(t, n)) return;
			w0.set(n), r.uniformMatrix2fv(this.addr, !1, w0), Mn(t, n)
		}
	}

	function Yw(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (bn(t, e)) return;
			r.uniformMatrix3fv(this.addr, !1, e), Mn(t, e)
		} else {
			if (bn(t, n)) return;
			M0.set(n), r.uniformMatrix3fv(this.addr, !1, M0), Mn(t, n)
		}
	}

	function Zw(r, e) {
		let t = this.cache,
			n = e.elements;
		if (n === void 0) {
			if (bn(t, e)) return;
			r.uniformMatrix4fv(this.addr, !1, e), Mn(t, e)
		} else {
			if (bn(t, n)) return;
			b0.set(n), r.uniformMatrix4fv(this.addr, !1, b0), Mn(t, n)
		}
	}

	function Kw(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e)
	}

	function Jw(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform2iv(this.addr, e), Mn(t, e))
	}

	function $w(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform3iv(this.addr, e), Mn(t, e))
	}

	function Qw(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform4iv(this.addr, e), Mn(t, e))
	}

	function eT(r, e) {
		let t = this.cache;
		t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e)
	}

	function tT(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform2uiv(this.addr, e), Mn(t, e))
	}

	function nT(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform3uiv(this.addr, e), Mn(t, e))
	}

	function iT(r, e) {
		let t = this.cache;
		bn(t, e) || (r.uniform4uiv(this.addr, e), Mn(t, e))
	}

	function rT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2D(e || cv, i)
	}

	function sT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || hv, i)
	}

	function oT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || fv, i)
	}

	function aT(r, e, t) {
		let n = this.cache,
			i = t.allocateTextureUnit();
		n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || uv, i)
	}

	function lT(r) {
		switch (r) {
			case 5126:
				return Hw;
			case 35664:
				return Ww;
			case 35665:
				return jw;
			case 35666:
				return qw;
			case 35674:
				return Xw;
			case 35675:
				return Yw;
			case 35676:
				return Zw;
			case 5124:
			case 35670:
				return Kw;
			case 35667:
			case 35671:
				return Jw;
			case 35668:
			case 35672:
				return $w;
			case 35669:
			case 35673:
				return Qw;
			case 5125:
				return eT;
			case 36294:
				return tT;
			case 36295:
				return nT;
			case 36296:
				return iT;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return rT;
			case 35679:
			case 36299:
			case 36307:
				return sT;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return oT;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return aT
		}
	}

	function cT(r, e) {
		r.uniform1fv(this.addr, e)
	}

	function uT(r, e) {
		let t = Sa(e, this.size, 2);
		r.uniform2fv(this.addr, t)
	}

	function hT(r, e) {
		let t = Sa(e, this.size, 3);
		r.uniform3fv(this.addr, t)
	}

	function fT(r, e) {
		let t = Sa(e, this.size, 4);
		r.uniform4fv(this.addr, t)
	}

	function dT(r, e) {
		let t = Sa(e, this.size, 4);
		r.uniformMatrix2fv(this.addr, !1, t)
	}

	function pT(r, e) {
		let t = Sa(e, this.size, 9);
		r.uniformMatrix3fv(this.addr, !1, t)
	}

	function mT(r, e) {
		let t = Sa(e, this.size, 16);
		r.uniformMatrix4fv(this.addr, !1, t)
	}

	function gT(r, e) {
		r.uniform1iv(this.addr, e)
	}

	function vT(r, e) {
		r.uniform2iv(this.addr, e)
	}

	function xT(r, e) {
		r.uniform3iv(this.addr, e)
	}

	function yT(r, e) {
		r.uniform4iv(this.addr, e)
	}

	function _T(r, e) {
		r.uniform1uiv(this.addr, e)
	}

	function bT(r, e) {
		r.uniform2uiv(this.addr, e)
	}

	function MT(r, e) {
		r.uniform3uiv(this.addr, e)
	}

	function wT(r, e) {
		r.uniform4uiv(this.addr, e)
	}

	function TT(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Iu(t, i);
		bn(n, s) || (r.uniform1iv(this.addr, s), Mn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || cv, s[o])
	}

	function ST(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Iu(t, i);
		bn(n, s) || (r.uniform1iv(this.addr, s), Mn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || hv, s[o])
	}

	function ET(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Iu(t, i);
		bn(n, s) || (r.uniform1iv(this.addr, s), Mn(n, s));
		for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || fv, s[o])
	}

	function CT(r, e, t) {
		let n = this.cache,
			i = e.length,
			s = Iu(t, i);
		bn(n, s) || (r.uniform1iv(this.addr, s), Mn(n, s));
		for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || uv, s[o])
	}

	function AT(r) {
		switch (r) {
			case 5126:
				return cT;
			case 35664:
				return uT;
			case 35665:
				return hT;
			case 35666:
				return fT;
			case 35674:
				return dT;
			case 35675:
				return pT;
			case 35676:
				return mT;
			case 5124:
			case 35670:
				return gT;
			case 35667:
			case 35671:
				return vT;
			case 35668:
			case 35672:
				return xT;
			case 35669:
			case 35673:
				return yT;
			case 5125:
				return _T;
			case 36294:
				return bT;
			case 36295:
				return MT;
			case 36296:
				return wT;
			case 35678:
			case 36198:
			case 36298:
			case 36306:
			case 35682:
				return TT;
			case 35679:
			case 36299:
			case 36307:
				return ST;
			case 35680:
			case 36300:
			case 36308:
			case 36293:
				return ET;
			case 36289:
			case 36303:
			case 36311:
			case 36292:
				return CT
		}
	}
	var bd = class {
			constructor(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.setValue = lT(t.type)
			}
		},
		Md = class {
			constructor(e, t, n) {
				this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = AT(t.type)
			}
		},
		wd = class {
			constructor(e) {
				this.id = e, this.seq = [], this.map = {}
			}
			setValue(e, t, n) {
				let i = this.seq;
				for (let s = 0, o = i.length; s !== o; ++s) {
					let a = i[s];
					a.setValue(e, t[a.id], n)
				}
			}
		},
		cd = /(\w+)(\])?(\[|\.)?/g;

	function T0(r, e) {
		r.seq.push(e), r.map[e.id] = e
	}

	function IT(r, e, t) {
		let n = r.name,
			i = n.length;
		for (cd.lastIndex = 0;;) {
			let s = cd.exec(n),
				o = cd.lastIndex,
				a = s[1],
				c = s[2] === "]",
				l = s[3];
			if (c && (a = a | 0), l === void 0 || l === "[" && o + 2 === i) {
				T0(t, l === void 0 ? new bd(a, r, e) : new Md(a, r, e));
				break
			} else {
				let h = t.map[a];
				h === void 0 && (h = new wd(a), T0(t, h)), t = h
			}
		}
	}
	var ca = class {
		constructor(e, t) {
			this.seq = [], this.map = {};
			let n = e.getProgramParameter(t, 35718);
			for (let i = 0; i < n; ++i) {
				let s = e.getActiveUniform(t, i),
					o = e.getUniformLocation(t, s.name);
				IT(s, o, this)
			}
		}
		setValue(e, t, n, i) {
			let s = this.map[t];
			s !== void 0 && s.setValue(e, n, i)
		}
		setOptional(e, t, n) {
			let i = t[n];
			i !== void 0 && this.setValue(e, n, i)
		}
		static upload(e, t, n, i) {
			for (let s = 0, o = t.length; s !== o; ++s) {
				let a = t[s],
					c = n[a.id];
				c.needsUpdate !== !1 && a.setValue(e, c.value, i)
			}
		}
		static seqWithValue(e, t) {
			let n = [];
			for (let i = 0, s = e.length; i !== s; ++i) {
				let o = e[i];
				o.id in t && n.push(o)
			}
			return n
		}
	};

	function S0(r, e, t) {
		let n = r.createShader(e);
		return r.shaderSource(n, t), r.compileShader(n), n
	}
	var RT = 0;

	function PT(r, e) {
		let t = r.split(`
`),
			n = [],
			i = Math.max(e - 6, 0),
			s = Math.min(e + 6, t.length);
		for (let o = i; o < s; o++) {
			let a = o + 1;
			n.push(`${a===e?">":" "} ${a}: ${t[o]}`)
		}
		return n.join(`
`)
	}

	function LT(r) {
		switch (r) {
			case Mo:
				return ["Linear", "( value )"];
			case Pt:
				return ["sRGB", "( value )"];
			default:
				return console.warn("THREE.WebGLProgram: Unsupported encoding:", r), ["Linear", "( value )"]
		}
	}

	function E0(r, e, t) {
		let n = r.getShaderParameter(e, 35713),
			i = r.getShaderInfoLog(e)
			.trim();
		if (n && i === "") return "";
		let s = /ERROR: 0:(\d+)/.exec(i);
		if (s) {
			let o = parseInt(s[1]);
			return t.toUpperCase() + `

` + i + `

` + PT(r.getShaderSource(e), o)
		} else return i
	}

	function NT(r, e) {
		let t = LT(e);
		return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
	}

	function DT(r, e) {
		let t;
		switch (e) {
			case Xy:
				t = "Linear";
				break;
			case Yy:
				t = "Reinhard";
				break;
			case Zy:
				t = "OptimizedCineon";
				break;
			case Ky:
				t = "ACESFilmic";
				break;
			case Jy:
				t = "Custom";
				break;
			default:
				console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
		}
		return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
	}

	function OT(r) {
		return [r.extensionDerivatives || !!r.envMapCubeUVHeight || r.bumpMap || r.tangentSpaceNormalMap || r.clearcoatNormalMap || r.flatShading || r.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (r.extensionFragDepth || r.logarithmicDepthBuffer) && r.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", r.extensionDrawBuffers && r.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (r.extensionShaderTextureLOD || r.envMap || r.transmission) && r.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(yl)
			.join(`
`)
	}

	function kT(r) {
		let e = [];
		for (let t in r) {
			let n = r[t];
			n !== !1 && e.push("#define " + t + " " + n)
		}
		return e.join(`
`)
	}

	function FT(r, e) {
		let t = {},
			n = r.getProgramParameter(e, 35721);
		for (let i = 0; i < n; i++) {
			let s = r.getActiveAttrib(e, i),
				o = s.name,
				a = 1;
			s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), t[o] = {
				type: s.type,
				location: r.getAttribLocation(e, o),
				locationSize: a
			}
		}
		return t
	}

	function yl(r) {
		return r !== ""
	}

	function C0(r, e) {
		let t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
		return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
			.replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
			.replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
			.replace(/NUM_SPOT_LIGHT_COORDS/g, t)
			.replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
			.replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
			.replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
			.replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
			.replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
			.replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
	}

	function A0(r, e) {
		return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
			.replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
	}
	var UT = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function Td(r) {
		return r.replace(UT, BT)
	}

	function BT(r, e) {
		let t = _t[e];
		if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
		return Td(t)
	}
	var GT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function I0(r) {
		return r.replace(GT, VT)
	}

	function VT(r, e, t, n) {
		let i = "";
		for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
			.replace(/UNROLLED_LOOP_INDEX/g, s);
		return i
	}

	function R0(r) {
		let e = "precision " + r.precision + ` float;
precision ` + r.precision + " int;";
		return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
	}

	function zT(r) {
		let e = "SHADOWMAP_TYPE_BASIC";
		return r.shadowMapType === ev ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === Sy ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === vl && (e = "SHADOWMAP_TYPE_VSM"), e
	}

	function HT(r) {
		let e = "ENVMAP_TYPE_CUBE";
		if (r.envMap) switch (r.envMapMode) {
			case ua:
			case ha:
				e = "ENVMAP_TYPE_CUBE";
				break;
			case Cu:
				e = "ENVMAP_TYPE_CUBE_UV";
				break
		}
		return e
	}

	function WT(r) {
		let e = "ENVMAP_MODE_REFLECTION";
		if (r.envMap) switch (r.envMapMode) {
			case ha:
				e = "ENVMAP_MODE_REFRACTION";
				break
		}
		return e
	}

	function jT(r) {
		let e = "ENVMAP_BLENDING_NONE";
		if (r.envMap) switch (r.combine) {
			case Eu:
				e = "ENVMAP_BLENDING_MULTIPLY";
				break;
			case jy:
				e = "ENVMAP_BLENDING_MIX";
				break;
			case qy:
				e = "ENVMAP_BLENDING_ADD";
				break
		}
		return e
	}

	function qT(r) {
		let e = r.envMapCubeUVHeight;
		if (e === null) return null;
		let t = Math.log2(e) - 2,
			n = 1 / e;
		return {
			texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
			texelHeight: n,
			maxMip: t
		}
	}

	function XT(r, e, t, n) {
		let i = r.getContext(),
			s = t.defines,
			o = t.vertexShader,
			a = t.fragmentShader,
			c = zT(t),
			l = HT(t),
			u = WT(t),
			h = jT(t),
			f = qT(t),
			p = t.isWebGL2 ? "" : OT(t),
			g = kT(s),
			m = i.createProgram(),
			d, v, x = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
		t.isRawShaderMaterial ? (d = [g].filter(yl)
			.join(`
`), d.length > 0 && (d += `
`), v = [p, g].filter(yl)
			.join(`
`), v.length > 0 && (v += `
`)) : (d = [R0(t), "#define SHADER_NAME " + t.shaderName, g, t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.displacementMap && t.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(yl)
			.join(`
`), v = [p, R0(t), "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + l : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + h : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMap && t.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", t.normalMap && t.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.vertexTangents ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUvs ? "#define USE_UV" : "", t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Yr ? "#define TONE_MAPPING" : "", t.toneMapping !== Yr ? _t.tonemapping_pars_fragment : "", t.toneMapping !== Yr ? DT("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", _t.encodings_pars_fragment, NT("linearToOutputTexel", t.outputEncoding), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(yl)
			.join(`
`)), o = Td(o), o = C0(o, t), o = A0(o, t), a = Td(a), a = C0(a, t), a = A0(a, t), o = I0(o), a = I0(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (x = `#version 300 es
`, d = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + d, v = ["#define varying in", t.glslVersion === e0 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === e0 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + v);
		let _ = x + d + o,
			y = x + v + a,
			w = S0(i, 35633, _),
			C = S0(i, 35632, y);
		if (i.attachShader(m, w), i.attachShader(m, C), t.index0AttributeName !== void 0 ? i.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m), r.debug.checkShaderErrors) {
			let T = i.getProgramInfoLog(m)
				.trim(),
				N = i.getShaderInfoLog(w)
				.trim(),
				V = i.getShaderInfoLog(C)
				.trim(),
				O = !0,
				k = !0;
			if (i.getProgramParameter(m, 35714) === !1) {
				O = !1;
				let I = E0(i, w, "vertex"),
					q = E0(i, C, "fragment");
				console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, 35715) + `

Program Info Log: ` + T + `
` + I + `
` + q)
			} else T !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", T) : (N === "" || V === "") && (k = !1);
			k && (this.diagnostics = {
				runnable: O,
				programLog: T,
				vertexShader: {
					log: N,
					prefix: d
				},
				fragmentShader: {
					log: V,
					prefix: v
				}
			})
		}
		i.deleteShader(w), i.deleteShader(C);
		let S;
		this.getUniforms = function() {
			return S === void 0 && (S = new ca(i, m)), S
		};
		let b;
		return this.getAttributes = function() {
			return b === void 0 && (b = FT(i, m)), b
		}, this.destroy = function() {
			n.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0
		}, this.name = t.shaderName, this.id = RT++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = w, this.fragmentShader = C, this
	}
	var YT = 0,
		Sd = class {
			constructor() {
				this.shaderCache = new Map, this.materialCache = new Map
			}
			update(e) {
				let t = e.vertexShader,
					n = e.fragmentShader,
					i = this._getShaderStage(t),
					s = this._getShaderStage(n),
					o = this._getShaderCacheForMaterial(e);
				return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
			}
			remove(e) {
				let t = this.materialCache.get(e);
				for (let n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
				return this.materialCache.delete(e), this
			}
			getVertexShaderID(e) {
				return this._getShaderStage(e.vertexShader)
					.id
			}
			getFragmentShaderID(e) {
				return this._getShaderStage(e.fragmentShader)
					.id
			}
			dispose() {
				this.shaderCache.clear(), this.materialCache.clear()
			}
			_getShaderCacheForMaterial(e) {
				let t = this.materialCache,
					n = t.get(e);
				return n === void 0 && (n = new Set, t.set(e, n)), n
			}
			_getShaderStage(e) {
				let t = this.shaderCache,
					n = t.get(e);
				return n === void 0 && (n = new Ed(e), t.set(e, n)), n
			}
		},
		Ed = class {
			constructor(e) {
				this.id = YT++, this.code = e, this.usedTimes = 0
			}
		};

	function ZT(r, e, t, n, i, s, o) {
		let a = new El,
			c = new Sd,
			l = [],
			u = i.isWebGL2,
			h = i.logarithmicDepthBuffer,
			f = i.vertexTextures,
			p = i.precision,
			g = {
				MeshDepthMaterial: "depth",
				MeshDistanceMaterial: "distanceRGBA",
				MeshNormalMaterial: "normal",
				MeshBasicMaterial: "basic",
				MeshLambertMaterial: "lambert",
				MeshPhongMaterial: "phong",
				MeshToonMaterial: "toon",
				MeshStandardMaterial: "physical",
				MeshPhysicalMaterial: "physical",
				MeshMatcapMaterial: "matcap",
				LineBasicMaterial: "basic",
				LineDashedMaterial: "dashed",
				PointsMaterial: "points",
				ShadowMaterial: "shadow",
				SpriteMaterial: "sprite"
			};

		function m(b, T, N, V, O) {
			let k = V.fog,
				I = O.geometry,
				q = b.isMeshStandardMaterial ? V.environment : null,
				B = (b.isMeshStandardMaterial ? t : e)
				.get(b.envMap || q),
				Y = !!B && B.mapping === Cu ? B.image.height : null,
				J = g[b.type];
			b.precision !== null && (p = i.getMaxPrecision(b.precision), p !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", p, "instead."));
			let H = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color,
				$ = H !== void 0 ? H.length : 0,
				ae = 0;
			I.morphAttributes.position !== void 0 && (ae = 1), I.morphAttributes.normal !== void 0 && (ae = 2), I.morphAttributes.color !== void 0 && (ae = 3);
			let oe, ie, U, A;
			if (J) {
				let de = yr[J];
				oe = de.vertexShader, ie = de.fragmentShader
			} else oe = b.vertexShader, ie = b.fragmentShader, c.update(b), U = c.getVertexShaderID(b), A = c.getFragmentShaderID(b);
			let L = r.getRenderTarget(),
				j = b.alphaTest > 0,
				K = b.clearcoat > 0,
				Q = b.iridescence > 0;
			return {
				isWebGL2: u,
				shaderID: J,
				shaderName: b.type,
				vertexShader: oe,
				fragmentShader: ie,
				defines: b.defines,
				customVertexShaderID: U,
				customFragmentShaderID: A,
				isRawShaderMaterial: b.isRawShaderMaterial === !0,
				glslVersion: b.glslVersion,
				precision: p,
				instancing: O.isInstancedMesh === !0,
				instancingColor: O.isInstancedMesh === !0 && O.instanceColor !== null,
				supportsVertexTextures: f,
				outputEncoding: L === null ? r.outputEncoding : L.isXRRenderTarget === !0 ? L.texture.encoding : Mo,
				map: !!b.map,
				matcap: !!b.matcap,
				envMap: !!B,
				envMapMode: B && B.mapping,
				envMapCubeUVHeight: Y,
				lightMap: !!b.lightMap,
				aoMap: !!b.aoMap,
				emissiveMap: !!b.emissiveMap,
				bumpMap: !!b.bumpMap,
				normalMap: !!b.normalMap,
				objectSpaceNormalMap: b.normalMapType === v_,
				tangentSpaceNormalMap: b.normalMapType === Au,
				decodeVideoTexture: !!b.map && b.map.isVideoTexture === !0 && b.map.encoding === Pt,
				clearcoat: K,
				clearcoatMap: K && !!b.clearcoatMap,
				clearcoatRoughnessMap: K && !!b.clearcoatRoughnessMap,
				clearcoatNormalMap: K && !!b.clearcoatNormalMap,
				iridescence: Q,
				iridescenceMap: Q && !!b.iridescenceMap,
				iridescenceThicknessMap: Q && !!b.iridescenceThicknessMap,
				displacementMap: !!b.displacementMap,
				roughnessMap: !!b.roughnessMap,
				metalnessMap: !!b.metalnessMap,
				specularMap: !!b.specularMap,
				specularIntensityMap: !!b.specularIntensityMap,
				specularColorMap: !!b.specularColorMap,
				opaque: b.transparent === !1 && b.blending === oa,
				alphaMap: !!b.alphaMap,
				alphaTest: j,
				gradientMap: !!b.gradientMap,
				sheen: b.sheen > 0,
				sheenColorMap: !!b.sheenColorMap,
				sheenRoughnessMap: !!b.sheenRoughnessMap,
				transmission: b.transmission > 0,
				transmissionMap: !!b.transmissionMap,
				thicknessMap: !!b.thicknessMap,
				combine: b.combine,
				vertexTangents: !!b.normalMap && !!I.attributes.tangent,
				vertexColors: b.vertexColors,
				vertexAlphas: b.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4,
				vertexUvs: !!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap || !!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatMap || !!b.clearcoatRoughnessMap || !!b.clearcoatNormalMap || !!b.iridescenceMap || !!b.iridescenceThicknessMap || !!b.displacementMap || !!b.transmissionMap || !!b.thicknessMap || !!b.specularIntensityMap || !!b.specularColorMap || !!b.sheenColorMap || !!b.sheenRoughnessMap,
				uvsVertexOnly: !(!!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap || !!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatNormalMap || !!b.iridescenceMap || !!b.iridescenceThicknessMap || b.transmission > 0 || !!b.transmissionMap || !!b.thicknessMap || !!b.specularIntensityMap || !!b.specularColorMap || b.sheen > 0 || !!b.sheenColorMap || !!b.sheenRoughnessMap) && !!b.displacementMap,
				fog: !!k,
				useFog: b.fog === !0,
				fogExp2: k && k.isFogExp2,
				flatShading: !!b.flatShading,
				sizeAttenuation: b.sizeAttenuation,
				logarithmicDepthBuffer: h,
				skinning: O.isSkinnedMesh === !0,
				morphTargets: I.morphAttributes.position !== void 0,
				morphNormals: I.morphAttributes.normal !== void 0,
				morphColors: I.morphAttributes.color !== void 0,
				morphTargetsCount: $,
				morphTextureStride: ae,
				numDirLights: T.directional.length,
				numPointLights: T.point.length,
				numSpotLights: T.spot.length,
				numSpotLightMaps: T.spotLightMap.length,
				numRectAreaLights: T.rectArea.length,
				numHemiLights: T.hemi.length,
				numDirLightShadows: T.directionalShadowMap.length,
				numPointLightShadows: T.pointShadowMap.length,
				numSpotLightShadows: T.spotShadowMap.length,
				numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
				numClippingPlanes: o.numPlanes,
				numClipIntersection: o.numIntersection,
				dithering: b.dithering,
				shadowMapEnabled: r.shadowMap.enabled && N.length > 0,
				shadowMapType: r.shadowMap.type,
				toneMapping: b.toneMapped ? r.toneMapping : Yr,
				physicallyCorrectLights: r.physicallyCorrectLights,
				premultipliedAlpha: b.premultipliedAlpha,
				doubleSided: b.side === Bn,
				flipSided: b.side === Rn,
				useDepthPacking: !!b.depthPacking,
				depthPacking: b.depthPacking || 0,
				index0AttributeName: b.index0AttributeName,
				extensionDerivatives: b.extensions && b.extensions.derivatives,
				extensionFragDepth: b.extensions && b.extensions.fragDepth,
				extensionDrawBuffers: b.extensions && b.extensions.drawBuffers,
				extensionShaderTextureLOD: b.extensions && b.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
				rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
				rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
				customProgramCacheKey: b.customProgramCacheKey()
			}
		}

		function d(b) {
			let T = [];
			if (b.shaderID ? T.push(b.shaderID) : (T.push(b.customVertexShaderID), T.push(b.customFragmentShaderID)), b.defines !== void 0)
				for (let N in b.defines) T.push(N), T.push(b.defines[N]);
			return b.isRawShaderMaterial === !1 && (v(T, b), x(T, b), T.push(r.outputEncoding)), T.push(b.customProgramCacheKey), T.join()
		}

		function v(b, T) {
			b.push(T.precision), b.push(T.outputEncoding), b.push(T.envMapMode), b.push(T.envMapCubeUVHeight), b.push(T.combine), b.push(T.vertexUvs), b.push(T.fogExp2), b.push(T.sizeAttenuation), b.push(T.morphTargetsCount), b.push(T.morphAttributeCount), b.push(T.numDirLights), b.push(T.numPointLights), b.push(T.numSpotLights), b.push(T.numSpotLightMaps), b.push(T.numHemiLights), b.push(T.numRectAreaLights), b.push(T.numDirLightShadows), b.push(T.numPointLightShadows), b.push(T.numSpotLightShadows), b.push(T.numSpotLightShadowsWithMaps), b.push(T.shadowMapType), b.push(T.toneMapping), b.push(T.numClippingPlanes), b.push(T.numClipIntersection), b.push(T.depthPacking)
		}

		function x(b, T) {
			a.disableAll(), T.isWebGL2 && a.enable(0), T.supportsVertexTextures && a.enable(1), T.instancing && a.enable(2), T.instancingColor && a.enable(3), T.map && a.enable(4), T.matcap && a.enable(5), T.envMap && a.enable(6), T.lightMap && a.enable(7), T.aoMap && a.enable(8), T.emissiveMap && a.enable(9), T.bumpMap && a.enable(10), T.normalMap && a.enable(11), T.objectSpaceNormalMap && a.enable(12), T.tangentSpaceNormalMap && a.enable(13), T.clearcoat && a.enable(14), T.clearcoatMap && a.enable(15), T.clearcoatRoughnessMap && a.enable(16), T.clearcoatNormalMap && a.enable(17), T.iridescence && a.enable(18), T.iridescenceMap && a.enable(19), T.iridescenceThicknessMap && a.enable(20), T.displacementMap && a.enable(21), T.specularMap && a.enable(22), T.roughnessMap && a.enable(23), T.metalnessMap && a.enable(24), T.gradientMap && a.enable(25), T.alphaMap && a.enable(26), T.alphaTest && a.enable(27), T.vertexColors && a.enable(28), T.vertexAlphas && a.enable(29), T.vertexUvs && a.enable(30), T.vertexTangents && a.enable(31), T.uvsVertexOnly && a.enable(32), b.push(a.mask), a.disableAll(), T.fog && a.enable(0), T.useFog && a.enable(1), T.flatShading && a.enable(2), T.logarithmicDepthBuffer && a.enable(3), T.skinning && a.enable(4), T.morphTargets && a.enable(5), T.morphNormals && a.enable(6), T.morphColors && a.enable(7), T.premultipliedAlpha && a.enable(8), T.shadowMapEnabled && a.enable(9), T.physicallyCorrectLights && a.enable(10), T.doubleSided && a.enable(11), T.flipSided && a.enable(12), T.useDepthPacking && a.enable(13), T.dithering && a.enable(14), T.specularIntensityMap && a.enable(15), T.specularColorMap && a.enable(16), T.transmission && a.enable(17), T.transmissionMap && a.enable(18), T.thicknessMap && a.enable(19), T.sheen && a.enable(20), T.sheenColorMap && a.enable(21), T.sheenRoughnessMap && a.enable(22), T.decodeVideoTexture && a.enable(23), T.opaque && a.enable(24), b.push(a.mask)
		}

		function _(b) {
			let T = g[b.type],
				N;
			if (T) {
				let V = yr[T];
				N = W_.clone(V.uniforms)
			} else N = b.uniforms;
			return N
		}

		function y(b, T) {
			let N;
			for (let V = 0, O = l.length; V < O; V++) {
				let k = l[V];
				if (k.cacheKey === T) {
					N = k, ++N.usedTimes;
					break
				}
			}
			return N === void 0 && (N = new XT(r, T, b, s), l.push(N)), N
		}

		function w(b) {
			if (--b.usedTimes === 0) {
				let T = l.indexOf(b);
				l[T] = l[l.length - 1], l.pop(), b.destroy()
			}
		}

		function C(b) {
			c.remove(b)
		}

		function S() {
			c.dispose()
		}
		return {
			getParameters: m,
			getProgramCacheKey: d,
			getUniforms: _,
			acquireProgram: y,
			releaseProgram: w,
			releaseShaderCache: C,
			programs: l,
			dispose: S
		}
	}

	function KT() {
		let r = new WeakMap;

		function e(s) {
			let o = r.get(s);
			return o === void 0 && (o = {}, r.set(s, o)), o
		}

		function t(s) {
			r.delete(s)
		}

		function n(s, o, a) {
			r.get(s)[o] = a
		}

		function i() {
			r = new WeakMap
		}
		return {
			get: e,
			remove: t,
			update: n,
			dispose: i
		}
	}

	function JT(r, e) {
		return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
	}

	function P0(r, e) {
		return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
	}

	function L0() {
		let r = [],
			e = 0,
			t = [],
			n = [],
			i = [];

		function s() {
			e = 0, t.length = 0, n.length = 0, i.length = 0
		}

		function o(h, f, p, g, m, d) {
			let v = r[e];
			return v === void 0 ? (v = {
				id: h.id,
				object: h,
				geometry: f,
				material: p,
				groupOrder: g,
				renderOrder: h.renderOrder,
				z: m,
				group: d
			}, r[e] = v) : (v.id = h.id, v.object = h, v.geometry = f, v.material = p, v.groupOrder = g, v.renderOrder = h.renderOrder, v.z = m, v.group = d), e++, v
		}

		function a(h, f, p, g, m, d) {
			let v = o(h, f, p, g, m, d);
			p.transmission > 0 ? n.push(v) : p.transparent === !0 ? i.push(v) : t.push(v)
		}

		function c(h, f, p, g, m, d) {
			let v = o(h, f, p, g, m, d);
			p.transmission > 0 ? n.unshift(v) : p.transparent === !0 ? i.unshift(v) : t.unshift(v)
		}

		function l(h, f) {
			t.length > 1 && t.sort(h || JT), n.length > 1 && n.sort(f || P0), i.length > 1 && i.sort(f || P0)
		}

		function u() {
			for (let h = e, f = r.length; h < f; h++) {
				let p = r[h];
				if (p.id === null) break;
				p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null
			}
		}
		return {
			opaque: t,
			transmissive: n,
			transparent: i,
			init: s,
			push: a,
			unshift: c,
			finish: u,
			sort: l
		}
	}

	function $T() {
		let r = new WeakMap;

		function e(n, i) {
			let s = r.get(n),
				o;
			return s === void 0 ? (o = new L0, r.set(n, [o])) : i >= s.length ? (o = new L0, s.push(o)) : o = s[i], o
		}

		function t() {
			r = new WeakMap
		}
		return {
			get: e,
			dispose: t
		}
	}

	function QT() {
		let r = {};
		return {
			get: function(e) {
				if (r[e.id] !== void 0) return r[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = {
							direction: new ne,
							color: new Xe
						};
						break;
					case "SpotLight":
						t = {
							position: new ne,
							direction: new ne,
							color: new Xe,
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;
					case "PointLight":
						t = {
							position: new ne,
							color: new Xe,
							distance: 0,
							decay: 0
						};
						break;
					case "HemisphereLight":
						t = {
							direction: new ne,
							skyColor: new Xe,
							groundColor: new Xe
						};
						break;
					case "RectAreaLight":
						t = {
							color: new Xe,
							position: new ne,
							halfWidth: new ne,
							halfHeight: new ne
						};
						break
				}
				return r[e.id] = t, t
			}
		}
	}

	function eS() {
		let r = {};
		return {
			get: function(e) {
				if (r[e.id] !== void 0) return r[e.id];
				let t;
				switch (e.type) {
					case "DirectionalLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new st
						};
						break;
					case "SpotLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new st
						};
						break;
					case "PointLight":
						t = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new st,
							shadowCameraNear: 1,
							shadowCameraFar: 1e3
						};
						break
				}
				return r[e.id] = t, t
			}
		}
	}
	var tS = 0;

	function nS(r, e) {
		return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
	}

	function iS(r, e) {
		let t = new QT,
			n = eS(),
			i = {
				version: 0,
				hash: {
					directionalLength: -1,
					pointLength: -1,
					spotLength: -1,
					rectAreaLength: -1,
					hemiLength: -1,
					numDirectionalShadows: -1,
					numPointShadows: -1,
					numSpotShadows: -1,
					numSpotMaps: -1
				},
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadow: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotLightMap: [],
				spotShadow: [],
				spotShadowMap: [],
				spotLightMatrix: [],
				rectArea: [],
				rectAreaLTC1: null,
				rectAreaLTC2: null,
				point: [],
				pointShadow: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
				numSpotLightShadowsWithMaps: 0
			};
		for (let u = 0; u < 9; u++) i.probe.push(new ne);
		let s = new ne,
			o = new ke,
			a = new ke;

		function c(u, h) {
			let f = 0,
				p = 0,
				g = 0;
			for (let V = 0; V < 9; V++) i.probe[V].set(0, 0, 0);
			let m = 0,
				d = 0,
				v = 0,
				x = 0,
				_ = 0,
				y = 0,
				w = 0,
				C = 0,
				S = 0,
				b = 0;
			u.sort(nS);
			let T = h !== !0 ? Math.PI : 1;
			for (let V = 0, O = u.length; V < O; V++) {
				let k = u[V],
					I = k.color,
					q = k.intensity,
					B = k.distance,
					Y = k.shadow && k.shadow.map ? k.shadow.map.texture : null;
				if (k.isAmbientLight) f += I.r * q * T, p += I.g * q * T, g += I.b * q * T;
				else if (k.isLightProbe)
					for (let J = 0; J < 9; J++) i.probe[J].addScaledVector(k.sh.coefficients[J], q);
				else if (k.isDirectionalLight) {
					let J = t.get(k);
					if (J.color.copy(k.color)
						.multiplyScalar(k.intensity * T), k.castShadow) {
						let H = k.shadow,
							$ = n.get(k);
						$.shadowBias = H.bias, $.shadowNormalBias = H.normalBias, $.shadowRadius = H.radius, $.shadowMapSize = H.mapSize, i.directionalShadow[m] = $, i.directionalShadowMap[m] = Y, i.directionalShadowMatrix[m] = k.shadow.matrix, y++
					}
					i.directional[m] = J, m++
				} else if (k.isSpotLight) {
					let J = t.get(k);
					J.position.setFromMatrixPosition(k.matrixWorld), J.color.copy(I)
						.multiplyScalar(q * T), J.distance = B, J.coneCos = Math.cos(k.angle), J.penumbraCos = Math.cos(k.angle * (1 - k.penumbra)), J.decay = k.decay, i.spot[v] = J;
					let H = k.shadow;
					if (k.map && (i.spotLightMap[S] = k.map, S++, H.updateMatrices(k), k.castShadow && b++), i.spotLightMatrix[v] = H.matrix, k.castShadow) {
						let $ = n.get(k);
						$.shadowBias = H.bias, $.shadowNormalBias = H.normalBias, $.shadowRadius = H.radius, $.shadowMapSize = H.mapSize, i.spotShadow[v] = $, i.spotShadowMap[v] = Y, C++
					}
					v++
				} else if (k.isRectAreaLight) {
					let J = t.get(k);
					J.color.copy(I)
						.multiplyScalar(q), J.halfWidth.set(k.width * .5, 0, 0), J.halfHeight.set(0, k.height * .5, 0), i.rectArea[x] = J, x++
				} else if (k.isPointLight) {
					let J = t.get(k);
					if (J.color.copy(k.color)
						.multiplyScalar(k.intensity * T), J.distance = k.distance, J.decay = k.decay, k.castShadow) {
						let H = k.shadow,
							$ = n.get(k);
						$.shadowBias = H.bias, $.shadowNormalBias = H.normalBias, $.shadowRadius = H.radius, $.shadowMapSize = H.mapSize, $.shadowCameraNear = H.camera.near, $.shadowCameraFar = H.camera.far, i.pointShadow[d] = $, i.pointShadowMap[d] = Y, i.pointShadowMatrix[d] = k.shadow.matrix, w++
					}
					i.point[d] = J, d++
				} else if (k.isHemisphereLight) {
					let J = t.get(k);
					J.skyColor.copy(k.color)
						.multiplyScalar(q * T), J.groundColor.copy(k.groundColor)
						.multiplyScalar(q * T), i.hemi[_] = J, _++
				}
			}
			x > 0 && (e.isWebGL2 || r.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Ne.LTC_FLOAT_1, i.rectAreaLTC2 = Ne.LTC_FLOAT_2) : r.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Ne.LTC_HALF_1, i.rectAreaLTC2 = Ne.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = f, i.ambient[1] = p, i.ambient[2] = g;
			let N = i.hash;
			(N.directionalLength !== m || N.pointLength !== d || N.spotLength !== v || N.rectAreaLength !== x || N.hemiLength !== _ || N.numDirectionalShadows !== y || N.numPointShadows !== w || N.numSpotShadows !== C || N.numSpotMaps !== S) && (i.directional.length = m, i.spot.length = v, i.rectArea.length = x, i.point.length = d, i.hemi.length = _, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = w, i.pointShadowMap.length = w, i.spotShadow.length = C, i.spotShadowMap.length = C, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = w, i.spotLightMatrix.length = C + S - b, i.spotLightMap.length = S, i.numSpotLightShadowsWithMaps = b, N.directionalLength = m, N.pointLength = d, N.spotLength = v, N.rectAreaLength = x, N.hemiLength = _, N.numDirectionalShadows = y, N.numPointShadows = w, N.numSpotShadows = C, N.numSpotMaps = S, i.version = tS++)
		}

		function l(u, h) {
			let f = 0,
				p = 0,
				g = 0,
				m = 0,
				d = 0,
				v = h.matrixWorldInverse;
			for (let x = 0, _ = u.length; x < _; x++) {
				let y = u[x];
				if (y.isDirectionalLight) {
					let w = i.directional[f];
					w.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), w.direction.sub(s), w.direction.transformDirection(v), f++
				} else if (y.isSpotLight) {
					let w = i.spot[g];
					w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(v), w.direction.setFromMatrixPosition(y.matrixWorld), s.setFromMatrixPosition(y.target.matrixWorld), w.direction.sub(s), w.direction.transformDirection(v), g++
				} else if (y.isRectAreaLight) {
					let w = i.rectArea[m];
					w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(v), a.identity(), o.copy(y.matrixWorld), o.premultiply(v), a.extractRotation(o), w.halfWidth.set(y.width * .5, 0, 0), w.halfHeight.set(0, y.height * .5, 0), w.halfWidth.applyMatrix4(a), w.halfHeight.applyMatrix4(a), m++
				} else if (y.isPointLight) {
					let w = i.point[p];
					w.position.setFromMatrixPosition(y.matrixWorld), w.position.applyMatrix4(v), p++
				} else if (y.isHemisphereLight) {
					let w = i.hemi[d];
					w.direction.setFromMatrixPosition(y.matrixWorld), w.direction.transformDirection(v), d++
				}
			}
		}
		return {
			setup: c,
			setupView: l,
			state: i
		}
	}

	function N0(r, e) {
		let t = new iS(r, e),
			n = [],
			i = [];

		function s() {
			n.length = 0, i.length = 0
		}

		function o(h) {
			n.push(h)
		}

		function a(h) {
			i.push(h)
		}

		function c(h) {
			t.setup(n, h)
		}

		function l(h) {
			t.setupView(n, h)
		}
		return {
			init: s,
			state: {
				lightsArray: n,
				shadowsArray: i,
				lights: t
			},
			setupLights: c,
			setupLightsView: l,
			pushLight: o,
			pushShadow: a
		}
	}

	function rS(r, e) {
		let t = new WeakMap;

		function n(s, o = 0) {
			let a = t.get(s),
				c;
			return a === void 0 ? (c = new N0(r, e), t.set(s, [c])) : o >= a.length ? (c = new N0(r, e), a.push(c)) : c = a[o], c
		}

		function i() {
			t = new WeakMap
		}
		return {
			get: n,
			dispose: i
		}
	}
	var Cd = class extends rr {
			constructor(e) {
				super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = m_, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
			}
		},
		Ad = class extends rr {
			constructor(e) {
				super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new ne, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
			}
		},
		sS = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
		oS = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

	function aS(r, e, t) {
		let n = new Al,
			i = new st,
			s = new st,
			o = new wt,
			a = new Cd({
				depthPacking: g_
			}),
			c = new Ad,
			l = {},
			u = t.maxTextureSize,
			h = {
				0: Rn,
				1: _r,
				2: Bn
			},
			f = new $r({
				defines: {
					VSM_SAMPLES: 8
				},
				uniforms: {
					shadow_pass: {
						value: null
					},
					resolution: {
						value: new st
					},
					radius: {
						value: 4
					}
				},
				vertexShader: sS,
				fragmentShader: oS
			}),
			p = f.clone();
		p.defines.HORIZONTAL_PASS = 1;
		let g = new bt;
		g.setAttribute("position", new Gn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
		let m = new zt(g, f),
			d = this;
		this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = ev, this.render = function(y, w, C) {
			if (d.enabled === !1 || d.autoUpdate === !1 && d.needsUpdate === !1 || y.length === 0) return;
			let S = r.getRenderTarget(),
				b = r.getActiveCubeFace(),
				T = r.getActiveMipmapLevel(),
				N = r.state;
			N.setBlending(Is), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(!0), N.setScissorTest(!1);
			for (let V = 0, O = y.length; V < O; V++) {
				let k = y[V],
					I = k.shadow;
				if (I === void 0) {
					console.warn("THREE.WebGLShadowMap:", k, "has no shadow.");
					continue
				}
				if (I.autoUpdate === !1 && I.needsUpdate === !1) continue;
				i.copy(I.mapSize);
				let q = I.getFrameExtents();
				if (i.multiply(q), s.copy(I.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / q.x), i.x = s.x * q.x, I.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / q.y), i.y = s.y * q.y, I.mapSize.y = s.y)), I.map === null) {
					let Y = this.type !== vl ? {
						minFilter: yn,
						magFilter: yn
					} : {};
					I.map = new Zr(i.x, i.y, Y), I.map.texture.name = k.name + ".shadowMap", I.camera.updateProjectionMatrix()
				}
				r.setRenderTarget(I.map), r.clear();
				let B = I.getViewportCount();
				for (let Y = 0; Y < B; Y++) {
					let J = I.getViewport(Y);
					o.set(s.x * J.x, s.y * J.y, s.x * J.z, s.y * J.w), N.viewport(o), I.updateMatrices(k, Y), n = I.getFrustum(), _(w, C, I.camera, k, this.type)
				}
				I.isPointLightShadow !== !0 && this.type === vl && v(I, C), I.needsUpdate = !1
			}
			d.needsUpdate = !1, r.setRenderTarget(S, b, T)
		};

		function v(y, w) {
			let C = e.update(m);
			f.defines.VSM_SAMPLES !== y.blurSamples && (f.defines.VSM_SAMPLES = y.blurSamples, p.defines.VSM_SAMPLES = y.blurSamples, f.needsUpdate = !0, p.needsUpdate = !0), y.mapPass === null && (y.mapPass = new Zr(i.x, i.y)), f.uniforms.shadow_pass.value = y.map.texture, f.uniforms.resolution.value = y.mapSize, f.uniforms.radius.value = y.radius, r.setRenderTarget(y.mapPass), r.clear(), r.renderBufferDirect(w, null, C, f, m, null), p.uniforms.shadow_pass.value = y.mapPass.texture, p.uniforms.resolution.value = y.mapSize, p.uniforms.radius.value = y.radius, r.setRenderTarget(y.map), r.clear(), r.renderBufferDirect(w, null, C, p, m, null)
		}

		function x(y, w, C, S, b, T) {
			let N = null,
				V = C.isPointLight === !0 ? y.customDistanceMaterial : y.customDepthMaterial;
			if (V !== void 0 ? N = V : N = C.isPointLight === !0 ? c : a, r.localClippingEnabled && w.clipShadows === !0 && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0) {
				let O = N.uuid,
					k = w.uuid,
					I = l[O];
				I === void 0 && (I = {}, l[O] = I);
				let q = I[k];
				q === void 0 && (q = N.clone(), I[k] = q), N = q
			}
			return N.visible = w.visible, N.wireframe = w.wireframe, T === vl ? N.side = w.shadowSide !== null ? w.shadowSide : w.side : N.side = w.shadowSide !== null ? w.shadowSide : h[w.side], N.alphaMap = w.alphaMap, N.alphaTest = w.alphaTest, N.clipShadows = w.clipShadows, N.clippingPlanes = w.clippingPlanes, N.clipIntersection = w.clipIntersection, N.displacementMap = w.displacementMap, N.displacementScale = w.displacementScale, N.displacementBias = w.displacementBias, N.wireframeLinewidth = w.wireframeLinewidth, N.linewidth = w.linewidth, C.isPointLight === !0 && N.isMeshDistanceMaterial === !0 && (N.referencePosition.setFromMatrixPosition(C.matrixWorld), N.nearDistance = S, N.farDistance = b), N
		}

		function _(y, w, C, S, b) {
			if (y.visible === !1) return;
			if (y.layers.test(w.layers) && (y.isMesh || y.isLine || y.isPoints) && (y.castShadow || y.receiveShadow && b === vl) && (!y.frustumCulled || n.intersectsObject(y))) {
				y.modelViewMatrix.multiplyMatrices(C.matrixWorldInverse, y.matrixWorld);
				let V = e.update(y),
					O = y.material;
				if (Array.isArray(O)) {
					let k = V.groups;
					for (let I = 0, q = k.length; I < q; I++) {
						let B = k[I],
							Y = O[B.materialIndex];
						if (Y && Y.visible) {
							let J = x(y, Y, S, C.near, C.far, b);
							r.renderBufferDirect(C, null, V, J, y, B)
						}
					}
				} else if (O.visible) {
					let k = x(y, O, S, C.near, C.far, b);
					r.renderBufferDirect(C, null, V, k, y, null)
				}
			}
			let N = y.children;
			for (let V = 0, O = N.length; V < O; V++) _(N[V], w, C, S, b)
		}
	}

	function lS(r, e, t) {
		let n = t.isWebGL2;

		function i() {
			let re = !1,
				Ce = new wt,
				Te = null,
				ge = new wt(0, 0, 0, 0);
			return {
				setMask: function(we) {
					Te !== we && !re && (r.colorMask(we, we, we, we), Te = we)
				},
				setLocked: function(we) {
					re = we
				},
				setClear: function(we, Oe, $e, vt, Wt) {
					Wt === !0 && (we *= vt, Oe *= vt, $e *= vt), Ce.set(we, Oe, $e, vt), ge.equals(Ce) === !1 && (r.clearColor(we, Oe, $e, vt), ge.copy(Ce))
				},
				reset: function() {
					re = !1, Te = null, ge.set(-1, 0, 0, 0)
				}
			}
		}

		function s() {
			let re = !1,
				Ce = null,
				Te = null,
				ge = null;
			return {
				setTest: function(we) {
					we ? j(2929) : K(2929)
				},
				setMask: function(we) {
					Ce !== we && !re && (r.depthMask(we), Ce = we)
				},
				setFunc: function(we) {
					if (Te !== we) {
						switch (we) {
							case Uy:
								r.depthFunc(512);
								break;
							case By:
								r.depthFunc(519);
								break;
							case Gy:
								r.depthFunc(513);
								break;
							case pd:
								r.depthFunc(515);
								break;
							case Vy:
								r.depthFunc(514);
								break;
							case zy:
								r.depthFunc(518);
								break;
							case Hy:
								r.depthFunc(516);
								break;
							case Wy:
								r.depthFunc(517);
								break;
							default:
								r.depthFunc(515)
						}
						Te = we
					}
				},
				setLocked: function(we) {
					re = we
				},
				setClear: function(we) {
					ge !== we && (r.clearDepth(we), ge = we)
				},
				reset: function() {
					re = !1, Ce = null, Te = null, ge = null
				}
			}
		}

		function o() {
			let re = !1,
				Ce = null,
				Te = null,
				ge = null,
				we = null,
				Oe = null,
				$e = null,
				vt = null,
				Wt = null;
			return {
				setTest: function(Ze) {
					re || (Ze ? j(2960) : K(2960))
				},
				setMask: function(Ze) {
					Ce !== Ze && !re && (r.stencilMask(Ze), Ce = Ze)
				},
				setFunc: function(Ze, Fe, Ie) {
					(Te !== Ze || ge !== Fe || we !== Ie) && (r.stencilFunc(Ze, Fe, Ie), Te = Ze, ge = Fe, we = Ie)
				},
				setOp: function(Ze, Fe, Ie) {
					(Oe !== Ze || $e !== Fe || vt !== Ie) && (r.stencilOp(Ze, Fe, Ie), Oe = Ze, $e = Fe, vt = Ie)
				},
				setLocked: function(Ze) {
					re = Ze
				},
				setClear: function(Ze) {
					Wt !== Ze && (r.clearStencil(Ze), Wt = Ze)
				},
				reset: function() {
					re = !1, Ce = null, Te = null, ge = null, we = null, Oe = null, $e = null, vt = null, Wt = null
				}
			}
		}
		let a = new i,
			c = new s,
			l = new o,
			u = new WeakMap,
			h = new WeakMap,
			f = {},
			p = {},
			g = new WeakMap,
			m = [],
			d = null,
			v = !1,
			x = null,
			_ = null,
			y = null,
			w = null,
			C = null,
			S = null,
			b = null,
			T = !1,
			N = null,
			V = null,
			O = null,
			k = null,
			I = null,
			q = r.getParameter(35661),
			B = !1,
			Y = 0,
			J = r.getParameter(7938);
		J.indexOf("WebGL") !== -1 ? (Y = parseFloat(/^WebGL (\d)/.exec(J)[1]), B = Y >= 1) : J.indexOf("OpenGL ES") !== -1 && (Y = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), B = Y >= 2);
		let H = null,
			$ = {},
			ae = r.getParameter(3088),
			oe = r.getParameter(2978),
			ie = new wt()
			.fromArray(ae),
			U = new wt()
			.fromArray(oe);

		function A(re, Ce, Te) {
			let ge = new Uint8Array(4),
				we = r.createTexture();
			r.bindTexture(re, we), r.texParameteri(re, 10241, 9728), r.texParameteri(re, 10240, 9728);
			for (let Oe = 0; Oe < Te; Oe++) r.texImage2D(Ce + Oe, 0, 6408, 1, 1, 0, 6408, 5121, ge);
			return we
		}
		let L = {};
		L[3553] = A(3553, 3553, 1), L[34067] = A(34067, 34069, 6), a.setClear(0, 0, 0, 1), c.setClear(1), l.setClear(0), j(2929), c.setFunc(pd), ht(!1), ct(bg), j(2884), Ee(Is);

		function j(re) {
			f[re] !== !0 && (r.enable(re), f[re] = !0)
		}

		function K(re) {
			f[re] !== !1 && (r.disable(re), f[re] = !1)
		}

		function Q(re, Ce) {
			return p[re] !== Ce ? (r.bindFramebuffer(re, Ce), p[re] = Ce, n && (re === 36009 && (p[36160] = Ce), re === 36160 && (p[36009] = Ce)), !0) : !1
		}

		function se(re, Ce) {
			let Te = m,
				ge = !1;
			if (re)
				if (Te = g.get(Ce), Te === void 0 && (Te = [], g.set(Ce, Te)), re.isWebGLMultipleRenderTargets) {
					let we = re.texture;
					if (Te.length !== we.length || Te[0] !== 36064) {
						for (let Oe = 0, $e = we.length; Oe < $e; Oe++) Te[Oe] = 36064 + Oe;
						Te.length = we.length, ge = !0
					}
				} else Te[0] !== 36064 && (Te[0] = 36064, ge = !0);
			else Te[0] !== 1029 && (Te[0] = 1029, ge = !0);
			ge && (t.isWebGL2 ? r.drawBuffers(Te) : e.get("WEBGL_draw_buffers")
				.drawBuffersWEBGL(Te))
		}

		function de(re) {
			return d !== re ? (r.useProgram(re), d = re, !0) : !1
		}
		let ue = {
			[ia]: 32774,
			[Cy]: 32778,
			[Ay]: 32779
		};
		if (n) ue[Sg] = 32775, ue[Eg] = 32776;
		else {
			let re = e.get("EXT_blend_minmax");
			re !== null && (ue[Sg] = re.MIN_EXT, ue[Eg] = re.MAX_EXT)
		}
		let xe = {
			[Iy]: 0,
			[Ry]: 1,
			[Py]: 768,
			[tv]: 770,
			[Fy]: 776,
			[Oy]: 774,
			[Ny]: 772,
			[Ly]: 769,
			[nv]: 771,
			[ky]: 775,
			[Dy]: 773
		};

		function Ee(re, Ce, Te, ge, we, Oe, $e, vt) {
			if (re === Is) {
				v === !0 && (K(3042), v = !1);
				return
			}
			if (v === !1 && (j(3042), v = !0), re !== Ey) {
				if (re !== x || vt !== T) {
					if ((_ !== ia || C !== ia) && (r.blendEquation(32774), _ = ia, C = ia), vt) switch (re) {
						case oa:
							r.blendFuncSeparate(1, 771, 1, 771);
							break;
						case Mg:
							r.blendFunc(1, 1);
							break;
						case wg:
							r.blendFuncSeparate(0, 769, 0, 1);
							break;
						case Tg:
							r.blendFuncSeparate(0, 768, 0, 770);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", re);
							break
					} else switch (re) {
						case oa:
							r.blendFuncSeparate(770, 771, 1, 771);
							break;
						case Mg:
							r.blendFunc(770, 1);
							break;
						case wg:
							r.blendFuncSeparate(0, 769, 0, 1);
							break;
						case Tg:
							r.blendFunc(0, 768);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", re);
							break
					}
					y = null, w = null, S = null, b = null, x = re, T = vt
				}
				return
			}
			we = we || Ce, Oe = Oe || Te, $e = $e || ge, (Ce !== _ || we !== C) && (r.blendEquationSeparate(ue[Ce], ue[we]), _ = Ce, C = we), (Te !== y || ge !== w || Oe !== S || $e !== b) && (r.blendFuncSeparate(xe[Te], xe[ge], xe[Oe], xe[$e]), y = Te, w = ge, S = Oe, b = $e), x = re, T = null
		}

		function De(re, Ce) {
			re.side === Bn ? K(2884) : j(2884);
			let Te = re.side === Rn;
			Ce && (Te = !Te), ht(Te), re.blending === oa && re.transparent === !1 ? Ee(Is) : Ee(re.blending, re.blendEquation, re.blendSrc, re.blendDst, re.blendEquationAlpha, re.blendSrcAlpha, re.blendDstAlpha, re.premultipliedAlpha), c.setFunc(re.depthFunc), c.setTest(re.depthTest), c.setMask(re.depthWrite), a.setMask(re.colorWrite);
			let ge = re.stencilWrite;
			l.setTest(ge), ge && (l.setMask(re.stencilWriteMask), l.setFunc(re.stencilFunc, re.stencilRef, re.stencilFuncMask), l.setOp(re.stencilFail, re.stencilZFail, re.stencilZPass)), Ve(re.polygonOffset, re.polygonOffsetFactor, re.polygonOffsetUnits), re.alphaToCoverage === !0 ? j(32926) : K(32926)
		}

		function ht(re) {
			N !== re && (re ? r.frontFace(2304) : r.frontFace(2305), N = re)
		}

		function ct(re) {
			re !== wy ? (j(2884), re !== V && (re === bg ? r.cullFace(1029) : re === Ty ? r.cullFace(1028) : r.cullFace(1032))) : K(2884), V = re
		}

		function He(re) {
			re !== O && (B && r.lineWidth(re), O = re)
		}

		function Ve(re, Ce, Te) {
			re ? (j(32823), (k !== Ce || I !== Te) && (r.polygonOffset(Ce, Te), k = Ce, I = Te)) : K(32823)
		}

		function ot(re) {
			re ? j(3089) : K(3089)
		}

		function it(re) {
			re === void 0 && (re = 33984 + q - 1), H !== re && (r.activeTexture(re), H = re)
		}

		function E(re, Ce, Te) {
			Te === void 0 && (H === null ? Te = 33984 + q - 1 : Te = H);
			let ge = $[Te];
			ge === void 0 && (ge = {
				type: void 0,
				texture: void 0
			}, $[Te] = ge), (ge.type !== re || ge.texture !== Ce) && (H !== Te && (r.activeTexture(Te), H = Te), r.bindTexture(re, Ce || L[re]), ge.type = re, ge.texture = Ce)
		}

		function M() {
			let re = $[H];
			re !== void 0 && re.type !== void 0 && (r.bindTexture(re.type, null), re.type = void 0, re.texture = void 0)
		}

		function D() {
			try {
				r.compressedTexImage2D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function X() {
			try {
				r.texSubImage2D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function W() {
			try {
				r.texSubImage3D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function te() {
			try {
				r.compressedTexSubImage2D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function ce() {
			try {
				r.texStorage2D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function le() {
			try {
				r.texStorage3D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function ee() {
			try {
				r.texImage2D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function pe() {
			try {
				r.texImage3D.apply(r, arguments)
			} catch (re) {
				console.error("THREE.WebGLState:", re)
			}
		}

		function ve(re) {
			ie.equals(re) === !1 && (r.scissor(re.x, re.y, re.z, re.w), ie.copy(re))
		}

		function Se(re) {
			U.equals(re) === !1 && (r.viewport(re.x, re.y, re.z, re.w), U.copy(re))
		}

		function Re(re, Ce) {
			let Te = h.get(Ce);
			Te === void 0 && (Te = new WeakMap, h.set(Ce, Te));
			let ge = Te.get(re);
			ge === void 0 && (ge = r.getUniformBlockIndex(Ce, re.name), Te.set(re, ge))
		}

		function We(re, Ce) {
			let ge = h.get(Ce)
				.get(re);
			u.get(re) !== ge && (r.uniformBlockBinding(Ce, ge, re.__bindingPointIndex), u.set(re, ge))
		}

		function Ye() {
			r.disable(3042), r.disable(2884), r.disable(2929), r.disable(32823), r.disable(3089), r.disable(2960), r.disable(32926), r.blendEquation(32774), r.blendFunc(1, 0), r.blendFuncSeparate(1, 0, 1, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(513), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(519, 0, 4294967295), r.stencilOp(7680, 7680, 7680), r.clearStencil(0), r.cullFace(1029), r.frontFace(2305), r.polygonOffset(0, 0), r.activeTexture(33984), r.bindFramebuffer(36160, null), n === !0 && (r.bindFramebuffer(36009, null), r.bindFramebuffer(36008, null)), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), f = {}, H = null, $ = {}, p = {}, g = new WeakMap, m = [], d = null, v = !1, x = null, _ = null, y = null, w = null, C = null, S = null, b = null, T = !1, N = null, V = null, O = null, k = null, I = null, ie.set(0, 0, r.canvas.width, r.canvas.height), U.set(0, 0, r.canvas.width, r.canvas.height), a.reset(), c.reset(), l.reset()
		}
		return {
			buffers: {
				color: a,
				depth: c,
				stencil: l
			},
			enable: j,
			disable: K,
			bindFramebuffer: Q,
			drawBuffers: se,
			useProgram: de,
			setBlending: Ee,
			setMaterial: De,
			setFlipSided: ht,
			setCullFace: ct,
			setLineWidth: He,
			setPolygonOffset: Ve,
			setScissorTest: ot,
			activeTexture: it,
			bindTexture: E,
			unbindTexture: M,
			compressedTexImage2D: D,
			texImage2D: ee,
			texImage3D: pe,
			updateUBOMapping: Re,
			uniformBlockBinding: We,
			texStorage2D: ce,
			texStorage3D: le,
			texSubImage2D: X,
			texSubImage3D: W,
			compressedTexSubImage2D: te,
			scissor: ve,
			viewport: Se,
			reset: Ye
		}
	}

	function cS(r, e, t, n, i, s, o) {
		let a = i.isWebGL2,
			c = i.maxTextures,
			l = i.maxCubemapSize,
			u = i.maxTextureSize,
			h = i.maxSamples,
			f = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
			p = /OculusBrowser/g.test(navigator.userAgent),
			g = new WeakMap,
			m, d = new WeakMap,
			v = !1;
		try {
			v = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1)
				.getContext("2d") !== null
		} catch {}

		function x(E, M) {
			return v ? new OffscreenCanvas(E, M) : Sl("canvas")
		}

		function _(E, M, D, X) {
			let W = 1;
			if ((E.width > X || E.height > X) && (W = X / Math.max(E.width, E.height)), W < 1 || M === !0)
				if (typeof HTMLImageElement < "u" && E instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && E instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && E instanceof ImageBitmap) {
					let te = M ? hu : Math.floor,
						ce = te(W * E.width),
						le = te(W * E.height);
					m === void 0 && (m = x(ce, le));
					let ee = D ? x(ce, le) : m;
					return ee.width = ce, ee.height = le, ee.getContext("2d")
						.drawImage(E, 0, 0, ce, le), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + E.width + "x" + E.height + ") to (" + ce + "x" + le + ")."), ee
				} else return "data" in E && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + E.width + "x" + E.height + ")."), E;
			return E
		}

		function y(E) {
			return vd(E.width) && vd(E.height)
		}

		function w(E) {
			return a ? !1 : E.wrapS !== Xt || E.wrapT !== Xt || E.minFilter !== yn && E.minFilter !== pn
		}

		function C(E, M) {
			return E.generateMipmaps && M && E.minFilter !== yn && E.minFilter !== pn
		}

		function S(E) {
			r.generateMipmap(E)
		}

		function b(E, M, D, X, W = !1) {
			if (a === !1) return M;
			if (E !== null) {
				if (r[E] !== void 0) return r[E];
				console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + E + "'")
			}
			let te = M;
			return M === 6403 && (D === 5126 && (te = 33326), D === 5131 && (te = 33325), D === 5121 && (te = 33321)), M === 33319 && (D === 5126 && (te = 33328), D === 5131 && (te = 33327), D === 5121 && (te = 33323)), M === 6408 && (D === 5126 && (te = 34836), D === 5131 && (te = 34842), D === 5121 && (te = X === Pt && W === !1 ? 35907 : 32856), D === 32819 && (te = 32854), D === 32820 && (te = 32855)), (te === 33325 || te === 33326 || te === 33327 || te === 33328 || te === 34842 || te === 34836) && e.get("EXT_color_buffer_float"), te
		}

		function T(E, M, D) {
			return C(E, D) === !0 || E.isFramebufferTexture && E.minFilter !== yn && E.minFilter !== pn ? Math.log2(Math.max(M.width, M.height)) + 1 : E.mipmaps !== void 0 && E.mipmaps.length > 0 ? E.mipmaps.length : E.isCompressedTexture && Array.isArray(E.image) ? M.mipmaps.length : 1
		}

		function N(E) {
			return E === yn || E === Cg || E === Ag ? 9728 : 9729
		}

		function V(E) {
			let M = E.target;
			M.removeEventListener("dispose", V), k(M), M.isVideoTexture && g.delete(M)
		}

		function O(E) {
			let M = E.target;
			M.removeEventListener("dispose", O), q(M)
		}

		function k(E) {
			let M = n.get(E);
			if (M.__webglInit === void 0) return;
			let D = E.source,
				X = d.get(D);
			if (X) {
				let W = X[M.__cacheKey];
				W.usedTimes--, W.usedTimes === 0 && I(E), Object.keys(X)
					.length === 0 && d.delete(D)
			}
			n.remove(E)
		}

		function I(E) {
			let M = n.get(E);
			r.deleteTexture(M.__webglTexture);
			let D = E.source,
				X = d.get(D);
			delete X[M.__cacheKey], o.memory.textures--
		}

		function q(E) {
			let M = E.texture,
				D = n.get(E),
				X = n.get(M);
			if (X.__webglTexture !== void 0 && (r.deleteTexture(X.__webglTexture), o.memory.textures--), E.depthTexture && E.depthTexture.dispose(), E.isWebGLCubeRenderTarget)
				for (let W = 0; W < 6; W++) r.deleteFramebuffer(D.__webglFramebuffer[W]), D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer[W]);
			else {
				if (r.deleteFramebuffer(D.__webglFramebuffer), D.__webglDepthbuffer && r.deleteRenderbuffer(D.__webglDepthbuffer), D.__webglMultisampledFramebuffer && r.deleteFramebuffer(D.__webglMultisampledFramebuffer), D.__webglColorRenderbuffer)
					for (let W = 0; W < D.__webglColorRenderbuffer.length; W++) D.__webglColorRenderbuffer[W] && r.deleteRenderbuffer(D.__webglColorRenderbuffer[W]);
				D.__webglDepthRenderbuffer && r.deleteRenderbuffer(D.__webglDepthRenderbuffer)
			}
			if (E.isWebGLMultipleRenderTargets)
				for (let W = 0, te = M.length; W < te; W++) {
					let ce = n.get(M[W]);
					ce.__webglTexture && (r.deleteTexture(ce.__webglTexture), o.memory.textures--), n.remove(M[W])
				}
			n.remove(M), n.remove(E)
		}
		let B = 0;

		function Y() {
			B = 0
		}

		function J() {
			let E = B;
			return E >= c && console.warn("THREE.WebGLTextures: Trying to use " + E + " texture units while this GPU supports only " + c), B += 1, E
		}

		function H(E) {
			let M = [];
			return M.push(E.wrapS), M.push(E.wrapT), M.push(E.magFilter), M.push(E.minFilter), M.push(E.anisotropy), M.push(E.internalFormat), M.push(E.format), M.push(E.type), M.push(E.generateMipmaps), M.push(E.premultiplyAlpha), M.push(E.flipY), M.push(E.unpackAlignment), M.push(E.encoding), M.join()
		}

		function $(E, M) {
			let D = n.get(E);
			if (E.isVideoTexture && ot(E), E.isRenderTargetTexture === !1 && E.version > 0 && D.__version !== E.version) {
				let X = E.image;
				if (X === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
				else if (X.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
				else {
					K(D, E, M);
					return
				}
			}
			t.bindTexture(3553, D.__webglTexture, 33984 + M)
		}

		function ae(E, M) {
			let D = n.get(E);
			if (E.version > 0 && D.__version !== E.version) {
				K(D, E, M);
				return
			}
			t.bindTexture(35866, D.__webglTexture, 33984 + M)
		}

		function oe(E, M) {
			let D = n.get(E);
			if (E.version > 0 && D.__version !== E.version) {
				K(D, E, M);
				return
			}
			t.bindTexture(32879, D.__webglTexture, 33984 + M)
		}

		function ie(E, M) {
			let D = n.get(E);
			if (E.version > 0 && D.__version !== E.version) {
				Q(D, E, M);
				return
			}
			t.bindTexture(34067, D.__webglTexture, 33984 + M)
		}
		let U = {
				[en]: 10497,
				[Xt]: 33071,
				[fa]: 33648
			},
			A = {
				[yn]: 9728,
				[Cg]: 9984,
				[Ag]: 9986,
				[pn]: 9729,
				[$y]: 9985,
				[Er]: 9987
			};

		function L(E, M, D) {
			if (D ? (r.texParameteri(E, 10242, U[M.wrapS]), r.texParameteri(E, 10243, U[M.wrapT]), (E === 32879 || E === 35866) && r.texParameteri(E, 32882, U[M.wrapR]), r.texParameteri(E, 10240, A[M.magFilter]), r.texParameteri(E, 10241, A[M.minFilter])) : (r.texParameteri(E, 10242, 33071), r.texParameteri(E, 10243, 33071), (E === 32879 || E === 35866) && r.texParameteri(E, 32882, 33071), (M.wrapS !== Xt || M.wrapT !== Xt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), r.texParameteri(E, 10240, N(M.magFilter)), r.texParameteri(E, 10241, N(M.minFilter)), M.minFilter !== yn && M.minFilter !== pn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === !0) {
				let X = e.get("EXT_texture_filter_anisotropic");
				if (M.type === As && e.has("OES_texture_float_linear") === !1 || a === !1 && M.type === wl && e.has("OES_texture_half_float_linear") === !1) return;
				(M.anisotropy > 1 || n.get(M)
					.__currentAnisotropy) && (r.texParameterf(E, X.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, i.getMaxAnisotropy())), n.get(M)
					.__currentAnisotropy = M.anisotropy)
			}
		}

		function j(E, M) {
			let D = !1;
			E.__webglInit === void 0 && (E.__webglInit = !0, M.addEventListener("dispose", V));
			let X = M.source,
				W = d.get(X);
			W === void 0 && (W = {}, d.set(X, W));
			let te = H(M);
			if (te !== E.__cacheKey) {
				W[te] === void 0 && (W[te] = {
					texture: r.createTexture(),
					usedTimes: 0
				}, o.memory.textures++, D = !0), W[te].usedTimes++;
				let ce = W[E.__cacheKey];
				ce !== void 0 && (W[E.__cacheKey].usedTimes--, ce.usedTimes === 0 && I(M)), E.__cacheKey = te, E.__webglTexture = W[te].texture
			}
			return D
		}

		function K(E, M, D) {
			let X = 3553;
			M.isDataArrayTexture && (X = 35866), M.isData3DTexture && (X = 32879);
			let W = j(E, M),
				te = M.source;
			t.bindTexture(X, E.__webglTexture, 33984 + D);
			let ce = n.get(te);
			if (te.version !== ce.__version || W === !0) {
				t.activeTexture(33984 + D), r.pixelStorei(37440, M.flipY), r.pixelStorei(37441, M.premultiplyAlpha), r.pixelStorei(3317, M.unpackAlignment), r.pixelStorei(37443, 0);
				let le = w(M) && y(M.image) === !1,
					ee = _(M.image, le, !1, u);
				ee = it(M, ee);
				let pe = y(ee) || a,
					ve = s.convert(M.format, M.encoding),
					Se = s.convert(M.type),
					Re = b(M.internalFormat, ve, Se, M.encoding, M.isVideoTexture);
				L(X, M, pe);
				let We, Ye = M.mipmaps,
					re = a && M.isVideoTexture !== !0,
					Ce = ce.__version === void 0 || W === !0,
					Te = T(M, ee, pe);
				if (M.isDepthTexture) Re = 6402, a ? M.type === As ? Re = 36012 : M.type === vo ? Re = 33190 : M.type === aa ? Re = 35056 : Re = 33189 : M.type === As && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), M.format === yo && Re === 6402 && M.type !== rv && M.type !== vo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), M.type = vo, Se = s.convert(M.type)), M.format === da && Re === 6402 && (Re = 34041, M.type !== aa && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), M.type = aa, Se = s.convert(M.type))), Ce && (re ? t.texStorage2D(3553, 1, Re, ee.width, ee.height) : t.texImage2D(3553, 0, Re, ee.width, ee.height, 0, ve, Se, null));
				else if (M.isDataTexture)
					if (Ye.length > 0 && pe) {
						re && Ce && t.texStorage2D(3553, Te, Re, Ye[0].width, Ye[0].height);
						for (let ge = 0, we = Ye.length; ge < we; ge++) We = Ye[ge], re ? t.texSubImage2D(3553, ge, 0, 0, We.width, We.height, ve, Se, We.data) : t.texImage2D(3553, ge, Re, We.width, We.height, 0, ve, Se, We.data);
						M.generateMipmaps = !1
					} else re ? (Ce && t.texStorage2D(3553, Te, Re, ee.width, ee.height), t.texSubImage2D(3553, 0, 0, 0, ee.width, ee.height, ve, Se, ee.data)) : t.texImage2D(3553, 0, Re, ee.width, ee.height, 0, ve, Se, ee.data);
				else if (M.isCompressedTexture) {
					re && Ce && t.texStorage2D(3553, Te, Re, Ye[0].width, Ye[0].height);
					for (let ge = 0, we = Ye.length; ge < we; ge++) We = Ye[ge], M.format !== ir ? ve !== null ? re ? t.compressedTexSubImage2D(3553, ge, 0, 0, We.width, We.height, ve, We.data) : t.compressedTexImage2D(3553, ge, Re, We.width, We.height, 0, We.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : re ? t.texSubImage2D(3553, ge, 0, 0, We.width, We.height, ve, Se, We.data) : t.texImage2D(3553, ge, Re, We.width, We.height, 0, ve, Se, We.data)
				} else if (M.isDataArrayTexture) re ? (Ce && t.texStorage3D(35866, Te, Re, ee.width, ee.height, ee.depth), t.texSubImage3D(35866, 0, 0, 0, 0, ee.width, ee.height, ee.depth, ve, Se, ee.data)) : t.texImage3D(35866, 0, Re, ee.width, ee.height, ee.depth, 0, ve, Se, ee.data);
				else if (M.isData3DTexture) re ? (Ce && t.texStorage3D(32879, Te, Re, ee.width, ee.height, ee.depth), t.texSubImage3D(32879, 0, 0, 0, 0, ee.width, ee.height, ee.depth, ve, Se, ee.data)) : t.texImage3D(32879, 0, Re, ee.width, ee.height, ee.depth, 0, ve, Se, ee.data);
				else if (M.isFramebufferTexture) {
					if (Ce)
						if (re) t.texStorage2D(3553, Te, Re, ee.width, ee.height);
						else {
							let ge = ee.width,
								we = ee.height;
							for (let Oe = 0; Oe < Te; Oe++) t.texImage2D(3553, Oe, Re, ge, we, 0, ve, Se, null), ge >>= 1, we >>= 1
						}
				} else if (Ye.length > 0 && pe) {
					re && Ce && t.texStorage2D(3553, Te, Re, Ye[0].width, Ye[0].height);
					for (let ge = 0, we = Ye.length; ge < we; ge++) We = Ye[ge], re ? t.texSubImage2D(3553, ge, 0, 0, ve, Se, We) : t.texImage2D(3553, ge, Re, ve, Se, We);
					M.generateMipmaps = !1
				} else re ? (Ce && t.texStorage2D(3553, Te, Re, ee.width, ee.height), t.texSubImage2D(3553, 0, 0, 0, ve, Se, ee)) : t.texImage2D(3553, 0, Re, ve, Se, ee);
				C(M, pe) && S(X), ce.__version = te.version, M.onUpdate && M.onUpdate(M)
			}
			E.__version = M.version
		}

		function Q(E, M, D) {
			if (M.image.length !== 6) return;
			let X = j(E, M),
				W = M.source;
			t.bindTexture(34067, E.__webglTexture, 33984 + D);
			let te = n.get(W);
			if (W.version !== te.__version || X === !0) {
				t.activeTexture(33984 + D), r.pixelStorei(37440, M.flipY), r.pixelStorei(37441, M.premultiplyAlpha), r.pixelStorei(3317, M.unpackAlignment), r.pixelStorei(37443, 0);
				let ce = M.isCompressedTexture || M.image[0].isCompressedTexture,
					le = M.image[0] && M.image[0].isDataTexture,
					ee = [];
				for (let ge = 0; ge < 6; ge++) !ce && !le ? ee[ge] = _(M.image[ge], !1, !0, l) : ee[ge] = le ? M.image[ge].image : M.image[ge], ee[ge] = it(M, ee[ge]);
				let pe = ee[0],
					ve = y(pe) || a,
					Se = s.convert(M.format, M.encoding),
					Re = s.convert(M.type),
					We = b(M.internalFormat, Se, Re, M.encoding),
					Ye = a && M.isVideoTexture !== !0,
					re = te.__version === void 0 || X === !0,
					Ce = T(M, pe, ve);
				L(34067, M, ve);
				let Te;
				if (ce) {
					Ye && re && t.texStorage2D(34067, Ce, We, pe.width, pe.height);
					for (let ge = 0; ge < 6; ge++) {
						Te = ee[ge].mipmaps;
						for (let we = 0; we < Te.length; we++) {
							let Oe = Te[we];
							M.format !== ir ? Se !== null ? Ye ? t.compressedTexSubImage2D(34069 + ge, we, 0, 0, Oe.width, Oe.height, Se, Oe.data) : t.compressedTexImage2D(34069 + ge, we, We, Oe.width, Oe.height, 0, Oe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ye ? t.texSubImage2D(34069 + ge, we, 0, 0, Oe.width, Oe.height, Se, Re, Oe.data) : t.texImage2D(34069 + ge, we, We, Oe.width, Oe.height, 0, Se, Re, Oe.data)
						}
					}
				} else {
					Te = M.mipmaps, Ye && re && (Te.length > 0 && Ce++, t.texStorage2D(34067, Ce, We, ee[0].width, ee[0].height));
					for (let ge = 0; ge < 6; ge++)
						if (le) {
							Ye ? t.texSubImage2D(34069 + ge, 0, 0, 0, ee[ge].width, ee[ge].height, Se, Re, ee[ge].data) : t.texImage2D(34069 + ge, 0, We, ee[ge].width, ee[ge].height, 0, Se, Re, ee[ge].data);
							for (let we = 0; we < Te.length; we++) {
								let $e = Te[we].image[ge].image;
								Ye ? t.texSubImage2D(34069 + ge, we + 1, 0, 0, $e.width, $e.height, Se, Re, $e.data) : t.texImage2D(34069 + ge, we + 1, We, $e.width, $e.height, 0, Se, Re, $e.data)
							}
						} else {
							Ye ? t.texSubImage2D(34069 + ge, 0, 0, 0, Se, Re, ee[ge]) : t.texImage2D(34069 + ge, 0, We, Se, Re, ee[ge]);
							for (let we = 0; we < Te.length; we++) {
								let Oe = Te[we];
								Ye ? t.texSubImage2D(34069 + ge, we + 1, 0, 0, Se, Re, Oe.image[ge]) : t.texImage2D(34069 + ge, we + 1, We, Se, Re, Oe.image[ge])
							}
						}
				}
				C(M, ve) && S(34067), te.__version = W.version, M.onUpdate && M.onUpdate(M)
			}
			E.__version = M.version
		}

		function se(E, M, D, X, W) {
			let te = s.convert(D.format, D.encoding),
				ce = s.convert(D.type),
				le = b(D.internalFormat, te, ce, D.encoding);
			n.get(M)
				.__hasExternalTextures || (W === 32879 || W === 35866 ? t.texImage3D(W, 0, le, M.width, M.height, M.depth, 0, te, ce, null) : t.texImage2D(W, 0, le, M.width, M.height, 0, te, ce, null)), t.bindFramebuffer(36160, E), Ve(M) ? f.framebufferTexture2DMultisampleEXT(36160, X, W, n.get(D)
					.__webglTexture, 0, He(M)) : r.framebufferTexture2D(36160, X, W, n.get(D)
					.__webglTexture, 0), t.bindFramebuffer(36160, null)
		}

		function de(E, M, D) {
			if (r.bindRenderbuffer(36161, E), M.depthBuffer && !M.stencilBuffer) {
				let X = 33189;
				if (D || Ve(M)) {
					let W = M.depthTexture;
					W && W.isDepthTexture && (W.type === As ? X = 36012 : W.type === vo && (X = 33190));
					let te = He(M);
					Ve(M) ? f.renderbufferStorageMultisampleEXT(36161, te, X, M.width, M.height) : r.renderbufferStorageMultisample(36161, te, X, M.width, M.height)
				} else r.renderbufferStorage(36161, X, M.width, M.height);
				r.framebufferRenderbuffer(36160, 36096, 36161, E)
			} else if (M.depthBuffer && M.stencilBuffer) {
				let X = He(M);
				D && Ve(M) === !1 ? r.renderbufferStorageMultisample(36161, X, 35056, M.width, M.height) : Ve(M) ? f.renderbufferStorageMultisampleEXT(36161, X, 35056, M.width, M.height) : r.renderbufferStorage(36161, 34041, M.width, M.height), r.framebufferRenderbuffer(36160, 33306, 36161, E)
			} else {
				let X = M.isWebGLMultipleRenderTargets === !0 ? M.texture : [M.texture];
				for (let W = 0; W < X.length; W++) {
					let te = X[W],
						ce = s.convert(te.format, te.encoding),
						le = s.convert(te.type),
						ee = b(te.internalFormat, ce, le, te.encoding),
						pe = He(M);
					D && Ve(M) === !1 ? r.renderbufferStorageMultisample(36161, pe, ee, M.width, M.height) : Ve(M) ? f.renderbufferStorageMultisampleEXT(36161, pe, ee, M.width, M.height) : r.renderbufferStorage(36161, ee, M.width, M.height)
				}
			}
			r.bindRenderbuffer(36161, null)
		}

		function ue(E, M) {
			if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
			if (t.bindFramebuffer(36160, E), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
			(!n.get(M.depthTexture)
				.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), $(M.depthTexture, 0);
			let X = n.get(M.depthTexture)
				.__webglTexture,
				W = He(M);
			if (M.depthTexture.format === yo) Ve(M) ? f.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, X, 0, W) : r.framebufferTexture2D(36160, 36096, 3553, X, 0);
			else if (M.depthTexture.format === da) Ve(M) ? f.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, X, 0, W) : r.framebufferTexture2D(36160, 33306, 3553, X, 0);
			else throw new Error("Unknown depthTexture format")
		}

		function xe(E) {
			let M = n.get(E),
				D = E.isWebGLCubeRenderTarget === !0;
			if (E.depthTexture && !M.__autoAllocateDepthBuffer) {
				if (D) throw new Error("target.depthTexture not supported in Cube render targets");
				ue(M.__webglFramebuffer, E)
			} else if (D) {
				M.__webglDepthbuffer = [];
				for (let X = 0; X < 6; X++) t.bindFramebuffer(36160, M.__webglFramebuffer[X]), M.__webglDepthbuffer[X] = r.createRenderbuffer(), de(M.__webglDepthbuffer[X], E, !1)
			} else t.bindFramebuffer(36160, M.__webglFramebuffer), M.__webglDepthbuffer = r.createRenderbuffer(), de(M.__webglDepthbuffer, E, !1);
			t.bindFramebuffer(36160, null)
		}

		function Ee(E, M, D) {
			let X = n.get(E);
			M !== void 0 && se(X.__webglFramebuffer, E, E.texture, 36064, 3553), D !== void 0 && xe(E)
		}

		function De(E) {
			let M = E.texture,
				D = n.get(E),
				X = n.get(M);
			E.addEventListener("dispose", O), E.isWebGLMultipleRenderTargets !== !0 && (X.__webglTexture === void 0 && (X.__webglTexture = r.createTexture()), X.__version = M.version, o.memory.textures++);
			let W = E.isWebGLCubeRenderTarget === !0,
				te = E.isWebGLMultipleRenderTargets === !0,
				ce = y(E) || a;
			if (W) {
				D.__webglFramebuffer = [];
				for (let le = 0; le < 6; le++) D.__webglFramebuffer[le] = r.createFramebuffer()
			} else {
				if (D.__webglFramebuffer = r.createFramebuffer(), te)
					if (i.drawBuffers) {
						let le = E.texture;
						for (let ee = 0, pe = le.length; ee < pe; ee++) {
							let ve = n.get(le[ee]);
							ve.__webglTexture === void 0 && (ve.__webglTexture = r.createTexture(), o.memory.textures++)
						}
					} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
				if (a && E.samples > 0 && Ve(E) === !1) {
					let le = te ? M : [M];
					D.__webglMultisampledFramebuffer = r.createFramebuffer(), D.__webglColorRenderbuffer = [], t.bindFramebuffer(36160, D.__webglMultisampledFramebuffer);
					for (let ee = 0; ee < le.length; ee++) {
						let pe = le[ee];
						D.__webglColorRenderbuffer[ee] = r.createRenderbuffer(), r.bindRenderbuffer(36161, D.__webglColorRenderbuffer[ee]);
						let ve = s.convert(pe.format, pe.encoding),
							Se = s.convert(pe.type),
							Re = b(pe.internalFormat, ve, Se, pe.encoding, E.isXRRenderTarget === !0),
							We = He(E);
						r.renderbufferStorageMultisample(36161, We, Re, E.width, E.height), r.framebufferRenderbuffer(36160, 36064 + ee, 36161, D.__webglColorRenderbuffer[ee])
					}
					r.bindRenderbuffer(36161, null), E.depthBuffer && (D.__webglDepthRenderbuffer = r.createRenderbuffer(), de(D.__webglDepthRenderbuffer, E, !0)), t.bindFramebuffer(36160, null)
				}
			}
			if (W) {
				t.bindTexture(34067, X.__webglTexture), L(34067, M, ce);
				for (let le = 0; le < 6; le++) se(D.__webglFramebuffer[le], E, M, 36064, 34069 + le);
				C(M, ce) && S(34067), t.unbindTexture()
			} else if (te) {
				let le = E.texture;
				for (let ee = 0, pe = le.length; ee < pe; ee++) {
					let ve = le[ee],
						Se = n.get(ve);
					t.bindTexture(3553, Se.__webglTexture), L(3553, ve, ce), se(D.__webglFramebuffer, E, ve, 36064 + ee, 3553), C(ve, ce) && S(3553)
				}
				t.unbindTexture()
			} else {
				let le = 3553;
				(E.isWebGL3DRenderTarget || E.isWebGLArrayRenderTarget) && (a ? le = E.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(le, X.__webglTexture), L(le, M, ce), se(D.__webglFramebuffer, E, M, 36064, le), C(M, ce) && S(le), t.unbindTexture()
			}
			E.depthBuffer && xe(E)
		}

		function ht(E) {
			let M = y(E) || a,
				D = E.isWebGLMultipleRenderTargets === !0 ? E.texture : [E.texture];
			for (let X = 0, W = D.length; X < W; X++) {
				let te = D[X];
				if (C(te, M)) {
					let ce = E.isWebGLCubeRenderTarget ? 34067 : 3553,
						le = n.get(te)
						.__webglTexture;
					t.bindTexture(ce, le), S(ce), t.unbindTexture()
				}
			}
		}

		function ct(E) {
			if (a && E.samples > 0 && Ve(E) === !1) {
				let M = E.isWebGLMultipleRenderTargets ? E.texture : [E.texture],
					D = E.width,
					X = E.height,
					W = 16384,
					te = [],
					ce = E.stencilBuffer ? 33306 : 36096,
					le = n.get(E),
					ee = E.isWebGLMultipleRenderTargets === !0;
				if (ee)
					for (let pe = 0; pe < M.length; pe++) t.bindFramebuffer(36160, le.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(36160, 36064 + pe, 36161, null), t.bindFramebuffer(36160, le.__webglFramebuffer), r.framebufferTexture2D(36009, 36064 + pe, 3553, null, 0);
				t.bindFramebuffer(36008, le.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, le.__webglFramebuffer);
				for (let pe = 0; pe < M.length; pe++) {
					te.push(36064 + pe), E.depthBuffer && te.push(ce);
					let ve = le.__ignoreDepthValues !== void 0 ? le.__ignoreDepthValues : !1;
					if (ve === !1 && (E.depthBuffer && (W |= 256), E.stencilBuffer && (W |= 1024)), ee && r.framebufferRenderbuffer(36008, 36064, 36161, le.__webglColorRenderbuffer[pe]), ve === !0 && (r.invalidateFramebuffer(36008, [ce]), r.invalidateFramebuffer(36009, [ce])), ee) {
						let Se = n.get(M[pe])
							.__webglTexture;
						r.framebufferTexture2D(36009, 36064, 3553, Se, 0)
					}
					r.blitFramebuffer(0, 0, D, X, 0, 0, D, X, W, 9728), p && r.invalidateFramebuffer(36008, te)
				}
				if (t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), ee)
					for (let pe = 0; pe < M.length; pe++) {
						t.bindFramebuffer(36160, le.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(36160, 36064 + pe, 36161, le.__webglColorRenderbuffer[pe]);
						let ve = n.get(M[pe])
							.__webglTexture;
						t.bindFramebuffer(36160, le.__webglFramebuffer), r.framebufferTexture2D(36009, 36064 + pe, 3553, ve, 0)
					}
				t.bindFramebuffer(36009, le.__webglMultisampledFramebuffer)
			}
		}

		function He(E) {
			return Math.min(h, E.samples)
		}

		function Ve(E) {
			let M = n.get(E);
			return a && E.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1
		}

		function ot(E) {
			let M = o.render.frame;
			g.get(E) !== M && (g.set(E, M), E.update())
		}

		function it(E, M) {
			let D = E.encoding,
				X = E.format,
				W = E.type;
			return E.isCompressedTexture === !0 || E.isVideoTexture === !0 || E.format === gd || D !== Mo && (D === Pt ? a === !1 ? e.has("EXT_sRGB") === !0 && X === ir ? (E.format = gd, E.minFilter = pn, E.generateMipmaps = !1) : M = wo.sRGBToLinear(M) : (X !== ir || W !== bo) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", D)), M
		}
		this.allocateTextureUnit = J, this.resetTextureUnits = Y, this.setTexture2D = $, this.setTexture2DArray = ae, this.setTexture3D = oe, this.setTextureCube = ie, this.rebindTextures = Ee, this.setupRenderTarget = De, this.updateRenderTargetMipmap = ht, this.updateMultisampleRenderTarget = ct, this.setupDepthRenderbuffer = xe, this.setupFrameBufferTexture = se, this.useMultisampledRTT = Ve
	}

	function uS(r, e, t) {
		let n = t.isWebGL2;

		function i(s, o = null) {
			let a;
			if (s === bo) return 5121;
			if (s === n_) return 32819;
			if (s === i_) return 32820;
			if (s === Qy) return 5120;
			if (s === e_) return 5122;
			if (s === rv) return 5123;
			if (s === t_) return 5124;
			if (s === vo) return 5125;
			if (s === As) return 5126;
			if (s === wl) return n ? 5131 : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
			if (s === r_) return 6406;
			if (s === ir) return 6408;
			if (s === o_) return 6409;
			if (s === a_) return 6410;
			if (s === yo) return 6402;
			if (s === da) return 34041;
			if (s === l_) return 6403;
			if (s === s_) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
			if (s === gd) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
			if (s === c_) return 36244;
			if (s === u_) return 33319;
			if (s === h_) return 33320;
			if (s === f_) return 36249;
			if (s === Df || s === Of || s === kf || s === Ff)
				if (o === Pt)
					if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
						if (s === Df) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
						if (s === Of) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
						if (s === kf) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
						if (s === Ff) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
					} else return null;
			else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
				if (s === Df) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if (s === Of) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if (s === kf) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if (s === Ff) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
			} else return null;
			if (s === Ig || s === Rg || s === Pg || s === Lg)
				if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
					if (s === Ig) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (s === Rg) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (s === Pg) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (s === Lg) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
				} else return null;
			if (s === d_) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
			if (s === Ng || s === Dg)
				if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
					if (s === Ng) return o === Pt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
					if (s === Dg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC
				} else return null;
			if (s === Og || s === kg || s === Fg || s === Ug || s === Bg || s === Gg || s === Vg || s === zg || s === Hg || s === Wg || s === jg || s === qg || s === Xg || s === Yg)
				if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
					if (s === Og) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
					if (s === kg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
					if (s === Fg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
					if (s === Ug) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
					if (s === Bg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
					if (s === Gg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
					if (s === Vg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
					if (s === zg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
					if (s === Hg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
					if (s === Wg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
					if (s === jg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
					if (s === qg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
					if (s === Xg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
					if (s === Yg) return o === Pt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR
				} else return null;
			if (s === Zg)
				if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
					if (s === Zg) return o === Pt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
				} else return null;
			return s === aa ? n ? 34042 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : r[s] !== void 0 ? r[s] : null
		}
		return {
			convert: i
		}
	}
	var Id = class extends Kt {
			constructor(e = []) {
				super(), this.isArrayCamera = !0, this.cameras = e
			}
		},
		_n = class extends yt {
			constructor() {
				super(), this.isGroup = !0, this.type = "Group"
			}
		},
		hS = {
			type: "move"
		},
		bl = class {
			constructor() {
				this._targetRay = null, this._grip = null, this._hand = null
			}
			getHandSpace() {
				return this._hand === null && (this._hand = new _n, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
					pinching: !1
				}), this._hand
			}
			getTargetRaySpace() {
				return this._targetRay === null && (this._targetRay = new _n, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ne, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ne), this._targetRay
			}
			getGripSpace() {
				return this._grip === null && (this._grip = new _n, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ne, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ne), this._grip
			}
			dispatchEvent(e) {
				return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
			}
			disconnect(e) {
				return this.dispatchEvent({
					type: "disconnected",
					data: e
				}), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
			}
			update(e, t, n) {
				let i = null,
					s = null,
					o = null,
					a = this._targetRay,
					c = this._grip,
					l = this._hand;
				if (e && t.session.visibilityState !== "visible-blurred") {
					if (l && e.hand) {
						o = !0;
						for (let m of e.hand.values()) {
							let d = t.getJointPose(m, n);
							if (l.joints[m.jointName] === void 0) {
								let x = new _n;
								x.matrixAutoUpdate = !1, x.visible = !1, l.joints[m.jointName] = x, l.add(x)
							}
							let v = l.joints[m.jointName];
							d !== null && (v.matrix.fromArray(d.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.jointRadius = d.radius), v.visible = d !== null
						}
						let u = l.joints["index-finger-tip"],
							h = l.joints["thumb-tip"],
							f = u.position.distanceTo(h.position),
							p = .02,
							g = .005;
						l.inputState.pinching && f > p + g ? (l.inputState.pinching = !1, this.dispatchEvent({
							type: "pinchend",
							handedness: e.handedness,
							target: this
						})) : !l.inputState.pinching && f <= p - g && (l.inputState.pinching = !0, this.dispatchEvent({
							type: "pinchstart",
							handedness: e.handedness,
							target: this
						}))
					} else c !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (c.matrix.fromArray(s.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), s.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(s.linearVelocity)) : c.hasLinearVelocity = !1, s.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(s.angularVelocity)) : c.hasAngularVelocity = !1));
					a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(hS)))
				}
				return a !== null && (a.visible = i !== null), c !== null && (c.visible = s !== null), l !== null && (l.visible = o !== null), this
			}
		},
		Rd = class extends Pn {
			constructor(e, t, n, i, s, o, a, c, l, u) {
				if (u = u !== void 0 ? u : yo, u !== yo && u !== da) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
				n === void 0 && u === yo && (n = vo), n === void 0 && u === da && (n = aa), super(null, i, s, o, a, c, u, n, l), this.isDepthTexture = !0, this.image = {
					width: e,
					height: t
				}, this.magFilter = a !== void 0 ? a : yn, this.minFilter = c !== void 0 ? c : yn, this.flipY = !1, this.generateMipmaps = !1
			}
		},
		Pd = class extends Rs {
			constructor(e, t) {
				super();
				let n = this,
					i = null,
					s = 1,
					o = null,
					a = "local-floor",
					c = null,
					l = null,
					u = null,
					h = null,
					f = null,
					p = null,
					g = t.getContextAttributes(),
					m = null,
					d = null,
					v = [],
					x = [],
					_ = new Kt;
				_.layers.enable(1), _.viewport = new wt;
				let y = new Kt;
				y.layers.enable(2), y.viewport = new wt;
				let w = [_, y],
					C = new Id;
				C.layers.enable(1), C.layers.enable(2);
				let S = null,
					b = null;
				this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
					let $ = v[H];
					return $ === void 0 && ($ = new bl, v[H] = $), $.getTargetRaySpace()
				}, this.getControllerGrip = function(H) {
					let $ = v[H];
					return $ === void 0 && ($ = new bl, v[H] = $), $.getGripSpace()
				}, this.getHand = function(H) {
					let $ = v[H];
					return $ === void 0 && ($ = new bl, v[H] = $), $.getHandSpace()
				};

				function T(H) {
					let $ = x.indexOf(H.inputSource);
					if ($ === -1) return;
					let ae = v[$];
					ae !== void 0 && ae.dispatchEvent({
						type: H.type,
						data: H.inputSource
					})
				}

				function N() {
					i.removeEventListener("select", T), i.removeEventListener("selectstart", T), i.removeEventListener("selectend", T), i.removeEventListener("squeeze", T), i.removeEventListener("squeezestart", T), i.removeEventListener("squeezeend", T), i.removeEventListener("end", N), i.removeEventListener("inputsourceschange", V);
					for (let H = 0; H < v.length; H++) {
						let $ = x[H];
						$ !== null && (x[H] = null, v[H].disconnect($))
					}
					S = null, b = null, e.setRenderTarget(m), f = null, h = null, u = null, i = null, d = null, J.stop(), n.isPresenting = !1, n.dispatchEvent({
						type: "sessionend"
					})
				}
				this.setFramebufferScaleFactor = function(H) {
					s = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
				}, this.setReferenceSpaceType = function(H) {
					a = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
				}, this.getReferenceSpace = function() {
					return c || o
				}, this.setReferenceSpace = function(H) {
					c = H
				}, this.getBaseLayer = function() {
					return h !== null ? h : f
				}, this.getBinding = function() {
					return u
				}, this.getFrame = function() {
					return p
				}, this.getSession = function() {
					return i
				}, this.setSession = async function(H) {
					if (i = H, i !== null) {
						if (m = e.getRenderTarget(), i.addEventListener("select", T), i.addEventListener("selectstart", T), i.addEventListener("selectend", T), i.addEventListener("squeeze", T), i.addEventListener("squeezestart", T), i.addEventListener("squeezeend", T), i.addEventListener("end", N), i.addEventListener("inputsourceschange", V), g.xrCompatible !== !0 && await t.makeXRCompatible(), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
							let $ = {
								antialias: i.renderState.layers === void 0 ? g.antialias : !0,
								alpha: g.alpha,
								depth: g.depth,
								stencil: g.stencil,
								framebufferScaleFactor: s
							};
							f = new XRWebGLLayer(i, t, $), i.updateRenderState({
								baseLayer: f
							}), d = new Zr(f.framebufferWidth, f.framebufferHeight, {
								format: ir,
								type: bo,
								encoding: e.outputEncoding,
								stencilBuffer: g.stencil
							})
						} else {
							let $ = null,
								ae = null,
								oe = null;
							g.depth && (oe = g.stencil ? 35056 : 33190, $ = g.stencil ? da : yo, ae = g.stencil ? aa : vo);
							let ie = {
								colorFormat: 32856,
								depthFormat: oe,
								scaleFactor: s
							};
							u = new XRWebGLBinding(i, t), h = u.createProjectionLayer(ie), i.updateRenderState({
								layers: [h]
							}), d = new Zr(h.textureWidth, h.textureHeight, {
								format: ir,
								type: bo,
								depthTexture: new Rd(h.textureWidth, h.textureHeight, ae, void 0, void 0, void 0, void 0, void 0, void 0, $),
								stencilBuffer: g.stencil,
								encoding: e.outputEncoding,
								samples: g.antialias ? 4 : 0
							});
							let U = e.properties.get(d);
							U.__ignoreDepthValues = h.ignoreDepthValues
						}
						d.isXRRenderTarget = !0, this.setFoveation(1), c = null, o = await i.requestReferenceSpace(a), J.setContext(i), J.start(), n.isPresenting = !0, n.dispatchEvent({
							type: "sessionstart"
						})
					}
				};

				function V(H) {
					for (let $ = 0; $ < H.removed.length; $++) {
						let ae = H.removed[$],
							oe = x.indexOf(ae);
						oe >= 0 && (x[oe] = null, v[oe].dispatchEvent({
							type: "disconnected",
							data: ae
						}))
					}
					for (let $ = 0; $ < H.added.length; $++) {
						let ae = H.added[$],
							oe = x.indexOf(ae);
						if (oe === -1) {
							for (let U = 0; U < v.length; U++)
								if (U >= x.length) {
									x.push(ae), oe = U;
									break
								} else if (x[U] === null) {
								x[U] = ae, oe = U;
								break
							}
							if (oe === -1) break
						}
						let ie = v[oe];
						ie && ie.dispatchEvent({
							type: "connected",
							data: ae
						})
					}
				}
				let O = new ne,
					k = new ne;

				function I(H, $, ae) {
					O.setFromMatrixPosition($.matrixWorld), k.setFromMatrixPosition(ae.matrixWorld);
					let oe = O.distanceTo(k),
						ie = $.projectionMatrix.elements,
						U = ae.projectionMatrix.elements,
						A = ie[14] / (ie[10] - 1),
						L = ie[14] / (ie[10] + 1),
						j = (ie[9] + 1) / ie[5],
						K = (ie[9] - 1) / ie[5],
						Q = (ie[8] - 1) / ie[0],
						se = (U[8] + 1) / U[0],
						de = A * Q,
						ue = A * se,
						xe = oe / (-Q + se),
						Ee = xe * -Q;
					$.matrixWorld.decompose(H.position, H.quaternion, H.scale), H.translateX(Ee), H.translateZ(xe), H.matrixWorld.compose(H.position, H.quaternion, H.scale), H.matrixWorldInverse.copy(H.matrixWorld)
						.invert();
					let De = A + xe,
						ht = L + xe,
						ct = de - Ee,
						He = ue + (oe - Ee),
						Ve = j * L / ht * De,
						ot = K * L / ht * De;
					H.projectionMatrix.makePerspective(ct, He, Ve, ot, De, ht)
				}

				function q(H, $) {
					$ === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices($.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld)
						.invert()
				}
				this.updateCamera = function(H) {
					if (i === null) return;
					C.near = y.near = _.near = H.near, C.far = y.far = _.far = H.far, (S !== C.near || b !== C.far) && (i.updateRenderState({
						depthNear: C.near,
						depthFar: C.far
					}), S = C.near, b = C.far);
					let $ = H.parent,
						ae = C.cameras;
					q(C, $);
					for (let ie = 0; ie < ae.length; ie++) q(ae[ie], $);
					C.matrixWorld.decompose(C.position, C.quaternion, C.scale), H.matrix.copy(C.matrix), H.matrix.decompose(H.position, H.quaternion, H.scale);
					let oe = H.children;
					for (let ie = 0, U = oe.length; ie < U; ie++) oe[ie].updateMatrixWorld(!0);
					ae.length === 2 ? I(C, _, y) : C.projectionMatrix.copy(_.projectionMatrix)
				}, this.getCamera = function() {
					return C
				}, this.getFoveation = function() {
					if (h !== null) return h.fixedFoveation;
					if (f !== null) return f.fixedFoveation
				}, this.setFoveation = function(H) {
					h !== null && (h.fixedFoveation = H), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = H)
				};
				let B = null;

				function Y(H, $) {
					if (l = $.getViewerPose(c || o), p = $, l !== null) {
						let ae = l.views;
						f !== null && (e.setRenderTargetFramebuffer(d, f.framebuffer), e.setRenderTarget(d));
						let oe = !1;
						ae.length !== C.cameras.length && (C.cameras.length = 0, oe = !0);
						for (let ie = 0; ie < ae.length; ie++) {
							let U = ae[ie],
								A = null;
							if (f !== null) A = f.getViewport(U);
							else {
								let j = u.getViewSubImage(h, U);
								A = j.viewport, ie === 0 && (e.setRenderTargetTextures(d, j.colorTexture, h.ignoreDepthValues ? void 0 : j.depthStencilTexture), e.setRenderTarget(d))
							}
							let L = w[ie];
							L === void 0 && (L = new Kt, L.layers.enable(ie), L.viewport = new wt, w[ie] = L), L.matrix.fromArray(U.transform.matrix), L.projectionMatrix.fromArray(U.projectionMatrix), L.viewport.set(A.x, A.y, A.width, A.height), ie === 0 && C.matrix.copy(L.matrix), oe === !0 && C.cameras.push(L)
						}
					}
					for (let ae = 0; ae < v.length; ae++) {
						let oe = x[ae],
							ie = v[ae];
						oe !== null && ie !== void 0 && ie.update(oe, $, c || o)
					}
					B && B(H, $), p = null
				}
				let J = new lv;
				J.setAnimationLoop(Y), this.setAnimationLoop = function(H) {
					B = H
				}, this.dispose = function() {}
			}
		};

	function fS(r, e) {
		function t(m, d) {
			m.fogColor.value.copy(d.color), d.isFog ? (m.fogNear.value = d.near, m.fogFar.value = d.far) : d.isFogExp2 && (m.fogDensity.value = d.density)
		}

		function n(m, d, v, x, _) {
			d.isMeshBasicMaterial || d.isMeshLambertMaterial ? i(m, d) : d.isMeshToonMaterial ? (i(m, d), u(m, d)) : d.isMeshPhongMaterial ? (i(m, d), l(m, d)) : d.isMeshStandardMaterial ? (i(m, d), h(m, d), d.isMeshPhysicalMaterial && f(m, d, _)) : d.isMeshMatcapMaterial ? (i(m, d), p(m, d)) : d.isMeshDepthMaterial ? i(m, d) : d.isMeshDistanceMaterial ? (i(m, d), g(m, d)) : d.isMeshNormalMaterial ? i(m, d) : d.isLineBasicMaterial ? (s(m, d), d.isLineDashedMaterial && o(m, d)) : d.isPointsMaterial ? a(m, d, v, x) : d.isSpriteMaterial ? c(m, d) : d.isShadowMaterial ? (m.color.value.copy(d.color), m.opacity.value = d.opacity) : d.isShaderMaterial && (d.uniformsNeedUpdate = !1)
		}

		function i(m, d) {
			m.opacity.value = d.opacity, d.color && m.diffuse.value.copy(d.color), d.emissive && m.emissive.value.copy(d.emissive)
				.multiplyScalar(d.emissiveIntensity), d.map && (m.map.value = d.map), d.alphaMap && (m.alphaMap.value = d.alphaMap), d.bumpMap && (m.bumpMap.value = d.bumpMap, m.bumpScale.value = d.bumpScale, d.side === Rn && (m.bumpScale.value *= -1)), d.displacementMap && (m.displacementMap.value = d.displacementMap, m.displacementScale.value = d.displacementScale, m.displacementBias.value = d.displacementBias), d.emissiveMap && (m.emissiveMap.value = d.emissiveMap), d.normalMap && (m.normalMap.value = d.normalMap, m.normalScale.value.copy(d.normalScale), d.side === Rn && m.normalScale.value.negate()), d.specularMap && (m.specularMap.value = d.specularMap), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
			let v = e.get(d)
				.envMap;
			if (v && (m.envMap.value = v, m.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = d.reflectivity, m.ior.value = d.ior, m.refractionRatio.value = d.refractionRatio), d.lightMap) {
				m.lightMap.value = d.lightMap;
				let y = r.physicallyCorrectLights !== !0 ? Math.PI : 1;
				m.lightMapIntensity.value = d.lightMapIntensity * y
			}
			d.aoMap && (m.aoMap.value = d.aoMap, m.aoMapIntensity.value = d.aoMapIntensity);
			let x;
			d.map ? x = d.map : d.specularMap ? x = d.specularMap : d.displacementMap ? x = d.displacementMap : d.normalMap ? x = d.normalMap : d.bumpMap ? x = d.bumpMap : d.roughnessMap ? x = d.roughnessMap : d.metalnessMap ? x = d.metalnessMap : d.alphaMap ? x = d.alphaMap : d.emissiveMap ? x = d.emissiveMap : d.clearcoatMap ? x = d.clearcoatMap : d.clearcoatNormalMap ? x = d.clearcoatNormalMap : d.clearcoatRoughnessMap ? x = d.clearcoatRoughnessMap : d.iridescenceMap ? x = d.iridescenceMap : d.iridescenceThicknessMap ? x = d.iridescenceThicknessMap : d.specularIntensityMap ? x = d.specularIntensityMap : d.specularColorMap ? x = d.specularColorMap : d.transmissionMap ? x = d.transmissionMap : d.thicknessMap ? x = d.thicknessMap : d.sheenColorMap ? x = d.sheenColorMap : d.sheenRoughnessMap && (x = d.sheenRoughnessMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uvTransform.value.copy(x.matrix));
			let _;
			d.aoMap ? _ = d.aoMap : d.lightMap && (_ = d.lightMap), _ !== void 0 && (_.isWebGLRenderTarget && (_ = _.texture), _.matrixAutoUpdate === !0 && _.updateMatrix(), m.uv2Transform.value.copy(_.matrix))
		}

		function s(m, d) {
			m.diffuse.value.copy(d.color), m.opacity.value = d.opacity
		}

		function o(m, d) {
			m.dashSize.value = d.dashSize, m.totalSize.value = d.dashSize + d.gapSize, m.scale.value = d.scale
		}

		function a(m, d, v, x) {
			m.diffuse.value.copy(d.color), m.opacity.value = d.opacity, m.size.value = d.size * v, m.scale.value = x * .5, d.map && (m.map.value = d.map), d.alphaMap && (m.alphaMap.value = d.alphaMap), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
			let _;
			d.map ? _ = d.map : d.alphaMap && (_ = d.alphaMap), _ !== void 0 && (_.matrixAutoUpdate === !0 && _.updateMatrix(), m.uvTransform.value.copy(_.matrix))
		}

		function c(m, d) {
			m.diffuse.value.copy(d.color), m.opacity.value = d.opacity, m.rotation.value = d.rotation, d.map && (m.map.value = d.map), d.alphaMap && (m.alphaMap.value = d.alphaMap), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
			let v;
			d.map ? v = d.map : d.alphaMap && (v = d.alphaMap), v !== void 0 && (v.matrixAutoUpdate === !0 && v.updateMatrix(), m.uvTransform.value.copy(v.matrix))
		}

		function l(m, d) {
			m.specular.value.copy(d.specular), m.shininess.value = Math.max(d.shininess, 1e-4)
		}

		function u(m, d) {
			d.gradientMap && (m.gradientMap.value = d.gradientMap)
		}

		function h(m, d) {
			m.roughness.value = d.roughness, m.metalness.value = d.metalness, d.roughnessMap && (m.roughnessMap.value = d.roughnessMap), d.metalnessMap && (m.metalnessMap.value = d.metalnessMap), e.get(d)
				.envMap && (m.envMapIntensity.value = d.envMapIntensity)
		}

		function f(m, d, v) {
			m.ior.value = d.ior, d.sheen > 0 && (m.sheenColor.value.copy(d.sheenColor)
				.multiplyScalar(d.sheen), m.sheenRoughness.value = d.sheenRoughness, d.sheenColorMap && (m.sheenColorMap.value = d.sheenColorMap), d.sheenRoughnessMap && (m.sheenRoughnessMap.value = d.sheenRoughnessMap)), d.clearcoat > 0 && (m.clearcoat.value = d.clearcoat, m.clearcoatRoughness.value = d.clearcoatRoughness, d.clearcoatMap && (m.clearcoatMap.value = d.clearcoatMap), d.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap), d.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(d.clearcoatNormalScale), m.clearcoatNormalMap.value = d.clearcoatNormalMap, d.side === Rn && m.clearcoatNormalScale.value.negate())), d.iridescence > 0 && (m.iridescence.value = d.iridescence, m.iridescenceIOR.value = d.iridescenceIOR, m.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1], d.iridescenceMap && (m.iridescenceMap.value = d.iridescenceMap), d.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = d.iridescenceThicknessMap)), d.transmission > 0 && (m.transmission.value = d.transmission, m.transmissionSamplerMap.value = v.texture, m.transmissionSamplerSize.value.set(v.width, v.height), d.transmissionMap && (m.transmissionMap.value = d.transmissionMap), m.thickness.value = d.thickness, d.thicknessMap && (m.thicknessMap.value = d.thicknessMap), m.attenuationDistance.value = d.attenuationDistance, m.attenuationColor.value.copy(d.attenuationColor)), m.specularIntensity.value = d.specularIntensity, m.specularColor.value.copy(d.specularColor), d.specularIntensityMap && (m.specularIntensityMap.value = d.specularIntensityMap), d.specularColorMap && (m.specularColorMap.value = d.specularColorMap)
		}

		function p(m, d) {
			d.matcap && (m.matcap.value = d.matcap)
		}

		function g(m, d) {
			m.referencePosition.value.copy(d.referencePosition), m.nearDistance.value = d.nearDistance, m.farDistance.value = d.farDistance
		}
		return {
			refreshFogUniforms: t,
			refreshMaterialUniforms: n
		}
	}

	function dS(r, e, t, n) {
		let i = {},
			s = {},
			o = [],
			a = t.isWebGL2 ? r.getParameter(35375) : 0;

		function c(x, _) {
			let y = _.program;
			n.uniformBlockBinding(x, y)
		}

		function l(x, _) {
			let y = i[x.id];
			y === void 0 && (g(x), y = u(x), i[x.id] = y, x.addEventListener("dispose", d));
			let w = _.program;
			n.updateUBOMapping(x, w);
			let C = e.render.frame;
			s[x.id] !== C && (f(x), s[x.id] = C)
		}

		function u(x) {
			let _ = h();
			x.__bindingPointIndex = _;
			let y = r.createBuffer(),
				w = x.__size,
				C = x.usage;
			return r.bindBuffer(35345, y), r.bufferData(35345, w, C), r.bindBuffer(35345, null), r.bindBufferBase(35345, _, y), y
		}

		function h() {
			for (let x = 0; x < a; x++)
				if (o.indexOf(x) === -1) return o.push(x), x;
			return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
		}

		function f(x) {
			let _ = i[x.id],
				y = x.uniforms,
				w = x.__cache;
			r.bindBuffer(35345, _);
			for (let C = 0, S = y.length; C < S; C++) {
				let b = y[C];
				if (p(b, C, w) === !0) {
					let T = b.value,
						N = b.__offset;
					typeof T == "number" ? (b.__data[0] = T, r.bufferSubData(35345, N, b.__data)) : (b.value.isMatrix3 ? (b.__data[0] = b.value.elements[0], b.__data[1] = b.value.elements[1], b.__data[2] = b.value.elements[2], b.__data[3] = b.value.elements[0], b.__data[4] = b.value.elements[3], b.__data[5] = b.value.elements[4], b.__data[6] = b.value.elements[5], b.__data[7] = b.value.elements[0], b.__data[8] = b.value.elements[6], b.__data[9] = b.value.elements[7], b.__data[10] = b.value.elements[8], b.__data[11] = b.value.elements[0]) : T.toArray(b.__data), r.bufferSubData(35345, N, b.__data))
				}
			}
			r.bindBuffer(35345, null)
		}

		function p(x, _, y) {
			let w = x.value;
			if (y[_] === void 0) return typeof w == "number" ? y[_] = w : y[_] = w.clone(), !0;
			if (typeof w == "number") {
				if (y[_] !== w) return y[_] = w, !0
			} else {
				let C = y[_];
				if (C.equals(w) === !1) return C.copy(w), !0
			}
			return !1
		}

		function g(x) {
			let _ = x.uniforms,
				y = 0,
				w = 16,
				C = 0;
			for (let S = 0, b = _.length; S < b; S++) {
				let T = _[S],
					N = m(T);
				if (T.__data = new Float32Array(N.storage / Float32Array.BYTES_PER_ELEMENT), T.__offset = y, S > 0) {
					C = y % w;
					let V = w - C;
					C !== 0 && V - N.boundary < 0 && (y += w - C, T.__offset = y)
				}
				y += N.storage
			}
			return C = y % w, C > 0 && (y += w - C), x.__size = y, x.__cache = {}, this
		}

		function m(x) {
			let _ = x.value,
				y = {
					boundary: 0,
					storage: 0
				};
			return typeof _ == "number" ? (y.boundary = 4, y.storage = 4) : _.isVector2 ? (y.boundary = 8, y.storage = 8) : _.isVector3 || _.isColor ? (y.boundary = 16, y.storage = 12) : _.isVector4 ? (y.boundary = 16, y.storage = 16) : _.isMatrix3 ? (y.boundary = 48, y.storage = 48) : _.isMatrix4 ? (y.boundary = 64, y.storage = 64) : _.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", _), y
		}

		function d(x) {
			let _ = x.target;
			_.removeEventListener("dispose", d);
			let y = o.indexOf(_.__bindingPointIndex);
			o.splice(y, 1), r.deleteBuffer(i[_.id]), delete i[_.id], delete s[_.id]
		}

		function v() {
			for (let x in i) r.deleteBuffer(i[x]);
			o = [], i = {}, s = {}
		}
		return {
			bind: c,
			update: l,
			dispose: v
		}
	}

	function pS() {
		let r = Sl("canvas");
		return r.style.display = "block", r
	}

	function kl(r = {}) {
		this.isWebGLRenderer = !0;
		let e = r.canvas !== void 0 ? r.canvas : pS(),
			t = r.context !== void 0 ? r.context : null,
			n = r.depth !== void 0 ? r.depth : !0,
			i = r.stencil !== void 0 ? r.stencil : !0,
			s = r.antialias !== void 0 ? r.antialias : !1,
			o = r.premultipliedAlpha !== void 0 ? r.premultipliedAlpha : !0,
			a = r.preserveDrawingBuffer !== void 0 ? r.preserveDrawingBuffer : !1,
			c = r.powerPreference !== void 0 ? r.powerPreference : "default",
			l = r.failIfMajorPerformanceCaveat !== void 0 ? r.failIfMajorPerformanceCaveat : !1,
			u;
		t !== null ? u = t.getContextAttributes()
			.alpha : u = r.alpha !== void 0 ? r.alpha : !1;
		let h = null,
			f = null,
			p = [],
			g = [];
		this.domElement = e, this.debug = {
			checkShaderErrors: !0
		}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = Mo, this.physicallyCorrectLights = !1, this.toneMapping = Yr, this.toneMappingExposure = 1, Object.defineProperties(this, {
			gammaFactor: {
				get: function() {
					return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
				},
				set: function() {
					console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
				}
			}
		});
		let m = this,
			d = !1,
			v = 0,
			x = 0,
			_ = null,
			y = -1,
			w = null,
			C = new wt,
			S = new wt,
			b = null,
			T = e.width,
			N = e.height,
			V = 1,
			O = null,
			k = null,
			I = new wt(0, 0, T, N),
			q = new wt(0, 0, T, N),
			B = !1,
			Y = new Al,
			J = !1,
			H = !1,
			$ = null,
			ae = new ke,
			oe = new st,
			ie = new ne,
			U = {
				background: null,
				fog: null,
				environment: null,
				overrideMaterial: null,
				isScene: !0
			};

		function A() {
			return _ === null ? V : 1
		}
		let L = t;

		function j(Z, fe) {
			for (let ye = 0; ye < Z.length; ye++) {
				let he = Z[ye],
					Me = e.getContext(he, fe);
				if (Me !== null) return Me
			}
			return null
		}
		try {
			let Z = {
				alpha: !0,
				depth: n,
				stencil: i,
				antialias: s,
				premultipliedAlpha: o,
				preserveDrawingBuffer: a,
				powerPreference: c,
				failIfMajorPerformanceCaveat: l
			};
			if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${qd}`), e.addEventListener("webglcontextlost", Re, !1), e.addEventListener("webglcontextrestored", We, !1), e.addEventListener("webglcontextcreationerror", Ye, !1), L === null) {
				let fe = ["webgl2", "webgl", "experimental-webgl"];
				if (m.isWebGL1Renderer === !0 && fe.shift(), L = j(fe, Z), L === null) throw j(fe) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
			}
			L.getShaderPrecisionFormat === void 0 && (L.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		} catch (Z) {
			throw console.error("THREE.WebGLRenderer: " + Z.message), Z
		}
		let K, Q, se, de, ue, xe, Ee, De, ht, ct, He, Ve, ot, it, E, M, D, X, W, te, ce, le, ee, pe;

		function ve() {
			K = new Ow(L), Q = new Iw(L, K, r), K.init(Q), le = new uS(L, K, Q), se = new lS(L, K, Q), de = new Uw, ue = new KT, xe = new cS(L, K, se, ue, Q, le, de), Ee = new Pw(m), De = new Dw(m), ht = new Z_(L, Q), ee = new Cw(L, K, ht, Q), ct = new kw(L, ht, de, ee), He = new zw(L, ct, ht, de), W = new Vw(L, Q, xe), M = new Rw(ue), Ve = new ZT(m, Ee, De, K, Q, ee, M), ot = new fS(m, ue), it = new $T, E = new rS(K, Q), X = new Ew(m, Ee, se, He, u, o), D = new aS(m, He, Q), pe = new dS(L, de, Q, se), te = new Aw(L, K, de, Q), ce = new Fw(L, K, de, Q), de.programs = Ve.programs, m.capabilities = Q, m.extensions = K, m.properties = ue, m.renderLists = it, m.shadowMap = D, m.state = se, m.info = de
		}
		ve();
		let Se = new Pd(m, L);
		this.xr = Se, this.getContext = function() {
			return L
		}, this.getContextAttributes = function() {
			return L.getContextAttributes()
		}, this.forceContextLoss = function() {
			let Z = K.get("WEBGL_lose_context");
			Z && Z.loseContext()
		}, this.forceContextRestore = function() {
			let Z = K.get("WEBGL_lose_context");
			Z && Z.restoreContext()
		}, this.getPixelRatio = function() {
			return V
		}, this.setPixelRatio = function(Z) {
			Z !== void 0 && (V = Z, this.setSize(T, N, !1))
		}, this.getSize = function(Z) {
			return Z.set(T, N)
		}, this.setSize = function(Z, fe, ye) {
			if (Se.isPresenting) {
				console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
				return
			}
			T = Z, N = fe, e.width = Math.floor(Z * V), e.height = Math.floor(fe * V), ye !== !1 && (e.style.width = Z + "px", e.style.height = fe + "px"), this.setViewport(0, 0, Z, fe)
		}, this.getDrawingBufferSize = function(Z) {
			return Z.set(T * V, N * V)
				.floor()
		}, this.setDrawingBufferSize = function(Z, fe, ye) {
			T = Z, N = fe, V = ye, e.width = Math.floor(Z * ye), e.height = Math.floor(fe * ye), this.setViewport(0, 0, Z, fe)
		}, this.getCurrentViewport = function(Z) {
			return Z.copy(C)
		}, this.getViewport = function(Z) {
			return Z.copy(I)
		}, this.setViewport = function(Z, fe, ye, he) {
			Z.isVector4 ? I.set(Z.x, Z.y, Z.z, Z.w) : I.set(Z, fe, ye, he), se.viewport(C.copy(I)
				.multiplyScalar(V)
				.floor())
		}, this.getScissor = function(Z) {
			return Z.copy(q)
		}, this.setScissor = function(Z, fe, ye, he) {
			Z.isVector4 ? q.set(Z.x, Z.y, Z.z, Z.w) : q.set(Z, fe, ye, he), se.scissor(S.copy(q)
				.multiplyScalar(V)
				.floor())
		}, this.getScissorTest = function() {
			return B
		}, this.setScissorTest = function(Z) {
			se.setScissorTest(B = Z)
		}, this.setOpaqueSort = function(Z) {
			O = Z
		}, this.setTransparentSort = function(Z) {
			k = Z
		}, this.getClearColor = function(Z) {
			return Z.copy(X.getClearColor())
		}, this.setClearColor = function() {
			X.setClearColor.apply(X, arguments)
		}, this.getClearAlpha = function() {
			return X.getClearAlpha()
		}, this.setClearAlpha = function() {
			X.setClearAlpha.apply(X, arguments)
		}, this.clear = function(Z = !0, fe = !0, ye = !0) {
			let he = 0;
			Z && (he |= 16384), fe && (he |= 256), ye && (he |= 1024), L.clear(he)
		}, this.clearColor = function() {
			this.clear(!0, !1, !1)
		}, this.clearDepth = function() {
			this.clear(!1, !0, !1)
		}, this.clearStencil = function() {
			this.clear(!1, !1, !0)
		}, this.dispose = function() {
			e.removeEventListener("webglcontextlost", Re, !1), e.removeEventListener("webglcontextrestored", We, !1), e.removeEventListener("webglcontextcreationerror", Ye, !1), it.dispose(), E.dispose(), ue.dispose(), Ee.dispose(), De.dispose(), He.dispose(), ee.dispose(), pe.dispose(), Ve.dispose(), Se.dispose(), Se.removeEventListener("sessionstart", Oe), Se.removeEventListener("sessionend", $e), $ && ($.dispose(), $ = null), vt.stop()
		};

		function Re(Z) {
			Z.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), d = !0
		}

		function We() {
			console.log("THREE.WebGLRenderer: Context Restored."), d = !1;
			let Z = de.autoReset,
				fe = D.enabled,
				ye = D.autoUpdate,
				he = D.needsUpdate,
				Me = D.type;
			ve(), de.autoReset = Z, D.enabled = fe, D.autoUpdate = ye, D.needsUpdate = he, D.type = Me
		}

		function Ye(Z) {
			console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Z.statusMessage)
		}

		function re(Z) {
			let fe = Z.target;
			fe.removeEventListener("dispose", re), Ce(fe)
		}

		function Ce(Z) {
			Te(Z), ue.remove(Z)
		}

		function Te(Z) {
			let fe = ue.get(Z)
				.programs;
			fe !== void 0 && (fe.forEach(function(ye) {
				Ve.releaseProgram(ye)
			}), Z.isShaderMaterial && Ve.releaseShaderCache(Z))
		}
		this.renderBufferDirect = function(Z, fe, ye, he, Me, tt) {
			fe === null && (fe = U);
			let ft = Me.isMesh && Me.matrixWorld.determinant() < 0,
				xt = jt(Z, fe, ye, he, Me);
			se.setMaterial(he, ft);
			let dt = ye.index,
				Ot = ye.attributes.position;
			if (dt === null) {
				if (Ot === void 0 || Ot.count === 0) return
			} else if (dt.count === 0) return;
			let St = 1;
			he.wireframe === !0 && (dt = ct.getWireframeAttribute(ye), St = 2), ee.setup(Me, he, xt, ye, dt);
			let Et, $t = te;
			dt !== null && (Et = ht.get(dt), $t = ce, $t.setIndex(Et));
			let Or = dt !== null ? dt.count : Ot.count,
				hn = ye.drawRange.start * St,
				bi = ye.drawRange.count * St,
				ri = tt !== null ? tt.start * St : 0,
				It = tt !== null ? tt.count * St : 1 / 0,
				fs = Math.max(hn, ri),
				tn = Math.min(Or, hn + bi, ri + It) - 1,
				si = Math.max(0, tn - fs + 1);
			if (si !== 0) {
				if (Me.isMesh) he.wireframe === !0 ? (se.setLineWidth(he.wireframeLinewidth * A()), $t.setMode(1)) : $t.setMode(4);
				else if (Me.isLine) {
					let gr = he.linewidth;
					gr === void 0 && (gr = 1), se.setLineWidth(gr * A()), Me.isLineSegments ? $t.setMode(1) : Me.isLineLoop ? $t.setMode(2) : $t.setMode(3)
				} else Me.isPoints ? $t.setMode(0) : Me.isSprite && $t.setMode(4);
				if (Me.isInstancedMesh) $t.renderInstances(fs, si, Me.count);
				else if (ye.isInstancedBufferGeometry) {
					let gr = Math.min(ye.instanceCount, ye._maxInstanceCount);
					$t.renderInstances(fs, si, gr)
				} else $t.render(fs, si)
			}
		}, this.compile = function(Z, fe) {
			function ye(he, Me, tt) {
				he.transparent === !0 && he.side === Bn ? (he.side = Rn, he.needsUpdate = !0, je(he, Me, tt), he.side = _r, he.needsUpdate = !0, je(he, Me, tt), he.side = Bn) : je(he, Me, tt)
			}
			f = E.get(Z), f.init(), g.push(f), Z.traverseVisible(function(he) {
				he.isLight && he.layers.test(fe.layers) && (f.pushLight(he), he.castShadow && f.pushShadow(he))
			}), f.setupLights(m.physicallyCorrectLights), Z.traverse(function(he) {
				let Me = he.material;
				if (Me)
					if (Array.isArray(Me))
						for (let tt = 0; tt < Me.length; tt++) {
							let ft = Me[tt];
							ye(ft, Z, he)
						} else ye(Me, Z, he)
			}), g.pop(), f = null
		};
		let ge = null;

		function we(Z) {
			ge && ge(Z)
		}

		function Oe() {
			vt.stop()
		}

		function $e() {
			vt.start()
		}
		let vt = new lv;
		vt.setAnimationLoop(we), typeof self < "u" && vt.setContext(self), this.setAnimationLoop = function(Z) {
			ge = Z, Se.setAnimationLoop(Z), Z === null ? vt.stop() : vt.start()
		}, Se.addEventListener("sessionstart", Oe), Se.addEventListener("sessionend", $e), this.render = function(Z, fe) {
			if (fe !== void 0 && fe.isCamera !== !0) {
				console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
				return
			}
			if (d === !0) return;
			Z.matrixWorldAutoUpdate === !0 && Z.updateMatrixWorld(), fe.parent === null && fe.matrixWorldAutoUpdate === !0 && fe.updateMatrixWorld(), Se.enabled === !0 && Se.isPresenting === !0 && (Se.cameraAutoUpdate === !0 && Se.updateCamera(fe), fe = Se.getCamera()), Z.isScene === !0 && Z.onBeforeRender(m, Z, fe, _), f = E.get(Z, g.length), f.init(), g.push(f), ae.multiplyMatrices(fe.projectionMatrix, fe.matrixWorldInverse), Y.setFromProjectionMatrix(ae), H = this.localClippingEnabled, J = M.init(this.clippingPlanes, H, fe), h = it.get(Z, p.length), h.init(), p.push(h), Wt(Z, fe, 0, m.sortObjects), h.finish(), m.sortObjects === !0 && h.sort(O, k), J === !0 && M.beginShadows();
			let ye = f.state.shadowsArray;
			if (D.render(ye, Z, fe), J === !0 && M.endShadows(), this.info.autoReset === !0 && this.info.reset(), X.render(h, Z), f.setupLights(m.physicallyCorrectLights), fe.isArrayCamera) {
				let he = fe.cameras;
				for (let Me = 0, tt = he.length; Me < tt; Me++) {
					let ft = he[Me];
					Ze(h, Z, ft, ft.viewport)
				}
			} else Ze(h, Z, fe);
			_ !== null && (xe.updateMultisampleRenderTarget(_), xe.updateRenderTargetMipmap(_)), Z.isScene === !0 && Z.onAfterRender(m, Z, fe), ee.resetDefaultState(), y = -1, w = null, g.pop(), g.length > 0 ? f = g[g.length - 1] : f = null, p.pop(), p.length > 0 ? h = p[p.length - 1] : h = null
		};

		function Wt(Z, fe, ye, he) {
			if (Z.visible === !1) return;
			if (Z.layers.test(fe.layers)) {
				if (Z.isGroup) ye = Z.renderOrder;
				else if (Z.isLOD) Z.autoUpdate === !0 && Z.update(fe);
				else if (Z.isLight) f.pushLight(Z), Z.castShadow && f.pushShadow(Z);
				else if (Z.isSprite) {
					if (!Z.frustumCulled || Y.intersectsSprite(Z)) {
						he && ie.setFromMatrixPosition(Z.matrixWorld)
							.applyMatrix4(ae);
						let ft = He.update(Z),
							xt = Z.material;
						xt.visible && h.push(Z, ft, xt, ye, ie.z, null)
					}
				} else if ((Z.isMesh || Z.isLine || Z.isPoints) && (Z.isSkinnedMesh && Z.skeleton.frame !== de.render.frame && (Z.skeleton.update(), Z.skeleton.frame = de.render.frame), !Z.frustumCulled || Y.intersectsObject(Z))) {
					he && ie.setFromMatrixPosition(Z.matrixWorld)
						.applyMatrix4(ae);
					let ft = He.update(Z),
						xt = Z.material;
					if (Array.isArray(xt)) {
						let dt = ft.groups;
						for (let Ot = 0, St = dt.length; Ot < St; Ot++) {
							let Et = dt[Ot],
								$t = xt[Et.materialIndex];
							$t && $t.visible && h.push(Z, ft, $t, ye, ie.z, Et)
						}
					} else xt.visible && h.push(Z, ft, xt, ye, ie.z, null)
				}
			}
			let tt = Z.children;
			for (let ft = 0, xt = tt.length; ft < xt; ft++) Wt(tt[ft], fe, ye, he)
		}

		function Ze(Z, fe, ye, he) {
			let Me = Z.opaque,
				tt = Z.transmissive,
				ft = Z.transparent;
			f.setupLightsView(ye), tt.length > 0 && Fe(Me, fe, ye), he && se.viewport(C.copy(he)), Me.length > 0 && Ie(Me, fe, ye), tt.length > 0 && Ie(tt, fe, ye), ft.length > 0 && Ie(ft, fe, ye), se.buffers.depth.setTest(!0), se.buffers.depth.setMask(!0), se.buffers.color.setMask(!0), se.setPolygonOffset(!1)
		}

		function Fe(Z, fe, ye) {
			let he = Q.isWebGL2;
			$ === null && ($ = new Zr(1, 1, {
				generateMipmaps: !0,
				type: K.has("EXT_color_buffer_half_float") ? wl : bo,
				minFilter: Er,
				samples: he && s === !0 ? 4 : 0
			})), m.getDrawingBufferSize(oe), he ? $.setSize(oe.x, oe.y) : $.setSize(hu(oe.x), hu(oe.y));
			let Me = m.getRenderTarget();
			m.setRenderTarget($), m.clear();
			let tt = m.toneMapping;
			m.toneMapping = Yr, Ie(Z, fe, ye), m.toneMapping = tt, xe.updateMultisampleRenderTarget($), xe.updateRenderTargetMipmap($), m.setRenderTarget(Me)
		}

		function Ie(Z, fe, ye) {
			let he = fe.isScene === !0 ? fe.overrideMaterial : null;
			for (let Me = 0, tt = Z.length; Me < tt; Me++) {
				let ft = Z[Me],
					xt = ft.object,
					dt = ft.geometry,
					Ot = he === null ? ft.material : he,
					St = ft.group;
				xt.layers.test(ye.layers) && Ue(xt, fe, ye, dt, Ot, St)
			}
		}

		function Ue(Z, fe, ye, he, Me, tt) {
			Z.onBeforeRender(m, fe, ye, he, Me, tt), Z.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, Z.matrixWorld), Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix), Me.onBeforeRender(m, fe, ye, he, Z, tt), Me.transparent === !0 && Me.side === Bn ? (Me.side = Rn, Me.needsUpdate = !0, m.renderBufferDirect(ye, fe, he, Me, Z, tt), Me.side = _r, Me.needsUpdate = !0, m.renderBufferDirect(ye, fe, he, Me, Z, tt), Me.side = Bn) : m.renderBufferDirect(ye, fe, he, Me, Z, tt), Z.onAfterRender(m, fe, ye, he, Me, tt)
		}

		function je(Z, fe, ye) {
			fe.isScene !== !0 && (fe = U);
			let he = ue.get(Z),
				Me = f.state.lights,
				tt = f.state.shadowsArray,
				ft = Me.state.version,
				xt = Ve.getParameters(Z, Me.state, tt, fe, ye),
				dt = Ve.getProgramCacheKey(xt),
				Ot = he.programs;
			he.environment = Z.isMeshStandardMaterial ? fe.environment : null, he.fog = fe.fog, he.envMap = (Z.isMeshStandardMaterial ? De : Ee)
				.get(Z.envMap || he.environment), Ot === void 0 && (Z.addEventListener("dispose", re), Ot = new Map, he.programs = Ot);
			let St = Ot.get(dt);
			if (St !== void 0) {
				if (he.currentProgram === St && he.lightsStateVersion === ft) return Ke(Z, xt), St
			} else xt.uniforms = Ve.getUniforms(Z), Z.onBuild(ye, xt, m), Z.onBeforeCompile(xt, m), St = Ve.acquireProgram(xt, dt), Ot.set(dt, St), he.uniforms = xt.uniforms;
			let Et = he.uniforms;
			(!Z.isShaderMaterial && !Z.isRawShaderMaterial || Z.clipping === !0) && (Et.clippingPlanes = M.uniform), Ke(Z, xt), he.needsLights = Ri(Z), he.lightsStateVersion = ft, he.needsLights && (Et.ambientLightColor.value = Me.state.ambient, Et.lightProbe.value = Me.state.probe, Et.directionalLights.value = Me.state.directional, Et.directionalLightShadows.value = Me.state.directionalShadow, Et.spotLights.value = Me.state.spot, Et.spotLightShadows.value = Me.state.spotShadow, Et.rectAreaLights.value = Me.state.rectArea, Et.ltc_1.value = Me.state.rectAreaLTC1, Et.ltc_2.value = Me.state.rectAreaLTC2, Et.pointLights.value = Me.state.point, Et.pointLightShadows.value = Me.state.pointShadow, Et.hemisphereLights.value = Me.state.hemi, Et.directionalShadowMap.value = Me.state.directionalShadowMap, Et.directionalShadowMatrix.value = Me.state.directionalShadowMatrix, Et.spotShadowMap.value = Me.state.spotShadowMap, Et.spotLightMatrix.value = Me.state.spotLightMatrix, Et.spotLightMap.value = Me.state.spotLightMap, Et.pointShadowMap.value = Me.state.pointShadowMap, Et.pointShadowMatrix.value = Me.state.pointShadowMatrix);
			let $t = St.getUniforms(),
				Or = ca.seqWithValue($t.seq, Et);
			return he.currentProgram = St, he.uniformsList = Or, St
		}

		function Ke(Z, fe) {
			let ye = ue.get(Z);
			ye.outputEncoding = fe.outputEncoding, ye.instancing = fe.instancing, ye.skinning = fe.skinning, ye.morphTargets = fe.morphTargets, ye.morphNormals = fe.morphNormals, ye.morphColors = fe.morphColors, ye.morphTargetsCount = fe.morphTargetsCount, ye.numClippingPlanes = fe.numClippingPlanes, ye.numIntersection = fe.numClipIntersection, ye.vertexAlphas = fe.vertexAlphas, ye.vertexTangents = fe.vertexTangents, ye.toneMapping = fe.toneMapping
		}

		function jt(Z, fe, ye, he, Me) {
			fe.isScene !== !0 && (fe = U), xe.resetTextureUnits();
			let tt = fe.fog,
				ft = he.isMeshStandardMaterial ? fe.environment : null,
				xt = _ === null ? m.outputEncoding : _.isXRRenderTarget === !0 ? _.texture.encoding : Mo,
				dt = (he.isMeshStandardMaterial ? De : Ee)
				.get(he.envMap || ft),
				Ot = he.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4,
				St = !!he.normalMap && !!ye.attributes.tangent,
				Et = !!ye.morphAttributes.position,
				$t = !!ye.morphAttributes.normal,
				Or = !!ye.morphAttributes.color,
				hn = he.toneMapped ? m.toneMapping : Yr,
				bi = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color,
				ri = bi !== void 0 ? bi.length : 0,
				It = ue.get(he),
				fs = f.state.lights;
			if (J === !0 && (H === !0 || Z !== w)) {
				let jn = Z === w && he.id === y;
				M.setState(he, Z, jn)
			}
			let tn = !1;
			he.version === It.__version ? (It.needsLights && It.lightsStateVersion !== fs.state.version || It.outputEncoding !== xt || Me.isInstancedMesh && It.instancing === !1 || !Me.isInstancedMesh && It.instancing === !0 || Me.isSkinnedMesh && It.skinning === !1 || !Me.isSkinnedMesh && It.skinning === !0 || It.envMap !== dt || he.fog === !0 && It.fog !== tt || It.numClippingPlanes !== void 0 && (It.numClippingPlanes !== M.numPlanes || It.numIntersection !== M.numIntersection) || It.vertexAlphas !== Ot || It.vertexTangents !== St || It.morphTargets !== Et || It.morphNormals !== $t || It.morphColors !== Or || It.toneMapping !== hn || Q.isWebGL2 === !0 && It.morphTargetsCount !== ri) && (tn = !0) : (tn = !0, It.__version = he.version);
			let si = It.currentProgram;
			tn === !0 && (si = je(he, fe, Me));
			let gr = !1,
				io = !1,
				Fo = !1,
				En = si.getUniforms(),
				oi = It.uniforms;
			if (se.useProgram(si.program) && (gr = !0, io = !0, Fo = !0), he.id !== y && (y = he.id, io = !0), gr || w !== Z) {
				if (En.setValue(L, "projectionMatrix", Z.projectionMatrix), Q.logarithmicDepthBuffer && En.setValue(L, "logDepthBufFC", 2 / (Math.log(Z.far + 1) / Math.LN2)), w !== Z && (w = Z, io = !0, Fo = !0), he.isShaderMaterial || he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshStandardMaterial || he.envMap) {
					let jn = En.map.cameraPosition;
					jn !== void 0 && jn.setValue(L, ie.setFromMatrixPosition(Z.matrixWorld))
				}(he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial) && En.setValue(L, "isOrthographic", Z.isOrthographicCamera === !0), (he.isMeshPhongMaterial || he.isMeshToonMaterial || he.isMeshLambertMaterial || he.isMeshBasicMaterial || he.isMeshStandardMaterial || he.isShaderMaterial || he.isShadowMaterial || Me.isSkinnedMesh) && En.setValue(L, "viewMatrix", Z.matrixWorldInverse)
			}
			if (Me.isSkinnedMesh) {
				En.setOptional(L, Me, "bindMatrix"), En.setOptional(L, Me, "bindMatrixInverse");
				let jn = Me.skeleton;
				jn && (Q.floatVertexTextures ? (jn.boneTexture === null && jn.computeBoneTexture(), En.setValue(L, "boneTexture", jn.boneTexture, xe), En.setValue(L, "boneTextureSize", jn.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
			}
			let ol = ye.morphAttributes;
			if ((ol.position !== void 0 || ol.normal !== void 0 || ol.color !== void 0 && Q.isWebGL2 === !0) && W.update(Me, ye, he, si), (io || It.receiveShadow !== Me.receiveShadow) && (It.receiveShadow = Me.receiveShadow, En.setValue(L, "receiveShadow", Me.receiveShadow)), he.isMeshGouraudMaterial && he.envMap !== null && (oi.envMap.value = dt, oi.flipEnvMap.value = dt.isCubeTexture && dt.isRenderTargetTexture === !1 ? -1 : 1), io && (En.setValue(L, "toneMappingExposure", m.toneMappingExposure), It.needsLights && Ii(oi, Fo), tt && he.fog === !0 && ot.refreshFogUniforms(oi, tt), ot.refreshMaterialUniforms(oi, he, V, N, $), ca.upload(L, It.uniformsList, oi, xe)), he.isShaderMaterial && he.uniformsNeedUpdate === !0 && (ca.upload(L, It.uniformsList, oi, xe), he.uniformsNeedUpdate = !1), he.isSpriteMaterial && En.setValue(L, "center", Me.center), En.setValue(L, "modelViewMatrix", Me.modelViewMatrix), En.setValue(L, "normalMatrix", Me.normalMatrix), En.setValue(L, "modelMatrix", Me.matrixWorld), he.isShaderMaterial || he.isRawShaderMaterial) {
				let jn = he.uniformsGroups;
				for (let al = 0, dc = jn.length; al < dc; al++)
					if (Q.isWebGL2) {
						let pc = jn[al];
						pe.update(pc, si), pe.bind(pc, si)
					} else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
			}
			return si
		}

		function Ii(Z, fe) {
			Z.ambientLightColor.needsUpdate = fe, Z.lightProbe.needsUpdate = fe, Z.directionalLights.needsUpdate = fe, Z.directionalLightShadows.needsUpdate = fe, Z.pointLights.needsUpdate = fe, Z.pointLightShadows.needsUpdate = fe, Z.spotLights.needsUpdate = fe, Z.spotLightShadows.needsUpdate = fe, Z.rectAreaLights.needsUpdate = fe, Z.hemisphereLights.needsUpdate = fe
		}

		function Ri(Z) {
			return Z.isMeshLambertMaterial || Z.isMeshToonMaterial || Z.isMeshPhongMaterial || Z.isMeshStandardMaterial || Z.isShadowMaterial || Z.isShaderMaterial && Z.lights === !0
		}
		this.getActiveCubeFace = function() {
			return v
		}, this.getActiveMipmapLevel = function() {
			return x
		}, this.getRenderTarget = function() {
			return _
		}, this.setRenderTargetTextures = function(Z, fe, ye) {
			ue.get(Z.texture)
				.__webglTexture = fe, ue.get(Z.depthTexture)
				.__webglTexture = ye;
			let he = ue.get(Z);
			he.__hasExternalTextures = !0, he.__hasExternalTextures && (he.__autoAllocateDepthBuffer = ye === void 0, he.__autoAllocateDepthBuffer || K.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), he.__useRenderToTexture = !1))
		}, this.setRenderTargetFramebuffer = function(Z, fe) {
			let ye = ue.get(Z);
			ye.__webglFramebuffer = fe, ye.__useDefaultFramebuffer = fe === void 0
		}, this.setRenderTarget = function(Z, fe = 0, ye = 0) {
			_ = Z, v = fe, x = ye;
			let he = !0;
			if (Z) {
				let dt = ue.get(Z);
				dt.__useDefaultFramebuffer !== void 0 ? (se.bindFramebuffer(36160, null), he = !1) : dt.__webglFramebuffer === void 0 ? xe.setupRenderTarget(Z) : dt.__hasExternalTextures && xe.rebindTextures(Z, ue.get(Z.texture)
					.__webglTexture, ue.get(Z.depthTexture)
					.__webglTexture)
			}
			let Me = null,
				tt = !1,
				ft = !1;
			if (Z) {
				let dt = Z.texture;
				(dt.isData3DTexture || dt.isDataArrayTexture) && (ft = !0);
				let Ot = ue.get(Z)
					.__webglFramebuffer;
				Z.isWebGLCubeRenderTarget ? (Me = Ot[fe], tt = !0) : Q.isWebGL2 && Z.samples > 0 && xe.useMultisampledRTT(Z) === !1 ? Me = ue.get(Z)
					.__webglMultisampledFramebuffer : Me = Ot, C.copy(Z.viewport), S.copy(Z.scissor), b = Z.scissorTest
			} else C.copy(I)
				.multiplyScalar(V)
				.floor(), S.copy(q)
				.multiplyScalar(V)
				.floor(), b = B;
			if (se.bindFramebuffer(36160, Me) && Q.drawBuffers && he && se.drawBuffers(Z, Me), se.viewport(C), se.scissor(S), se.setScissorTest(b), tt) {
				let dt = ue.get(Z.texture);
				L.framebufferTexture2D(36160, 36064, 34069 + fe, dt.__webglTexture, ye)
			} else if (ft) {
				let dt = ue.get(Z.texture),
					Ot = fe || 0;
				L.framebufferTextureLayer(36160, 36064, dt.__webglTexture, ye || 0, Ot)
			}
			y = -1
		}, this.readRenderTargetPixels = function(Z, fe, ye, he, Me, tt, ft) {
			if (!(Z && Z.isWebGLRenderTarget)) {
				console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
				return
			}
			let xt = ue.get(Z)
				.__webglFramebuffer;
			if (Z.isWebGLCubeRenderTarget && ft !== void 0 && (xt = xt[ft]), xt) {
				se.bindFramebuffer(36160, xt);
				try {
					let dt = Z.texture,
						Ot = dt.format,
						St = dt.type;
					if (Ot !== ir && le.convert(Ot) !== L.getParameter(35739)) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
						return
					}
					let Et = St === wl && (K.has("EXT_color_buffer_half_float") || Q.isWebGL2 && K.has("EXT_color_buffer_float"));
					if (St !== bo && le.convert(St) !== L.getParameter(35738) && !(St === As && (Q.isWebGL2 || K.has("OES_texture_float") || K.has("WEBGL_color_buffer_float"))) && !Et) {
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
						return
					}
					fe >= 0 && fe <= Z.width - he && ye >= 0 && ye <= Z.height - Me && L.readPixels(fe, ye, he, Me, le.convert(Ot), le.convert(St), tt)
				} finally {
					let dt = _ !== null ? ue.get(_)
						.__webglFramebuffer : null;
					se.bindFramebuffer(36160, dt)
				}
			}
		}, this.copyFramebufferToTexture = function(Z, fe, ye = 0) {
			let he = Math.pow(2, -ye),
				Me = Math.floor(fe.image.width * he),
				tt = Math.floor(fe.image.height * he);
			xe.setTexture2D(fe, 0), L.copyTexSubImage2D(3553, ye, 0, 0, Z.x, Z.y, Me, tt), se.unbindTexture()
		}, this.copyTextureToTexture = function(Z, fe, ye, he = 0) {
			let Me = fe.image.width,
				tt = fe.image.height,
				ft = le.convert(ye.format),
				xt = le.convert(ye.type);
			xe.setTexture2D(ye, 0), L.pixelStorei(37440, ye.flipY), L.pixelStorei(37441, ye.premultiplyAlpha), L.pixelStorei(3317, ye.unpackAlignment), fe.isDataTexture ? L.texSubImage2D(3553, he, Z.x, Z.y, Me, tt, ft, xt, fe.image.data) : fe.isCompressedTexture ? L.compressedTexSubImage2D(3553, he, Z.x, Z.y, fe.mipmaps[0].width, fe.mipmaps[0].height, ft, fe.mipmaps[0].data) : L.texSubImage2D(3553, he, Z.x, Z.y, ft, xt, fe.image), he === 0 && ye.generateMipmaps && L.generateMipmap(3553), se.unbindTexture()
		}, this.copyTextureToTexture3D = function(Z, fe, ye, he, Me = 0) {
			if (m.isWebGL1Renderer) {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
				return
			}
			let tt = Z.max.x - Z.min.x + 1,
				ft = Z.max.y - Z.min.y + 1,
				xt = Z.max.z - Z.min.z + 1,
				dt = le.convert(he.format),
				Ot = le.convert(he.type),
				St;
			if (he.isData3DTexture) xe.setTexture3D(he, 0), St = 32879;
			else if (he.isDataArrayTexture) xe.setTexture2DArray(he, 0), St = 35866;
			else {
				console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
				return
			}
			L.pixelStorei(37440, he.flipY), L.pixelStorei(37441, he.premultiplyAlpha), L.pixelStorei(3317, he.unpackAlignment);
			let Et = L.getParameter(3314),
				$t = L.getParameter(32878),
				Or = L.getParameter(3316),
				hn = L.getParameter(3315),
				bi = L.getParameter(32877),
				ri = ye.isCompressedTexture ? ye.mipmaps[0] : ye.image;
			L.pixelStorei(3314, ri.width), L.pixelStorei(32878, ri.height), L.pixelStorei(3316, Z.min.x), L.pixelStorei(3315, Z.min.y), L.pixelStorei(32877, Z.min.z), ye.isDataTexture || ye.isData3DTexture ? L.texSubImage3D(St, Me, fe.x, fe.y, fe.z, tt, ft, xt, dt, Ot, ri.data) : ye.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), L.compressedTexSubImage3D(St, Me, fe.x, fe.y, fe.z, tt, ft, xt, dt, ri.data)) : L.texSubImage3D(St, Me, fe.x, fe.y, fe.z, tt, ft, xt, dt, Ot, ri), L.pixelStorei(3314, Et), L.pixelStorei(32878, $t), L.pixelStorei(3316, Or), L.pixelStorei(3315, hn), L.pixelStorei(32877, bi), Me === 0 && he.generateMipmaps && L.generateMipmap(St), se.unbindTexture()
		}, this.initTexture = function(Z) {
			Z.isCubeTexture ? xe.setTextureCube(Z, 0) : Z.isData3DTexture ? xe.setTexture3D(Z, 0) : Z.isDataArrayTexture ? xe.setTexture2DArray(Z, 0) : xe.setTexture2D(Z, 0), se.unbindTexture()
		}, this.resetState = function() {
			v = 0, x = 0, _ = null, se.reset(), ee.reset()
		}, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}
	var Ld = class extends kl {};
	Ld.prototype.isWebGL1Renderer = !0;
	var wr = class extends yt {
		constructor() {
			super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
				detail: this
			}))
		}
		copy(e, t) {
			return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
		}
		toJSON(e) {
			let t = super.toJSON(e);
			return this.fog !== null && (t.object.fog = this.fog.toJSON()), t
		}
		get autoUpdate() {
			return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate
		}
		set autoUpdate(e) {
			console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = e
		}
	};
	var D0 = new ne,
		O0 = new wt,
		k0 = new wt,
		mS = new ne,
		F0 = new ke,
		va = class extends zt {
			constructor(e, t) {
				super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ke, this.bindMatrixInverse = new ke
			}
			copy(e, t) {
				return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, this
			}
			bind(e, t) {
				this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t)
					.invert()
			}
			pose() {
				this.skeleton.pose()
			}
			normalizeSkinWeights() {
				let e = new wt,
					t = this.geometry.attributes.skinWeight;
				for (let n = 0, i = t.count; n < i; n++) {
					e.fromBufferAttribute(t, n);
					let s = 1 / e.manhattanLength();
					s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
				}
			}
			updateMatrixWorld(e) {
				super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld)
					.invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix)
					.invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
			}
			boneTransform(e, t) {
				let n = this.skeleton,
					i = this.geometry;
				O0.fromBufferAttribute(i.attributes.skinIndex, e), k0.fromBufferAttribute(i.attributes.skinWeight, e), D0.copy(t)
					.applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
				for (let s = 0; s < 4; s++) {
					let o = k0.getComponent(s);
					if (o !== 0) {
						let a = O0.getComponent(s);
						F0.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(mS.copy(D0)
							.applyMatrix4(F0), o)
					}
				}
				return t.applyMatrix4(this.bindMatrixInverse)
			}
		},
		Ps = class extends yt {
			constructor() {
				super(), this.isBone = !0, this.type = "Bone"
			}
		},
		xa = class extends Pn {
			constructor(e = null, t = 1, n = 1, i, s, o, a, c, l = yn, u = yn, h, f) {
				super(null, o, a, c, l, u, i, s, h, f), this.isDataTexture = !0, this.image = {
					data: e,
					width: t,
					height: n
				}, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
			}
		},
		U0 = new ke,
		gS = new ke,
		Ls = class {
			constructor(e = [], t = []) {
				this.uuid = Gs(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
			}
			init() {
				let e = this.bones,
					t = this.boneInverses;
				if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
				else if (e.length !== t.length) {
					console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
					for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new ke)
				}
			}
			calculateInverses() {
				this.boneInverses.length = 0;
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = new ke;
					this.bones[e] && n.copy(this.bones[e].matrixWorld)
						.invert(), this.boneInverses.push(n)
				}
			}
			pose() {
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = this.bones[e];
					n && n.matrixWorld.copy(this.boneInverses[e])
						.invert()
				}
				for (let e = 0, t = this.bones.length; e < t; e++) {
					let n = this.bones[e];
					n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld)
						.invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
				}
			}
			update() {
				let e = this.bones,
					t = this.boneInverses,
					n = this.boneMatrices,
					i = this.boneTexture;
				for (let s = 0, o = e.length; s < o; s++) {
					let a = e[s] ? e[s].matrixWorld : gS;
					U0.multiplyMatrices(a, t[s]), U0.toArray(n, s * 16)
				}
				i !== null && (i.needsUpdate = !0)
			}
			clone() {
				return new Ls(this.bones, this.boneInverses)
			}
			computeBoneTexture() {
				let e = Math.sqrt(this.bones.length * 4);
				e = sv(e), e = Math.max(e, 4);
				let t = new Float32Array(e * e * 4);
				t.set(this.boneMatrices);
				let n = new xa(t, e, e, ir, As);
				return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
			}
			getBoneByName(e) {
				for (let t = 0, n = this.bones.length; t < n; t++) {
					let i = this.bones[t];
					if (i.name === e) return i
				}
			}
			dispose() {
				this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
			}
			fromJSON(e, t) {
				this.uuid = e.uuid;
				for (let n = 0, i = e.bones.length; n < i; n++) {
					let s = e.bones[n],
						o = t[s];
					o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Ps), this.bones.push(o), this.boneInverses.push(new ke()
						.fromArray(e.boneInverses[n]))
				}
				return this.init(), this
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.5,
						type: "Skeleton",
						generator: "Skeleton.toJSON"
					},
					bones: [],
					boneInverses: []
				};
				e.uuid = this.uuid;
				let t = this.bones,
					n = this.boneInverses;
				for (let i = 0, s = t.length; i < s; i++) {
					let o = t[i];
					e.bones.push(o.uuid);
					let a = n[i];
					e.boneInverses.push(a.toArray())
				}
				return e
			}
		};
	var Si = class extends rr {
			constructor(e) {
				super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Xe(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
			}
		},
		B0 = new ne,
		G0 = new ne,
		V0 = new ke,
		ud = new pa,
		Qc = new Kr,
		Qr = class extends yt {
			constructor(e = new bt, t = new Si) {
				super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
			}
			computeLineDistances() {
				let e = this.geometry;
				if (e.index === null) {
					let t = e.attributes.position,
						n = [0];
					for (let i = 1, s = t.count; i < s; i++) B0.fromBufferAttribute(t, i - 1), G0.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += B0.distanceTo(G0);
					e.setAttribute("lineDistance", new ze(n, 1))
				} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.matrixWorld,
					s = e.params.Line.threshold,
					o = n.drawRange;
				if (n.boundingSphere === null && n.computeBoundingSphere(), Qc.copy(n.boundingSphere), Qc.applyMatrix4(i), Qc.radius += s, e.ray.intersectsSphere(Qc) === !1) return;
				V0.copy(i)
					.invert(), ud.copy(e.ray)
					.applyMatrix4(V0);
				let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					c = a * a,
					l = new ne,
					u = new ne,
					h = new ne,
					f = new ne,
					p = this.isLineSegments ? 2 : 1,
					g = n.index,
					d = n.attributes.position;
				if (g !== null) {
					let v = Math.max(0, o.start),
						x = Math.min(g.count, o.start + o.count);
					for (let _ = v, y = x - 1; _ < y; _ += p) {
						let w = g.getX(_),
							C = g.getX(_ + 1);
						if (l.fromBufferAttribute(d, w), u.fromBufferAttribute(d, C), ud.distanceSqToSegment(l, u, f, h) > c) continue;
						f.applyMatrix4(this.matrixWorld);
						let b = e.ray.origin.distanceTo(f);
						b < e.near || b > e.far || t.push({
							distance: b,
							point: h.clone()
								.applyMatrix4(this.matrixWorld),
							index: _,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				} else {
					let v = Math.max(0, o.start),
						x = Math.min(d.count, o.start + o.count);
					for (let _ = v, y = x - 1; _ < y; _ += p) {
						if (l.fromBufferAttribute(d, _), u.fromBufferAttribute(d, _ + 1), ud.distanceSqToSegment(l, u, f, h) > c) continue;
						f.applyMatrix4(this.matrixWorld);
						let C = e.ray.origin.distanceTo(f);
						C < e.near || C > e.far || t.push({
							distance: C,
							point: h.clone()
								.applyMatrix4(this.matrixWorld),
							index: _,
							face: null,
							faceIndex: null,
							object: this
						})
					}
				}
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
		},
		z0 = new ne,
		H0 = new ne,
		Ns = class extends Qr {
			constructor(e, t) {
				super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
			}
			computeLineDistances() {
				let e = this.geometry;
				if (e.index === null) {
					let t = e.attributes.position,
						n = [];
					for (let i = 0, s = t.count; i < s; i += 2) z0.fromBufferAttribute(t, i), H0.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + z0.distanceTo(H0);
					e.setAttribute("lineDistance", new ze(n, 1))
				} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
				return this
			}
		};
	var Il = class extends rr {
			constructor(e) {
				super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Xe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
			}
			copy(e) {
				return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
			}
		},
		W0 = new ke,
		Nd = new pa,
		eu = new Kr,
		tu = new ne,
		vu = class extends yt {
			constructor(e = new bt, t = new Il) {
				super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
			}
			copy(e, t) {
				return super.copy(e, t), this.material = e.material, this.geometry = e.geometry, this
			}
			raycast(e, t) {
				let n = this.geometry,
					i = this.matrixWorld,
					s = e.params.Points.threshold,
					o = n.drawRange;
				if (n.boundingSphere === null && n.computeBoundingSphere(), eu.copy(n.boundingSphere), eu.applyMatrix4(i), eu.radius += s, e.ray.intersectsSphere(eu) === !1) return;
				W0.copy(i)
					.invert(), Nd.copy(e.ray)
					.applyMatrix4(W0);
				let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					c = a * a,
					l = n.index,
					h = n.attributes.position;
				if (l !== null) {
					let f = Math.max(0, o.start),
						p = Math.min(l.count, o.start + o.count);
					for (let g = f, m = p; g < m; g++) {
						let d = l.getX(g);
						tu.fromBufferAttribute(h, d), j0(tu, d, c, i, e, t, this)
					}
				} else {
					let f = Math.max(0, o.start),
						p = Math.min(h.count, o.start + o.count);
					for (let g = f, m = p; g < m; g++) tu.fromBufferAttribute(h, g), j0(tu, g, c, i, e, t, this)
				}
			}
			updateMorphTargets() {
				let t = this.geometry.morphAttributes,
					n = Object.keys(t);
				if (n.length > 0) {
					let i = t[n[0]];
					if (i !== void 0) {
						this.morphTargetInfluences = [], this.morphTargetDictionary = {};
						for (let s = 0, o = i.length; s < o; s++) {
							let a = i[s].name || String(s);
							this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
						}
					}
				}
			}
		};

	function j0(r, e, t, n, i, s, o) {
		let a = Nd.distanceSqToPoint(r);
		if (a < t) {
			let c = new ne;
			Nd.closestPointToPoint(r, c), c.applyMatrix4(n);
			let l = i.ray.origin.distanceTo(c);
			if (l < i.near || l > i.far) return;
			s.push({
				distance: l,
				distanceToRay: Math.sqrt(a),
				point: c,
				index: e,
				face: null,
				object: o
			})
		}
	}
	var Rl = class {
			constructor() {
				this.type = "Curve", this.arcLengthDivisions = 200
			}
			getPoint() {
				return console.warn("THREE.Curve: .getPoint() not implemented."), null
			}
			getPointAt(e, t) {
				let n = this.getUtoTmapping(e);
				return this.getPoint(n, t)
			}
			getPoints(e = 5) {
				let t = [];
				for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
				return t
			}
			getSpacedPoints(e = 5) {
				let t = [];
				for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
				return t
			}
			getLength() {
				let e = this.getLengths();
				return e[e.length - 1]
			}
			getLengths(e = this.arcLengthDivisions) {
				if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
				this.needsUpdate = !1;
				let t = [],
					n, i = this.getPoint(0),
					s = 0;
				t.push(0);
				for (let o = 1; o <= e; o++) n = this.getPoint(o / e), s += n.distanceTo(i), t.push(s), i = n;
				return this.cacheArcLengths = t, t
			}
			updateArcLengths() {
				this.needsUpdate = !0, this.getLengths()
			}
			getUtoTmapping(e, t) {
				let n = this.getLengths(),
					i = 0,
					s = n.length,
					o;
				t ? o = t : o = e * n[s - 1];
				let a = 0,
					c = s - 1,
					l;
				for (; a <= c;)
					if (i = Math.floor(a + (c - a) / 2), l = n[i] - o, l < 0) a = i + 1;
					else if (l > 0) c = i - 1;
				else {
					c = i;
					break
				}
				if (i = c, n[i] === o) return i / (s - 1);
				let u = n[i],
					f = n[i + 1] - u,
					p = (o - u) / f;
				return (i + p) / (s - 1)
			}
			getTangent(e, t) {
				let i = e - 1e-4,
					s = e + 1e-4;
				i < 0 && (i = 0), s > 1 && (s = 1);
				let o = this.getPoint(i),
					a = this.getPoint(s),
					c = t || (o.isVector2 ? new st : new ne);
				return c.copy(a)
					.sub(o)
					.normalize(), c
			}
			getTangentAt(e, t) {
				let n = this.getUtoTmapping(e);
				return this.getTangent(n, t)
			}
			computeFrenetFrames(e, t) {
				let n = new ne,
					i = [],
					s = [],
					o = [],
					a = new ne,
					c = new ke;
				for (let p = 0; p <= e; p++) {
					let g = p / e;
					i[p] = this.getTangentAt(g, new ne)
				}
				s[0] = new ne, o[0] = new ne;
				let l = Number.MAX_VALUE,
					u = Math.abs(i[0].x),
					h = Math.abs(i[0].y),
					f = Math.abs(i[0].z);
				u <= l && (l = u, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), f <= l && n.set(0, 0, 1), a.crossVectors(i[0], n)
					.normalize(), s[0].crossVectors(i[0], a), o[0].crossVectors(i[0], s[0]);
				for (let p = 1; p <= e; p++) {
					if (s[p] = s[p - 1].clone(), o[p] = o[p - 1].clone(), a.crossVectors(i[p - 1], i[p]), a.length() > Number.EPSILON) {
						a.normalize();
						let g = Math.acos(Kn(i[p - 1].dot(i[p]), -1, 1));
						s[p].applyMatrix4(c.makeRotationAxis(a, g))
					}
					o[p].crossVectors(i[p], s[p])
				}
				if (t === !0) {
					let p = Math.acos(Kn(s[0].dot(s[e]), -1, 1));
					p /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (p = -p);
					for (let g = 1; g <= e; g++) s[g].applyMatrix4(c.makeRotationAxis(i[g], p * g)), o[g].crossVectors(i[g], s[g])
				}
				return {
					tangents: i,
					normals: s,
					binormals: o
				}
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			copy(e) {
				return this.arcLengthDivisions = e.arcLengthDivisions, this
			}
			toJSON() {
				let e = {
					metadata: {
						version: 4.5,
						type: "Curve",
						generator: "Curve.toJSON"
					}
				};
				return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
			}
			fromJSON(e) {
				return this.arcLengthDivisions = e.arcLengthDivisions, this
			}
		},
		xu = class extends Rl {
			constructor(e = 0, t = 0, n = 1, i = 1, s = 0, o = Math.PI * 2, a = !1, c = 0) {
				super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = c
			}
			getPoint(e, t) {
				let n = t || new st,
					i = Math.PI * 2,
					s = this.aEndAngle - this.aStartAngle,
					o = Math.abs(s) < Number.EPSILON;
				for (; s < 0;) s += i;
				for (; s > i;) s -= i;
				s < Number.EPSILON && (o ? s = 0 : s = i), this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
				let a = this.aStartAngle + e * s,
					c = this.aX + this.xRadius * Math.cos(a),
					l = this.aY + this.yRadius * Math.sin(a);
				if (this.aRotation !== 0) {
					let u = Math.cos(this.aRotation),
						h = Math.sin(this.aRotation),
						f = c - this.aX,
						p = l - this.aY;
					c = f * u - p * h + this.aX, l = f * h + p * u + this.aY
				}
				return n.set(c, l)
			}
			copy(e) {
				return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}
			toJSON() {
				let e = super.toJSON();
				return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
			}
			fromJSON(e) {
				return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
			}
		};
	var So = class extends bt {
			constructor(e = 1, t = 1, n = 1, i = 8, s = 1, o = !1, a = 0, c = Math.PI * 2) {
				super(), this.type = "CylinderGeometry", this.parameters = {
					radiusTop: e,
					radiusBottom: t,
					height: n,
					radialSegments: i,
					heightSegments: s,
					openEnded: o,
					thetaStart: a,
					thetaLength: c
				};
				let l = this;
				i = Math.floor(i), s = Math.floor(s);
				let u = [],
					h = [],
					f = [],
					p = [],
					g = 0,
					m = [],
					d = n / 2,
					v = 0;
				x(), o === !1 && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(u), this.setAttribute("position", new ze(h, 3)), this.setAttribute("normal", new ze(f, 3)), this.setAttribute("uv", new ze(p, 2));

				function x() {
					let y = new ne,
						w = new ne,
						C = 0,
						S = (t - e) / n;
					for (let b = 0; b <= s; b++) {
						let T = [],
							N = b / s,
							V = N * (t - e) + e;
						for (let O = 0; O <= i; O++) {
							let k = O / i,
								I = k * c + a,
								q = Math.sin(I),
								B = Math.cos(I);
							w.x = V * q, w.y = -N * n + d, w.z = V * B, h.push(w.x, w.y, w.z), y.set(q, S, B)
								.normalize(), f.push(y.x, y.y, y.z), p.push(k, 1 - N), T.push(g++)
						}
						m.push(T)
					}
					for (let b = 0; b < i; b++)
						for (let T = 0; T < s; T++) {
							let N = m[T][b],
								V = m[T + 1][b],
								O = m[T + 1][b + 1],
								k = m[T][b + 1];
							u.push(N, V, k), u.push(V, O, k), C += 6
						}
					l.addGroup(v, C, 0), v += C
				}

				function _(y) {
					let w = g,
						C = new st,
						S = new ne,
						b = 0,
						T = y === !0 ? e : t,
						N = y === !0 ? 1 : -1;
					for (let O = 1; O <= i; O++) h.push(0, d * N, 0), f.push(0, N, 0), p.push(.5, .5), g++;
					let V = g;
					for (let O = 0; O <= i; O++) {
						let I = O / i * c + a,
							q = Math.cos(I),
							B = Math.sin(I);
						S.x = T * B, S.y = d * N, S.z = T * q, h.push(S.x, S.y, S.z), f.push(0, N, 0), C.x = q * .5 + .5, C.y = B * .5 * N + .5, p.push(C.x, C.y), g++
					}
					for (let O = 0; O < i; O++) {
						let k = w + O,
							I = V + O;
						y === !0 ? u.push(I, I + 1, k) : u.push(I + 1, I, k), b += 3
					}
					l.addGroup(v, b, y === !0 ? 1 : 2), v += b
				}
			}
			static fromJSON(e) {
				return new So(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
			}
		},
		ya = class extends So {
			constructor(e = 1, t = 1, n = 8, i = 1, s = !1, o = 0, a = Math.PI * 2) {
				super(0, e, t, n, i, s, o, a), this.type = "ConeGeometry", this.parameters = {
					radius: e,
					height: t,
					radialSegments: n,
					heightSegments: i,
					openEnded: s,
					thetaStart: o,
					thetaLength: a
				}
			}
			static fromJSON(e) {
				return new ya(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
			}
		};
	var nu = new ne,
		iu = new ne,
		hd = new ne,
		ru = new Di,
		yu = class extends bt {
			constructor(e = null, t = 1) {
				if (super(), this.type = "EdgesGeometry", this.parameters = {
					geometry: e,
					thresholdAngle: t
				}, e !== null) {
					let i = Math.pow(10, 4),
						s = Math.cos(la * t),
						o = e.getIndex(),
						a = e.getAttribute("position"),
						c = o ? o.count : a.count,
						l = [0, 0, 0],
						u = ["a", "b", "c"],
						h = new Array(3),
						f = {},
						p = [];
					for (let g = 0; g < c; g += 3) {
						o ? (l[0] = o.getX(g), l[1] = o.getX(g + 1), l[2] = o.getX(g + 2)) : (l[0] = g, l[1] = g + 1, l[2] = g + 2);
						let {
							a: m,
							b: d,
							c: v
						} = ru;
						if (m.fromBufferAttribute(a, l[0]), d.fromBufferAttribute(a, l[1]), v.fromBufferAttribute(a, l[2]), ru.getNormal(hd), h[0] = `${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`, h[1] = `${Math.round(d.x*i)},${Math.round(d.y*i)},${Math.round(d.z*i)}`, h[2] = `${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`, !(h[0] === h[1] || h[1] === h[2] || h[2] === h[0]))
							for (let x = 0; x < 3; x++) {
								let _ = (x + 1) % 3,
									y = h[x],
									w = h[_],
									C = ru[u[x]],
									S = ru[u[_]],
									b = `${y}_${w}`,
									T = `${w}_${y}`;
								T in f && f[T] ? (hd.dot(f[T].normal) <= s && (p.push(C.x, C.y, C.z), p.push(S.x, S.y, S.z)), f[T] = null) : b in f || (f[b] = {
									index0: l[x],
									index1: l[_],
									normal: hd.clone()
								})
							}
					}
					for (let g in f)
						if (f[g]) {
							let {
								index0: m,
								index1: d
							} = f[g];
							nu.fromBufferAttribute(a, m), iu.fromBufferAttribute(a, d), p.push(nu.x, nu.y, nu.z), p.push(iu.x, iu.y, iu.z)
						} this.setAttribute("position", new ze(p, 3))
				}
			}
		};
	var vS = {
		triangulate: function(r, e, t = 2) {
			let n = e && e.length,
				i = n ? e[0] * t : r.length,
				s = dv(r, 0, i, t, !0),
				o = [];
			if (!s || s.next === s.prev) return o;
			let a, c, l, u, h, f, p;
			if (n && (s = MS(r, e, s, t)), r.length > 80 * t) {
				a = l = r[0], c = u = r[1];
				for (let g = t; g < i; g += t) h = r[g], f = r[g + 1], h < a && (a = h), f < c && (c = f), h > l && (l = h), f > u && (u = f);
				p = Math.max(l - a, u - c), p = p !== 0 ? 1 / p : 0
			}
			return Pl(s, o, t, a, c, p), o
		}
	};

	function dv(r, e, t, n, i) {
		let s, o;
		if (i === NS(r, e, t, n) > 0)
			for (s = e; s < t; s += n) o = q0(s, r[s], r[s + 1], o);
		else
			for (s = t - n; s >= e; s -= n) o = q0(s, r[s], r[s + 1], o);
		return o && Ru(o, o.next) && (Nl(o), o = o.next), o
	}

	function Ds(r, e) {
		if (!r) return r;
		e || (e = r);
		let t = r,
			n;
		do
			if (n = !1, !t.steiner && (Ru(t, t.next) || rn(t.prev, t, t.next) === 0)) {
				if (Nl(t), t = e = t.prev, t === t.next) break;
				n = !0
			} else t = t.next; while (n || t !== e);
		return e
	}

	function Pl(r, e, t, n, i, s, o) {
		if (!r) return;
		!o && s && CS(r, n, i, s);
		let a = r,
			c, l;
		for (; r.prev !== r.next;) {
			if (c = r.prev, l = r.next, s ? yS(r, n, i, s) : xS(r)) {
				e.push(c.i / t), e.push(r.i / t), e.push(l.i / t), Nl(r), r = l.next, a = l.next;
				continue
			}
			if (r = l, r === a) {
				o ? o === 1 ? (r = _S(Ds(r), e, t), Pl(r, e, t, n, i, s, 2)) : o === 2 && bS(r, e, t, n, i, s) : Pl(Ds(r), e, t, n, i, s, 1);
				break
			}
		}
	}

	function xS(r) {
		let e = r.prev,
			t = r,
			n = r.next;
		if (rn(e, t, n) >= 0) return !1;
		let i = r.next.next;
		for (; i !== r.prev;) {
			if (sa(e.x, e.y, t.x, t.y, n.x, n.y, i.x, i.y) && rn(i.prev, i, i.next) >= 0) return !1;
			i = i.next
		}
		return !0
	}

	function yS(r, e, t, n) {
		let i = r.prev,
			s = r,
			o = r.next;
		if (rn(i, s, o) >= 0) return !1;
		let a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
			c = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
			l = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
			u = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
			h = Dd(a, c, e, t, n),
			f = Dd(l, u, e, t, n),
			p = r.prevZ,
			g = r.nextZ;
		for (; p && p.z >= h && g && g.z <= f;) {
			if (p !== r.prev && p !== r.next && sa(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && rn(p.prev, p, p.next) >= 0 || (p = p.prevZ, g !== r.prev && g !== r.next && sa(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) && rn(g.prev, g, g.next) >= 0)) return !1;
			g = g.nextZ
		}
		for (; p && p.z >= h;) {
			if (p !== r.prev && p !== r.next && sa(i.x, i.y, s.x, s.y, o.x, o.y, p.x, p.y) && rn(p.prev, p, p.next) >= 0) return !1;
			p = p.prevZ
		}
		for (; g && g.z <= f;) {
			if (g !== r.prev && g !== r.next && sa(i.x, i.y, s.x, s.y, o.x, o.y, g.x, g.y) && rn(g.prev, g, g.next) >= 0) return !1;
			g = g.nextZ
		}
		return !0
	}

	function _S(r, e, t) {
		let n = r;
		do {
			let i = n.prev,
				s = n.next.next;
			!Ru(i, s) && pv(i, n, n.next, s) && Ll(i, s) && Ll(s, i) && (e.push(i.i / t), e.push(n.i / t), e.push(s.i / t), Nl(n), Nl(n.next), n = r = s), n = n.next
		} while (n !== r);
		return Ds(n)
	}

	function bS(r, e, t, n, i, s) {
		let o = r;
		do {
			let a = o.next.next;
			for (; a !== o.prev;) {
				if (o.i !== a.i && RS(o, a)) {
					let c = mv(o, a);
					o = Ds(o, o.next), c = Ds(c, c.next), Pl(o, e, t, n, i, s), Pl(c, e, t, n, i, s);
					return
				}
				a = a.next
			}
			o = o.next
		} while (o !== r)
	}

	function MS(r, e, t, n) {
		let i = [],
			s, o, a, c, l;
		for (s = 0, o = e.length; s < o; s++) a = e[s] * n, c = s < o - 1 ? e[s + 1] * n : r.length, l = dv(r, a, c, n, !1), l === l.next && (l.steiner = !0), i.push(IS(l));
		for (i.sort(wS), s = 0; s < i.length; s++) TS(i[s], t), t = Ds(t, t.next);
		return t
	}

	function wS(r, e) {
		return r.x - e.x
	}

	function TS(r, e) {
		if (e = SS(r, e), e) {
			let t = mv(e, r);
			Ds(e, e.next), Ds(t, t.next)
		}
	}

	function SS(r, e) {
		let t = e,
			n = r.x,
			i = r.y,
			s = -1 / 0,
			o;
		do {
			if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
				let f = t.x + (i - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
				if (f <= n && f > s) {
					if (s = f, f === n) {
						if (i === t.y) return t;
						if (i === t.next.y) return t.next
					}
					o = t.x < t.next.x ? t : t.next
				}
			}
			t = t.next
		} while (t !== e);
		if (!o) return null;
		if (n === s) return o;
		let a = o,
			c = o.x,
			l = o.y,
			u = 1 / 0,
			h;
		t = o;
		do n >= t.x && t.x >= c && n !== t.x && sa(i < l ? n : s, i, c, l, i < l ? s : n, i, t.x, t.y) && (h = Math.abs(i - t.y) / (n - t.x), Ll(t, r) && (h < u || h === u && (t.x > o.x || t.x === o.x && ES(o, t))) && (o = t, u = h)), t = t.next; while (t !== a);
		return o
	}

	function ES(r, e) {
		return rn(r.prev, r, e.prev) < 0 && rn(e.next, r, r.next) < 0
	}

	function CS(r, e, t, n) {
		let i = r;
		do i.z === null && (i.z = Dd(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== r);
		i.prevZ.nextZ = null, i.prevZ = null, AS(i)
	}

	function AS(r) {
		let e, t, n, i, s, o, a, c, l = 1;
		do {
			for (t = r, r = null, s = null, o = 0; t;) {
				for (o++, n = t, a = 0, e = 0; e < l && (a++, n = n.nextZ, !!n); e++);
				for (c = l; a > 0 || c > 0 && n;) a !== 0 && (c === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, c--), s ? s.nextZ = i : r = i, i.prevZ = s, s = i;
				t = n
			}
			s.nextZ = null, l *= 2
		} while (o > 1);
		return r
	}

	function Dd(r, e, t, n, i) {
		return r = 32767 * (r - t) * i, e = 32767 * (e - n) * i, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1
	}

	function IS(r) {
		let e = r,
			t = r;
		do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== r);
		return t
	}

	function sa(r, e, t, n, i, s, o, a) {
		return (i - o) * (e - a) - (r - o) * (s - a) >= 0 && (r - o) * (n - a) - (t - o) * (e - a) >= 0 && (t - o) * (s - a) - (i - o) * (n - a) >= 0
	}

	function RS(r, e) {
		return r.next.i !== e.i && r.prev.i !== e.i && !PS(r, e) && (Ll(r, e) && Ll(e, r) && LS(r, e) && (rn(r.prev, r, e.prev) || rn(r, e.prev, e)) || Ru(r, e) && rn(r.prev, r, r.next) > 0 && rn(e.prev, e, e.next) > 0)
	}

	function rn(r, e, t) {
		return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
	}

	function Ru(r, e) {
		return r.x === e.x && r.y === e.y
	}

	function pv(r, e, t, n) {
		let i = ou(rn(r, e, t)),
			s = ou(rn(r, e, n)),
			o = ou(rn(t, n, r)),
			a = ou(rn(t, n, e));
		return !!(i !== s && o !== a || i === 0 && su(r, t, e) || s === 0 && su(r, n, e) || o === 0 && su(t, r, n) || a === 0 && su(t, e, n))
	}

	function su(r, e, t) {
		return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
	}

	function ou(r) {
		return r > 0 ? 1 : r < 0 ? -1 : 0
	}

	function PS(r, e) {
		let t = r;
		do {
			if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && pv(t, t.next, r, e)) return !0;
			t = t.next
		} while (t !== r);
		return !1
	}

	function Ll(r, e) {
		return rn(r.prev, r, r.next) < 0 ? rn(r, e, r.next) >= 0 && rn(r, r.prev, e) >= 0 : rn(r, e, r.prev) < 0 || rn(r, r.next, e) < 0
	}

	function LS(r, e) {
		let t = r,
			n = !1,
			i = (r.x + e.x) / 2,
			s = (r.y + e.y) / 2;
		do t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next; while (t !== r);
		return n
	}

	function mv(r, e) {
		let t = new Od(r.i, r.x, r.y),
			n = new Od(e.i, e.x, e.y),
			i = r.next,
			s = e.prev;
		return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n
	}

	function q0(r, e, t, n) {
		let i = new Od(r, e, t);
		return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i
	}

	function Nl(r) {
		r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ)
	}

	function Od(r, e, t) {
		this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
	}

	function NS(r, e, t, n) {
		let i = 0;
		for (let s = e, o = t - n; s < t; s += n) i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]), o = s;
		return i
	}
	var _a = class {
		static area(e) {
			let t = e.length,
				n = 0;
			for (let i = t - 1, s = 0; s < t; i = s++) n += e[i].x * e[s].y - e[s].x * e[i].y;
			return n * .5
		}
		static isClockWise(e) {
			return _a.area(e) < 0
		}
		static triangulateShape(e, t) {
			let n = [],
				i = [],
				s = [];
			X0(e), Y0(n, e);
			let o = e.length;
			t.forEach(X0);
			for (let c = 0; c < t.length; c++) i.push(o), o += t[c].length, Y0(n, t[c]);
			let a = vS.triangulate(n, i);
			for (let c = 0; c < a.length; c += 3) s.push(a.slice(c, c + 3));
			return s
		}
	};

	function X0(r) {
		let e = r.length;
		e > 2 && r[e - 1].equals(r[0]) && r.pop()
	}

	function Y0(r, e) {
		for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y)
	}
	var Os = class extends bt {
		constructor(e = 1, t = 32, n = 16, i = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
			super(), this.type = "SphereGeometry", this.parameters = {
				radius: e,
				widthSegments: t,
				heightSegments: n,
				phiStart: i,
				phiLength: s,
				thetaStart: o,
				thetaLength: a
			}, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
			let c = Math.min(o + a, Math.PI),
				l = 0,
				u = [],
				h = new ne,
				f = new ne,
				p = [],
				g = [],
				m = [],
				d = [];
			for (let v = 0; v <= n; v++) {
				let x = [],
					_ = v / n,
					y = 0;
				v == 0 && o == 0 ? y = .5 / t : v == n && c == Math.PI && (y = -.5 / t);
				for (let w = 0; w <= t; w++) {
					let C = w / t;
					h.x = -e * Math.cos(i + C * s) * Math.sin(o + _ * a), h.y = e * Math.cos(o + _ * a), h.z = e * Math.sin(i + C * s) * Math.sin(o + _ * a), g.push(h.x, h.y, h.z), f.copy(h)
						.normalize(), m.push(f.x, f.y, f.z), d.push(C + y, 1 - _), x.push(l++)
				}
				u.push(x)
			}
			for (let v = 0; v < n; v++)
				for (let x = 0; x < t; x++) {
					let _ = u[v][x + 1],
						y = u[v][x],
						w = u[v + 1][x],
						C = u[v + 1][x + 1];
					(v !== 0 || o > 0) && p.push(_, y, C), (v !== n - 1 || c < Math.PI) && p.push(y, w, C)
				}
			this.setIndex(p), this.setAttribute("position", new ze(g, 3)), this.setAttribute("normal", new ze(m, 3)), this.setAttribute("uv", new ze(d, 2))
		}
		static fromJSON(e) {
			return new Os(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
		}
	};
	var ks = class extends rr {
		constructor(e) {
			super(), this.isMeshStandardMaterial = !0, this.defines = {
				STANDARD: ""
			}, this.type = "MeshStandardMaterial", this.color = new Xe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Au, this.normalScale = new st(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.defines = {
				STANDARD: ""
			}, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};
	var an = class extends rr {
		constructor(e) {
			super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Xe(16777215), this.specular = new Xe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Au, this.normalScale = new st(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Eu, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};
	var ba = class extends rr {
		constructor(e) {
			super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Xe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Xe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Au, this.normalScale = new st(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = Eu, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
		}
		copy(e) {
			return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
		}
	};

	function Cs(r, e, t) {
		return gv(r) ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length)) : r.slice(e, t)
	}

	function au(r, e, t) {
		return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
	}

	function gv(r) {
		return ArrayBuffer.isView(r) && !(r instanceof DataView)
	}

	function DS(r) {
		function e(i, s) {
			return r[i] - r[s]
		}
		let t = r.length,
			n = new Array(t);
		for (let i = 0; i !== t; ++i) n[i] = i;
		return n.sort(e), n
	}

	function Z0(r, e, t) {
		let n = r.length,
			i = new r.constructor(n);
		for (let s = 0, o = 0; o !== n; ++s) {
			let a = t[s] * e;
			for (let c = 0; c !== e; ++c) i[o++] = r[a + c]
		}
		return i
	}

	function vv(r, e, t, n) {
		let i = 1,
			s = r[0];
		for (; s !== void 0 && s[n] === void 0;) s = r[i++];
		if (s === void 0) return;
		let o = s[n];
		if (o !== void 0)
			if (Array.isArray(o))
				do o = s[n], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = r[i++]; while (s !== void 0);
			else if (o.toArray !== void 0)
			do o = s[n], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = r[i++]; while (s !== void 0);
		else
			do o = s[n], o !== void 0 && (e.push(s.time), t.push(o)), s = r[i++]; while (s !== void 0)
	}
	var Ma = class {
			constructor(e, t, n, i) {
				this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
			}
			evaluate(e) {
				let t = this.parameterPositions,
					n = this._cachedIndex,
					i = t[n],
					s = t[n - 1];
				e: {
					t: {
						let o;n: {
							i: if (!(e < i)) {
								for (let a = n + 2;;) {
									if (i === void 0) {
										if (e < s) break i;
										return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
									}
									if (n === a) break;
									if (s = i, i = t[++n], e < i) break t
								}
								o = t.length;
								break n
							}if (!(e >= s)) {
								let a = t[1];
								e < a && (n = 2, s = a);
								for (let c = n - 2;;) {
									if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
									if (n === c) break;
									if (i = s, s = t[--n - 1], e >= s) break t
								}
								o = n, n = 0;
								break n
							}
							break e
						}
						for (; n < o;) {
							let a = n + o >>> 1;
							e < t[a] ? o = a : n = a + 1
						}
						if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0,
						this.copySampleValue_(0);
						if (i === void 0) return n = t.length,
						this._cachedIndex = n,
						this.copySampleValue_(n - 1)
					}
					this._cachedIndex = n,
					this.intervalChanged_(n, s, i)
				}
				return this.interpolate_(n, s, e, i)
			}
			getSettings_() {
				return this.settings || this.DefaultSettings_
			}
			copySampleValue_(e) {
				let t = this.resultBuffer,
					n = this.sampleValues,
					i = this.valueSize,
					s = e * i;
				for (let o = 0; o !== i; ++o) t[o] = n[s + o];
				return t
			}
			interpolate_() {
				throw new Error("call to abstract method")
			}
			intervalChanged_() {}
		},
		kd = class extends Ma {
			constructor(e, t, n, i) {
				super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
					endingStart: Kg,
					endingEnd: Kg
				}
			}
			intervalChanged_(e, t, n) {
				let i = this.parameterPositions,
					s = e - 2,
					o = e + 1,
					a = i[s],
					c = i[o];
				if (a === void 0) switch (this.getSettings_()
					.endingStart) {
					case Jg:
						s = e, a = 2 * t - n;
						break;
					case $g:
						s = i.length - 2, a = t + i[s] - i[s + 1];
						break;
					default:
						s = e, a = n
				}
				if (c === void 0) switch (this.getSettings_()
					.endingEnd) {
					case Jg:
						o = e, c = 2 * n - t;
						break;
					case $g:
						o = 1, c = n + i[1] - i[0];
						break;
					default:
						o = e - 1, c = t
				}
				let l = (n - t) * .5,
					u = this.valueSize;
				this._weightPrev = l / (t - a), this._weightNext = l / (c - n), this._offsetPrev = s * u, this._offsetNext = o * u
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					c = e * a,
					l = c - a,
					u = this._offsetPrev,
					h = this._offsetNext,
					f = this._weightPrev,
					p = this._weightNext,
					g = (n - t) / (i - t),
					m = g * g,
					d = m * g,
					v = -f * d + 2 * f * m - f * g,
					x = (1 + f) * d + (-1.5 - 2 * f) * m + (-.5 + f) * g + 1,
					_ = (-1 - p) * d + (1.5 + p) * m + .5 * g,
					y = p * d - p * m;
				for (let w = 0; w !== a; ++w) s[w] = v * o[u + w] + x * o[l + w] + _ * o[c + w] + y * o[h + w];
				return s
			}
		},
		Fd = class extends Ma {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					c = e * a,
					l = c - a,
					u = (n - t) / (i - t),
					h = 1 - u;
				for (let f = 0; f !== a; ++f) s[f] = o[l + f] * h + o[c + f] * u;
				return s
			}
		},
		Ud = class extends Ma {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e) {
				return this.copySampleValue_(e - 1)
			}
		},
		ki = class {
			constructor(e, t, n, i) {
				if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
				if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
				this.name = e, this.times = au(t, this.TimeBufferType), this.values = au(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
			}
			static toJSON(e) {
				let t = e.constructor,
					n;
				if (t.toJSON !== this.toJSON) n = t.toJSON(e);
				else {
					n = {
						name: e.name,
						times: au(e.times, Array),
						values: au(e.values, Array)
					};
					let i = e.getInterpolation();
					i !== e.DefaultInterpolation && (n.interpolation = i)
				}
				return n.type = e.ValueTypeName, n
			}
			InterpolantFactoryMethodDiscrete(e) {
				return new Ud(this.times, this.values, this.getValueSize(), e)
			}
			InterpolantFactoryMethodLinear(e) {
				return new Fd(this.times, this.values, this.getValueSize(), e)
			}
			InterpolantFactoryMethodSmooth(e) {
				return new kd(this.times, this.values, this.getValueSize(), e)
			}
			setInterpolation(e) {
				let t;
				switch (e) {
					case cu:
						t = this.InterpolantFactoryMethodDiscrete;
						break;
					case uu:
						t = this.InterpolantFactoryMethodLinear;
						break;
					case Uf:
						t = this.InterpolantFactoryMethodSmooth;
						break
				}
				if (t === void 0) {
					let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
					if (this.createInterpolant === void 0)
						if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
						else throw new Error(n);
					return console.warn("THREE.KeyframeTrack:", n), this
				}
				return this.createInterpolant = t, this
			}
			getInterpolation() {
				switch (this.createInterpolant) {
					case this.InterpolantFactoryMethodDiscrete:
						return cu;
					case this.InterpolantFactoryMethodLinear:
						return uu;
					case this.InterpolantFactoryMethodSmooth:
						return Uf
				}
			}
			getValueSize() {
				return this.values.length / this.times.length
			}
			shift(e) {
				if (e !== 0) {
					let t = this.times;
					for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
				}
				return this
			}
			scale(e) {
				if (e !== 1) {
					let t = this.times;
					for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
				}
				return this
			}
			trim(e, t) {
				let n = this.times,
					i = n.length,
					s = 0,
					o = i - 1;
				for (; s !== i && n[s] < e;) ++s;
				for (; o !== -1 && n[o] > t;) --o;
				if (++o, s !== 0 || o !== i) {
					s >= o && (o = Math.max(o, 1), s = o - 1);
					let a = this.getValueSize();
					this.times = Cs(n, s, o), this.values = Cs(this.values, s * a, o * a)
				}
				return this
			}
			validate() {
				let e = !0,
					t = this.getValueSize();
				t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
				let n = this.times,
					i = this.values,
					s = n.length;
				s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
				let o = null;
				for (let a = 0; a !== s; a++) {
					let c = n[a];
					if (typeof c == "number" && isNaN(c)) {
						console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, c), e = !1;
						break
					}
					if (o !== null && o > c) {
						console.error("THREE.KeyframeTrack: Out of order keys.", this, a, c, o), e = !1;
						break
					}
					o = c
				}
				if (i !== void 0 && gv(i))
					for (let a = 0, c = i.length; a !== c; ++a) {
						let l = i[a];
						if (isNaN(l)) {
							console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, l), e = !1;
							break
						}
					}
				return e
			}
			optimize() {
				let e = Cs(this.times),
					t = Cs(this.values),
					n = this.getValueSize(),
					i = this.getInterpolation() === Uf,
					s = e.length - 1,
					o = 1;
				for (let a = 1; a < s; ++a) {
					let c = !1,
						l = e[a],
						u = e[a + 1];
					if (l !== u && (a !== 1 || l !== e[0]))
						if (i) c = !0;
						else {
							let h = a * n,
								f = h - n,
								p = h + n;
							for (let g = 0; g !== n; ++g) {
								let m = t[h + g];
								if (m !== t[f + g] || m !== t[p + g]) {
									c = !0;
									break
								}
							}
						} if (c) {
						if (a !== o) {
							e[o] = e[a];
							let h = a * n,
								f = o * n;
							for (let p = 0; p !== n; ++p) t[f + p] = t[h + p]
						}++o
					}
				}
				if (s > 0) {
					e[o] = e[s];
					for (let a = s * n, c = o * n, l = 0; l !== n; ++l) t[c + l] = t[a + l];
					++o
				}
				return o !== e.length ? (this.times = Cs(e, 0, o), this.values = Cs(t, 0, o * n)) : (this.times = e, this.values = t), this
			}
			clone() {
				let e = Cs(this.times, 0),
					t = Cs(this.values, 0),
					n = this.constructor,
					i = new n(this.name, e, t);
				return i.createInterpolant = this.createInterpolant, i
			}
		};
	ki.prototype.TimeBufferType = Float32Array;
	ki.prototype.ValueBufferType = Float32Array;
	ki.prototype.DefaultInterpolation = uu;
	var Fs = class extends ki {};
	Fs.prototype.ValueTypeName = "bool";
	Fs.prototype.ValueBufferType = Array;
	Fs.prototype.DefaultInterpolation = cu;
	Fs.prototype.InterpolantFactoryMethodLinear = void 0;
	Fs.prototype.InterpolantFactoryMethodSmooth = void 0;
	var _u = class extends ki {};
	_u.prototype.ValueTypeName = "color";
	var Us = class extends ki {};
	Us.prototype.ValueTypeName = "number";
	var Bd = class extends Ma {
			constructor(e, t, n, i) {
				super(e, t, n, i)
			}
			interpolate_(e, t, n, i) {
				let s = this.resultBuffer,
					o = this.sampleValues,
					a = this.valueSize,
					c = (n - t) / (i - t),
					l = e * a;
				for (let u = l + a; l !== u; l += 4) mn.slerpFlat(s, 0, o, l - a, o, l, c);
				return s
			}
		},
		sr = class extends ki {
			InterpolantFactoryMethodLinear(e) {
				return new Bd(this.times, this.values, this.getValueSize(), e)
			}
		};
	sr.prototype.ValueTypeName = "quaternion";
	sr.prototype.DefaultInterpolation = uu;
	sr.prototype.InterpolantFactoryMethodSmooth = void 0;
	var Bs = class extends ki {};
	Bs.prototype.ValueTypeName = "string";
	Bs.prototype.ValueBufferType = Array;
	Bs.prototype.DefaultInterpolation = cu;
	Bs.prototype.InterpolantFactoryMethodLinear = void 0;
	Bs.prototype.InterpolantFactoryMethodSmooth = void 0;
	var or = class extends ki {};
	or.prototype.ValueTypeName = "vector";
	var Eo = class {
		constructor(e, t = -1, n, i = p_) {
			this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Gs(), this.duration < 0 && this.resetDuration()
		}
		static parse(e) {
			let t = [],
				n = e.tracks,
				i = 1 / (e.fps || 1);
			for (let o = 0, a = n.length; o !== a; ++o) t.push(kS(n[o])
				.scale(i));
			let s = new this(e.name, e.duration, t, e.blendMode);
			return s.uuid = e.uuid, s
		}
		static toJSON(e) {
			let t = [],
				n = e.tracks,
				i = {
					name: e.name,
					duration: e.duration,
					tracks: t,
					uuid: e.uuid,
					blendMode: e.blendMode
				};
			for (let s = 0, o = n.length; s !== o; ++s) t.push(ki.toJSON(n[s]));
			return i
		}
		static CreateFromMorphTargetSequence(e, t, n, i) {
			let s = t.length,
				o = [];
			for (let a = 0; a < s; a++) {
				let c = [],
					l = [];
				c.push((a + s - 1) % s, a, (a + 1) % s), l.push(0, 1, 0);
				let u = DS(c);
				c = Z0(c, 1, u), l = Z0(l, 1, u), !i && c[0] === 0 && (c.push(s), l.push(l[0])), o.push(new Us(".morphTargetInfluences[" + t[a].name + "]", c, l)
					.scale(1 / n))
			}
			return new this(e, -1, o)
		}
		static findByName(e, t) {
			let n = e;
			if (!Array.isArray(e)) {
				let i = e;
				n = i.geometry && i.geometry.animations || i.animations
			}
			for (let i = 0; i < n.length; i++)
				if (n[i].name === t) return n[i];
			return null
		}
		static CreateClipsFromMorphTargetSequences(e, t, n) {
			let i = {},
				s = /^([\w-]*?)([\d]+)$/;
			for (let a = 0, c = e.length; a < c; a++) {
				let l = e[a],
					u = l.name.match(s);
				if (u && u.length > 1) {
					let h = u[1],
						f = i[h];
					f || (i[h] = f = []), f.push(l)
				}
			}
			let o = [];
			for (let a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
			return o
		}
		static parseAnimation(e, t) {
			if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
			let n = function(h, f, p, g, m) {
					if (p.length !== 0) {
						let d = [],
							v = [];
						vv(p, d, v, g), d.length !== 0 && m.push(new h(f, d, v))
					}
				},
				i = [],
				s = e.name || "default",
				o = e.fps || 30,
				a = e.blendMode,
				c = e.length || -1,
				l = e.hierarchy || [];
			for (let h = 0; h < l.length; h++) {
				let f = l[h].keys;
				if (!(!f || f.length === 0))
					if (f[0].morphTargets) {
						let p = {},
							g;
						for (g = 0; g < f.length; g++)
							if (f[g].morphTargets)
								for (let m = 0; m < f[g].morphTargets.length; m++) p[f[g].morphTargets[m]] = -1;
						for (let m in p) {
							let d = [],
								v = [];
							for (let x = 0; x !== f[g].morphTargets.length; ++x) {
								let _ = f[g];
								d.push(_.time), v.push(_.morphTarget === m ? 1 : 0)
							}
							i.push(new Us(".morphTargetInfluence[" + m + "]", d, v))
						}
						c = p.length * o
					} else {
						let p = ".bones[" + t[h].name + "]";
						n(or, p + ".position", f, "pos", i), n(sr, p + ".quaternion", f, "rot", i), n(or, p + ".scale", f, "scl", i)
					}
			}
			return i.length === 0 ? null : new this(s, c, i, a)
		}
		resetDuration() {
			let e = this.tracks,
				t = 0;
			for (let n = 0, i = e.length; n !== i; ++n) {
				let s = this.tracks[n];
				t = Math.max(t, s.times[s.times.length - 1])
			}
			return this.duration = t, this
		}
		trim() {
			for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
			return this
		}
		validate() {
			let e = !0;
			for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
			return e
		}
		optimize() {
			for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
			return this
		}
		clone() {
			let e = [];
			for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
			return new this.constructor(this.name, this.duration, e, this.blendMode)
		}
		toJSON() {
			return this.constructor.toJSON(this)
		}
	};

	function OS(r) {
		switch (r.toLowerCase()) {
			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":
				return Us;
			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":
				return or;
			case "color":
				return _u;
			case "quaternion":
				return sr;
			case "bool":
			case "boolean":
				return Fs;
			case "string":
				return Bs
		}
		throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
	}

	function kS(r) {
		if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
		let e = OS(r.type);
		if (r.times === void 0) {
			let t = [],
				n = [];
			vv(r.keys, t, n, "value"), r.times = t, r.values = n
		}
		return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation)
	}
	var bu = {
			enabled: !1,
			files: {},
			add: function(r, e) {
				this.enabled !== !1 && (this.files[r] = e)
			},
			get: function(r) {
				if (this.enabled !== !1) return this.files[r]
			},
			remove: function(r) {
				delete this.files[r]
			},
			clear: function() {
				this.files = {}
			}
		},
		Dl = class {
			constructor(e, t, n) {
				let i = this,
					s = !1,
					o = 0,
					a = 0,
					c, l = [];
				this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
					a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), s = !0
				}, this.itemEnd = function(u) {
					o++, i.onProgress !== void 0 && i.onProgress(u, o, a), o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
				}, this.itemError = function(u) {
					i.onError !== void 0 && i.onError(u)
				}, this.resolveURL = function(u) {
					return c ? c(u) : u
				}, this.setURLModifier = function(u) {
					return c = u, this
				}, this.addHandler = function(u, h) {
					return l.push(u, h), this
				}, this.removeHandler = function(u) {
					let h = l.indexOf(u);
					return h !== -1 && l.splice(h, 2), this
				}, this.getHandler = function(u) {
					for (let h = 0, f = l.length; h < f; h += 2) {
						let p = l[h],
							g = l[h + 1];
						if (p.global && (p.lastIndex = 0), p.test(u)) return g
					}
					return null
				}
			}
		},
		FS = new Dl,
		ei = class {
			constructor(e) {
				this.manager = e !== void 0 ? e : FS, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
			}
			load() {}
			loadAsync(e, t) {
				let n = this;
				return new Promise(function(i, s) {
					n.load(e, i, t, s)
				})
			}
			parse() {}
			setCrossOrigin(e) {
				return this.crossOrigin = e, this
			}
			setWithCredentials(e) {
				return this.withCredentials = e, this
			}
			setPath(e) {
				return this.path = e, this
			}
			setResourcePath(e) {
				return this.resourcePath = e, this
			}
			setRequestHeader(e) {
				return this.requestHeader = e, this
			}
		},
		qr = {},
		Gd = class extends Error {
			constructor(e, t) {
				super(e), this.response = t
			}
		},
		ar = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
				let s = bu.get(e);
				if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
					t && t(s), this.manager.itemEnd(e)
				}, 0), s;
				if (qr[e] !== void 0) {
					qr[e].push({
						onLoad: t,
						onProgress: n,
						onError: i
					});
					return
				}
				qr[e] = [], qr[e].push({
					onLoad: t,
					onProgress: n,
					onError: i
				});
				let o = new Request(e, {
						headers: new Headers(this.requestHeader),
						credentials: this.withCredentials ? "include" : "same-origin"
					}),
					a = this.mimeType,
					c = this.responseType;
				fetch(o)
					.then(l => {
						if (l.status === 200 || l.status === 0) {
							if (l.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || l.body === void 0 || l.body.getReader === void 0) return l;
							let u = qr[e],
								h = l.body.getReader(),
								f = l.headers.get("Content-Length"),
								p = f ? parseInt(f) : 0,
								g = p !== 0,
								m = 0,
								d = new ReadableStream({
									start(v) {
										x();

										function x() {
											h.read()
												.then(({
													done: _,
													value: y
												}) => {
													if (_) v.close();
													else {
														m += y.byteLength;
														let w = new ProgressEvent("progress", {
															lengthComputable: g,
															loaded: m,
															total: p
														});
														for (let C = 0, S = u.length; C < S; C++) {
															let b = u[C];
															b.onProgress && b.onProgress(w)
														}
														v.enqueue(y), x()
													}
												})
										}
									}
								});
							return new Response(d)
						} else throw new Gd(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`, l)
					})
					.then(l => {
						switch (c) {
							case "arraybuffer":
								return l.arrayBuffer();
							case "blob":
								return l.blob();
							case "document":
								return l.text()
									.then(u => new DOMParser()
										.parseFromString(u, a));
							case "json":
								return l.json();
							default:
								if (a === void 0) return l.text(); {
									let h = /charset="?([^;"\s]*)"?/i.exec(a),
										f = h && h[1] ? h[1].toLowerCase() : void 0,
										p = new TextDecoder(f);
									return l.arrayBuffer()
										.then(g => p.decode(g))
								}
						}
					})
					.then(l => {
						bu.add(e, l);
						let u = qr[e];
						delete qr[e];
						for (let h = 0, f = u.length; h < f; h++) {
							let p = u[h];
							p.onLoad && p.onLoad(l)
						}
					})
					.catch(l => {
						let u = qr[e];
						if (u === void 0) throw this.manager.itemError(e), l;
						delete qr[e];
						for (let h = 0, f = u.length; h < f; h++) {
							let p = u[h];
							p.onError && p.onError(l)
						}
						this.manager.itemError(e)
					})
					.finally(() => {
						this.manager.itemEnd(e)
					}), this.manager.itemStart(e)
			}
			setResponseType(e) {
				return this.responseType = e, this
			}
			setMimeType(e) {
				return this.mimeType = e, this
			}
		};
	var Mu = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
				let s = this,
					o = bu.get(e);
				if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
					t && t(o), s.manager.itemEnd(e)
				}, 0), o;
				let a = Sl("img");

				function c() {
					u(), bu.add(e, this), t && t(this), s.manager.itemEnd(e)
				}

				function l(h) {
					u(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e)
				}

				function u() {
					a.removeEventListener("load", c, !1), a.removeEventListener("error", l, !1)
				}
				return a.addEventListener("load", c, !1), a.addEventListener("error", l, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
			}
		},
		wu = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = new Cl,
					o = new Mu(this.manager);
				o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
				let a = 0;

				function c(l) {
					o.load(e[l], function(u) {
						s.images[l] = u, a++, a === 6 && (s.needsUpdate = !0, t && t(s))
					}, void 0, i)
				}
				for (let l = 0; l < e.length; ++l) c(l);
				return s
			}
		},
		Tu = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = this,
					o = new xa,
					a = new ar(this.manager);
				return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(c) {
					let l = s.parse(c);
					!l || (l.image !== void 0 ? o.image = l.image : l.data !== void 0 && (o.image.width = l.width, o.image.height = l.height, o.image.data = l.data), o.wrapS = l.wrapS !== void 0 ? l.wrapS : Xt, o.wrapT = l.wrapT !== void 0 ? l.wrapT : Xt, o.magFilter = l.magFilter !== void 0 ? l.magFilter : pn, o.minFilter = l.minFilter !== void 0 ? l.minFilter : pn, o.anisotropy = l.anisotropy !== void 0 ? l.anisotropy : 1, l.encoding !== void 0 && (o.encoding = l.encoding), l.flipY !== void 0 && (o.flipY = l.flipY), l.format !== void 0 && (o.format = l.format), l.type !== void 0 && (o.type = l.type), l.mipmaps !== void 0 && (o.mipmaps = l.mipmaps, o.minFilter = Er), l.mipmapCount === 1 && (o.minFilter = pn), l.generateMipmaps !== void 0 && (o.generateMipmaps = l.generateMipmaps), o.needsUpdate = !0, t && t(o, l))
				}, n, i), o
			}
		},
		Fi = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = new Pn,
					o = new Mu(this.manager);
				return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
					s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
				}, n, i), s
			}
		},
		wa = class extends yt {
			constructor(e, t = 1) {
				super(), this.isLight = !0, this.type = "Light", this.color = new Xe(e), this.intensity = t
			}
			dispose() {}
			copy(e, t) {
				return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
			}
			toJSON(e) {
				let t = super.toJSON(e);
				return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t
			}
		};
	var fd = new ke,
		K0 = new ne,
		J0 = new ne,
		Ol = class {
			constructor(e) {
				this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new st(512, 512), this.map = null, this.mapPass = null, this.matrix = new ke, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Al, this._frameExtents = new st(1, 1), this._viewportCount = 1, this._viewports = [new wt(0, 0, 1, 1)]
			}
			getViewportCount() {
				return this._viewportCount
			}
			getFrustum() {
				return this._frustum
			}
			updateMatrices(e) {
				let t = this.camera,
					n = this.matrix;
				K0.setFromMatrixPosition(e.matrixWorld), t.position.copy(K0), J0.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(J0), t.updateMatrixWorld(), fd.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fd), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(fd)
			}
			getViewport(e) {
				return this._viewports[e]
			}
			getFrameExtents() {
				return this._frameExtents
			}
			dispose() {
				this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
			}
			copy(e) {
				return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
			}
			clone() {
				return new this.constructor()
					.copy(this)
			}
			toJSON() {
				let e = {};
				return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1)
					.object, delete e.camera.matrix, e
			}
		},
		Vd = class extends Ol {
			constructor() {
				super(new Kt(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
			}
			updateMatrices(e) {
				let t = this.camera,
					n = Tl * 2 * e.angle * this.focus,
					i = this.mapSize.width / this.mapSize.height,
					s = e.distance || t.far;
				(n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
			}
			copy(e) {
				return super.copy(e), this.focus = e.focus, this
			}
		},
		Ta = class extends wa {
			constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 1) {
				super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(yt.DefaultUp), this.updateMatrix(), this.target = new yt, this.distance = n, this.angle = i, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new Vd
			}
			get power() {
				return this.intensity * Math.PI
			}
			set power(e) {
				this.intensity = e / Math.PI
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e, t) {
				return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
			}
		},
		$0 = new ke,
		gl = new ne,
		dd = new ne,
		zd = class extends Ol {
			constructor() {
				super(new Kt(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new st(4, 2), this._viewportCount = 6, this._viewports = [new wt(2, 1, 1, 1), new wt(0, 1, 1, 1), new wt(3, 1, 1, 1), new wt(1, 1, 1, 1), new wt(3, 0, 1, 1), new wt(1, 0, 1, 1)], this._cubeDirections = [new ne(1, 0, 0), new ne(-1, 0, 0), new ne(0, 0, 1), new ne(0, 0, -1), new ne(0, 1, 0), new ne(0, -1, 0)], this._cubeUps = [new ne(0, 1, 0), new ne(0, 1, 0), new ne(0, 1, 0), new ne(0, 1, 0), new ne(0, 0, 1), new ne(0, 0, -1)]
			}
			updateMatrices(e, t = 0) {
				let n = this.camera,
					i = this.matrix,
					s = e.distance || n.far;
				s !== n.far && (n.far = s, n.updateProjectionMatrix()), gl.setFromMatrixPosition(e.matrixWorld), n.position.copy(gl), dd.copy(n.position), dd.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(dd), n.updateMatrixWorld(), i.makeTranslation(-gl.x, -gl.y, -gl.z), $0.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix($0)
			}
		},
		Co = class extends wa {
			constructor(e, t, n = 0, i = 1) {
				super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new zd
			}
			get power() {
				return this.intensity * 4 * Math.PI
			}
			set power(e) {
				this.intensity = e / (4 * Math.PI)
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e, t) {
				return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
			}
		},
		Hd = class extends Ol {
			constructor() {
				super(new Mr(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
			}
		},
		Tr = class extends wa {
			constructor(e, t) {
				super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(yt.DefaultUp), this.updateMatrix(), this.target = new yt, this.shadow = new Hd
			}
			dispose() {
				this.shadow.dispose()
			}
			copy(e) {
				return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
			}
		},
		Sr = class extends wa {
			constructor(e, t) {
				super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
			}
		};
	var fi = class {
		static decodeText(e) {
			if (typeof TextDecoder < "u") return new TextDecoder()
				.decode(e);
			let t = "";
			for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
			try {
				return decodeURIComponent(escape(t))
			} catch {
				return t
			}
		}
		static extractUrlBase(e) {
			let t = e.lastIndexOf("/");
			return t === -1 ? "./" : e.slice(0, t + 1)
		}
		static resolveURL(e, t) {
			return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
		}
	};
	var Zd = "\\[\\]\\.:\\/",
		US = new RegExp("[" + Zd + "]", "g"),
		Kd = "[^" + Zd + "]",
		BS = "[^" + Zd.replace("\\.", "") + "]",
		GS = /((?:WC+[\/:])*)/.source.replace("WC", Kd),
		VS = /(WCOD+)?/.source.replace("WCOD", BS),
		zS = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Kd),
		HS = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Kd),
		WS = new RegExp("^" + GS + VS + zS + HS + "$"),
		jS = ["material", "materials", "bones", "map"],
		Wd = class {
			constructor(e, t, n) {
				let i = n || Ct.parseTrackName(t);
				this._targetGroup = e, this._bindings = e.subscribe_(t, i)
			}
			getValue(e, t) {
				this.bind();
				let n = this._targetGroup.nCachedObjects_,
					i = this._bindings[n];
				i !== void 0 && i.getValue(e, t)
			}
			setValue(e, t) {
				let n = this._bindings;
				for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t)
			}
			bind() {
				let e = this._bindings;
				for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
			}
			unbind() {
				let e = this._bindings;
				for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
			}
		},
		Ct = class {
			constructor(e, t, n) {
				this.path = t, this.parsedPath = n || Ct.parseTrackName(t), this.node = Ct.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
			static create(e, t, n) {
				return e && e.isAnimationObjectGroup ? new Ct.Composite(e, t, n) : new Ct(e, t, n)
			}
			static sanitizeNodeName(e) {
				return e.replace(/\s/g, "_")
					.replace(US, "")
			}
			static parseTrackName(e) {
				let t = WS.exec(e);
				if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
				let n = {
						nodeName: t[2],
						objectName: t[3],
						objectIndex: t[4],
						propertyName: t[5],
						propertyIndex: t[6]
					},
					i = n.nodeName && n.nodeName.lastIndexOf(".");
				if (i !== void 0 && i !== -1) {
					let s = n.nodeName.substring(i + 1);
					jS.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
				}
				if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
				return n
			}
			static findNode(e, t) {
				if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
				if (e.skeleton) {
					let n = e.skeleton.getBoneByName(t);
					if (n !== void 0) return n
				}
				if (e.children) {
					let n = function(s) {
							for (let o = 0; o < s.length; o++) {
								let a = s[o];
								if (a.name === t || a.uuid === t) return a;
								let c = n(a.children);
								if (c) return c
							}
							return null
						},
						i = n(e.children);
					if (i) return i
				}
				return null
			}
			_getValue_unavailable() {}
			_setValue_unavailable() {}
			_getValue_direct(e, t) {
				e[t] = this.targetObject[this.propertyName]
			}
			_getValue_array(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i]
			}
			_getValue_arrayElement(e, t) {
				e[t] = this.resolvedProperty[this.propertyIndex]
			}
			_getValue_toArray(e, t) {
				this.resolvedProperty.toArray(e, t)
			}
			_setValue_direct(e, t) {
				this.targetObject[this.propertyName] = e[t]
			}
			_setValue_direct_setNeedsUpdate(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
			}
			_setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
				this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_array(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++]
			}
			_setValue_array_setNeedsUpdate(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
				this.targetObject.needsUpdate = !0
			}
			_setValue_array_setMatrixWorldNeedsUpdate(e, t) {
				let n = this.resolvedProperty;
				for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_arrayElement(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t]
			}
			_setValue_arrayElement_setNeedsUpdate(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
			}
			_setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
				this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_setValue_fromArray(e, t) {
				this.resolvedProperty.fromArray(e, t)
			}
			_setValue_fromArray_setNeedsUpdate(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
			}
			_setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
				this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
			}
			_getValue_unbound(e, t) {
				this.bind(), this.getValue(e, t)
			}
			_setValue_unbound(e, t) {
				this.bind(), this.setValue(e, t)
			}
			bind() {
				let e = this.node,
					t = this.parsedPath,
					n = t.objectName,
					i = t.propertyName,
					s = t.propertyIndex;
				if (e || (e = Ct.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
					console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
					return
				}
				if (n) {
					let l = t.objectIndex;
					switch (n) {
						case "materials":
							if (!e.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!e.material.materials) {
								console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
								return
							}
							e = e.material.materials;
							break;
						case "bones":
							if (!e.skeleton) {
								console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								return
							}
							e = e.skeleton.bones;
							for (let u = 0; u < e.length; u++)
								if (e[u].name === l) {
									l = u;
									break
								} break;
						case "map":
							if ("map" in e) {
								e = e.map;
								break
							}
							if (!e.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!e.material.map) {
								console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
								return
							}
							e = e.material.map;
							break;
						default:
							if (e[n] === void 0) {
								console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								return
							}
							e = e[n]
					}
					if (l !== void 0) {
						if (e[l] === void 0) {
							console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
							return
						}
						e = e[l]
					}
				}
				let o = e[i];
				if (o === void 0) {
					let l = t.nodeName;
					console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e);
					return
				}
				let a = this.Versioning.None;
				this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
				let c = this.BindingType.Direct;
				if (s !== void 0) {
					if (i === "morphTargetInfluences") {
						if (!e.geometry) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							return
						}
						if (!e.geometry.morphAttributes) {
							console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
							return
						}
						e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
					}
					c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
				} else o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
				this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][a]
			}
			unbind() {
				this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
			}
		};
	Ct.Composite = Wd;
	Ct.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	Ct.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	Ct.prototype.GetterByBindingType = [Ct.prototype._getValue_direct, Ct.prototype._getValue_array, Ct.prototype._getValue_arrayElement, Ct.prototype._getValue_toArray];
	Ct.prototype.SetterByBindingTypeAndVersioning = [
		[Ct.prototype._setValue_direct, Ct.prototype._setValue_direct_setNeedsUpdate, Ct.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
		[Ct.prototype._setValue_array, Ct.prototype._setValue_array_setNeedsUpdate, Ct.prototype._setValue_array_setMatrixWorldNeedsUpdate],
		[Ct.prototype._setValue_arrayElement, Ct.prototype._setValue_arrayElement_setNeedsUpdate, Ct.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
		[Ct.prototype._setValue_fromArray, Ct.prototype._setValue_fromArray_setNeedsUpdate, Ct.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
	];
	var Q1 = new Float32Array(1);
	var Su = class {
		constructor(e, t, n = 0, i = 1 / 0) {
			this.ray = new pa(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new El, this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			}
		}
		set(e, t) {
			this.ray.set(e, t)
		}
		setFromCamera(e, t) {
			t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5)
				.unproject(t)
				.sub(this.ray.origin)
				.normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
				.unproject(t), this.ray.direction.set(0, 0, -1)
				.transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
		}
		intersectObject(e, t = !0, n = []) {
			return jd(e, this, n, t), n.sort(Q0), n
		}
		intersectObjects(e, t = !0, n = []) {
			for (let i = 0, s = e.length; i < s; i++) jd(e[i], this, n, t);
			return n.sort(Q0), n
		}
	};

	function Q0(r, e) {
		return r.distance - e.distance
	}

	function jd(r, e, t, n) {
		if (r.layers.test(e.layers) && r.raycast(e, t), n === !0) {
			let i = r.children;
			for (let s = 0, o = i.length; s < o; s++) jd(i[s], e, t, !0)
		}
	}
	typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
		detail: {
			revision: qd
		}
	}));
	typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = qd);

	function xv() {
		let r = document.createElement("canvas");
		document.body.appendChild(r);
		let e = {
				canvas: r,
				antialias: !0
			},
			t = new kl(e);
		t.setClearColor("#ffffff", 1), t.setSize(10, 10);
		let n = new wr,
			i = new Sr(8947848);
		n.add(i);
		let s = new Tr(8947848);
		s.position.set(0, 0, 1), n.add(s);
		let o = new Kt(45, 1, .1, 1e3);
		o.position.set(0, 0, 1), o.up.set(0, 1, 0), o.lookAt(new ne(0, 0, 0)), n.add(o);
		let a = new To(1, 1),
			c = new zt(a, new an({
				color: 13369344
			}));
		n.add(c), t.render(n, o);
		let l = t.getContext(),
			u = new Uint8Array(4);
		l.readPixels(5, 5, 1, 1, l.RGBA, l.UNSIGNED_BYTE, u), document.body.removeChild(r);
		let h = 50;
		return u[0] < h && u[1] < h && u[2] < h
	}
	var wn = {
		Phong: 1,
		Physical: 2
	};

	function yv(r) {
		let e = 0,
			t = 0;
		for (let n = 0; n < r.MaterialCount(); n++) {
			let i = r.GetMaterial(n);
			i.type === on.Phong ? e += 1 : i.type === on.Physical && (t += 1)
		}
		return e >= t ? wn.Phong : wn.Physical
	}

	function Pu(r) {
		return Ki(r.r, r.g, r.b)
	}

	function Ui(r) {
		return new Xe(r.r / 255, r.g / 255, r.b / 255)
	}

	function es(r, e) {
		let t = new Qt,
			n = r.attributes.position.array,
			i = r.attributes.position.itemSize || 3;
		for (let l = 0; l < n.length; l += i) {
			let u = n[l],
				h = n[l + 1],
				f = n[l + 2];
			t.AddVertex(new Le(u, h, f))
		}
		let s = r.attributes.color !== void 0;
		if (s) {
			let l = r.attributes.color.array,
				u = r.attributes.color.itemSize || 3;
			for (let h = 0; h < l.length; h += u) {
				let f = new Xe(l[h], l[h + 1], l[h + 2]);
				t.AddVertexColor(Pu(f))
			}
		}
		let o = r.attributes.normal !== void 0;
		if (o) {
			let l = r.attributes.normal.array,
				u = r.attributes.normal.itemSize || 3;
			for (let h = 0; h < l.length; h += u) {
				let f = l[h],
					p = l[h + 1],
					g = l[h + 2];
				t.AddNormal(new Le(f, p, g))
			}
		}
		let a = r.attributes.uv !== void 0;
		if (a) {
			let l = r.attributes.uv.array,
				u = r.attributes.uv.itemSize || 2;
			for (let h = 0; h < l.length; h += u) {
				let f = l[h],
					p = l[h + 1];
				t.AddTextureUV(new Rt(f, p))
			}
		}
		let c = null;
		if (r.index !== null) c = r.index.array;
		else {
			c = [];
			for (let l = 0; l < n.length / 3; l++) c.push(l)
		}
		for (let l = 0; l < c.length; l += 3) {
			let u = c[l],
				h = c[l + 1],
				f = c[l + 2],
				p = new qt(u, h, f);
			s && p.SetVertexColors(u, h, f), o && p.SetNormals(u, h, f), a && p.SetTextureUVs(u, h, f), e !== null && p.SetMaterial(e), t.AddTriangle(p)
		}
		return t
	}

	function _v(r, e, t) {
		let n = e / t,
			i = n * n;
		return r * (i / (2 * (i - n) + 1))
	}

	function Lu(r, e, t, n) {
		let i = Un(e, r)
			.Normalize(),
			s = Mi(r, e),
			o = [];
		for (let a = 0; a < t; a++) {
			let c = n(s, a, t - 1);
			o.push(r.Clone()
				.Offset(i, c))
		}
		return o
	}
	var Jd = class {
			constructor() {
				this.prev = new Rt(0, 0), this.curr = new Rt(0, 0), this.diff = new Rt(0, 0), this.buttons = []
			}
			Down(e, t) {
				this.buttons.push(t.which), this.curr = this.GetPositionFromEvent(e, t), this.prev = this.curr.Clone()
			}
			Move(e, t) {
				this.curr = this.GetPositionFromEvent(e, t), this.diff = wf(this.curr, this.prev), this.prev = this.curr.Clone()
			}
			Up(e, t) {
				let n = this.buttons.indexOf(t.which);
				n !== -1 && this.buttons.splice(n, 1), this.curr = this.GetPositionFromEvent(e, t)
			}
			Leave(e, t) {
				this.buttons = [], this.curr = this.GetPositionFromEvent(e, t)
			}
			IsButtonDown() {
				return this.buttons.length > 0
			}
			GetButton() {
				let e = this.buttons.length;
				return e === 0 ? 0 : this.buttons[e - 1]
			}
			GetPosition() {
				return this.curr
			}
			GetMoveDiff() {
				return this.diff
			}
			GetPositionFromEvent(e, t) {
				return oo(e, t.clientX, t.clientY)
			}
		},
		$d = class {
			constructor() {
				this.prevPos = new Rt(0, 0), this.currPos = new Rt(0, 0), this.diffPos = new Rt(0, 0), this.prevDist = 0, this.currDist = 0, this.diffDist = 0, this.fingers = 0
			}
			Start(e, t) {
				t.touches.length !== 0 && (this.fingers = t.touches.length, this.currPos = this.GetPositionFromEvent(e, t), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.prevDist = this.currDist)
			}
			Move(e, t) {
				t.touches.length !== 0 && (this.currPos = this.GetPositionFromEvent(e, t), this.diffPos = wf(this.currPos, this.prevPos), this.prevPos = this.currPos.Clone(), this.currDist = this.GetTouchDistanceFromEvent(e, t), this.diffDist = this.currDist - this.prevDist, this.prevDist = this.currDist)
			}
			End(e, t) {
				t.touches.length !== 0 && (this.fingers = 0, this.currPos = this.GetPositionFromEvent(e, t), this.currDist = this.GetTouchDistanceFromEvent(e, t))
			}
			IsFingerDown() {
				return this.fingers !== 0
			}
			GetFingerCount() {
				return this.fingers
			}
			GetPosition() {
				return this.currPos
			}
			GetMoveDiff() {
				return this.diffPos
			}
			GetDistanceDiff() {
				return this.diffDist
			}
			GetPositionFromEvent(e, t) {
				let n = null;
				if (t.touches.length !== 0) {
					let i = t.touches[0];
					n = oo(e, i.pageX, i.pageY)
				}
				return n
			}
			GetTouchDistanceFromEvent(e, t) {
				if (t.touches.length !== 2) return 0;
				let n = t.touches[0],
					i = t.touches[1];
				return Tf(oo(e, n.pageX, n.pageY), oo(e, i.pageX, i.pageY))
			}
		},
		Qd = class {
			constructor() {
				this.isClick = !1, this.startPosition = null
			}
			Start(e) {
				this.isClick = !0, this.startPosition = e
			}
			Move(e) {
				!this.isClick || (this.startPosition !== null ? Tf(this.startPosition, e) > 3 && this.Cancel() : this.Cancel())
			}
			End() {
				this.startPosition = null
			}
			Cancel() {
				this.isClick = !1, this.startPosition = null
			}
			IsClick() {
				return this.isClick
			}
		},
		Ei = {
			None: 0,
			Orbit: 1,
			Pan: 2,
			Zoom: 3
		},
		Nu = class {
			constructor(e, t, n) {
				this.canvas = e, this.camera = t, this.callbacks = n, this.fixUpVector = !0, this.mouse = new Jd, this.touch = new $d, this.clickDetector = new Qd, this.onMouseClick = null, this.onMouseMove = null, this.onContext = null, this.canvas.addEventListener && (this.canvas.addEventListener("mousedown", this.OnMouseDown.bind(this)), this.canvas.addEventListener("wheel", this.OnMouseWheel.bind(this)), this.canvas.addEventListener("touchstart", this.OnTouchStart.bind(this)), this.canvas.addEventListener("touchmove", this.OnTouchMove.bind(this)), this.canvas.addEventListener("touchcancel", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("touchend", this.OnTouchEnd.bind(this)), this.canvas.addEventListener("contextmenu", this.OnContextMenu.bind(this))), document.addEventListener && (document.addEventListener("mousemove", this.OnMouseMove.bind(this)), document.addEventListener("mouseup", this.OnMouseUp.bind(this)), document.addEventListener("mouseleave", this.OnMouseLeave.bind(this)))
			}
			SetMouseClickHandler(e) {
				this.onMouseClick = e
			}
			SetMouseMoveHandler(e) {
				this.onMouseMove = e
			}
			SetContextMenuHandler(e) {
				this.onContext = e
			}
			IsFixUpVector() {
				return this.fixUpVector
			}
			SetFixUpVector(e) {
				this.fixUpVector = e
			}
			GetCamera() {
				return this.camera
			}
			SetCamera(e) {
				this.camera = e
			}
			MoveCamera(e, t) {
				function n(i, s, o, a) {
					i.camera.eye = s.eye[a], i.camera.center = s.center[a], i.camera.up = s.up[a], i.Update(), a < o - 1 && requestAnimationFrame(() => {
						n(i, s, o, a + 1)
					})
				}
				if (e !== null) {
					if (t === 0 || _g(this.camera, e)) this.camera = e;
					else {
						let i = _v,
							s = {
								eye: Lu(this.camera.eye, e.eye, t, i),
								center: Lu(this.camera.center, e.center, t, i),
								up: Lu(this.camera.up, e.up, t, i)
							};
						requestAnimationFrame(() => {
							n(this, s, t, 0)
						})
					}
					this.Update()
				}
			}
			GetFitToSphereCamera(e, t) {
				if (cl(t)) return null;
				let n = this.camera.Clone(),
					i = Un(n.center, e);
				n.eye = Un(n.eye, i), n.center = e.Clone();
				let s = Un(n.eye, n.center)
					.Normalize(),
					o = this.camera.fov / 2;
				this.canvas.width < this.canvas.height && (o = o * this.canvas.width / this.canvas.height);
				let a = t / Math.sin(o * ps);
				return n.eye = n.center.Clone()
					.Offset(s, a), n
			}
			OnMouseDown(e) {
				e.preventDefault(), this.mouse.Down(this.canvas, e), this.clickDetector.Start(this.mouse.GetPosition())
			}
			OnMouseMove(e) {
				if (this.mouse.Move(this.canvas, e), this.clickDetector.Move(this.mouse.GetPosition()), this.onMouseMove) {
					let s = oo(this.canvas, e.clientX, e.clientY);
					this.onMouseMove(s)
				}
				if (!this.mouse.IsButtonDown()) return;
				let t = this.mouse.GetMoveDiff(),
					n = this.mouse.GetButton(),
					i = Ei.None;
				if (n === 1 ? e.ctrlKey ? i = Ei.Zoom : e.shiftKey ? i = Ei.Pan : i = Ei.Orbit : (n === 2 || n === 3) && (i = Ei.Pan), i === Ei.Orbit) {
					let s = .5;
					this.Orbit(t.x * s, t.y * s)
				} else if (i === Ei.Pan) {
					let s = Mi(this.camera.eye, this.camera.center),
						o = .001 * s;
					this.Pan(t.x * o, t.y * o)
				} else if (i === Ei.Zoom) {
					let s = .005;
					this.Zoom(-t.y * s)
				}
				this.Update()
			}
			OnMouseUp(e) {
				if (this.mouse.Up(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.mouse.GetPosition();
					this.Click(e.which, t)
				}
			}
			OnMouseLeave(e) {
				this.mouse.Leave(this.canvas, e), this.clickDetector.Cancel()
			}
			OnTouchStart(e) {
				e.preventDefault(), this.touch.Start(this.canvas, e), this.clickDetector.Start(this.touch.GetPosition())
			}
			OnTouchMove(e) {
				if (e.preventDefault(), this.touch.Move(this.canvas, e), this.clickDetector.Move(this.touch.GetPosition()), !this.touch.IsFingerDown()) return;
				let t = this.touch.GetMoveDiff(),
					n = this.touch.GetDistanceDiff(),
					i = this.touch.GetFingerCount(),
					s = Ei.None;
				if (i === 1 ? s = Ei.Orbit : i === 2 && (s = Ei.Pan), s === Ei.Orbit) {
					let o = .5;
					this.Orbit(t.x * o, t.y * o)
				} else if (s === Ei.Pan) {
					let o = .005;
					this.Zoom(n * o);
					let a = .001 * Mi(this.camera.eye, this.camera.center);
					this.Pan(t.x * a, t.y * a)
				}
				this.Update()
			}
			OnTouchEnd(e) {
				if (e.preventDefault(), this.touch.End(this.canvas, e), this.clickDetector.End(), this.clickDetector.IsClick()) {
					let t = this.touch.GetPosition();
					this.touch.GetFingerCount() === 1 && this.Click(1, t)
				}
			}
			OnMouseWheel(e) {
				let t = e || window.event;
				t.preventDefault();
				let n = -t.deltaY / 40,
					i = .1;
				n < 0 && (i = i * -1), this.Zoom(i), this.Update()
			}
			OnContextMenu(e) {
				e.preventDefault(), this.clickDetector.IsClick() && (this.Context(e.clientX, e.clientY), this.clickDetector.Cancel())
			}
			Orbit(e, t) {
				let n = e * ps,
					i = t * ps,
					s = Un(this.camera.center, this.camera.eye)
					.Normalize(),
					o = Br(s, this.camera.up)
					.Normalize();
				if (this.fixUpVector) {
					let c = yg(s, this.camera.up) + i;
					Jm(c, 0) && yc(c, Math.PI) && this.camera.eye.Rotate(o, -i, this.camera.center), this.camera.eye.Rotate(this.camera.up, -n, this.camera.center)
				} else {
					let a = Br(o, s)
						.Normalize();
					this.camera.eye.Rotate(o, -i, this.camera.center), this.camera.eye.Rotate(a, -n, this.camera.center), this.camera.up = a
				}
			}
			Pan(e, t) {
				let n = Un(this.camera.center, this.camera.eye)
					.Normalize(),
					i = Br(n, this.camera.up)
					.Normalize(),
					s = Br(i, n)
					.Normalize();
				this.camera.eye.Offset(i, -e), this.camera.center.Offset(i, -e), this.camera.eye.Offset(s, t), this.camera.center.Offset(s, t)
			}
			Zoom(e) {
				let t = Un(this.camera.center, this.camera.eye),
					i = t.Length() * e;
				this.camera.eye.Offset(t, i)
			}
			Update() {
				this.callbacks.onUpdate()
			}
			Click(e, t) {
				this.onMouseClick && this.onMouseClick(e, t)
			}
			Context(e, t) {
				if (this.onContext) {
					let n = {
							x: e,
							y: t
						},
						i = oo(this.canvas, e, t);
					this.onContext(n, i)
				}
			}
		};

	function bv(r, e) {
		function t(n, i) {
			for (let s of n) s.polygonOffset = i, s.polygonOffsetUnit = 1, s.polygonOffsetFactor = 1
		}
		t(r.material, e), r.userData.threeMaterials && t(r.userData.threeMaterials, e)
	}
	var Du = class {
			constructor(e) {
				this.scene = e, this.mainObject = null, this.mainEdgeObject = null, this.edgeSettings = {
					showEdges: !1,
					edgeColor: new nt(0, 0, 0),
					edgeThreshold: 1
				}
			}
			SetMainObject(e) {
				this.mainObject = e, this.scene.add(this.mainObject), this.edgeSettings.showEdges && this.GenerateMainEdgeObject()
			}
			UpdateWorldMatrix() {
				this.mainObject !== null && this.mainObject.updateWorldMatrix(!0, !0)
			}
			SetEdgeSettings(e, t, n) {
				let i = !1;
				if (e && (!this.edgeSettings.showEdges || this.edgeSettings.edgeThreshold !== n) && (i = !0), this.edgeSettings.showEdges = e, this.edgeSettings.edgeThreshold = n, this.edgeSettings.edgeColor = t, this.mainObject !== null)
					if (this.edgeSettings.showEdges)
						if (i) this.ClearMainEdgeObject(), this.GenerateMainEdgeObject();
						else {
							let s = Ui(this.edgeSettings.edgeColor);
							this.EnumerateEdges(o => {
								o.material.color = s
							})
						}
				else this.ClearMainEdgeObject()
			}
			GenerateMainEdgeObject() {
				let e = Ui(this.edgeSettings.edgeColor);
				this.mainEdgeObject = new yt, this.UpdateWorldMatrix(), this.EnumerateMeshes(t => {
					bv(t, !0);
					let n = new yu(t.geometry, this.edgeSettings.edgeThreshold),
						i = new Ns(n, new Si({
							color: e
						}));
					i.applyMatrix4(t.matrixWorld), i.userData = t.userData, i.visible = t.visible, this.mainEdgeObject.add(i)
				}), this.scene.add(this.mainEdgeObject)
			}
			GetBoundingBox(e) {
				let t = !1,
					n = new br;
				return this.EnumerateMeshes(i => {
					e(i.userData) && (n.union(new br()
						.setFromObject(i)), t = !0)
				}), t ? n : null
			}
			GetBoundingSphere(e) {
				let t = this.GetBoundingBox(e);
				if (t === null) return null;
				let n = new Kr;
				return t.getBoundingSphere(n), n
			}
			Clear() {
				this.ClearMainObject(), this.ClearMainEdgeObject()
			}
			ClearMainObject() {
				this.mainObject !== null && (this.EnumerateMeshes(e => {
					e.geometry.dispose()
				}), this.scene.remove(this.mainObject), this.mainObject = null)
			}
			ClearMainEdgeObject() {
				this.mainEdgeObject !== null && (this.EnumerateMeshes(e => {
					bv(e, !1)
				}), this.EnumerateEdges(e => {
					e.geometry.dispose()
				}), this.scene.remove(this.mainEdgeObject), this.mainEdgeObject = null)
			}
			EnumerateMeshes(e) {
				this.mainObject !== null && this.mainObject.traverse(t => {
					t.isMesh && e(t)
				})
			}
			EnumerateEdges(e) {
				this.mainEdgeObject !== null && this.mainEdgeObject.traverse(t => {
					t.isLineSegments && e(t)
				})
			}
			GetMeshIntersectionUnderMouse(e, t, n, i) {
				if (this.mainObject === null || e.x < 0 || e.x > n || e.y < 0 || e.y > i) return null;
				let s = new Su,
					o = new st;
				o.x = e.x / n * 2 - 1, o.y = -(e.y / i) * 2 + 1, s.setFromCamera(o, t);
				let a = s.intersectObject(this.mainObject, !0);
				for (let c = 0; c < a.length; c++) {
					let l = a[c];
					if (l.object.type === "Mesh" && l.object.visible) return l
				}
				return null
			}
		},
		Ou = class {
			constructor(e) {
				this.scene = e, this.mainObject = null
			}
			AddObject(e) {
				this.mainObject === null && (this.mainObject = new yt, this.scene.add(this.mainObject)), this.mainObject.add(e)
			}
			Clear() {
				this.mainObject !== null && (this.mainObject.traverse(e => {
					(e.isMesh || e.isLineSegments) && e.geometry.dispose()
				}), this.scene.remove(this.mainObject), this.mainObject = null)
			}
		};
	var Nn = {
		Perspective: 1,
		Orthographic: 2
	};

	function Mv(r) {
		let e = 45;
		return r === lt.X ? new xr(new Le(2, -3, 1.5), new Le(0, 0, 0), new Le(1, 0, 0), e) : r === lt.Y ? new xr(new Le(-1.5, 2, 3), new Le(0, 0, 0), new Le(0, 1, 0), e) : r === lt.Z ? new xr(new Le(-1.5, -3, 2), new Le(0, 0, 0), new Le(0, 0, 1), e) : null
	}

	function wv(r, e) {
		if (!e(r)) return !1;
		for (let t of r.children)
			if (!wv(t, e)) return !1;
		return !0
	}

	function qS(r) {
		let e = null;
		return wv(r, t => {
			if (t.isMesh)
				for (let n of t.material) return n.type === "MeshPhongMaterial" ? e = wn.Phong : n.type === "MeshStandardMaterial" && (e = wn.Physical), !1;
			return !0
		}), e
	}
	var ep = class {
			constructor() {
				this.eyeCenterDistance = 0, this.forceUpdate = !0
			}
			ForceUpdate() {
				this.forceUpdate = !0
			}
			ValidatePerspective() {
				return this.forceUpdate ? (this.forceUpdate = !1, !1) : !0
			}
			ValidateOrthographic(e) {
				return this.forceUpdate || !Yt(this.eyeCenterDistance, e) ? (this.eyeCenterDistance = e, this.forceUpdate = !1, !1) : !0
			}
		},
		tp = class {
			constructor() {
				this.direction = lt.Z, this.isFixed = !0, this.isFlipped = !1
			}
			SetDirection(e, t) {
				this.direction = e, this.isFlipped = !1;
				let n = Mv(this.direction),
					i = Un(n.eye, n.center),
					s = Mi(t.center, t.eye),
					o = t.center.Clone()
					.Offset(i, s),
					a = t.Clone();
				return this.direction === lt.X ? (a.up = new Le(1, 0, 0), a.eye = o) : this.direction === lt.Y ? (a.up = new Le(0, 1, 0), a.eye = o) : this.direction === lt.Z && (a.up = new Le(0, 0, 1), a.eye = o), a
			}
			SetFixed(e, t) {
				return this.isFixed = e, this.isFixed ? this.SetDirection(this.direction, t) : null
			}
			Flip(e) {
				this.isFlipped = !this.isFlipped;
				let t = e.Clone();
				return t.up.MultiplyScalar(-1), t
			}
		},
		np = class {
			constructor(e) {
				this.scene = e, this.type = wn.Phong, this.cameraMode = Nn.Perspective, this.ambientLight = new Sr(8947848), this.directionalLight = new Tr(8947848), this.environment = null, this.backgroundIsEnvMap = !1, this.scene.add(this.ambientLight), this.scene.add(this.directionalLight)
			}
			SetShadingType(e) {
				this.type = e, this.UpdateShading()
			}
			SetCameraMode(e) {
				this.cameraMode = e, this.UpdateShading()
			}
			UpdateShading() {
				this.type === wn.Phong ? (this.ambientLight.color.set(8947848), this.directionalLight.color.set(8947848), this.scene.environment = null) : this.type === wn.Physical && (this.ambientLight.color.set(0), this.directionalLight.color.set(5592405), this.scene.environment = this.environment), this.backgroundIsEnvMap && this.cameraMode === Nn.Perspective ? this.scene.background = this.environment : this.scene.background = null
			}
			SetEnvironment(e, t, n) {
				let i = new wu;
				this.environment = i.load(e, () => {
					n()
				}), this.backgroundIsEnvMap = t
			}
			UpdateByCamera(e) {
				let t = Un(e.eye, e.center);
				this.directionalLight.position.set(t.x, t.y, t.z)
			}
			CreateHighlightMaterial(e, t) {
				let n = null;
				return this.type === wn.Phong ? n = new an({
					color: e,
					side: Bn
				}) : this.type === wn.Physical && (n = new ks({
					color: e,
					side: Bn
				})), n !== null && t && (n.polygonOffset = !0, n.polygonOffsetUnit = 1, n.polygonOffsetFactor = 1), n
			}
		},
		Ea = class {
			constructor() {
				this.canvas = null, this.renderer = null, this.scene = null, this.geometry = null, this.extraGeometry = null, this.camera = null, this.cameraMode = null, this.cameraValidator = null, this.shadingModel = null, this.navigation = null, this.upVector = null, this.settings = {
					animationSteps: 40
				}
			}
			Init(e) {
				this.canvas = e, this.canvas.id = "viewer";
				let t = {
					canvas: this.canvas,
					antialias: !0
				};
				this.renderer = new kl(t), window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setClearColor("#ffffff", 1), this.renderer.setSize(this.canvas.width, this.canvas.height), this.scene = new wr, this.geometry = new Du(this.scene), this.extraGeometry = new Ou(this.scene), this.InitNavigation(), this.InitShading(), this.Render()
			}
			SetMouseClickHandler(e) {
				this.navigation.SetMouseClickHandler(e)
			}
			SetMouseMoveHandler(e) {
				this.navigation.SetMouseMoveHandler(e)
			}
			SetContextMenuHandler(e) {
				this.navigation.SetContextMenuHandler(e)
			}
			SetEnvironmentMapSettings(e, t) {
				this.shadingModel.SetEnvironment(e, t, () => {
					this.Render()
				}), this.shadingModel.UpdateShading(), this.Render()
			}
			SetBackgroundColor(e) {
				let t = new Xe(lo(e.r), lo(e.g), lo(e.b)),
					n = lo(e.a);
				this.renderer.setClearColor(t, n), this.Render()
			}
			SetEdgeSettings(e, t, n) {
				this.geometry.SetEdgeSettings(e, t, n), this.Render()
			}
			GetCanvas() {
				return this.canvas
			}
			GetCamera() {
				return this.navigation.GetCamera()
			}
			GetCameraMode() {
				return this.cameraMode
			}
			SetCamera(e) {
				this.navigation.SetCamera(e), this.cameraValidator.ForceUpdate(), this.Render()
			}
			SetCameraMode(e) {
				this.cameraMode !== e && (this.scene.remove(this.camera), e === Nn.Perspective ? this.camera = new Kt(45, 1, .1, 1e3) : e === Nn.Orthographic && (this.camera = new Mr(-1, 1, 1, -1, .1, 1e3)), this.scene.add(this.camera), this.cameraMode = e, this.shadingModel.SetCameraMode(e), this.cameraValidator.ForceUpdate(), this.AdjustClippingPlanes(), this.Render())
			}
			Resize(e, t) {
				let n = eg(this.canvas, e, t);
				this.ResizeRenderer(n.width, n.height)
			}
			ResizeRenderer(e, t) {
				window.devicePixelRatio && this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(e, t), this.cameraValidator.ForceUpdate(), this.Render()
			}
			FitSphereToWindow(e, t) {
				if (e === null) return;
				let n = new Le(e.center.x, e.center.y, e.center.z),
					i = e.radius,
					s = this.navigation.GetFitToSphereCamera(n, i);
				this.navigation.MoveCamera(s, t ? this.settings.animationSteps : 0)
			}
			AdjustClippingPlanes() {
				let e = this.GetBoundingSphere(t => !0);
				this.AdjustClippingPlanesToSphere(e)
			}
			AdjustClippingPlanesToSphere(e) {
				e !== null && (e.radius < 10 ? (this.camera.near = .01, this.camera.far = 100) : e.radius < 100 ? (this.camera.near = .1, this.camera.far = 1e3) : e.radius < 1e3 ? (this.camera.near = 10, this.camera.far = 1e4) : (this.camera.near = 100, this.camera.far = 1e6), this.cameraValidator.ForceUpdate(), this.Render())
			}
			IsFixUpVector() {
				return this.navigation.IsFixUpVector()
			}
			SetFixUpVector(e) {
				let t = this.navigation.GetCamera(),
					n = this.upVector.SetFixed(e, t);
				this.navigation.SetFixUpVector(e), n !== null && this.navigation.MoveCamera(n, this.settings.animationSteps), this.Render()
			}
			SetUpVector(e, t) {
				let n = this.navigation.GetCamera(),
					i = this.upVector.SetDirection(e, n),
					s = t ? this.settings.animationSteps : 0;
				this.navigation.MoveCamera(i, s), this.Render()
			}
			FlipUpVector() {
				let e = this.navigation.GetCamera(),
					t = this.upVector.Flip(e);
				this.navigation.MoveCamera(t, 0), this.Render()
			}
			Render() {
				let e = this.navigation.GetCamera();
				if (this.camera.position.set(e.eye.x, e.eye.y, e.eye.z), this.camera.up.set(e.up.x, e.up.y, e.up.z), this.camera.lookAt(new ne(e.center.x, e.center.y, e.center.z)), this.cameraMode === Nn.Perspective) this.cameraValidator.ValidatePerspective() || (this.camera.aspect = this.canvas.width / this.canvas.height, this.camera.fov = e.fov, this.camera.updateProjectionMatrix());
				else if (this.cameraMode === Nn.Orthographic) {
					let t = Mi(e.eye, e.center);
					if (!this.cameraValidator.ValidateOrthographic(t)) {
						let n = this.canvas.width / this.canvas.height,
							s = Mi(e.eye, e.center) * Math.tan(.5 * e.fov * ps);
						this.camera.left = -s * n, this.camera.right = s * n, this.camera.top = s, this.camera.bottom = -s, this.camera.updateProjectionMatrix()
					}
				}
				this.shadingModel.UpdateByCamera(e), this.renderer.render(this.scene, this.camera)
			}
			SetMainObject(e) {
				let t = qS(e);
				this.geometry.SetMainObject(e), this.shadingModel.SetShadingType(t), this.Render()
			}
			AddExtraObject(e) {
				this.extraGeometry.AddObject(e), this.Render()
			}
			Clear() {
				this.geometry.Clear(), this.extraGeometry.Clear(), this.Render()
			}
			ClearExtra() {
				this.extraGeometry.Clear(), this.Render()
			}
			SetMeshesVisibility(e) {
				this.geometry.EnumerateMeshes(t => {
					let n = e(t.userData);
					t.visible !== n && (t.visible = n)
				}), this.geometry.EnumerateEdges(t => {
					let n = e(t.userData);
					t.visible !== n && (t.visible = n)
				}), this.Render()
			}
			SetMeshesHighlight(e, t) {
				function n(s, o) {
					let a = [];
					for (let c = 0; c < s.length; c++) a.push(o);
					return a
				}
				let i = this.CreateHighlightMaterial(e);
				this.geometry.EnumerateMeshes(s => {
					t(s.userData) ? s.userData.threeMaterials === null && (s.userData.threeMaterials = s.material, s.material = n(s.material, i)) : s.userData.threeMaterials !== null && (s.material = s.userData.threeMaterials, s.userData.threeMaterials = null)
				}), this.Render()
			}
			CreateHighlightMaterial(e) {
				let t = this.geometry.edgeSettings.showEdges;
				return this.shadingModel.CreateHighlightMaterial(e, t)
			}
			GetMeshUserDataUnderMouse(e) {
				let t = this.GetMeshIntersectionUnderMouse(e);
				return t === null ? null : t.object.userData
			}
			GetMeshIntersectionUnderMouse(e) {
				let t = this.GetCanvasSize(),
					n = this.geometry.GetMeshIntersectionUnderMouse(e, this.camera, t.width, t.height);
				return n === null ? null : n
			}
			GetBoundingBox(e) {
				return this.geometry.GetBoundingBox(e)
			}
			GetBoundingSphere(e) {
				return this.geometry.GetBoundingSphere(e)
			}
			EnumerateMeshesUserData(e) {
				this.geometry.EnumerateMeshes(t => {
					e(t.userData)
				})
			}
			InitNavigation() {
				let e = Mv(lt.Z);
				this.camera = new Kt(45, 1, .1, 1e3), this.cameraMode = Nn.Perspective, this.cameraValidator = new ep, this.scene.add(this.camera);
				let t = this.renderer.domElement;
				this.navigation = new Nu(t, e, {
					onUpdate: () => {
						this.Render()
					}
				}), this.upVector = new tp
			}
			InitShading() {
				this.shadingModel = new np(this.scene)
			}
			GetShadingType() {
				return this.shadingModel.type
			}
			GetImageSize() {
				let e = new st;
				return this.renderer.getSize(e), {
					width: parseInt(e.x, 10),
					height: parseInt(e.y, 10)
				}
			}
			GetCanvasSize() {
				let e = this.canvas.width,
					t = this.canvas.height;
				return window.devicePixelRatio && (e /= window.devicePixelRatio, t /= window.devicePixelRatio), {
					width: e,
					height: t
				}
			}
			GetImageAsDataUrl(e, t) {
				let n = this.GetImageSize(),
					i = e,
					s = t;
				window.devicePixelRatio && (i /= window.devicePixelRatio, s /= window.devicePixelRatio), this.ResizeRenderer(i, s), this.Render();
				let o = this.renderer.domElement.toDataURL();
				return this.ResizeRenderer(n.width, n.height), o
			}
		};
	var Tn = {
			IntegerToString(r) {
				return r.toString()
			},
			StringToInteger(r) {
				return parseInt(r, 10)
			},
			NumberToString(r) {
				let e = 5;
				return r.toFixed(e)
			},
			StringToNumber(r) {
				return parseFloat(r)
			},
			ModelUrlsToString: function(r) {
				return r === null ? null : r.join(",")
			},
			StringToModelUrls: function(r) {
				return r === null || r.length === 0 ? null : r.split(",")
			},
			CameraToString: function(r) {
				return r === null ? null : [this.NumberToString(r.eye.x), this.NumberToString(r.eye.y), this.NumberToString(r.eye.z), this.NumberToString(r.center.x), this.NumberToString(r.center.y), this.NumberToString(r.center.z), this.NumberToString(r.up.x), this.NumberToString(r.up.y), this.NumberToString(r.up.z), this.NumberToString(r.fov)].join(",")
			},
			CameraModeToString: function(r) {
				return r === Nn.Perspective ? "perspective" : r === Nn.Orthographic ? "orthographic" : null
			},
			StringToCamera: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				if (e.length !== 9 && e.length !== 10) return null;
				let t = 45;
				return e.length >= 10 && (t = this.StringToNumber(e[9])), new xr(new Le(this.StringToNumber(e[0]), this.StringToNumber(e[1]), this.StringToNumber(e[2])), new Le(this.StringToNumber(e[3]), this.StringToNumber(e[4]), this.StringToNumber(e[5])), new Le(this.StringToNumber(e[6]), this.StringToNumber(e[7]), this.StringToNumber(e[8])), t)
			},
			StringToCameraMode: function(r) {
				return r === "perspective" ? Nn.Perspective : r === "orthographic" ? Nn.Orthographic : null
			},
			RGBColorToString: function(r) {
				return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b)].join(",")
			},
			RGBAColorToString: function(r) {
				return r === null ? null : [this.IntegerToString(r.r), this.IntegerToString(r.g), this.IntegerToString(r.b), this.IntegerToString(r.a)].join(",")
			},
			StringToRGBColor: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 3 ? null : new nt(this.StringToInteger(e[0]), this.StringToInteger(e[1]), this.StringToInteger(e[2]))
			},
			StringToRGBAColor: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				if (e.length !== 3 && e.length !== 4) return null;
				let t = new Qn(this.StringToInteger(e[0]), this.StringToInteger(e[1]), this.StringToInteger(e[2]), 255);
				return e.length === 4 && (t.a = this.StringToInteger(e[3])), t
			},
			EnvironmentSettingsToString(r) {
				return r === null ? null : [r.environmentMapName, r.backgroundIsEnvMap ? "on" : "off"].join(",")
			},
			StringToEnvironmentSettings: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 2 ? null : {
					environmentMapName: e[0],
					backgroundIsEnvMap: e[1] === "on"
				}
			},
			EdgeSettingsToString: function(r) {
				return r === null ? null : [r.showEdges ? "on" : "off", this.RGBColorToString(r.edgeColor), this.IntegerToString(r.edgeThreshold)].join(",")
			},
			StringToEdgeSettings: function(r) {
				if (r === null || r.length === 0) return null;
				let e = r.split(",");
				return e.length !== 5 ? null : {
					showEdges: e[0] === "on",
					edgeColor: new nt(this.StringToInteger(e[1]), this.StringToInteger(e[2]), this.StringToInteger(e[3])),
					edgeThreshold: this.StringToInteger(e[4])
				}
			}
		},
		ip = class {
			constructor(e) {
				this.separator = e, this.paramList = ""
			}
			AddModelUrls(e) {
				return this.AddUrlPart("model", Tn.ModelUrlsToString(e)), this
			}
			AddCamera(e) {
				return this.AddUrlPart("camera", Tn.CameraToString(e)), this
			}
			AddCameraMode(e) {
				return this.AddUrlPart("cameramode", Tn.CameraModeToString(e)), this
			}
			AddEnvironmentSettings(e) {
				return this.AddUrlPart("envsettings", Tn.EnvironmentSettingsToString(e)), this
			}
			AddBackgroundColor(e) {
				return this.AddUrlPart("backgroundcolor", Tn.RGBAColorToString(e)), this
			}
			AddDefaultColor(e) {
				return this.AddUrlPart("defaultcolor", Tn.RGBColorToString(e)), this
			}
			AddEdgeSettings(e) {
				return this.AddUrlPart("edgesettings", Tn.EdgeSettingsToString(e)), this
			}
			AddUrlPart(e, t) {
				e === null || t === null || (this.paramList.length > 0 && (this.paramList += this.separator), this.paramList += e + "=" + t)
			}
			GetParameterList() {
				return this.paramList
			}
		},
		rp = class {
			constructor(e, t) {
				this.separator = t, this.paramList = e
			}
			GetModelUrls() {
				if (this.paramList.indexOf("=") === -1) return this.paramList.split(",");
				let e = this.GetKeywordParams("model");
				return Tn.StringToModelUrls(e)
			}
			GetCamera() {
				let e = this.GetKeywordParams("camera");
				return Tn.StringToCamera(e)
			}
			GetCameraMode() {
				let e = this.GetKeywordParams("cameramode");
				return Tn.StringToCameraMode(e)
			}
			GetEnvironmentSettings() {
				let e = this.GetKeywordParams("envsettings");
				return Tn.StringToEnvironmentSettings(e)
			}
			GetBackgroundColor() {
				let e = this.GetKeywordParams("backgroundcolor");
				return Tn.StringToRGBAColor(e)
			}
			GetDefaultColor() {
				let e = this.GetKeywordParams("defaultcolor");
				return Tn.StringToRGBColor(e)
			}
			GetEdgeSettings() {
				let e = this.GetKeywordParams("edgesettings");
				return Tn.StringToEdgeSettings(e)
			}
			GetKeywordParams(e) {
				if (this.paramList === null || this.paramList.length === 0) return null;
				let t = e + "=",
					n = this.paramList.split(this.separator);
				for (let i = 0; i < n.length; i++) {
					let s = n[i];
					if (s.startsWith(t)) return s.substring(t.length)
				}
				return null
			}
		};

	function ku() {
		return new ip("$")
	}

	function zs(r) {
		return new rp(r, "$")
	}

	function Fu(r) {
		let e = ku();
		return e.AddModelUrls(r), e.GetParameterList()
	}
	var lr = {
			Url: 1,
			File: 2,
			Decompressed: 3
		},
		Dt = {
			Text: 1,
			Binary: 2
		};

	function Sn(r) {
		let e = r.lastIndexOf("/");
		e === -1 && (e = r.lastIndexOf("\\"));
		let t = r;
		e !== -1 && (t = r.substring(e + 1));
		let n = t.indexOf("?");
		return n !== -1 && (t = t.substring(0, n)), decodeURI(t)
	}

	function cr(r) {
		let e = Sn(r),
			t = e.lastIndexOf(".");
		return t === -1 ? "" : e.substring(t + 1)
			.toLowerCase()
	}

	function Tv(r, e) {
		return new Promise((t, n) => {
			let i = new XMLHttpRequest;
			i.open("GET", r, !0), i.onprogress = s => {
				e(s.loaded, s.total)
			}, i.onload = () => {
				i.status === 200 ? t(i.response) : n()
			}, i.onerror = () => {
				n()
			}, i.responseType = "arraybuffer", i.send(null)
		})
	}

	function Sv(r, e) {
		return new Promise((t, n) => {
			let i = new FileReader;
			i.onprogress = s => {
				e(s.loaded, s.total)
			}, i.onloadend = s => {
				s.target.readyState === FileReader.DONE && t(s.target.result)
			}, i.onerror = () => {
				n()
			}, i.readAsArrayBuffer(r)
		})
	}

	function Uu(r) {
		for (let e = 0; e < r.length; e++) {
			let t = r[e];
			if (t.search(/www\.dropbox\.com/u) !== -1) {
				t = t.replace("www.dropbox.com", "dl.dropbox.com");
				let n = t.indexOf("?");
				n !== -1 && (t = t.substring(0, n)), r[e] = t
			} else if (t.search(/github\.com/u) !== -1) {
				t = t.replace("github.com", "raw.githubusercontent.com"), t = t.replace("/blob", "");
				let n = t.indexOf("?");
				n !== -1 && (t = t.substring(0, n)), r[e] = t
			}
		}
	}

	function Ev(r) {
		let e = /^https?:\/\/\S+$/g;
		return r.match(e) !== null
	}
	var Bu = class {
		constructor() {
			this.count = null, this.current = null, this.callbacks = null
		}
		Run(e, t) {
			this.count = e, this.current = 0, this.callbacks = t, e === 0 ? this.TaskReady() : this.RunOnce()
		}
		RunBatch(e, t, n) {
			let i = 0;
			e > 0 && (i = parseInt((e - 1) / t, 10) + 1), this.Run(i, {
				runTask: (s, o) => {
					let a = s * t,
						c = Math.min((s + 1) * t, e) - 1;
					n.runTask(a, c, o)
				},
				onReady: n.onReady
			})
		}
		RunOnce() {
			setTimeout(() => {
				this.callbacks.runTask(this.current, this.TaskReady.bind(this))
			}, 0)
		}
		TaskReady() {
			this.current += 1, this.current < this.count ? this.RunOnce() : this.callbacks.onReady && this.callbacks.onReady()
		}
	};

	function Ao(r) {
		setTimeout(() => {
			r()
		}, 10)
	}

	function Cv(r, e) {
		new Bu()
			.Run(r, e)
	}

	function Av(r, e, t) {
		new Bu()
			.RunBatch(r, e, t)
	}

	function Iv(r) {
		function e(t) {
			t() && setTimeout(() => {
				e(t)
			}, 10)
		}
		e(r)
	}
	var Gu = class {
		constructor(e, t, n) {
			this.name = e, this.source = t, this.data = n
		}
	};

	function Vu(r) {
		let e = [];
		for (let t of r) {
			let n = Sn(t);
			e.push(new Gu(n, lr.Url, t))
		}
		return e
	}

	function Rv(r) {
		let e = [];
		for (let t of r) {
			let n = Sn(t.name);
			e.push(new Gu(n, lr.File, t))
		}
		return e
	}
	var Fl = class {
			constructor(e, t, n) {
				this.name = Sn(e), this.extension = cr(e), this.source = t, this.data = n, this.content = null
			}
			SetContent(e) {
				this.content = e
			}
		},
		Ul = class {
			constructor() {
				this.files = []
			}
			FillFromInputFiles(e) {
				this.files = [];
				for (let t of e) {
					let n = new Fl(t.name, t.source, t.data);
					this.files.push(n)
				}
			}
			ExtendFromFileList(e) {
				let t = e.GetFiles();
				for (let n = 0; n < t.length; n++) {
					let i = t[n];
					this.ContainsFileByPath(i.name) || this.files.push(i)
				}
			}
			GetFiles() {
				return this.files
			}
			GetContent(e) {
				Cv(this.files.length, {
					runTask: (t, n) => {
						e.onFileListProgress(t, this.files.length), this.GetFileContent(this.files[t], {
							onReady: n,
							onProgress: e.onFileLoadProgress
						})
					},
					onReady: e.onReady
				})
			}
			ContainsFileByPath(e) {
				return this.FindFileByPath(e) !== null
			}
			FindFileByPath(e) {
				let t = Sn(e)
					.toLowerCase();
				for (let n = 0; n < this.files.length; n++) {
					let i = this.files[n];
					if (i.name.toLowerCase() === t) return i
				}
				return null
			}
			IsOnlyUrlSource() {
				if (this.files.length === 0) return !1;
				for (let e = 0; e < this.files.length; e++) {
					let t = this.files[e];
					if (t.source !== lr.Url && t.source !== lr.Decompressed) return !1
				}
				return !0
			}
			AddFile(e) {
				this.files.push(e)
			}
			GetFileContent(e, t) {
				if (e.content !== null) {
					t.onReady();
					return
				}
				let n = null;
				if (e.source === lr.Url) n = Tv(e.data, t.onProgress);
				else if (e.source === lr.File) n = Sv(e.data, t.onProgress);
				else {
					t.onReady();
					return
				}
				n.then(i => {
						e.SetContent(i)
					})
					.catch(() => {})
					.finally(() => {
						t.onReady()
					})
			}
		};
	var di = class {
		constructor(e, t, n, i) {
			this.x = e, this.y = t, this.z = n, this.w = i
		}
	};

	function Ca(r) {
		return new di(r[0], r[1], r[2], r[3])
	}

	function Pv(r, e) {
		let t = e / 2,
			n = Math.sin(t);
		return new di(r.x * n, r.y * n, r.z * n, Math.cos(t))
	}
	var ur = class {
		constructor(e, t, n, i) {
			this.x = e, this.y = t, this.z = n, this.w = i
		}
		Clone() {
			return new ur(this.x, this.y, this.z, this.w)
		}
	};
	var kt = class {
		constructor(e) {
			this.matrix = null, e != null && (this.matrix = e)
		}
		IsValid() {
			return this.matrix !== null
		}
		Set(e) {
			return this.matrix = e, this
		}
		Get() {
			return this.matrix
		}
		Clone() {
			let e = [this.matrix[0], this.matrix[1], this.matrix[2], this.matrix[3], this.matrix[4], this.matrix[5], this.matrix[6], this.matrix[7], this.matrix[8], this.matrix[9], this.matrix[10], this.matrix[11], this.matrix[12], this.matrix[13], this.matrix[14], this.matrix[15]];
			return new kt(e)
		}
		CreateIdentity() {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], this
		}
		IsIdentity() {
			let e = new kt()
				.CreateIdentity()
				.Get();
			for (let t = 0; t < 16; t++)
				if (!Yt(this.matrix[t], e[t])) return !1;
			return !0
		}
		CreateTranslation(e, t, n) {
			return this.matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, n, 1], this
		}
		CreateRotation(e, t, n, i) {
			let s = e + e,
				o = t + t,
				a = n + n,
				c = e * s,
				l = e * o,
				u = e * a,
				h = t * o,
				f = t * a,
				p = n * a,
				g = i * s,
				m = i * o,
				d = i * a;
			return this.matrix = [1 - (h + p), l + d, u - m, 0, l - d, 1 - (c + p), f + g, 0, u + m, f - g, 1 - (c + h), 0, 0, 0, 0, 1], this
		}
		CreateRotationAxisAngle(e, t) {
			let n = Pv(e, t);
			return this.CreateRotation(n.x, n.y, n.z, n.w)
		}
		CreateScale(e, t, n) {
			return this.matrix = [e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1], this
		}
		ComposeTRS(e, t, n) {
			let i = e.x,
				s = e.y,
				o = e.z,
				a = t.x,
				c = t.y,
				l = t.z,
				u = t.w,
				h = n.x,
				f = n.y,
				p = n.z,
				g = a + a,
				m = c + c,
				d = l + l,
				v = a * g,
				x = a * m,
				_ = a * d,
				y = c * m,
				w = c * d,
				C = l * d,
				S = u * g,
				b = u * m,
				T = u * d;
			return this.matrix = [(1 - (y + C)) * h, (x + T) * h, (_ - b) * h, 0, (x - T) * f, (1 - (v + C)) * f, (w + S) * f, 0, (_ + b) * p, (w - S) * p, (1 - (v + y)) * p, 0, i, s, o, 1], this
		}
		DecomposeTRS() {
			let e = new Le(this.matrix[12], this.matrix[13], this.matrix[14]),
				t = Pc(this.matrix[0], this.matrix[1], this.matrix[2]),
				n = Pc(this.matrix[4], this.matrix[5], this.matrix[6]),
				i = Pc(this.matrix[8], this.matrix[9], this.matrix[10]),
				s = this.Determinant();
			ro(s) && (t *= -1);
			let o = new Le(t, n, i),
				a = this.matrix[0] / t,
				c = this.matrix[4] / n,
				l = this.matrix[8] / i,
				u = this.matrix[1] / t,
				h = this.matrix[5] / n,
				f = this.matrix[9] / i,
				p = this.matrix[2] / t,
				g = this.matrix[6] / n,
				m = this.matrix[10] / i,
				d = null,
				v = a + h + m;
			if (v > 0) {
				let x = Math.sqrt(v + 1) * 2;
				d = new di((g - f) / x, (l - p) / x, (u - c) / x, .25 * x)
			} else if (a > h && a > m) {
				let x = Math.sqrt(1 + a - h - m) * 2;
				d = new di(.25 * x, (c + u) / x, (l + p) / x, (g - f) / x)
			} else if (h > m) {
				let x = Math.sqrt(1 + h - a - m) * 2;
				d = new di((c + u) / x, .25 * x, (f + g) / x, (l - p) / x)
			} else {
				let x = Math.sqrt(1 + m - a - h) * 2;
				d = new di((l + p) / x, (f + g) / x, .25 * x, (u - c) / x)
			}
			return {
				translation: e,
				rotation: d,
				scale: o
			}
		}
		Determinant() {
			let e = this.matrix[0],
				t = this.matrix[1],
				n = this.matrix[2],
				i = this.matrix[3],
				s = this.matrix[4],
				o = this.matrix[5],
				a = this.matrix[6],
				c = this.matrix[7],
				l = this.matrix[8],
				u = this.matrix[9],
				h = this.matrix[10],
				f = this.matrix[11],
				p = this.matrix[12],
				g = this.matrix[13],
				m = this.matrix[14],
				d = this.matrix[15],
				v = e * o - t * s,
				x = e * a - n * s,
				_ = e * c - i * s,
				y = t * a - n * o,
				w = t * c - i * o,
				C = n * c - i * a,
				S = l * g - u * p,
				b = l * m - h * p,
				T = l * d - f * p,
				N = u * m - h * g,
				V = u * d - f * g,
				O = h * d - f * m;
			return v * O - x * V + _ * N + y * T - w * b + C * S
		}
		Invert() {
			let e = this.matrix[0],
				t = this.matrix[1],
				n = this.matrix[2],
				i = this.matrix[3],
				s = this.matrix[4],
				o = this.matrix[5],
				a = this.matrix[6],
				c = this.matrix[7],
				l = this.matrix[8],
				u = this.matrix[9],
				h = this.matrix[10],
				f = this.matrix[11],
				p = this.matrix[12],
				g = this.matrix[13],
				m = this.matrix[14],
				d = this.matrix[15],
				v = e * o - t * s,
				x = e * a - n * s,
				_ = e * c - i * s,
				y = t * a - n * o,
				w = t * c - i * o,
				C = n * c - i * a,
				S = l * g - u * p,
				b = l * m - h * p,
				T = l * d - f * p,
				N = u * m - h * g,
				V = u * d - f * g,
				O = h * d - f * m,
				k = v * O - x * V + _ * N + y * T - w * b + C * S;
			if (Yt(k, 0)) return null;
			let I = [(o * O - a * V + c * N) / k, (n * V - t * O - i * N) / k, (g * C - m * w + d * y) / k, (h * w - u * C - f * y) / k, (a * T - s * O - c * b) / k, (e * O - n * T + i * b) / k, (m * _ - p * C - d * x) / k, (l * C - h * _ + f * x) / k, (s * V - o * T + c * S) / k, (t * T - e * V - i * S) / k, (p * w - g * _ + d * v) / k, (u * _ - l * w - f * v) / k, (o * b - s * N - a * S) / k, (e * N - t * b + n * S) / k, (g * x - p * y - m * v) / k, (l * y - u * x + h * v) / k];
			return new kt(I)
		}
		Transpose() {
			let e = [this.matrix[0], this.matrix[4], this.matrix[8], this.matrix[12], this.matrix[1], this.matrix[5], this.matrix[9], this.matrix[13], this.matrix[2], this.matrix[6], this.matrix[10], this.matrix[14], this.matrix[3], this.matrix[7], this.matrix[11], this.matrix[15]];
			return new kt(e)
		}
		InvertTranspose() {
			let e = this.Invert();
			return e === null ? null : e.Transpose()
		}
		MultiplyVector(e) {
			let t = e.x,
				n = e.y,
				i = e.z,
				s = e.w,
				o = this.matrix[0],
				a = this.matrix[1],
				c = this.matrix[2],
				l = this.matrix[3],
				u = this.matrix[4],
				h = this.matrix[5],
				f = this.matrix[6],
				p = this.matrix[7],
				g = this.matrix[8],
				m = this.matrix[9],
				d = this.matrix[10],
				v = this.matrix[11],
				x = this.matrix[12],
				_ = this.matrix[13],
				y = this.matrix[14],
				w = this.matrix[15];
			return new ur(t * o + n * u + i * g + s * x, t * a + n * h + i * m + s * _, t * c + n * f + i * d + s * y, t * l + n * p + i * v + s * w)
		}
		MultiplyMatrix(e) {
			let t = this.matrix[0],
				n = this.matrix[1],
				i = this.matrix[2],
				s = this.matrix[3],
				o = this.matrix[4],
				a = this.matrix[5],
				c = this.matrix[6],
				l = this.matrix[7],
				u = this.matrix[8],
				h = this.matrix[9],
				f = this.matrix[10],
				p = this.matrix[11],
				g = this.matrix[12],
				m = this.matrix[13],
				d = this.matrix[14],
				v = this.matrix[15],
				x = e.matrix[0],
				_ = e.matrix[1],
				y = e.matrix[2],
				w = e.matrix[3],
				C = e.matrix[4],
				S = e.matrix[5],
				b = e.matrix[6],
				T = e.matrix[7],
				N = e.matrix[8],
				V = e.matrix[9],
				O = e.matrix[10],
				k = e.matrix[11],
				I = e.matrix[12],
				q = e.matrix[13],
				B = e.matrix[14],
				Y = e.matrix[15],
				J = [t * x + n * C + i * N + s * I, t * _ + n * S + i * V + s * q, t * y + n * b + i * O + s * B, t * w + n * T + i * k + s * Y, o * x + a * C + c * N + l * I, o * _ + a * S + c * V + l * q, o * y + a * b + c * O + l * B, o * w + a * T + c * k + l * Y, u * x + h * C + f * N + p * I, u * _ + h * S + f * V + p * q, u * y + h * b + f * O + p * B, u * w + h * T + f * k + p * Y, g * x + m * C + d * N + v * I, g * _ + m * S + d * V + v * q, g * y + m * b + d * O + v * B, g * w + m * T + d * k + v * Y];
			return new kt(J)
		}
	};
	var Jt = class {
		constructor(e) {
			e != null ? this.matrix = e : (this.matrix = new kt, this.matrix.CreateIdentity())
		}
		SetMatrix(e) {
			return this.matrix = e, this
		}
		GetMatrix() {
			return this.matrix
		}
		IsIdentity() {
			return this.matrix.IsIdentity()
		}
		AppendMatrix(e) {
			return this.matrix = this.matrix.MultiplyMatrix(e), this
		}
		Append(e) {
			return this.AppendMatrix(e.GetMatrix()), this
		}
		TransformCoord3D(e) {
			let t = new ur(e.x, e.y, e.z, 1),
				n = this.matrix.MultiplyVector(t);
			return new Le(n.x, n.y, n.z)
		}
		Clone() {
			let e = this.matrix.Clone();
			return new Jt(e)
		}
	};
	var Hs = {
		Empty: 0,
		TriangleMesh: 1
	};

	function Aa(r) {
		return r.TriangleCount() > 0 ? Hs.TriangleMesh : Hs.Empty
	}

	function Bl(r, e, t) {
		let n = Un(e, r),
			i = Un(t, r),
			s = Br(n, i);
		return s.Normalize(), s
	}

	function Ws(r, e) {
		if (!e.IsIdentity()) {
			for (let t = 0; t < r.VertexCount(); t++) {
				let n = r.GetVertex(t),
					i = e.TransformCoord3D(n);
				n.x = i.x, n.y = i.y, n.z = i.z
			}
			if (r.NormalCount() > 0) {
				let t = e.GetMatrix()
					.InvertTranspose();
				if (t !== null) {
					let n = new Jt(t);
					for (let i = 0; i < r.NormalCount(); i++) {
						let s = r.GetNormal(i),
							o = n.TransformCoord3D(s);
						s.x = o.x, s.y = o.y, s.z = o.z
					}
				}
			}
		}
	}

	function Lv(r) {
		for (let e = 0; e < r.TriangleCount(); e++) {
			let t = r.GetTriangle(e),
				n = t.v1;
			t.v1 = t.v2, t.v2 = n
		}
	}
	var Gl = class {
			constructor(e, t) {
				this.min = e, this.max = t
			}
			GetMin() {
				return this.min
			}
			GetMax() {
				return this.max
			}
			GetCenter() {
				return new Le((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, (this.min.z + this.max.z) / 2)
			}
		},
		zu = class {
			constructor() {
				this.box = new Gl(new Le(1 / 0, 1 / 0, 1 / 0), new Le(-1 / 0, -1 / 0, -1 / 0)), this.isValid = !1
			}
			GetBox() {
				return this.isValid ? this.box : null
			}
			AddPoint(e) {
				this.box.min.x = Math.min(this.box.min.x, e.x), this.box.min.y = Math.min(this.box.min.y, e.y), this.box.min.z = Math.min(this.box.min.z, e.z), this.box.max.x = Math.max(this.box.max.x, e.x), this.box.max.y = Math.max(this.box.max.y, e.y), this.box.max.z = Math.max(this.box.max.z, e.z), this.isValid = !0
			}
		};
	var Vl = class {
			constructor(e, t) {
				this.boundingBox = e, this.level = t, this.pointItems = [], this.childNodes = []
			}
			AddPoint(e, t, n) {
				let i = this.FindNodeForPoint(e);
				if (i === null || i.FindPointDirectly(e) !== null) return !1;
				if (i.pointItems.length < n.maxPointsPerNode || i.level >= n.maxTreeDepth) return i.AddPointDirectly(e, t), !0; {
					i.CreateChildNodes();
					let s = i.pointItems;
					i.pointItems = [];
					for (let o = 0; o < s.length; o++) {
						let a = s[o];
						if (!i.AddPoint(a.point, a.data, n)) return !1
					}
					return i.AddPoint(e, t, n)
				}
			}
			FindPoint(e) {
				let t = this.FindNodeForPoint(e);
				return t === null ? null : t.FindPointDirectly(e)
			}
			AddPointDirectly(e, t) {
				this.pointItems.push({
					point: e,
					data: t
				})
			}
			FindPointDirectly(e) {
				for (let t = 0; t < this.pointItems.length; t++) {
					let n = this.pointItems[t];
					if (Ji(e, n.point)) return n.data
				}
				return null
			}
			FindNodeForPoint(e) {
				if (!this.IsPointInBounds(e)) return null;
				if (this.childNodes.length === 0) return this;
				for (let t = 0; t < this.childNodes.length; t++) {
					let i = this.childNodes[t].FindNodeForPoint(e);
					if (i !== null) return i
				}
				return null
			}
			CreateChildNodes() {
				function e(a, c, l, u, h, f, p) {
					let g = new Gl(new Le(c, l, u), new Le(c + h, l + f, u + p));
					a.childNodes.push(new Vl(g, a.level + 1))
				}
				let t = this.boundingBox.min,
					n = this.boundingBox.GetCenter(),
					i = (this.boundingBox.max.x - this.boundingBox.min.x) / 2,
					s = (this.boundingBox.max.y - this.boundingBox.min.y) / 2,
					o = (this.boundingBox.max.z - this.boundingBox.min.z) / 2;
				e(this, t.x, t.y, t.z, i, s, o), e(this, n.x, t.y, t.z, i, s, o), e(this, t.x, n.y, t.z, i, s, o), e(this, n.x, n.y, t.z, i, s, o), e(this, t.x, t.y, n.z, i, s, o), e(this, n.x, t.y, n.z, i, s, o), e(this, t.x, n.y, n.z, i, s, o), e(this, n.x, n.y, n.z, i, s, o)
			}
			IsPointInBounds(e) {
				return bc(e.x, this.boundingBox.min.x) && bc(e.y, this.boundingBox.min.y) && bc(e.z, this.boundingBox.min.z) && _c(e.x, this.boundingBox.max.x) && _c(e.y, this.boundingBox.max.y) && _c(e.z, this.boundingBox.max.z)
			}
		},
		Hu = class {
			constructor(e, t) {
				this.options = {
					maxPointsPerNode: 10,
					maxTreeDepth: 10
				}, t !== void 0 && (t.maxPointsPerNode !== void 0 && (this.options.maxPointsPerNode = t.maxPointsPerNode), t.maxTreeDepth !== void 0 && (this.options.maxTreeDepth = t.maxTreeDepth)), this.rootNode = new Vl(e, 0)
			}
			AddPoint(e, t) {
				return this.rootNode.AddPoint(e, t, this.options)
			}
			FindPoint(e) {
				return this.rootNode.FindPoint(e)
			}
		};
	var ts = class {
			constructor(e, t) {
				this.nodeId = e, this.meshIndex = t
			}
			IsEqual(e) {
				return this.nodeId === e.nodeId && this.meshIndex === e.meshIndex
			}
			GetKey() {
				return this.nodeId.toString() + ":" + this.meshIndex.toString()
			}
		},
		zl = class extends ys {
			constructor(e, t, n) {
				super(), this.id = e, this.node = t, this.mesh = n
			}
			GetId() {
				return this.id
			}
			GetTransformation() {
				return this.node.GetWorldTransformation()
			}
			GetMesh() {
				return this.mesh
			}
			VertexCount() {
				return this.mesh.VertexCount()
			}
			VertexColorCount() {
				return this.mesh.VertexColorCount()
			}
			NormalCount() {
				return this.mesh.NormalCount()
			}
			TextureUVCount() {
				return this.mesh.TextureUVCount()
			}
			TriangleCount() {
				return this.mesh.TriangleCount()
			}
			EnumerateVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateVertices(e) : this.mesh.EnumerateVertices(n => {
					let i = t.TransformCoord3D(n);
					e(i)
				})
			}
			EnumerateTriangleVertexIndices(e) {
				this.mesh.EnumerateTriangleVertexIndices(e)
			}
			EnumerateTriangleVertices(e) {
				let t = this.node.GetWorldTransformation();
				t.IsIdentity() ? this.mesh.EnumerateTriangleVertices(e) : this.mesh.EnumerateTriangleVertices((n, i, s) => {
					let o = t.TransformCoord3D(n),
						a = t.TransformCoord3D(i),
						c = t.TransformCoord3D(s);
					e(o, a, c)
				})
			}
			PropertyGroupCount() {
				return this.mesh.PropertyGroupCount()
			}
			AddPropertyGroup(e) {
				return this.mesh.AddPropertyGroup(e)
			}
			GetPropertyGroup(e) {
				return this.mesh.GetPropertyGroup(e)
			}
			GetTransformedMesh() {
				let e = this.node.GetWorldTransformation(),
					t = this.mesh.Clone();
				return Ws(t, e), t
			}
		};
	var sp = class {
			constructor() {
				this.nextId = 0
			}
			GenerateId() {
				let e = this.nextId;
				return this.nextId += 1, e
			}
		},
		zn = {
			GroupNode: 0,
			MeshNode: 1
		},
		Dn = class {
			constructor() {
				this.type = zn.GroupNode, this.name = "", this.parent = null, this.transformation = new Jt, this.childNodes = [], this.meshIndices = [], this.idGenerator = new sp, this.id = this.idGenerator.GenerateId()
			}
			IsEmpty() {
				return this.childNodes.length === 0 && this.meshIndices.length === 0
			}
			GetType() {
				return this.type
			}
			SetType(e) {
				this.type = e
			}
			GetId() {
				return this.id
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			HasParent() {
				return this.parent !== null
			}
			GetParent() {
				return this.parent
			}
			GetTransformation() {
				return this.transformation
			}
			GetWorldTransformation() {
				let e = this.transformation.Clone(),
					t = this.parent;
				for (; t !== null;) e.Append(t.transformation), t = t.parent;
				return e
			}
			SetTransformation(e) {
				this.transformation = e
			}
			AddChildNode(e) {
				return e.parent = this, e.idGenerator = this.idGenerator, e.id = e.idGenerator.GenerateId(), this.childNodes.push(e), this.childNodes.length - 1
			}
			RemoveChildNode(e) {
				e.parent = null;
				let t = this.childNodes.indexOf(e);
				this.childNodes.splice(t, 1)
			}
			GetChildNodes() {
				return this.childNodes
			}
			ChildNodeCount() {
				return this.childNodes.length
			}
			GetChildNode(e) {
				return this.childNodes[e]
			}
			AddMeshIndex(e) {
				return this.meshIndices.push(e), this.meshIndices.length - 1
			}
			MeshIndexCount() {
				return this.meshIndices.length
			}
			GetMeshIndex(e) {
				return this.meshIndices[e]
			}
			GetMeshIndices() {
				return this.meshIndices
			}
			Enumerate(e) {
				e(this);
				for (let t of this.childNodes) t.Enumerate(e)
			}
			EnumerateChildren(e) {
				for (let t of this.childNodes) e(t), t.EnumerateChildren(e)
			}
			EnumerateMeshIndices(e) {
				for (let t of this.meshIndices) e(t);
				for (let t of this.childNodes) t.EnumerateMeshIndices(e)
			}
		};
	var js = class extends ys {
		constructor() {
			super(), this.root = new Dn, this.materials = [], this.meshes = []
		}
		GetRootNode() {
			return this.root
		}
		MaterialCount() {
			return this.materials.length
		}
		MeshCount() {
			return this.meshes.length
		}
		MeshInstanceCount() {
			let e = 0;
			return this.root.Enumerate(t => {
				e += t.MeshIndexCount()
			}), e
		}
		VertexCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexCount()
			}), e
		}
		VertexColorCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.VertexColorCount()
			}), e
		}
		NormalCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.NormalCount()
			}), e
		}
		TextureUVCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TextureUVCount()
			}), e
		}
		TriangleCount() {
			let e = 0;
			return this.EnumerateMeshInstances(t => {
				e += t.TriangleCount()
			}), e
		}
		AddMaterial(e) {
			return this.materials.push(e), this.materials.length - 1
		}
		GetMaterial(e) {
			return this.materials[e]
		}
		AddMesh(e) {
			return this.meshes.push(e), this.meshes.length - 1
		}
		AddMeshToRootNode(e) {
			let t = this.AddMesh(e);
			return this.root.AddMeshIndex(t), t
		}
		RemoveMesh(e) {
			this.meshes.splice(e, 1), this.root.Enumerate(t => {
				for (let n = 0; n < t.meshIndices.length; n++) t.meshIndices[n] === e ? (t.meshIndices.splice(n, 1), n -= 1) : t.meshIndices[n] > e && (t.meshIndices[n] -= 1)
			})
		}
		GetMesh(e) {
			return this.meshes[e]
		}
		GetMeshInstance(e) {
			let t = null;
			if (this.root.Enumerate(o => {
					o.GetId() === e.nodeId && (t = o)
				}), t === null || t.GetMeshIndices()
				.indexOf(e.meshIndex) === -1) return null;
			let i = this.GetMesh(e.meshIndex),
				s = new ts(t.GetId(), e.meshIndex);
			return new zl(s, t, i)
		}
		EnumerateMeshes(e) {
			for (let t of this.meshes) e(t)
		}
		EnumerateMeshInstances(e) {
			this.root.Enumerate(t => {
				for (let n of t.GetMeshIndices()) {
					let i = new ts(t.GetId(), n),
						s = this.GetMesh(n),
						o = new zl(i, t, s);
					e(o)
				}
			})
		}
		EnumerateTransformedMeshes(e) {
			this.EnumerateMeshInstances(t => {
				let n = t.GetTransformedMesh();
				e(n)
			})
		}
		EnumerateVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateVertices(e)
			})
		}
		EnumerateTriangleVertexIndices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertexIndices(e)
			})
		}
		EnumerateTriangleVertices(e) {
			this.EnumerateMeshInstances(t => {
				t.EnumerateTriangleVertices(e)
			})
		}
	};
	var op = class {
			constructor() {
				this.edges = [], this.triangles = []
			}
		},
		ap = class {
			constructor(e, t) {
				this.vertex1 = e, this.vertex2 = t, this.triangles = []
			}
		},
		lp = class {
			constructor(e, t) {
				this.edge = e, this.reversed = t
			}
		},
		cp = class {
			constructor() {
				this.triEdge1 = null, this.triEdge2 = null, this.triEdge3 = null
			}
		},
		Wu = class {
			constructor() {
				this.vertices = [], this.edges = [], this.triangleEdges = [], this.triangles = [], this.edgeStartToEndVertexMap = new Map
			}
			AddVertex() {
				return this.vertices.push(new op), this.vertices.length - 1
			}
			AddTriangle(e, t, n) {
				function i(l, u, h) {
					l[u].triangles.push(h)
				}

				function s(l, u, h, f) {
					let p = l[h],
						g = u[f];
					p.edges.push(g.edge)
				}

				function o(l, u, h, f) {
					let p = u[h];
					l[p.edge].triangles.push(f)
				}
				let a = this.triangles.length,
					c = new cp;
				c.triEdge1 = this.AddTriangleEdge(e, t), c.triEdge2 = this.AddTriangleEdge(t, n), c.triEdge3 = this.AddTriangleEdge(n, e), i(this.vertices, e, a), i(this.vertices, t, a), i(this.vertices, n, a), s(this.vertices, this.triangleEdges, e, c.triEdge1), s(this.vertices, this.triangleEdges, t, c.triEdge2), s(this.vertices, this.triangleEdges, n, c.triEdge3), o(this.edges, this.triangleEdges, c.triEdge1, a), o(this.edges, this.triangleEdges, c.triEdge2, a), o(this.edges, this.triangleEdges, c.triEdge3, a), this.triangles.push(c)
			}
			AddTriangleEdge(e, t) {
				let n = e,
					i = t,
					s = !1;
				t < e && (n = t, i = e, s = !0);
				let o = this.AddEdge(n, i);
				return this.triangleEdges.push(new lp(o, s)), this.triangleEdges.length - 1
			}
			AddEdge(e, t) {
				this.edgeStartToEndVertexMap.has(e) || this.edgeStartToEndVertexMap.set(e, []);
				let n = this.edgeStartToEndVertexMap.get(e);
				for (let s = 0; s < n.length; s++) {
					let o = n[s];
					if (o.endVertex === t) return o.edgeIndex
				}
				let i = this.edges.length;
				return n.push({
					endVertex: t,
					edgeIndex: i
				}), this.edges.push(new ap(e, t)), i
			}
		};

	function ju(r) {
		let e = !0;
		return r.EnumerateMeshInstances(t => {
			Aa(t) !== Hs.Empty && (e = !1)
		}), e
	}

	function up(r) {
		let e = new zu;
		return r.EnumerateVertices(t => {
			e.AddPoint(t)
		}), e.GetBox()
	}

	function XS(r) {
		function e(s, o, a) {
			let c = o.FindPoint(s);
			return c === null && (c = a.AddVertex(), o.AddPoint(s, c)), c
		}
		let t = up(r),
			n = new Hu(t),
			i = new Wu;
		return r.EnumerateTriangleVertices((s, o, a) => {
			let c = e(s, n, i),
				l = e(o, n, i),
				u = e(a, n, i);
			i.AddTriangle(c, l, u)
		}), i
	}

	function hp(r) {
		function e(t, n, i) {
			let s = t.triangles[n],
				o = t.triangleEdges[s.triEdge1],
				a = t.triangleEdges[s.triEdge2],
				c = t.triangleEdges[s.triEdge3];
			return o.edge === i ? o.reversed : a.edge === i ? a.reversed : c.edge === i ? c.reversed : null
		}
		if (r instanceof js) {
			let t = !0;
			return r.EnumerateMeshInstances(n => {
				t && (t = hp(n))
			}), t
		} else {
			let t = XS(r);
			for (let n = 0; n < t.edges.length; n++) {
				let i = t.edges[n];
				if (i.triangles.length !== 2) return !1;
				let s = e(t, i.triangles[0], n),
					o = e(t, i.triangles[1], n);
				if (s === null || o === null || s === o) return !1
			}
			return !0
		}
	}

	function Nv(r) {
		for (let e = 0; e < r.MaterialCount(); e++) {
			let t = r.GetMaterial(e);
			if (t.isDefault && !t.vertexColors) return !0
		}
		return !1
	}

	function fp(r, e) {
		for (let t = 0; t < r.MaterialCount(); t++) {
			let n = r.GetMaterial(t);
			n.isDefault && (n.color = e)
		}
	}

	function Ia(r) {
		return r != null
	}

	function Cr(r, e) {
		return r??e
	}

	function qu(r, e) {
		if (!!Ia(r))
			for (let t of Object.keys(r)) Ia(r[t]) && (e[t] = r[t])
	}

	function Dv(r) {
		return Object.keys(r)
			.length === 0
	}

	function Ov(r) {
		return r.replace(/</g, "&lt;")
			.replace(/>/g, "&gt;")
	}
	var ut = {
			Text: 1,
			Integer: 2,
			Number: 3,
			Boolean: 4,
			Percent: 5,
			Color: 6
		},
		mt = class {
			constructor(e, t, n) {
				this.type = e, this.name = t, this.value = n
			}
			Clone() {
				return this.type === ut.Color ? new mt(this.type, this.name, this.value.Clone()) : new mt(this.type, this.name, this.value)
			}
		},
		On = class {
			constructor(e) {
				this.name = e, this.properties = []
			}
			PropertyCount() {
				return this.properties.length
			}
			AddProperty(e) {
				this.properties.push(e)
			}
			GetProperty(e) {
				return this.properties[e]
			}
			Clone() {
				let e = new On(this.name);
				for (let t of this.properties) e.AddProperty(t.Clone());
				return e
			}
		};

	function Hl(r) {
		return r.type === ut.Text ? Ov(r.value) : r.type === ut.Integer ? r.value.toLocaleString() : r.type === ut.Number ? r.value.toLocaleString(void 0, {
				minimumFractionDigits: 2,
				maximumFractionDigits: 2
			}) : r.type === ut.Boolean ? r.value ? "True" : "False" : r.type === ut.Percent ? parseInt(r.value * 100, 10)
			.toString() + "%" : r.type === ut.Color ? "#" + Pi(r.value) : null
	}
	var dp = class {
		constructor(e) {
			this.params = {
				getDefaultMaterialColor: () => new nt(0, 0, 0)
			}, qu(e, this.params), this.defaultMaterialIndex = null
		}
		Finalize(e) {
			this.Reset(), this.FinalizeMeshes(e), this.FinalizeMaterials(e), this.FinalizeNodes(e)
		}
		FinalizeMaterials(e) {
			if (e.VertexColorCount() === 0) return;
			let t = new Map;
			for (let n = 0; n < e.MeshCount(); n++) {
				let i = e.GetMesh(n);
				for (let s = 0; s < i.TriangleCount(); s++) {
					let o = i.GetTriangle(s),
						a = o.HasVertexColors();
					t.has(o.mat) ? a || t.set(o.mat, !1) : t.set(o.mat, a)
				}
			}
			for (let [n, i] of t) {
				let s = e.GetMaterial(n);
				s.vertexColors = i
			}
		}
		FinalizeMeshes(e) {
			for (let t = 0; t < e.MeshCount(); t++) {
				let n = e.GetMesh(t);
				if (Aa(n) === Hs.Empty) {
					e.RemoveMesh(t), t = t - 1;
					continue
				}
				this.FinalizeMesh(e, n)
			}
		}
		FinalizeMesh(e, t) {
			function n(s) {
				function o(l, u, h, f, p) {
					function g(x, _) {
						for (let y = 0; y < x.length; y++) {
							let w = x[y];
							if (Ji(w, _)) return !0
						}
						return !1
					}
					let m = [],
						d = p.get(h);
					for (let x = 0; x < d.length; x++) {
						let _ = d[x],
							y = l.GetTriangle(_);
						if (u.curve === y.curve) {
							let w = f[_];
							g(m, w) || m.push(w)
						}
					}
					let v = new Le(0, 0, 0);
					for (let x = 0; x < m.length; x++) v = xg(v, m[x]);
					return v.MultiplyScalar(1 / m.length), v.Normalize(), l.AddNormal(v)
				}
				let a = [],
					c = new Map;
				for (let l = 0; l < s.VertexCount(); l++) c.set(l, []);
				for (let l = 0; l < s.TriangleCount(); l++) {
					let u = s.GetTriangle(l),
						h = s.GetVertex(u.v0),
						f = s.GetVertex(u.v1),
						p = s.GetVertex(u.v2),
						g = Bl(h, f, p);
					a.push(g), c.get(u.v0)
						.push(l), c.get(u.v1)
						.push(l), c.get(u.v2)
						.push(l)
				}
				for (let l = 0; l < s.TriangleCount(); l++) {
					let u = s.GetTriangle(l);
					if (!u.HasNormals()) {
						let h = o(s, u, u.v0, a, c),
							f = o(s, u, u.v1, a, c),
							p = o(s, u, u.v2, a, c);
						u.SetNormals(h, f, p)
					}
				}
			}
			let i = {
				calculateCurveNormals: !1
			};
			for (let s = 0; s < t.TriangleCount(); s++) {
				let o = t.GetTriangle(s);
				this.FinalizeTriangle(t, o, i), o.mat === null && (o.mat = this.GetDefaultMaterialIndex(e))
			}
			i.calculateCurveNormals && n(t)
		}
		FinalizeTriangle(e, t, n) {
			if (!t.HasNormals())
				if (t.curve === null || t.curve === 0) {
					let i = e.GetVertex(t.v0),
						s = e.GetVertex(t.v1),
						o = e.GetVertex(t.v2),
						a = Bl(i, s, o),
						c = e.AddNormal(a);
					t.SetNormals(c, c, c)
				} else n.calculateCurveNormals = !0;
			t.curve === null && (t.curve = 0)
		}
		FinalizeNodes(e) {
			let t = e.GetRootNode(),
				n = [];
			t.EnumerateChildren(i => {
				i.IsEmpty() && n.push(i)
			});
			for (let i = 0; i < n.length; i++) {
				let s = n[i],
					o = s.GetParent();
				o !== null && (o.RemoveChildNode(s), o.IsEmpty() && n.push(o))
			}
		}
		GetDefaultMaterialIndex(e) {
			if (this.defaultMaterialIndex === null) {
				let t = this.params.getDefaultMaterialColor(),
					n = new An;
				n.color = t, n.isDefault = !0, this.defaultMaterialIndex = e.AddMaterial(n)
			}
			return this.defaultMaterialIndex
		}
		Reset() {
			this.defaultMaterialIndex = null
		}
	};

	function kv(r, e) {
		new dp(e)
			.Finalize(r)
	}
	var Ht = class {
		constructor() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null
		}
		Import(e, t, n, i) {
			this.Clear(), this.name = e, this.extension = t, this.callbacks = i, this.model = new js, this.error = !1, this.message = null, this.ResetContent(), this.ImportContent(n, () => {
				this.CreateResult(i)
			})
		}
		Clear() {
			this.name = null, this.extension = null, this.callbacks = null, this.model = null, this.error = null, this.message = null, this.ClearContent()
		}
		CreateResult(e) {
			if (this.error) {
				e.onError(), e.onComplete();
				return
			}
			if (ju(this.model)) {
				this.SetError("The model doesn't contain any meshes."), e.onError(), e.onComplete();
				return
			}
			kv(this.model, {
				getDefaultMaterialColor: this.callbacks.getDefaultMaterialColor
			}), e.onSuccess(), e.onComplete()
		}
		CanImportExtension(e) {
			return !1
		}
		GetUpDirection() {
			return lt.Z
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {}
		GetModel() {
			return this.model
		}
		SetError(e) {
			this.error = !0, e != null && (this.message = e)
		}
		WasError() {
			return this.error
		}
		GetErrorMessage() {
			return this.message
		}
	};

	function qs(r, e, t) {
		let n = r.substring(e),
			i = n.indexOf(t);
		return i !== -1 && (n = n.substring(0, i)), n.trim()
	}

	function ns(r, e) {
		if (e !== null) {
			let t = r.indexOf(e);
			t !== -1 && (r = r.substring(0, t)
				.trim())
		}
		return r.split(/\s+/u)
	}

	function Gi(r, e) {
		function t(s, o) {
			let a = s.trim();
			a.length > 0 && o(a)
		}
		let n = 0,
			i = r.indexOf(`
`, n);
		for (; i !== -1;) t(r.substring(n, i), e), n = i + 1, i = r.indexOf(`
`, n);
		t(r.substring(n), e)
	}

	function Vi(r) {
		r.transparent = !1, yc(r.opacity, 1) && (r.transparent = !0)
	}
	var Bi = class {
		constructor(e) {
			this.model = e, this.colorToMaterialIndex = new Map
		}
		GetMaterialIndex(e, t, n, i) {
			let s = Fn(e) + Fn(t) + Fn(n),
				o = i != null;
			if (o && (s += Fn(i)), this.colorToMaterialIndex.has(s)) return this.colorToMaterialIndex.get(s); {
				let a = new An;
				a.name = s.toUpperCase(), a.color = new nt(e, t, n), o && i < 255 && (a.opacity = i / 255, Vi(a));
				let c = this.model.AddMaterial(a);
				return this.colorToMaterialIndex.set(s, c), c
			}
		}
	};
	var Xu = class extends Ht {
		constructor() {
			super(), this.rhino = null
		}
		CanImportExtension(e) {
			return e === "3dm"
		}
		GetUpDirection() {
			return lt.Z
		}
		ClearContent() {
			this.instanceIdToObject = null, this.instanceIdToDefinition = null
		}
		ResetContent() {
			this.instanceIdToObject = new Map, this.instanceIdToDefinition = new Map
		}
		ImportContent(e, t) {
			this.rhino === null ? ds("loaders/rhino3dm.min.js")
				.then(() => {
					rhino3dm()
						.then(n => {
							this.rhino = n, this.ImportRhinoContent(e), t()
						})
				})
				.catch(() => {
					this.SetError("Failed to load rhino3dm."), t()
				}) : (this.ImportRhinoContent(e), t())
		}
		ImportRhinoContent(e) {
			let t = this.rhino.File3dm.fromByteArray(e);
			if (t === null) {
				this.SetError("Failed to read Rhino file.");
				return
			}
			this.ImportRhinoDocument(t), ju(this.model) && this.SetError("The model doesn't contain any 3D meshes. Try to save the model while you are in shaded view in Rhino.")
		}
		ImportRhinoDocument(e) {
			this.InitRhinoInstances(e), this.ImportRhinoUserStrings(e), this.ImportRhinoGeometry(e)
		}
		InitRhinoInstances(e) {
			let t = e.objects();
			for (let i = 0; i < t.count; i++) {
				let s = t.get(i),
					o = s.attributes();
				o.isInstanceDefinitionObject && this.instanceIdToObject.set(o.id, s)
			}
			let n = e.instanceDefinitions();
			for (let i = 0; i < n.count(); i++) {
				let s = n.get(i);
				this.instanceIdToDefinition.set(s.id, s)
			}
		}
		ImportRhinoUserStrings(e) {
			let t = e.strings();
			if (t.count() > 0) {
				let n = new On("Document user texts");
				for (let i = 0; i < t.count(); i++) {
					let s = t.get(i);
					n.AddProperty(new mt(ut.Text, s[0], s[1]))
				}
				this.model.AddPropertyGroup(n)
			}
		}
		ImportRhinoGeometry(e) {
			let t = e.objects();
			for (let n = 0; n < t.count; n++) {
				let i = t.get(n);
				this.ImportRhinoGeometryObject(e, i, [])
			}
		}
		ImportRhinoGeometryObject(e, t, n) {
			let i = t.geometry(),
				s = t.attributes(),
				o = i.objectType;
			if (s.isInstanceDefinitionObject && n.length === 0) return;
			let a = null,
				c = !1;
			if (o === this.rhino.ObjectType.Mesh) a = i, c = !1;
			else if (o === this.rhino.ObjectType.Extrusion) a = i.getMesh(this.rhino.MeshType.Any), c = !0;
			else if (o === this.rhino.ObjectType.Brep) {
				a = new this.rhino.Mesh;
				let l = i.faces();
				for (let u = 0; u < l.count; u++) {
					let h = l.get(u),
						f = h.getMesh(this.rhino.MeshType.Any);
					f && (a.append(f), f.delete()), h.delete()
				}
				l.delete(), a.compact(), c = !0
			} else if (o === this.rhino.ObjectType.SubD) i.subdivide(3), a = this.rhino.Mesh.createFromSubDControlNet(i), c = !0;
			else if (o === this.rhino.ObjectType.InstanceReference) {
				let l = i.parentIdefId;
				if (this.instanceIdToDefinition.has(l)) {
					let h = this.instanceIdToDefinition.get(l)
						.getObjectIds();
					for (let f = 0; f < h.length; f++) {
						let p = h[f];
						if (this.instanceIdToObject.has(p)) {
							let g = this.instanceIdToObject.get(p);
							n.push(t), this.ImportRhinoGeometryObject(e, g, n), n.pop()
						}
					}
				}
			}
			a !== null && (this.ImportRhinoMesh(e, a, t, n), c && a.delete())
		}
		ImportRhinoMesh(e, t, n, i) {
			let s = n.attributes(),
				o = this.GetMaterialIndex(e, n, i),
				a = t.toThreejsJSON(),
				c = es(a.data, o);
			c.SetName(s.name);
			let l = s.getUserStrings();
			if (l.length > 0) {
				let u = new On("User texts");
				for (let h = 0; h < l.length; h++) {
					let f = l[h];
					u.AddProperty(new mt(ut.Text, f[0], f[1]))
				}
				c.AddPropertyGroup(u)
			}
			if (i.length !== 0) {
				let u = new kt()
					.CreateIdentity();
				for (let f = i.length - 1; f >= 0; f--) {
					let m = i[f].geometry()
						.xform.toFloatArray(!1),
						d = new kt(m);
					u = u.MultiplyMatrix(d)
				}
				let h = new Jt(u);
				Ws(c, h)
			}
			this.model.AddMeshToRootNode(c)
		}
		GetMaterialIndex(e, t, n) {
			function i(c, l, u) {
				let h = l.attributes();
				if (h.materialSource === c.ObjectMaterialSource.MaterialFromObject) {
					let f = h.materialIndex;
					if (f > -1) return e.materials()
						.get(f)
				} else if (h.materialSource === c.ObjectMaterialSource.MaterialFromLayer) {
					let f = h.layerIndex;
					if (f > -1) {
						let g = e.layers()
							.get(f)
							.renderMaterialIndex;
						if (g > -1) return e.materials()
							.get(g)
					}
				} else if (h.materialSource === c.ObjectMaterialSource.MaterialFromParent && u.length !== 0) return i(c, u[0], []);
				return null
			}

			function s(c, l) {
				function u(d, v) {
					d.Set(v.r, v.g, v.b)
				}

				function h(d) {
					return d.r === 0 && d.g === 0 && d.b === 0
				}

				function f(d) {
					return d.r === 255 && d.g === 255 && d.b === 255
				}
				let p = null,
					g = c.physicallyBased();
				g.supported ? (p = new xs, p.metalness = g.metallic ? 1 : 0, p.roughness = g.roughness) : (p = new An, u(p.ambient, c.ambientColor), u(p.specular, c.specularColor)), p.name = c.name, u(p.color, c.diffuseColor), p.opacity = 1 - c.transparency, Vi(p), h(p.color) && !f(c.reflectionColor) && u(p.color, c.reflectionColor), h(p.color) && !f(c.transparentColor) && u(p.color, c.transparentColor);
				let m = c.getBitmapTexture();
				if (m) {
					let d = new Li,
						v = Sn(m.fileName),
						x = l.getFileBuffer(v);
					d.name = v, d.buffer = x, p.diffuseMap = d
				}
				return p
			}

			function o(c, l, u) {
				let h = s(l, u);
				for (let f = 0; f < c.MaterialCount(); f++)
					if (c.GetMaterial(f)
						.IsEqual(h)) return f;
				return c.AddMaterial(h)
			}
			let a = i(this.rhino, t, n);
			return a === null ? null : o(this.model, a, this.callbacks)
		}
	};
	var Ci = class {
		constructor(e, t) {
			this.arrayBuffer = e, this.dataView = new DataView(e), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		GetByteLength() {
			return this.arrayBuffer.byteLength
		}
		Skip(e) {
			this.position = this.position + e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		ReadArrayBuffer(e) {
			let t = new Uint8Array(this.arrayBuffer),
				n = new ArrayBuffer(e),
				i = new Uint8Array(n),
				s = t.subarray(this.position, this.position + e);
			return i.set(s, 0), this.position += e, n
		}
		ReadBoolean8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, !!e
		}
		ReadCharacter8() {
			let e = this.dataView.getInt8(this.position);
			return this.position = this.position + 1, e
		}
		ReadUnsignedCharacter8() {
			let e = this.dataView.getUint8(this.position);
			return this.position = this.position + 1, e
		}
		ReadInteger16() {
			let e = this.dataView.getInt16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadUnsignedInteger16() {
			let e = this.dataView.getUint16(this.position, this.isLittleEndian);
			return this.position = this.position + 2, e
		}
		ReadInteger32() {
			let e = this.dataView.getInt32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadUnsignedInteger32() {
			let e = this.dataView.getUint32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadFloat32() {
			let e = this.dataView.getFloat32(this.position, this.isLittleEndian);
			return this.position = this.position + 4, e
		}
		ReadDouble64() {
			let e = this.dataView.getFloat64(this.position, this.isLittleEndian);
			return this.position = this.position + 8, e
		}
	};
	var pt = {
			MAIN3DS: 19789,
			EDIT3DS: 15677,
			EDIT_MATERIAL: 45055,
			MAT_NAME: 40960,
			MAT_AMBIENT: 40976,
			MAT_DIFFUSE: 40992,
			MAT_SPECULAR: 41008,
			MAT_SHININESS: 41024,
			MAT_SHININESS_STRENGTH: 41025,
			MAT_TRANSPARENCY: 41040,
			MAT_COLOR_F: 16,
			MAT_COLOR: 17,
			MAT_LIN_COLOR: 18,
			MAT_LIN_COLOR_F: 19,
			MAT_TEXMAP: 41472,
			MAT_TEXMAP_NAME: 41728,
			MAT_TEXMAP_UOFFSET: 41816,
			MAT_TEXMAP_VOFFSET: 41818,
			MAT_TEXMAP_USCALE: 41812,
			MAT_TEXMAP_VSCALE: 41814,
			MAT_TEXMAP_ROTATION: 41820,
			PERCENTAGE: 48,
			PERCENTAGE_F: 49,
			EDIT_OBJECT: 16384,
			OBJ_TRIMESH: 16640,
			OBJ_LIGHT: 17920,
			OBJ_CAMERA: 18176,
			TRI_VERTEX: 16656,
			TRI_TEXVERTEX: 16704,
			TRI_FACE: 16672,
			TRI_TRANSFORMATION: 16736,
			TRI_MATERIAL: 16688,
			TRI_SMOOTH: 16720,
			KF3DS: 45056,
			OBJECT_NODE: 45058,
			OBJECT_HIERARCHY: 45072,
			OBJECT_INSTANCE_NAME: 45073,
			OBJECT_PIVOT: 45075,
			OBJECT_POSITION: 45088,
			OBJECT_ROTATION: 45089,
			OBJECT_SCALE: 45090,
			OBJECT_ID: 45104
		},
		pp = class {
			constructor() {
				this.id = -1, this.name = "", this.flags = -1, this.parentId = -1, this.instanceName = "", this.pivot = [0, 0, 0], this.positions = [], this.rotations = [], this.scales = []
			}
		},
		mp = class {
			constructor() {
				this.nodes = [], this.nodeIdToNode = new Map
			}
			IsEmpty() {
				return this.nodes.length === 0
			}
			AddNode(e) {
				this.nodes.push(e), this.nodeIdToNode.set(e.nodeId, e)
			}
			GetNodes() {
				return this.nodes
			}
		},
		Yu = class extends Ht {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "3ds"
			}
			GetUpDirection() {
				return lt.Z
			}
			ClearContent() {
				this.materialNameToIndex = null, this.meshNameToIndex = null, this.nodeList = null
			}
			ResetContent() {
				this.materialNameToIndex = new Map, this.meshNameToIndex = new Map, this.nodeList = new mp
			}
			ImportContent(e, t) {
				this.ProcessBinary(e), t()
			}
			ProcessBinary(e) {
				let t = new Ci(e, !0),
					n = t.GetByteLength();
				this.ReadChunks(t, n, (i, s) => {
					i === pt.MAIN3DS ? this.ReadMainChunk(t, s) : this.SkipChunk(t, s)
				})
			}
			ReadMainChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === pt.EDIT3DS ? this.ReadEditorChunk(e, s) : i === pt.KF3DS ? this.ReadKeyFrameChunk(e, s) : this.SkipChunk(e, s)
				}), this.BuildNodeHierarchy()
			}
			ReadEditorChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === pt.EDIT_MATERIAL ? this.ReadMaterialChunk(e, s) : i === pt.EDIT_OBJECT ? this.ReadObjectChunk(e, s) : this.SkipChunk(e, s)
				})
			}
			ReadMaterialChunk(e, t) {
				let n = new An,
					i = this.GetChunkEnd(e, t),
					s = null,
					o = null;
				this.ReadChunks(e, i, (c, l) => {
					c === pt.MAT_NAME ? n.name = this.ReadName(e) : c === pt.MAT_AMBIENT ? n.ambient = this.ReadColorChunk(e, l) : c === pt.MAT_DIFFUSE ? n.color = this.ReadColorChunk(e, l) : c === pt.MAT_SPECULAR ? n.specular = this.ReadColorChunk(e, l) : c === pt.MAT_SHININESS ? s = this.ReadPercentageChunk(e, l) : c === pt.MAT_SHININESS_STRENGTH ? o = this.ReadPercentageChunk(e, l) : c === pt.MAT_TRANSPARENCY ? (n.opacity = 1 - this.ReadPercentageChunk(e, l), Vi(n)) : c === pt.MAT_TEXMAP ? (n.diffuseMap = this.ReadTextureMapChunk(e, l), Vi(n)) : this.SkipChunk(e, l)
				}), s !== null && o !== null && (n.shininess = s * o / 10);
				let a = this.model.AddMaterial(n);
				this.materialNameToIndex.set(n.name, a)
			}
			ReadTextureMapChunk(e, t) {
				let n = new Li,
					i = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, i, (s, o) => {
					if (s === pt.MAT_TEXMAP_NAME) {
						let a = this.ReadName(e),
							c = this.callbacks.getFileBuffer(a);
						n.name = a, n.buffer = c
					} else s === pt.MAT_TEXMAP_UOFFSET ? n.offset.x = e.ReadFloat32() : s === pt.MAT_TEXMAP_VOFFSET ? n.offset.y = e.ReadFloat32() : s === pt.MAT_TEXMAP_USCALE ? n.scale.x = e.ReadFloat32() : s === pt.MAT_TEXMAP_VSCALE ? n.scale.y = e.ReadFloat32() : s === pt.MAT_TEXMAP_ROTATION ? n.rotation = e.ReadFloat32() * ps : this.SkipChunk(e, o)
				}), n
			}
			ReadColorChunk(e, t) {
				let n = new nt(0, 0, 0),
					i = this.GetChunkEnd(e, t),
					s = !1;
				return this.ReadChunks(e, i, (o, a) => {
					o === pt.MAT_COLOR ? s || (n.r = e.ReadUnsignedCharacter8(), n.g = e.ReadUnsignedCharacter8(), n.b = e.ReadUnsignedCharacter8()) : o === pt.MAT_LIN_COLOR ? (n.r = e.ReadUnsignedCharacter8(), n.g = e.ReadUnsignedCharacter8(), n.b = e.ReadUnsignedCharacter8(), s = !0) : o === pt.MAT_COLOR_F ? s || (n.r = Cn(e.ReadFloat32()), n.g = Cn(e.ReadFloat32()), n.b = Cn(e.ReadFloat32())) : o === pt.MAT_LIN_COLOR_F ? (n.r = Cn(e.ReadFloat32()), n.g = Cn(e.ReadFloat32()), n.b = Cn(e.ReadFloat32()), s = !0) : this.SkipChunk(e, a)
				}), n
			}
			ReadPercentageChunk(e, t) {
				let n = 0,
					i = this.GetChunkEnd(e, t);
				return this.ReadChunks(e, i, (s, o) => {
					s === pt.PERCENTAGE ? n = e.ReadUnsignedInteger16() / 100 : s === pt.PERCENTAGE_F ? n = e.ReadFloat32() : this.SkipChunk(e, o)
				}), n
			}
			ReadObjectChunk(e, t) {
				let n = this.GetChunkEnd(e, t),
					i = this.ReadName(e);
				this.ReadChunks(e, n, (s, o) => {
					s === pt.OBJ_TRIMESH ? this.ReadMeshChunk(e, o, i) : this.SkipChunk(e, o)
				})
			}
			ReadMeshChunk(e, t, n) {
				function i(u, h) {
					if (!h.IsValid()) return;
					let f = h.Determinant(),
						p = ro(f);
					p && (h = new kt()
						.CreateScale(-1, 1, 1)
						.MultiplyMatrix(h));
					let g = h.Invert();
					if (g === null) return;
					let m = new Jt(g);
					Ws(u, m), p && Lv(u)
				}
				let s = new Qt;
				s.SetName(n);
				let o = this.GetChunkEnd(e, t),
					a = null;
				if (this.ReadChunks(e, o, (u, h) => {
					u === pt.TRI_VERTEX ? this.ReadVerticesChunk(s, e) : u === pt.TRI_TEXVERTEX ? this.ReadTextureVerticesChunk(s, e) : u === pt.TRI_FACE ? this.ReadFacesChunk(s, e, h) : u === pt.TRI_TRANSFORMATION ? a = this.ReadTransformationChunk(e) : this.SkipChunk(e, h)
				}), s.VertexCount() === s.TextureUVCount())
					for (let u = 0; u < s.TriangleCount(); u++) {
						let h = s.GetTriangle(u);
						h.SetTextureUVs(h.v0, h.v1, h.v2)
					}
				let c = new kt(a);
				i(s, c);
				let l = this.model.AddMesh(s);
				this.meshNameToIndex.set(s.GetName(), l)
			}
			ReadVerticesChunk(e, t) {
				let n = t.ReadUnsignedInteger16();
				for (let i = 0; i < n; i++) {
					let s = t.ReadFloat32(),
						o = t.ReadFloat32(),
						a = t.ReadFloat32();
					e.AddVertex(new Le(s, o, a))
				}
			}
			ReadTextureVerticesChunk(e, t) {
				let n = t.ReadUnsignedInteger16();
				for (let i = 0; i < n; i++) {
					let s = t.ReadFloat32(),
						o = t.ReadFloat32();
					e.AddTextureUV(new Rt(s, o))
				}
			}
			ReadFacesChunk(e, t, n) {
				let i = this.GetChunkEnd(t, n),
					s = t.ReadUnsignedInteger16();
				for (let o = 0; o < s; o++) {
					let a = t.ReadUnsignedInteger16(),
						c = t.ReadUnsignedInteger16(),
						l = t.ReadUnsignedInteger16();
					t.ReadUnsignedInteger16(), e.AddTriangle(new qt(a, c, l))
				}
				this.ReadChunks(t, i, (o, a) => {
					o === pt.TRI_MATERIAL ? this.ReadFaceMaterialsChunk(e, t) : o === pt.TRI_SMOOTH ? this.ReadFaceSmoothingGroupsChunk(e, s, t) : this.SkipChunk(t, a)
				})
			}
			ReadFaceMaterialsChunk(e, t) {
				let n = this.ReadName(t),
					i = this.materialNameToIndex.get(n),
					s = t.ReadUnsignedInteger16();
				for (let o = 0; o < s; o++) {
					let a = t.ReadUnsignedInteger16(),
						c = e.GetTriangle(a);
					i !== void 0 && (c.mat = i)
				}
			}
			ReadFaceSmoothingGroupsChunk(e, t, n) {
				for (let i = 0; i < t; i++) {
					let s = n.ReadUnsignedInteger32(),
						o = e.GetTriangle(i);
					o.curve = s
				}
			}
			ReadTransformationChunk(e) {
				let t = [];
				for (let n = 0; n < 4; n++) {
					for (let i = 0; i < 3; i++) t.push(e.ReadFloat32());
					n < 3 ? t.push(0) : t.push(1)
				}
				return t
			}
			ReadKeyFrameChunk(e, t) {
				let n = this.GetChunkEnd(e, t);
				this.ReadChunks(e, n, (i, s) => {
					i === pt.OBJECT_NODE ? this.ReadObjectNodeChunk(e, s) : this.SkipChunk(e, s)
				})
			}
			BuildNodeHierarchy() {
				function e(n, i) {
					function s(l) {
						return l.positions.length === 0 ? [0, 0, 0] : l.positions[0]
					}

					function o(l) {
						function u(f) {
							let p = [0, 0, 0, 1],
								g = Math.sqrt(f[0] * f[0] + f[1] * f[1] + f[2] * f[2]);
							if (g > 0) {
								let m = f[3] * -.5,
									d = Math.sin(m) / g;
								p = [d * f[0], d * f[1], d * f[2], Math.cos(m)]
							}
							return p
						}
						if (l.rotations.length === 0) return [0, 0, 0, 1];
						let h = l.rotations[0];
						return u(h)
					}

					function a(l) {
						return l.scales.length === 0 ? [1, 1, 1] : l.scales[0]
					}
					let c = new kt;
					if (c.ComposeTRS(Gr(s(n)), Ca(o(n)), Gr(a(n))), i) {
						let l = n.pivot;
						c = new kt()
							.CreateTranslation(-l[0], -l[1], -l[2])
							.MultiplyMatrix(c)
					}
					return new Jt(c)
				}
				let t = this.model.GetRootNode();
				if (this.nodeList.IsEmpty())
					for (let n = 0; n < this.model.MeshCount(); n++) t.AddMeshIndex(n);
				else {
					let n = new Map;
					for (let i of this.nodeList.GetNodes()) {
						let s = new Dn;
						i.name.length > 0 && i.name !== "$$$DUMMY" && (s.SetName(i.name), i.instanceName.length > 0 && s.SetName(s.GetName() + " " + i.instanceName)), i.parentId === 65535 || !n.has(i.parentId) ? t.AddChildNode(s) : n.get(i.parentId)
							.AddChildNode(s), n.set(i.id, s);
						let o = this.meshNameToIndex.has(i.name);
						s.SetTransformation(e(i, o)), o && (s.SetType(zn.MeshNode), s.AddMeshIndex(this.meshNameToIndex.get(i.name)))
					}
				}
			}
			ReadObjectNodeChunk(e, t) {
				function n(o, a, c) {
					let l = [];
					a.Skip(10);
					let u = a.ReadInteger32();
					for (let h = 0; h < u; h++) {
						a.ReadInteger32(), a.ReadUnsignedInteger16() !== 0 && a.ReadFloat32();
						let p = null;
						if (c === pt.OBJECT_ROTATION) {
							let g = a.ReadFloat32();
							p = o.ReadVector(a), p[3] = g
						} else p = o.ReadVector(a);
						l.push(p)
					}
					return l
				}
				let i = new pp,
					s = this.GetChunkEnd(e, t);
				this.ReadChunks(e, s, (o, a) => {
					o === pt.OBJECT_HIERARCHY ? (i.name = this.ReadName(e), i.flags = e.ReadUnsignedInteger32(), i.parentId = e.ReadUnsignedInteger16()) : o === pt.OBJECT_INSTANCE_NAME ? i.instanceName = this.ReadName(e) : o === pt.OBJECT_PIVOT ? i.pivot = this.ReadVector(e) : o === pt.OBJECT_POSITION ? i.positions = n(this, e, pt.OBJECT_POSITION) : o === pt.OBJECT_ROTATION ? i.rotations = n(this, e, pt.OBJECT_ROTATION) : o === pt.OBJECT_SCALE ? i.scales = n(this, e, pt.OBJECT_SCALE) : o === pt.OBJECT_ID ? i.id = e.ReadUnsignedInteger16() : this.SkipChunk(e, a)
				}), this.nodeList.AddNode(i)
			}
			ReadName(e) {
				let t = "",
					n = 0,
					i = 0;
				for (; i < 64 && (n = e.ReadCharacter8(), n !== 0);) t = t + String.fromCharCode(n), i = i + 1;
				return t
			}
			ReadVector(e) {
				return [e.ReadFloat32(), e.ReadFloat32(), e.ReadFloat32()]
			}
			ReadChunks(e, t, n) {
				for (; e.GetPosition() <= t - 6;) {
					let i = e.ReadUnsignedInteger16(),
						s = e.ReadUnsignedInteger32();
					n(i, s)
				}
			}
			GetChunkEnd(e, t) {
				return e.GetPosition() + t - 6
			}
			SkipChunk(e, t) {
				e.Skip(t - 6)
			}
		};
	var pi = {
			BYTE: 5120,
			UNSIGNED_BYTE: 5121,
			SHORT: 5122,
			UNSIGNED_SHORT: 5123,
			UNSIGNED_INT: 5125,
			FLOAT: 5126
		},
		hr = {
			SCALAR: 0,
			VEC2: 1,
			VEC3: 2,
			VEC4: 3,
			MAT2: 4,
			MAT3: 5,
			MAT4: 6
		},
		Io = {
			POINTS: 0,
			LINES: 1,
			LINE_LOOP: 2,
			LINE_STRIP: 3,
			TRIANGLES: 4,
			TRIANGLE_STRIP: 5,
			TRIANGLE_FAN: 6
		},
		gp = {
			GLTF_STRING: 1179937895,
			JSON_CHUNK_TYPE: 1313821514,
			BINARY_CHUNK_TYPE: 5130562
		};

	function Wl(r) {
		return Ki(ul(r[0]), ul(r[1]), ul(r[2]))
	}

	function YS(r, e) {
		function t(n, i) {
			let s = n;
			return i === pi.UNSIGNED_BYTE ? s /= 255 : i === pi.UNSIGNED_SHORT && (s /= 65535), Cn(ul(s))
		}
		return new nt(t(r[0], e), t(r[1], e), t(r[2], e))
	}
	var vp = class {
			constructor(e) {
				this.reader = new Ci(e, !0), this.componentType = null, this.dataType = null, this.byteStride = null, this.dataCount = null, this.sparseReader = null
			}
			SetComponentType(e) {
				this.componentType = e
			}
			SetDataType(e) {
				e === "SCALAR" ? this.dataType = hr.SCALAR : e === "VEC2" ? this.dataType = hr.VEC2 : e === "VEC3" ? this.dataType = hr.VEC3 : e === "VEC4" ? this.dataType = hr.VEC4 : e === "MAT2" ? this.dataType = hr.MAT2 : e === "MAT3" ? this.dataType = hr.MAT3 : e === "MAT4" && (this.dataType = hr.MAT4)
			}
			SetByteStride(e) {
				this.byteStride = e
			}
			SetDataCount(e) {
				this.dataCount = e
			}
			SetSparseReader(e, t) {
				this.sparseReader = {
					indexReader: e,
					valueReader: t
				}
			}
			ReadArrayBuffer(e) {
				return this.reader.ReadArrayBuffer(e)
			}
			GetDataCount() {
				return this.dataCount
			}
			ReadData() {
				if (this.dataType === null) return null;
				if (this.dataType === hr.SCALAR) {
					let e = this.ReadComponent();
					return this.SkipBytesByStride(1), e
				} else if (this.dataType === hr.VEC2) {
					let e = this.ReadComponent(),
						t = this.ReadComponent();
					return this.SkipBytesByStride(2), new Rt(e, t)
				} else if (this.dataType === hr.VEC3) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						n = this.ReadComponent();
					return this.SkipBytesByStride(3), new Le(e, t, n)
				} else if (this.dataType === hr.VEC4) {
					let e = this.ReadComponent(),
						t = this.ReadComponent(),
						n = this.ReadComponent(),
						i = this.ReadComponent();
					return this.SkipBytesByStride(4), new ur(e, t, n, i)
				}
				return null
			}
			EnumerateData(e) {
				if (this.sparseReader === null)
					for (let t = 0; t < this.dataCount; t++) e(this.ReadData());
				else {
					let t = [];
					for (let i = 0; i < this.sparseReader.indexReader.GetDataCount(); i++) {
						let s = this.sparseReader.indexReader.ReadData(),
							o = this.sparseReader.valueReader.ReadData();
						t.push({
							index: s,
							value: o
						})
					}
					let n = 0;
					for (let i = 0; i < this.dataCount; i++) {
						let s = this.ReadData();
						n < t.length && t[n].index === i ? (e(t[n].value), n += 1) : e(s)
					}
				}
			}
			SkipBytes(e) {
				this.reader.Skip(e)
			}
			ReadComponent() {
				return this.componentType === null ? null : this.componentType === pi.BYTE ? this.reader.ReadCharacter8() : this.componentType === pi.UNSIGNED_BYTE ? this.reader.ReadUnsignedCharacter8() : this.componentType === pi.SHORT ? this.reader.ReadInteger16() : this.componentType === pi.UNSIGNED_SHORT ? this.reader.ReadUnsignedInteger16() : this.componentType === pi.UNSIGNED_INT ? this.reader.ReadInteger32() : this.componentType === pi.FLOAT ? this.reader.ReadFloat32() : null
			}
			SkipBytesByStride(e) {
				if (this.byteStride === null) return;
				let t = e * this.GetComponentSize();
				this.reader.Skip(this.byteStride - t)
			}
			GetComponentSize() {
				return this.componentType === pi.BYTE || this.componentType === pi.UNSIGNED_BYTE ? 1 : this.componentType === pi.SHORT || this.componentType === pi.UNSIGNED_SHORT ? 2 : this.componentType === pi.UNSIGNED_INT || this.componentType === pi.FLOAT ? 4 : 0
			}
		},
		xp = class {
			constructor() {
				this.supportedExtensions = ["KHR_draco_mesh_compression", "KHR_materials_pbrSpecularGlossiness", "KHR_texture_transform"], this.draco = null
			}
			LoadLibraries(e, t) {
				if (e === void 0) {
					t.onSuccess();
					return
				}
				this.draco === null && e.indexOf("KHR_draco_mesh_compression") !== -1 ? ds("loaders/draco_decoder.js")
					.then(() => {
						DracoDecoderModule()
							.then(n => {
								this.draco = n, t.onSuccess()
							})
					})
					.catch(() => {
						t.onError("Failed to load draco decoder.")
					}) : t.onSuccess()
			}
			GetUnsupportedExtensions(e) {
				let t = [];
				if (e === void 0) return t;
				for (let n = 0; n < e.length; n++) {
					let i = e[n];
					this.supportedExtensions.indexOf(i) === -1 && t.push(i)
				}
				return t
			}
			ProcessMaterial(e, t, n) {
				if (e.extensions === void 0) return null;
				let i = e.extensions.KHR_materials_pbrSpecularGlossiness;
				if (i === void 0) return null;
				let s = new An,
					o = i.diffuseFactor;
				o !== void 0 && (s.color = Wl(o), s.opacity = o[3]);
				let a = i.diffuseTexture;
				a !== void 0 && (s.diffuseMap = n(a));
				let c = i.specularFactor;
				c !== void 0 && (s.specular = Wl(c));
				let l = i.specularGlossinessTexture;
				l !== void 0 && (s.specularMap = n(l));
				let u = i.glossinessFactor;
				return u !== void 0 && (s.shininess = u), s
			}
			ProcessTexture(e, t) {
				if (e.extensions === void 0) return;
				let n = e.extensions.KHR_texture_transform;
				n !== void 0 && (n.offset !== void 0 && (t.offset.x = n.offset[0], t.offset.y = -n.offset[1]), n.scale !== void 0 && (t.scale.x = n.scale[0], t.scale.y = n.scale[1]), n.rotation !== void 0 && (t.rotation = -n.rotation))
			}
			ProcessPrimitive(e, t, n, i) {
				function s(O, k, I, q, B) {
					let Y = k.GetAttributeByUniqueId(I, q),
						J = Y.num_components(),
						$ = I.num_points() * J,
						ae = $ * 4,
						oe = O._malloc(ae);
					k.GetAttributeDataArrayForAllPoints(I, Y, O.DT_FLOAT32, ae, oe);
					let ie = new Float32Array(O.HEAPF32.buffer, oe, $)
						.slice();
					if (J === 2)
						for (let U = 0; U < ie.length; U += 2) B(new Rt(ie[U + 0], ie[U + 1]));
					else if (J === 3)
						for (let U = 0; U < ie.length; U += 3) B(new Le(ie[U + 0], ie[U + 1], ie[U + 2]));
					else if (J === 4)
						for (let U = 0; U < ie.length; U += 4) B(new ur(ie[U + 0], ie[U + 1], ie[U + 2], ie[U + 3]));
					O._free(oe)
				}
				if (this.draco === null || n.extensions === void 0 || n.extensions.KHR_draco_mesh_compression === void 0) return !1;
				let o = new this.draco.Decoder,
					a = new this.draco.DecoderBuffer,
					c = n.extensions.KHR_draco_mesh_compression,
					l = t.bufferViews[c.bufferView],
					h = e.GetReaderFromBufferView(l)
					.ReadArrayBuffer(l.byteLength);
				if (a.Init(new Int8Array(h), h.byteLength), o.GetEncodedGeometryType(a) !== this.draco.TRIANGULAR_MESH) return !0;
				let p = new this.draco.Mesh;
				if (!o.DecodeBufferToMesh(a, p)
					.ok()) return !0;
				let m = c.attributes.POSITION !== void 0,
					d = !1,
					v = c.attributes.NORMAL !== void 0,
					x = c.attributes.TEXCOORD_0 !== void 0;
				if (!m) return !0;
				let _ = i.VertexCount(),
					y = i.VertexColorCount(),
					w = i.NormalCount(),
					C = i.TextureUVCount();
				s(this.draco, o, p, c.attributes.POSITION, O => {
					i.AddVertex(O)
				}), v && s(this.draco, o, p, c.attributes.NORMAL, O => {
					i.AddNormal(O)
				}), x && s(this.draco, o, p, c.attributes.TEXCOORD_0, O => {
					O.y = -O.y, i.AddTextureUV(O)
				});
				let b = p.num_faces() * 3,
					T = b * 4,
					N = this.draco._malloc(T);
				o.GetTrianglesUInt32Array(p, T, N);
				let V = new Uint32Array(this.draco.HEAPU32.buffer, N, b)
					.slice();
				for (let O = 0; O < V.length; O += 3) {
					let k = V[O],
						I = V[O + 1],
						q = V[O + 2];
					e.AddTriangle(n, i, k, I, q, d, v, x, _, y, w, C)
				}
				return this.draco._free(N), !0
			}
		},
		Zu = class extends Ht {
			constructor() {
				super(), this.gltfExtensions = new xp
			}
			CanImportExtension(e) {
				return e === "gltf" || e === "glb"
			}
			GetUpDirection() {
				return lt.Y
			}
			ClearContent() {
				this.bufferContents = null, this.imageIndexToTextureParams = null
			}
			ResetContent() {
				this.bufferContents = [], this.imageIndexToTextureParams = new Map
			}
			ImportContent(e, t) {
				this.extension === "gltf" ? this.ProcessGltf(e, t) : this.extension === "glb" && this.ProcessBinaryGltf(e, t)
			}
			ProcessGltf(e, t) {
				let n = fn(e),
					i = JSON.parse(n);
				if (i.asset.version !== "2.0") {
					this.SetError("Invalid glTF version."), t();
					return
				}
				for (let s = 0; s < i.buffers.length; s++) {
					let o = null,
						a = i.buffers[s],
						c = hl(a.uri);
					if (c !== null) o = c.buffer;
					else {
						let l = this.callbacks.getFileBuffer(a.uri);
						l !== null && (o = l)
					}
					if (o === null) {
						this.SetError("One of the requested buffers is missing."), t();
						return
					}
					this.bufferContents.push(o)
				}
				this.ProcessMainFile(i, t)
			}
			ProcessBinaryGltf(e, t) {
				function n(l) {
					let u = l.ReadUnsignedInteger32(),
						h = l.ReadUnsignedInteger32(),
						f = l.ReadArrayBuffer(u);
					return {
						type: h,
						buffer: f
					}
				}
				let i = new Ci(e, !0);
				if (i.ReadUnsignedInteger32() !== gp.GLTF_STRING) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				if (i.ReadUnsignedInteger32() !== 2) {
					this.SetError("Invalid glTF version."), t();
					return
				}
				if (i.ReadUnsignedInteger32() !== i.GetByteLength()) {
					this.SetError("Invalid glTF file."), t();
					return
				}
				let c = null;
				for (; !i.End();) {
					let l = n(i);
					l.type === gp.JSON_CHUNK_TYPE ? c = fn(l.buffer) : l.type === gp.BINARY_CHUNK_TYPE && this.bufferContents.push(l.buffer)
				}
				if (c !== null) {
					let l = JSON.parse(c);
					this.ProcessMainFile(l, t)
				}
			}
			ProcessMainFile(e, t) {
				let n = this.gltfExtensions.GetUnsupportedExtensions(e.extensionsRequired);
				if (n.length > 0) {
					this.SetError("Unsupported extension: " + n.join(", ") + "."), t();
					return
				}
				this.gltfExtensions.LoadLibraries(e.extensionsRequired, {
					onSuccess: () => {
						this.ImportModel(e), t()
					},
					onError: i => {
						this.SetError(i), t()
					}
				})
			}
			ImportModel(e) {
				let t = e.materials;
				if (t !== void 0)
					for (let i of t) this.ImportMaterial(e, i);
				let n = e.meshes;
				if (n !== void 0)
					for (let i of n) this.ImportMesh(e, i);
				this.ImportNodes(e), this.ImportModelProperties(e)
			}
			ImportModelProperties(e) {
				function t(n, i, s) {
					let o = new On(i);
					for (let a in s)
						if (Object.prototype.hasOwnProperty.call(s, a) && typeof s[a] == "string") {
							let c = new mt(ut.Text, a, s[a]);
							o.AddProperty(c)
						} return o.PropertyCount() > 0 && n.AddPropertyGroup(o), o
				}
				t(this.model, "Asset properties", e.asset), e.asset.extras && t(this.model, "Extras", e.asset.extras)
			}
			GetDefaultScene(e) {
				let t = e.scene || 0;
				return t >= e.scenes.length ? null : e.scenes[t]
			}
			ImportMaterial(e, t) {
				let n = new xs;
				if (t.name !== void 0 && (n.name = t.name), n.color = Wl([1, 1, 1]), t.pbrMetallicRoughness !== void 0) {
					let s = t.pbrMetallicRoughness.baseColorFactor;
					s !== void 0 && (n.color = Wl(s), n.opacity = s[3]);
					let o = t.pbrMetallicRoughness.metallicFactor;
					o !== void 0 && (n.metalness = o);
					let a = t.pbrMetallicRoughness.roughnessFactor;
					a !== void 0 && (n.roughness = a);
					let c = t.emissiveFactor;
					c !== void 0 && (n.emissive = Wl(c)), n.diffuseMap = this.ImportTexture(e, t.pbrMetallicRoughness.baseColorTexture), n.metalnessMap = this.ImportTexture(e, t.pbrMetallicRoughness.metallicRoughnessTexture), n.normalMap = this.ImportTexture(e, t.normalTexture), n.emissiveMap = this.ImportTexture(e, t.emissiveTexture), n.diffuseMap !== null && (n.multiplyDiffuseMap = !0);
					let l = t.alphaMode;
					l !== void 0 && (l === "BLEND" ? n.transparent = !0 : l === "MASK" && (n.transparent = !0, n.alphaTest = t.alphaCutoff || .5))
				}
				let i = this.gltfExtensions.ProcessMaterial(t, n, s => this.ImportTexture(e, s));
				i !== null && (n = i), this.model.AddMaterial(n)
			}
			ImportTexture(e, t) {
				if (t == null) return null;
				let n = new Li,
					s = e.textures[t.index].source,
					o = e.images[s],
					a = null;
				if (this.imageIndexToTextureParams.has(s)) a = this.imageIndexToTextureParams.get(s);
				else {
					a = {
						name: null,
						mimeType: null,
						buffer: null
					};
					let c = s.toString();
					if (o.uri !== void 0) {
						let l = hl(o.uri);
						if (l !== null) a.name = "Embedded_" + c + "." + Vo(l.mimeType), a.mimeType = l.mimeType, a.buffer = l.buffer;
						else {
							let u = this.callbacks.getFileBuffer(o.uri);
							a.name = o.uri, a.buffer = u
						}
					} else if (o.bufferView !== void 0) {
						let l = e.bufferViews[o.bufferView],
							u = this.GetReaderFromBufferView(l);
						if (u !== null) {
							let h = u.ReadArrayBuffer(l.byteLength);
							a.name = "Binary_" + c + "." + Vo(o.mimeType), a.mimeType = o.mimeType, a.buffer = h
						}
					}
					this.imageIndexToTextureParams.set(s, a)
				}
				return n.name = a.name, n.mimeType = a.mimeType, n.buffer = a.buffer, this.gltfExtensions.ProcessTexture(t, n), n
			}
			ImportMesh(e, t) {
				let n = new Qt;
				this.model.AddMesh(n), t.name !== void 0 && n.SetName(t.name);
				for (let i = 0; i < t.primitives.length; i++) {
					let s = t.primitives[i];
					this.ImportPrimitive(e, s, n)
				}
			}
			ImportPrimitive(e, t, n) {
				function i(d, v, x) {
					let _ = v.attributes[x];
					if (_ === void 0) return !1;
					let y = d.accessors[_];
					return !(y === void 0 || y.count === 0)
				}
				if (this.gltfExtensions.ProcessPrimitive(this, e, t, n) || t.attributes === void 0) return;
				let s = i(e, t, "POSITION"),
					o = i(e, t, "COLOR_0"),
					a = i(e, t, "NORMAL"),
					c = i(e, t, "TEXCOORD_0"),
					l = t.indices !== void 0,
					u = Io.TRIANGLES;
				if (t.mode !== void 0 && (u = t.mode), u !== Io.TRIANGLES && u !== Io.TRIANGLE_STRIP && u !== Io.TRIANGLE_FAN) return;
				let h = n.VertexCount(),
					f = n.VertexColorCount(),
					p = n.NormalCount(),
					g = n.TextureUVCount();
				if (s) {
					let d = e.accessors[t.attributes.POSITION],
						v = this.GetReaderFromAccessor(e, d);
					if (v === null) return;
					v.EnumerateData(x => {
						n.AddVertex(x)
					})
				} else return;
				if (o) {
					let d = e.accessors[t.attributes.COLOR_0],
						v = this.GetReaderFromAccessor(e, d);
					if (v === null) return;
					v.EnumerateData(x => {
						let _ = YS([x.x, x.y, x.z], v.componentType);
						n.AddVertexColor(_)
					})
				}
				if (a) {
					let d = e.accessors[t.attributes.NORMAL],
						v = this.GetReaderFromAccessor(e, d);
					if (v === null) return;
					v.EnumerateData(x => {
						n.AddNormal(x)
					})
				}
				if (c) {
					let d = e.accessors[t.attributes.TEXCOORD_0],
						v = this.GetReaderFromAccessor(e, d);
					if (v === null) return;
					v.EnumerateData(x => {
						x.y = -x.y, n.AddTextureUV(x)
					})
				}
				let m = [];
				if (l) {
					let d = e.accessors[t.indices],
						v = this.GetReaderFromAccessor(e, d);
					if (v === null) return;
					v.EnumerateData(x => {
						m.push(x)
					})
				} else {
					let d = n.VertexCount() - h;
					for (let v = 0; v < d; v++) m.push(v)
				}
				if (u === Io.TRIANGLES)
					for (let d = 0; d < m.length; d += 3) {
						let v = m[d],
							x = m[d + 1],
							_ = m[d + 2];
						this.AddTriangle(t, n, v, x, _, o, a, c, h, f, p, g)
					} else if (u === Io.TRIANGLE_STRIP)
						for (let d = 0; d < m.length - 2; d++) {
							let v = m[d],
								x = m[d + 1],
								_ = m[d + 2];
							if (d % 2 === 1) {
								let y = x;
								x = _, _ = y
							}
							this.AddTriangle(t, n, v, x, _, o, a, c, h, f, p, g)
						} else if (u === Io.TRIANGLE_FAN)
							for (let d = 1; d < m.length - 1; d++) {
								let v = m[0],
									x = m[d],
									_ = m[d + 1];
								this.AddTriangle(t, n, v, x, _, o, a, c, h, f, p, g)
							}
			}
			AddTriangle(e, t, n, i, s, o, a, c, l, u, h, f) {
				let p = new qt(l + n, l + i, l + s);
				o && p.SetVertexColors(u + n, u + i, u + s), a && p.SetNormals(h + n, h + i, h + s), c && p.SetTextureUVs(f + n, f + i, f + s), e.material !== void 0 && (p.mat = e.material), t.AddTriangle(p)
			}
			ImportNodes(e) {
				let t = this.GetDefaultScene(e);
				if (t === null) return;
				let n = this.model.GetRootNode();
				for (let i of t.nodes) {
					let s = e.nodes[i];
					this.ImportNode(e, s, n)
				}
			}
			ImportNode(e, t, n) {
				function i(o) {
					let a = new kt()
						.CreateIdentity();
					if (o.matrix !== void 0) a.Set(o.matrix);
					else {
						let c = [0, 0, 0],
							l = [0, 0, 0, 1],
							u = [1, 1, 1];
						o.translation !== void 0 && (c = o.translation), o.rotation !== void 0 && (l = o.rotation), o.scale !== void 0 && (u = o.scale), a.ComposeTRS(Gr(c), Ca(l), Gr(u))
					}
					return new Jt(a)
				}
				if (t.children === void 0 && t.mesh === void 0) return;
				let s = new Dn;
				if (t.name !== void 0 && s.SetName(t.name), s.SetTransformation(i(t)), n.AddChildNode(s), t.children !== void 0)
					for (let o of t.children) {
						let a = e.nodes[o];
						this.ImportNode(e, a, s)
					}
				t.mesh !== void 0 && ((t.children === void 0 || t.children.length === 0) && s.SetType(zn.MeshNode), s.AddMeshIndex(t.mesh))
			}
			GetReaderFromBufferView(e) {
				let t = e.buffer || 0,
					n = this.bufferContents[t];
				if (n == null) return null;
				let i = new vp(n);
				i.SkipBytes(e.byteOffset || 0);
				let s = e.byteStride;
				return s !== void 0 && s !== 0 && i.SetByteStride(s), i
			}
			GetReaderFromAccessor(e, t) {
				let n = t.bufferView || 0,
					i = e.bufferViews[n],
					s = this.GetReaderFromBufferView(i);
				if (s === null) return null;
				if (s.SetComponentType(t.componentType), s.SetDataType(t.type), s.SetDataCount(t.count), s.SkipBytes(t.byteOffset || 0), t.sparse !== void 0) {
					let o = this.GetReaderFromSparseAccessor(e, t.sparse.indices, t.sparse.indices.componentType, "SCALAR", t.sparse.count),
						a = this.GetReaderFromSparseAccessor(e, t.sparse.values, t.componentType, t.type, t.sparse.count);
					o !== null && a !== null && s.SetSparseReader(o, a)
				}
				return s
			}
			GetReaderFromSparseAccessor(e, t, n, i, s) {
				if (t.bufferView === void 0) return null;
				let o = e.bufferViews[t.bufferView],
					a = this.GetReaderFromBufferView(o);
				return a === null ? null : (a.SetComponentType(n), a.SetDataType(i), a.SetDataCount(s), a.SkipBytes(t.byteOffset || 0), a)
			}
		};
	var Ku = class extends Ht {
		constructor() {
			super(), this.ifc = null
		}
		CanImportExtension(e) {
			return e === "ifc"
		}
		GetUpDirection() {
			return lt.Y
		}
		ClearContent() {
			this.expressIDToMesh = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.expressIDToMesh = new Map, this.colorToMaterial = new Bi(this.model)
		}
		ImportContent(e, t) {
			this.ifc === null ? ds("loaders/web-ifc-api-browser.js")
				.then(() => {
					this.ifc = new WebIFC.IfcAPI, this.ifc.Init()
						.then(() => {
							this.ImportIfcContent(e), t()
						})
				})
				.catch(() => {
					this.SetError("Failed to load web-ifc."), t()
				}) : (this.ImportIfcContent(e), t())
		}
		ImportIfcContent(e) {
			let t = new Uint8Array(e),
				n = this.ifc.OpenModel(t, {
					COORDINATE_TO_ORIGIN: !0
				}),
				i = this.ifc.LoadAllGeometry(n);
			for (let s = 0; s < i.size(); s++) {
				let o = i.get(s);
				o.geometries.size() > 0 && this.ImportIfcMesh(n, o)
			}
			this.ImportProperties(n), this.ifc.CloseModel(n)
		}
		ImportIfcMesh(e, t) {
			let n = new Qt;
			n.SetName("Mesh " + t.expressID.toString());
			let i = 0,
				s = t.geometries;
			for (let o = 0; o < s.size(); o++) {
				let a = s.get(o),
					c = this.ifc.GetGeometry(e, a.geometryExpressID),
					l = this.ifc.GetVertexArray(c.GetVertexData(), c.GetVertexDataSize()),
					u = this.ifc.GetIndexArray(c.GetIndexData(), c.GetIndexDataSize()),
					h = this.GetMaterialIndexByColor(a.color),
					f = new kt(a.flatTransformation),
					p = new Jt(f);
				for (let g = 0; g < l.length; g += 6) {
					let m = l[g],
						d = l[g + 1],
						v = l[g + 2],
						x = new Le(m, d, v),
						_ = p.TransformCoord3D(x);
					n.AddVertex(_)
				}
				for (let g = 0; g < u.length; g += 3) {
					let m = u[g],
						d = u[g + 1],
						v = u[g + 2],
						x = new qt(i + m, i + d, i + v);
					x.SetMaterial(h), n.AddTriangle(x)
				}
				i += l.length / 6
			}
			this.expressIDToMesh.set(t.expressID, n), this.model.AddMeshToRootNode(n)
		}
		ImportProperties(e) {
			let t = this.ifc.GetLineIDsWithType(e, WebIFC.IFCRELDEFINESBYPROPERTIES);
			for (let n = 0; n < t.size(); n++) {
				let i = t.get(n),
					s = this.ifc.GetLine(e, i);
				Array.isArray(s.RelatingPropertyDefinition) || s.RelatedObjects.forEach(o => {
					let a = null;
					if (this.expressIDToMesh.has(o.value) ? a = this.expressIDToMesh.get(o.value) : this.ifc.GetLine(e, o.value, !0)
						.type === WebIFC.IFCBUILDING && (a = this.model), a === null) return;
					let c = s.RelatingPropertyDefinition,
						l = this.ifc.GetLine(e, c.value, !0);
					if (!l || !l.HasProperties) return;
					let u = new On(l.Name.value);
					l.HasProperties.forEach(h => {
						if (!h || !h.Name || !h.NominalValue) return;
						let f = null,
							p = this.GetIFCString(h.Name.value),
							g = null;
						switch (h.NominalValue.label) {
							case "IFCTEXT":
							case "IFCLABEL":
							case "IFCIDENTIFIER":
								f = new mt(ut.Text, p, this.GetIFCString(h.NominalValue.value));
								break;
							case "IFCBOOLEAN":
							case "IFCLOGICAL":
								g = "Unknown", h.NominalValue.value === "T" ? g = "True" : h.NominalValue.value === "F" && (g = "False"), f = new mt(ut.Text, p, g);
								break;
							case "IFCINTEGER":
							case "IFCCOUNTMEASURE":
								f = new mt(ut.Integer, p, h.NominalValue.value);
								break;
							case "IFCREAL":
							case "IFCLENGTHMEASURE":
							case "IFCPOSITIVELENGTHMEASURE":
							case "IFCAREAMEASURE":
							case "IFCVOLUMEMEASURE":
							case "IFCRATIOMEASURE":
							case "IFCPOSITIVERATIOMEASURE":
							case "IFCMASSMEASURE":
							case "IFCMASSPERLENGTHMEASURE":
							case "IFCPLANEANGLEMEASURE":
							case "IFCTHERMALTRANSMITTANCEMEASURE":
								f = new mt(ut.Number, p, h.NominalValue.value);
								break;
							default:
								console.log(h.NominalValue.label), console.log(h.NominalValue.value);
								break
						}
						f !== null && u.AddProperty(f)
					}), u.PropertyCount() > 0 && a.AddPropertyGroup(u)
				})
			}
		}
		GetMaterialIndexByColor(e) {
			let t = Ki(e.x, e.y, e.z),
				n = parseInt(e.w * 255, 10);
			return this.colorToMaterial.GetMaterialIndex(t.r, t.g, t.b, n)
		}
		GetIFCString(e) {
			let t = this.DecodeIFCString(e);
			return t.length === 0 && (t = "-"), t
		}
		DecodeIFCString(e) {
			let t = /\\X2\\(.*?)\\X0\\/uig,
				n = e,
				i = t.exec(e);
			for (; i;) {
				let s = String.fromCharCode(parseInt(i[1], 16));
				n = n.replace(i[0], s), i = t.exec(e)
			}
			return n
		}
	};
	var jl = class {
			constructor() {
				this.name = null, this.material = null
			}
			SetName(e) {
				return this.name = e, this
			}
			SetMaterial(e) {
				return this.material = e, this
			}
		},
		Ra = class {
			constructor(e) {
				this.params = e || new jl, this.mesh = new Qt, this.params.name !== null && this.mesh.SetName(this.params.name), this.curve = null
			}
			GetMesh() {
				return this.mesh
			}
			AddVertex(e, t, n) {
				let i = new Le(e, t, n);
				return this.mesh.AddVertex(i)
			}
			AddVertices(e) {
				let t = [];
				for (let n = 0; n < e.length; n++) {
					let i = e[n];
					t.push(this.AddVertex(i.x, i.y, i.z))
				}
				return t
			}
			SetCurve(e) {
				this.curve = e
			}
			ResetCurve() {
				this.curve = null
			}
			AddTriangle(e, t, n) {
				let i = new qt(e, t, n);
				return this.params.material !== null && (i.mat = this.params.material), this.curve !== null && i.SetCurve(this.curve), this.mesh.AddTriangle(i)
			}
			AddTriangleInverted(e, t, n) {
				this.AddTriangle(e, n, t)
			}
			AddConvexPolygon(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangle(e[0], e[t + 1], e[t + 2])
			}
			AddConvexPolygonInverted(e) {
				for (let t = 0; t < e.length - 2; t++) this.AddTriangleInverted(e[0], e[t + 1], e[t + 2])
			}
		},
		Ju = class {
			constructor(e) {
				this.generator = e
			}
			GenerateSurfaceBetweenPolygons(e, t) {
				if (e.length !== t.length) return;
				let n = e.length;
				for (let i = 0; i < n; i++) {
					let s = i,
						o = i < n - 1 ? s + 1 : 0;
					this.generator.AddConvexPolygon([e[s], e[o], t[o], t[s]])
				}
			}
			GenerateTriangleFan(e, t) {
				let n = e.length;
				for (let i = 0; i < n; i++) {
					let s = i,
						o = i < n - 1 ? s + 1 : 0;
					this.generator.AddTriangle(t, e[s], e[o])
				}
			}
		};

	function Fv(r, e) {
		return new Rt(r * Math.cos(e), r * Math.sin(e))
	}

	function Uv(r, e, t, n) {
		if (!vr(e) || !vr(t) || !vr(n)) return null;
		let i = new Ra(r);
		return i.AddVertex(0, 0, 0), i.AddVertex(e, 0, 0), i.AddVertex(e, t, 0), i.AddVertex(0, t, 0), i.AddVertex(0, 0, n), i.AddVertex(e, 0, n), i.AddVertex(e, t, n), i.AddVertex(0, t, n), i.AddConvexPolygon([0, 3, 2, 1]), i.AddConvexPolygon([0, 1, 5, 4]), i.AddConvexPolygon([1, 2, 6, 5]), i.AddConvexPolygon([2, 3, 7, 6]), i.AddConvexPolygon([3, 0, 4, 7]), i.AddConvexPolygon([4, 5, 6, 7]), i.GetMesh()
	}

	function yp(r, e, t, n, i, s) {
		if (ro(e) || ro(t) || !vr(n) || i < 3) return null;
		let o = cl(e),
			a = cl(t);
		if (o && a) return null;
		let c = new Ra(r),
			l = new Ju(c),
			u = 2 * Math.PI / i,
			h = s ? 1 : null,
			f = [];
		if (o) f.push(c.AddVertex(0, 0, n));
		else
			for (let g = 0; g < i; g++) {
				let m = Fv(e, g * u);
				f.push(c.AddVertex(m.x, m.y, n))
			}
		let p = [];
		if (a) p.push(c.AddVertex(0, 0, 0));
		else
			for (let g = 0; g < i; g++) {
				let m = Fv(t, g * u);
				p.push(c.AddVertex(m.x, m.y, 0))
			}
		return o ? (c.SetCurve(h), l.GenerateTriangleFan(p, f[0]), c.ResetCurve(), c.AddConvexPolygonInverted(p)) : a ? (c.SetCurve(h), l.GenerateTriangleFan(f.slice()
			.reverse(), p[0]), c.ResetCurve(), c.AddConvexPolygon(f)) : (c.SetCurve(h), l.GenerateSurfaceBetweenPolygons(p, f), c.ResetCurve(), c.AddConvexPolygonInverted(p), c.AddConvexPolygon(f)), c.GetMesh()
	}

	function Bv(r, e, t, n, i) {
		return yp(r, e, e, t, n, i)
	}

	function Gv(r, e, t, n) {
		function i(p, g, m) {
			return new Le(p * Math.sin(g) * Math.cos(m), p * Math.sin(g) * Math.sin(m), p * Math.cos(g))
		}
		if (!vr(e) || t < 3) return null;
		let s = new Ra(r),
			o = new Ju(s);
		s.SetCurve(n ? 1 : null);
		let a = [],
			c = t + 1,
			l = Math.PI / t,
			u = 2 * Math.PI / t;
		for (let p = 1; p < c - 1; p++) {
			let g = [],
				m = p * l;
			for (let d = 0; d < t; d++) {
				let v = d * u,
					x = i(e, m, -v);
				g.push(s.AddVertex(x.x, x.y, x.z))
			}
			p > 1 && o.GenerateSurfaceBetweenPolygons(a[a.length - 1], g), a.push(g)
		}
		let h = s.AddVertex(0, 0, e),
			f = s.AddVertex(0, 0, -e);
		return o.GenerateTriangleFan(a[0].slice()
			.reverse(), h), o.GenerateTriangleFan(a[a.length - 1], f), s.ResetCurve(), s.GetMesh()
	}

	function Vv(r, e, t) {
		function n(s, o, a, c, l) {
			let u = new Le(a, c, l);
			u.MultiplyScalar(o / u.Length()), s.AddVertex(u.x, u.y, u.z)
		}
		if (!vr(t)) return null;
		let i = new Ra(r);
		if (e === "tetrahedron") {
			let s = 1;
			n(i, t, +s, +s, +s), n(i, t, -s, -s, +s), n(i, t, -s, +s, -s), n(i, t, +s, -s, -s), i.AddTriangle(0, 1, 3), i.AddTriangle(0, 2, 1), i.AddTriangle(0, 3, 2), i.AddTriangle(1, 2, 3)
		} else if (e === "hexahedron") {
			let s = 1;
			n(i, t, +s, +s, +s), n(i, t, +s, +s, -s), n(i, t, +s, -s, +s), n(i, t, +s, -s, -s), n(i, t, -s, +s, +s), n(i, t, -s, +s, -s), n(i, t, -s, -s, +s), n(i, t, -s, -s, -s), i.AddConvexPolygon([0, 1, 5, 4]), i.AddConvexPolygon([0, 2, 3, 1]), i.AddConvexPolygon([0, 4, 6, 2]), i.AddConvexPolygon([1, 3, 7, 5]), i.AddConvexPolygon([2, 6, 7, 3]), i.AddConvexPolygon([4, 5, 7, 6])
		} else if (e === "octahedron") {
			let s = 1,
				o = 0;
			n(i, t, +s, +o, +o), n(i, t, -s, +o, +o), n(i, t, +o, +s, +o), n(i, t, +o, -s, +o), n(i, t, +o, +o, +s), n(i, t, +o, +o, -s), i.AddTriangle(0, 2, 4), i.AddTriangle(0, 3, 5), i.AddTriangle(0, 4, 3), i.AddTriangle(0, 5, 2), i.AddTriangle(1, 2, 5), i.AddTriangle(1, 3, 4), i.AddTriangle(1, 4, 2), i.AddTriangle(1, 5, 3)
		} else if (e === "dodecahedron") {
			let s = 1,
				o = 0,
				a = (1 + Math.sqrt(5)) / 2,
				c = 1 / a;
			n(i, t, +s, +s, +s), n(i, t, +s, +s, -s), n(i, t, +s, -s, +s), n(i, t, -s, +s, +s), n(i, t, +s, -s, -s), n(i, t, -s, +s, -s), n(i, t, -s, -s, +s), n(i, t, -s, -s, -s), n(i, t, +o, +c, +a), n(i, t, +o, +c, -a), n(i, t, +o, -c, +a), n(i, t, +o, -c, -a), n(i, t, +c, +a, +o), n(i, t, +c, -a, +o), n(i, t, -c, +a, +o), n(i, t, -c, -a, +o), n(i, t, +a, +o, +c), n(i, t, -a, +o, +c), n(i, t, +a, +o, -c), n(i, t, -a, +o, -c), i.AddConvexPolygon([0, 8, 10, 2, 16]), i.AddConvexPolygon([0, 16, 18, 1, 12]), i.AddConvexPolygon([0, 12, 14, 3, 8]), i.AddConvexPolygon([1, 9, 5, 14, 12]), i.AddConvexPolygon([1, 18, 4, 11, 9]), i.AddConvexPolygon([2, 10, 6, 15, 13]), i.AddConvexPolygon([2, 13, 4, 18, 16]), i.AddConvexPolygon([3, 14, 5, 19, 17]), i.AddConvexPolygon([3, 17, 6, 10, 8]), i.AddConvexPolygon([4, 13, 15, 7, 11]), i.AddConvexPolygon([5, 9, 11, 7, 19]), i.AddConvexPolygon([6, 17, 19, 7, 15])
		} else if (e === "icosahedron") {
			let s = 1,
				o = 0,
				a = (1 + Math.sqrt(5)) / 2;
			n(i, t, +o, +s, +a), n(i, t, +o, +s, -a), n(i, t, +o, -s, +a), n(i, t, +o, -s, -a), n(i, t, +s, +a, +o), n(i, t, +s, -a, +o), n(i, t, -s, +a, +o), n(i, t, -s, -a, +o), n(i, t, +a, +o, +s), n(i, t, +a, +o, -s), n(i, t, -a, +o, +s), n(i, t, -a, +o, -s), i.AddTriangle(0, 2, 8), i.AddTriangle(0, 4, 6), i.AddTriangle(0, 6, 10), i.AddTriangle(0, 8, 4), i.AddTriangle(0, 10, 2), i.AddTriangle(1, 3, 11), i.AddTriangle(1, 4, 9), i.AddTriangle(1, 6, 4), i.AddTriangle(1, 9, 3), i.AddTriangle(1, 11, 6), i.AddTriangle(2, 5, 8), i.AddTriangle(2, 7, 5), i.AddTriangle(2, 10, 7), i.AddTriangle(3, 5, 7), i.AddTriangle(3, 7, 11), i.AddTriangle(3, 9, 5), i.AddTriangle(4, 8, 9), i.AddTriangle(5, 9, 8), i.AddTriangle(6, 11, 10), i.AddTriangle(7, 10, 11)
		}
		return i.GetMesh()
	}
	var $u = class extends Ht {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "o3dv"
		}
		GetUpDirection() {
			return lt.Z
		}
		ClearContent() {}
		ResetContent() {}
		ImportContent(e, t) {
			let n = fn(e),
				i = JSON.parse(n);
			if (i.root === void 0) {
				t();
				return
			}
			if (i.materials !== void 0)
				for (let o = 0; o < i.materials.length; o++) {
					let a = i.materials[o];
					this.ImportMaterial(a)
				}
			if (i.meshes !== void 0)
				for (let o = 0; o < i.meshes.length; o++) {
					let a = i.meshes[o];
					this.ImportMesh(a)
				}
			let s = i.nodes[i.root];
			this.ImportNode(i, s, this.model.GetRootNode()), this.ImportProperties(this.model, i), t()
		}
		ImportMaterial(e) {
			let t = new xs;
			t.color.Set(255, 255, 255), e.name !== void 0 && (t.name = e.name), e.color !== void 0 && (t.color = ig(e.color)), t.metalness = Cr(e.metalness, 0), t.roughness = Cr(e.roughness, 1), this.model.AddMaterial(t)
		}
		ImportMesh(e) {
			let t = new jl;
			e.name !== void 0 && t.SetName(e.name), e.material !== void 0 && t.SetMaterial(e.material);
			let n = e.parameters;
			if (n === void 0) return;
			let i = null;
			if (e.type === "cuboid") {
				if (n.size_x === void 0 || n.size_y === void 0 || n.size_z === void 0) return;
				i = Uv(t, n.size_x, n.size_y, n.size_z)
			} else if (e.type === "cylinder") {
				if (n.radius === void 0 || n.height === void 0) return;
				let s = Cr(n.segments, 25),
					o = Cr(n.smooth, !0);
				i = Bv(t, n.radius, n.height, s, o)
			} else if (e.type === "cone") {
				if (n.top_radius === void 0 || n.bottom_radius === void 0 || n.height === void 0) return;
				let s = Cr(n.segments, 25),
					o = Cr(n.smooth, !0);
				i = yp(t, n.top_radius, n.bottom_radius, n.height, s, o)
			} else if (e.type === "sphere") {
				if (n.radius === void 0) return;
				let s = Cr(n.segments, 20),
					o = Cr(n.smooth, !0);
				i = Gv(t, n.radius, s, o)
			} else if (e.type === "platonic") {
				if (n.solid_type === void 0) return;
				let s = Cr(n.radius, 1);
				i = Vv(t, n.solid_type, s)
			}
			i !== null && (this.ImportProperties(i, e), this.model.AddMesh(i))
		}
		ImportNode(e, t, n) {
			if (t.name !== void 0 && n.SetName(t.name), t.transformation !== void 0) {
				let i = this.GetTransformation(t.transformation);
				n.SetTransformation(i)
			}
			if (t.children !== void 0)
				for (let i of t.children) {
					let s = e.nodes[i],
						o = new Dn;
					n.AddChildNode(o), this.ImportNode(e, s, o)
				}
			t.mesh !== void 0 && ((t.children === void 0 || t.children.length === 0) && n.SetType(zn.MeshNode), n.AddMeshIndex(t.mesh))
		}
		ImportProperties(e, t) {
			if (t.properties !== void 0) {
				let n = new On("Properties");
				e.AddPropertyGroup(n);
				for (let i of t.properties) {
					let s = new mt(ut.Text, i.name, i.value);
					n.AddProperty(s)
				}
			}
		}
		GetTransformation(e) {
			let t = new Le(0, 0, 0),
				n = new di(0, 0, 0, 1),
				i = new Le(1, 1, 1);
			e.translation !== void 0 && (t = Gr(e.translation)), e.rotation !== void 0 && (n = Ca(e.rotation)), e.scale !== void 0 && (i = Gr(e.scale));
			let s = new kt()
				.ComposeTRS(t, n, i);
			return new Jt(s)
		}
	};
	var _p = class {
		constructor(e) {
			this.mesh = e, this.globalToMeshVertices = new Map, this.globalToMeshVertexColors = new Map, this.globalToMeshNormals = new Map, this.globalToMeshUvs = new Map
		}
		AddVertex(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertices, n => this.mesh.AddVertex(new Le(n.x, n.y, n.z)))
		}
		AddVertexColor(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshVertexColors, n => this.mesh.AddVertexColor(new nt(n.r, n.g, n.b)))
		}
		AddNormal(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshNormals, n => this.mesh.AddNormal(new Le(n.x, n.y, n.z)))
		}
		AddUV(e, t) {
			return this.GetLocalIndex(e, t, this.globalToMeshUvs, n => this.mesh.AddTextureUV(new Rt(n.x, n.y)))
		}
		AddTriangle(e) {
			this.mesh.AddTriangle(e)
		}
		GetLocalIndex(e, t, n, i) {
			if (isNaN(e) || e < 0 || e >= t.length) return null;
			if (n.has(e)) return n.get(e); {
				let s = t[e],
					o = i(s);
				return n.set(e, o), o
			}
		}
	};

	function Qu(r, e, t) {
		return Ki(parseFloat(r), parseFloat(e), parseFloat(t))
	}
	var eh = class extends Ht {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "obj"
		}
		GetUpDirection() {
			return lt.Y
		}
		ClearContent() {
			this.globalVertices = null, this.globalVertexColors = null, this.globalNormals = null, this.globalUvs = null, this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = null, this.materialNameToIndex = null
		}
		ResetContent() {
			this.globalVertices = [], this.globalVertexColors = [], this.globalNormals = [], this.globalUvs = [], this.currentMeshConverter = null, this.currentMaterial = null, this.currentMaterialIndex = null, this.meshNameToConverter = new Map, this.materialNameToIndex = new Map
		}
		ImportContent(e, t) {
			let n = fn(e);
			Gi(n, i => {
				this.WasError() || this.ProcessLine(i)
			}), t()
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = ns(e, "#");
			if (t.length === 0) return;
			let n = t[0].toLowerCase();
			t.shift(), !this.ProcessMeshParameter(n, t, e) && this.ProcessMaterialParameter(n, t, e)
		}
		AddNewMesh(e) {
			if (this.meshNameToConverter.has(e)) this.currentMeshConverter = this.meshNameToConverter.get(e);
			else {
				let t = new Qt;
				t.SetName(e), this.model.AddMeshToRootNode(t), this.currentMeshConverter = new _p(t), this.meshNameToConverter.set(e, this.currentMeshConverter)
			}
		}
		ProcessMeshParameter(e, t, n) {
			if (e === "g" || e === "o") {
				if (t.length === 0) return !0;
				let i = qs(n, e.length, "#");
				return this.AddNewMesh(i), !0
			} else {
				if (e === "v") return t.length < 3 || (this.globalVertices.push(new Le(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), t.length >= 6 && this.globalVertexColors.push(Qu(t[3], t[4], t[5]))), !0;
				if (e === "vn") return t.length < 3 || this.globalNormals.push(new Le(parseFloat(t[0]), parseFloat(t[1]), parseFloat(t[2]))), !0;
				if (e === "vt") return t.length < 2 || this.globalUvs.push(new Rt(parseFloat(t[0]), parseFloat(t[1]))), !0;
				if (e === "f") return t.length < 3 || this.ProcessFace(t), !0
			}
			return !1
		}
		ProcessMaterialParameter(e, t, n) {
			function i(s, o, a) {
				let c = new Li,
					l = qs(o, s.length, "#"),
					u = a.getFileBuffer(l);
				return c.name = l, c.buffer = u, c
			}
			if (e === "newmtl") {
				if (t.length === 0) return !0;
				let s = new An,
					o = qs(n, e.length, "#"),
					a = this.model.AddMaterial(s);
				return s.name = o, this.currentMaterial = s, this.materialNameToIndex.set(o, a), !0
			} else if (e === "usemtl") {
				if (t.length === 0) return !0;
				let s = qs(n, e.length, "#");
				return this.materialNameToIndex.has(s) && (this.currentMaterialIndex = this.materialNameToIndex.get(s)), !0
			} else if (e === "mtllib") {
				if (t.length === 0) return !0;
				let s = qs(n, e.length, "#"),
					o = this.callbacks.getFileBuffer(s);
				if (o !== null) {
					let a = fn(o);
					Gi(a, c => {
						this.WasError() || this.ProcessLine(c)
					})
				}
				return !0
			} else {
				if (e === "map_kd") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.diffuseMap = i(e, n, this.callbacks), Vi(this.currentMaterial)), !0;
				if (e === "map_ks") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.specularMap = i(e, n, this.callbacks)), !0;
				if (e === "map_bump" || e === "bump") return this.currentMaterial === null || t.length === 0 || (this.currentMaterial.bumpMap = i(e, n, this.callbacks)), !0;
				if (e === "ka") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.ambient = Qu(t[0], t[1], t[2])), !0;
				if (e === "kd") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.color = Qu(t[0], t[1], t[2])), !0;
				if (e === "ks") return this.currentMaterial === null || t.length < 3 || (this.currentMaterial.specular = Qu(t[0], t[1], t[2])), !0;
				if (e === "ns") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.shininess = parseFloat(t[0]) / 1e3), !0;
				if (e === "tr") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = 1 - parseFloat(t[0]), Vi(this.currentMaterial)), !0;
				if (e === "d") return this.currentMaterial === null || t.length < 1 || (this.currentMaterial.opacity = parseFloat(t[0]), Vi(this.currentMaterial)), !0
			}
			return !1
		}
		ProcessFace(e) {
			function t(a, c) {
				return a > 0 ? a - 1 : c + a
			}
			let n = [],
				i = [],
				s = [],
				o = [];
			for (let a = 0; a < e.length; a++) {
				let c = e[a].split("/");
				n.push(t(parseInt(c[0], 10), this.globalVertices.length)), this.globalVertices.length === this.globalVertexColors.length && i.push(t(parseInt(c[0], 10), this.globalVertices.length)), c.length > 1 && c[1].length > 0 && o.push(t(parseInt(c[1], 10), this.globalUvs.length)), c.length > 2 && c[2].length > 0 && s.push(t(parseInt(c[2], 10), this.globalNormals.length))
			}
			this.currentMeshConverter === null && this.AddNewMesh("");
			for (let a = 0; a < n.length - 2; a++) {
				let c = this.currentMeshConverter.AddVertex(n[0], this.globalVertices),
					l = this.currentMeshConverter.AddVertex(n[a + 1], this.globalVertices),
					u = this.currentMeshConverter.AddVertex(n[a + 2], this.globalVertices);
				if (c === null || l === null || u === null) {
					this.SetError("Invalid vertex index.");
					break
				}
				let h = new qt(c, l, u);
				if (i.length === n.length) {
					let f = this.currentMeshConverter.AddVertexColor(i[0], this.globalVertexColors),
						p = this.currentMeshConverter.AddVertexColor(i[a + 1], this.globalVertexColors),
						g = this.currentMeshConverter.AddVertexColor(i[a + 2], this.globalVertexColors);
					if (f === null || p === null || g === null) {
						this.SetError("Invalid vertex color index.");
						break
					}
					h.SetVertexColors(f, p, g)
				}
				if (s.length === n.length) {
					let f = this.currentMeshConverter.AddNormal(s[0], this.globalNormals),
						p = this.currentMeshConverter.AddNormal(s[a + 1], this.globalNormals),
						g = this.currentMeshConverter.AddNormal(s[a + 2], this.globalNormals);
					if (f === null || p === null || g === null) {
						this.SetError("Invalid normal index.");
						break
					}
					h.SetNormals(f, p, g)
				}
				if (o.length === n.length) {
					let f = this.currentMeshConverter.AddUV(o[0], this.globalUvs),
						p = this.currentMeshConverter.AddUV(o[a + 1], this.globalUvs),
						g = this.currentMeshConverter.AddUV(o[a + 2], this.globalUvs);
					if (f === null || p === null || g === null) {
						this.SetError("Invalid uv index.");
						break
					}
					h.SetTextureUVs(f, p, g)
				}
				this.currentMaterialIndex !== null && (h.mat = this.currentMaterialIndex), this.currentMeshConverter.AddTriangle(h)
			}
		}
	};
	var th = class extends Ht {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "off"
		}
		GetUpDirection() {
			return lt.Y
		}
		ClearContent() {
			this.mesh = null, this.status = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.mesh = new Qt, this.model.AddMeshToRootNode(this.mesh), this.status = {
				vertexCount: 0,
				faceCount: 0,
				foundVertex: 0,
				foundFace: 0
			}, this.colorToMaterial = new Bi(this.model)
		}
		ImportContent(e, t) {
			let n = fn(e);
			Gi(n, i => {
				this.WasError() || this.ProcessLine(i)
			}), t()
		}
		ProcessLine(e) {
			function t(s) {
				return s.indexOf(".") !== -1 ? Cn(parseFloat(s)) : parseInt(s, 10)
			}
			if (e[0] === "#") return;
			let n = ns(e, "#");
			if (n.length === 0 || n[0] === "OFF") return;
			if (this.status.vertexCount === 0 && this.status.faceCount === 0) {
				n.length > 1 && (this.status.vertexCount = parseInt(n[0], 10), this.status.faceCount = parseInt(n[1], 10));
				return
			}
			if (this.status.foundVertex < this.status.vertexCount) {
				n.length >= 3 && (this.mesh.AddVertex(new Le(parseFloat(n[0]), parseFloat(n[1]), parseFloat(n[2]))), this.status.foundVertex += 1), n.length >= 6 && this.mesh.AddVertexColor(new nt(t(n[3]), t(n[4]), t(n[5])));
				return
			}
			let i = this.mesh.VertexCount() === this.mesh.VertexColorCount();
			if (this.status.foundFace < this.status.faceCount) {
				if (n.length >= 4) {
					let s = parseInt(n[0], 10);
					if (n.length < s + 1) return;
					let o = null;
					if (!i && n.length >= s + 4) {
						let a = new nt(t(n[s + 1]), t(n[s + 2]), t(n[s + 3]));
						o = this.colorToMaterial.GetMaterialIndex(a.r, a.g, a.b)
					}
					for (let a = 0; a < s - 2; a++) {
						let c = parseInt(n[1]),
							l = parseInt(n[a + 2]),
							u = parseInt(n[a + 3]),
							h = new qt(c, l, u);
						i ? h.SetVertexColors(c, l, u) : h.SetMaterial(o), this.mesh.AddTriangle(h)
					}
					this.status.foundFace += 1
				}
				return
			}
		}
	};
	var Xs = {
			Ok: 1,
			NoVertices: 2,
			NoFaces: 3,
			UnknownError: 4
		},
		bp = class {
			constructor() {
				this.format = null, this.elements = []
			}
			SetFormat(e) {
				this.format = e
			}
			AddElement(e, t) {
				this.elements.push({
					name: e,
					count: t,
					format: []
				})
			}
			GetElements() {
				return this.elements
			}
			AddSingleFormat(e, t) {
				this.elements[this.elements.length - 1].format.push({
					name: t,
					isSingle: !0,
					elemType: e
				})
			}
			AddListFormat(e, t, n) {
				this.elements[this.elements.length - 1].format.push({
					name: n,
					isSingle: !1,
					countType: e,
					elemType: t
				})
			}
			GetElement(e) {
				for (let t = 0; t < this.elements.length; t++) {
					let n = this.elements[t];
					if (n.name === e) return n
				}
				return null
			}
			Check() {
				let e = this.GetElement("vertex");
				if (e === null || e.length === 0 || e.format.length < 3) return Xs.NoVertices;
				let t = this.GetElement("face");
				if (this.format === "ascii") {
					if (t === null || t.count === 0 || t.format.length < 0) return Xs.NoFaces
				} else if (this.format === "binary_little_endian" || this.format === "binary_big_endian") {
					let n = this.GetElement("tristrips"),
						i = t !== null && t.count > 0 && t.format.length > 0,
						s = n !== null && n.count > 0 && n.format.length > 0;
					if (!i && !s) return Xs.NoFaces
				} else return Xs.UnknownError;
				return Xs.Ok
			}
		},
		Mp = class {
			constructor(e) {
				this.model = e, this.colorToMaterial = new Map
			}
			GetMaterialIndexByColor(e) {
				let t = "Color " + Fn(e[0]) + Fn(e[1]) + Fn(e[2]) + Fn(e[3]);
				if (this.colorToMaterial.has(t)) return this.colorToMaterial.get(t); {
					let n = new An;
					n.name = t, n.color = new nt(e[0], e[1], e[2]), n.opacity = e[3] / 255, Vi(n);
					let i = this.model.AddMaterial(n);
					return this.colorToMaterial.set(t, i), i
				}
			}
		},
		nh = class extends Ht {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "ply"
			}
			GetUpDirection() {
				return lt.Y
			}
			ClearContent() {
				this.mesh = null
			}
			ResetContent() {
				this.mesh = new Qt, this.model.AddMeshToRootNode(this.mesh)
			}
			ImportContent(e, t) {
				let n = this.GetHeaderContent(e),
					i = this.ReadHeader(n),
					s = i.Check();
				if (s === Xs.Ok)
					if (i.format === "ascii") {
						let o = fn(e);
						o = o.substring(n.length), this.ReadAsciiContent(i, o)
					} else(i.format === "binary_little_endian" || i.format === "binary_big_endian") && this.ReadBinaryContent(i, e, n.length);
				else s === Xs.NoVertices ? this.SetError("The model contains no vertices.") : s === Xs.NoFaces ? this.SetError("The model contains no faces.") : this.SetError("Invalid header information.");
				t()
			}
			GetHeaderContent(e) {
				let t = "",
					n = new Uint8Array(e),
					i = 0;
				for (i = 0; i < e.byteLength && (t += String.fromCharCode(n[i]), !t.endsWith("end_header")); i++);
				for (i += 1; i < e.byteLength;) {
					let s = String.fromCharCode(n[i]);
					if (t += s, i += 1, s === `
`) break
				}
				return t
			}
			ReadHeader(e) {
				let t = new bp;
				return Gi(e, n => {
					let i = ns(n, null);
					i.length === 0 || i[0] === "comment" || i[0] !== "ply" && (i[0] === "format" && i.length >= 2 ? t.SetFormat(i[1]) : i[0] === "element" && i.length >= 3 ? t.AddElement(i[1], parseInt(i[2], 10)) : i[0] === "property" && i.length >= 3 && (i[1] === "list" && i.length >= 5 ? t.AddListFormat(i[2], i[3], i[4]) : t.AddSingleFormat(i[1], i[2])))
				}), t
			}
			ReadAsciiContent(e, t) {
				let n = e.GetElement("vertex"),
					i = e.GetElement("face"),
					s = 0,
					o = 0;
				Gi(t, a => {
					if (this.WasError()) return;
					let c = ns(a, null);
					if (!(c.length === 0 || c[0] === "comment")) {
						if (s < n.count) {
							c.length >= 3 && (this.mesh.AddVertex(new Le(parseFloat(c[0]), parseFloat(c[1]), parseFloat(c[2]))), s += 1);
							return
						}
						if (i !== null && o < i.count) {
							if (c.length >= 4) {
								let l = parseInt(c[0], 10);
								if (c.length < l + 1) return;
								for (let u = 0; u < l - 2; u++) {
									let h = parseInt(c[1]),
										f = parseInt(c[u + 2]),
										p = parseInt(c[u + 3]),
										g = new qt(h, f, p);
									this.mesh.AddTriangle(g)
								}
								o += 1
							}
							return
						}
					}
				})
			}
			ReadBinaryContent(e, t, n) {
				function i(u, h) {
					function f(p, g) {
						return g === "char" || g === "int8" ? p.ReadCharacter8() : g === "uchar" || g === "uint8" ? p.ReadUnsignedCharacter8() : g === "short" || g === "int16" ? p.ReadInteger16() : g === "ushort" || g === "uint16" ? p.ReadUnsignedInteger16() : g === "int" || g === "int32" ? p.ReadInteger32() : g === "uint" || g === "uint32" ? p.ReadUnsignedInteger32() : g === "float" || g === "float32" ? p.ReadFloat32() : g === "double" || g === "double64" ? p.ReadDouble64() : null
					}
					if (h.isSingle) return f(u, h.elemType); {
						let p = [],
							g = f(u, h.countType);
						for (let m = 0; m < g; m++) p.push(f(u, h.elemType));
						return p
					}
				}

				function s(u, h, f) {
					for (let p = f; p < h.length; p++) i(u, h[p])
				}

				function o(u, h, f) {
					let p = null,
						g = null,
						m = null,
						d = 255;
					for (let v = f; v < h.length; v++) {
						let x = h[v],
							_ = i(u, x);
						x.name === "red" ? p = _ : x.name === "green" ? g = _ : x.name === "blue" ? m = _ : x.name === "alpha" && (d = _)
					}
					return p !== null && g !== null && m !== null ? [p, g, m, d] : null
				}
				let a = null;
				if (e.format === "binary_little_endian") a = new Ci(t, !0);
				else if (e.format === "binary_big_endian") a = new Ci(t, !1);
				else return;
				a.Skip(n);
				let c = new Mp(this.model),
					l = e.GetElements();
				for (let u = 0; u < l.length; u++) {
					let h = l[u];
					if (h.name === "vertex")
						for (let f = 0; f < h.count; f++) {
							let p = i(a, h.format[0]),
								g = i(a, h.format[1]),
								m = i(a, h.format[2]),
								d = o(a, h.format, 3);
							d !== null && this.mesh.AddVertexColor(new nt(d[0], d[1], d[2])), this.mesh.AddVertex(new Le(p, g, m))
						} else if (h.name === "face")
							for (let f = 0; f < h.count; f++) {
								let p = i(a, h.format[0]),
									g = o(a, h.format, 1);
								for (let m = 0; m < p.length - 2; m++) {
									let d = p[0],
										v = p[m + 1],
										x = p[m + 2],
										_ = new qt(d, v, x);
									g !== null ? _.mat = c.GetMaterialIndexByColor(g) : this.mesh.VertexColorCount() > 0 && _.SetVertexColors(d, v, x), this.mesh.AddTriangle(_)
								}
							} else if (h.name === "tristrips")
								for (let f = 0; f < h.count; f++) {
									let p = i(a, h.format[0]);
									s(a, h.format, 1);
									let g = !0;
									for (let m = 0; m < p.length - 2; m++) {
										let d = p[m],
											v = p[m + 1],
											x = p[m + 2];
										if (x === -1) {
											m += 2, g = !0;
											continue
										}
										if (!g) {
											let y = v;
											v = x, x = y
										}
										g = !g;
										let _ = new qt(d, v, x);
										this.mesh.AddTriangle(_)
									}
								} else s(a, h.format, 0)
				}
			}
		};
	var ih = class extends Ht {
		constructor() {
			super(), this.worker = null
		}
		CanImportExtension(e) {
			return e === "stp" || e === "step" || e === "igs" || e === "iges" || e === "brp" || e === "brep"
		}
		GetUpDirection() {
			return lt.Y
		}
		ClearContent() {
			this.worker !== null && (this.worker.terminate(), this.worker = null)
		}
		ResetContent() {
			this.worker = null
		}
		ImportContent(e, t) {
			let n = ll("loaders/occt-import-js-worker.js");
			this.worker = new Worker(n), this.worker.addEventListener("message", o => {
				this.ImportResultJson(o.data, t)
			}), this.worker.addEventListener("error", o => {
				this.SetError("Failed to load occt-import-js."), t()
			});
			let i = null;
			if (this.extension === "stp" || this.extension === "step") i = "step";
			else if (this.extension === "igs" || this.extension === "iges") i = "iges";
			else if (this.extension === "brp" || this.extension === "brep") i = "brep";
			else {
				t();
				return
			}
			let s = new Uint8Array(e);
			this.worker.postMessage({
				format: i,
				buffer: s
			})
		}
		ImportResultJson(e, t) {
			if (!e.success) {
				t();
				return
			}
			let n = new Bi(this.model),
				i = this.model.GetRootNode();
			this.ImportNode(e, e.root, i, n), t()
		}
		ImportNode(e, t, n, i) {
			for (let s of t.meshes) {
				let o = e.meshes[s],
					a = this.ImportMesh(o, i),
					c = this.model.AddMesh(a);
				n.AddMeshIndex(c)
			}
			for (let s of t.children) {
				let o = new Dn;
				o.SetName(s.name), n.AddChildNode(o), this.ImportNode(e, s, o, i)
			}
		}
		ImportMesh(e, t) {
			let n = null;
			if (e.color) {
				let s = Ki(e.color[0], e.color[1], e.color[2]);
				n = t.GetMaterialIndex(s.r, s.g, s.b, null)
			}
			let i = es(e, n);
			if (e.name && i.SetName(e.name), e.face_colors)
				for (let s of e.face_colors) {
					let o = Ki(s.color[0], s.color[1], s.color[2]),
						a = t.GetMaterialIndex(o.r, o.g, o.b, null);
					for (let c = s.first; c <= s.last; c++) i.GetTriangle(c)
						.SetMaterial(a)
				}
			return i
		}
	};
	var rh = class extends Ht {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "stl"
		}
		GetUpDirection() {
			return lt.Z
		}
		ClearContent() {
			this.mesh = null, this.triangle = null
		}
		ResetContent() {
			this.mesh = new Qt, this.model.AddMeshToRootNode(this.mesh), this.triangle = null
		}
		ImportContent(e, t) {
			if (this.IsBinaryStlFile(e)) this.ProcessBinary(e);
			else {
				let n = fn(e);
				Gi(n, i => {
					this.WasError() || this.ProcessLine(i)
				})
			}
			t()
		}
		IsBinaryStlFile(e) {
			let t = e.byteLength;
			if (t < 84) return !1;
			let n = new Ci(e, !0);
			n.Skip(80);
			let i = n.ReadUnsignedInteger32();
			return t === i * 50 + 84
		}
		ProcessLine(e) {
			if (e[0] === "#") return;
			let t = ns(e, "#");
			if (t.length === 0) return;
			let n = t[0];
			if (n === "solid") {
				if (t.length > 1) {
					let i = qs(e, n.length, "#");
					this.mesh.SetName(i)
				}
				return
			}
			if (n === "facet") {
				if (this.triangle = new qt(-1, -1, -1), t.length >= 5 && t[1] === "normal") {
					let i = new Le(parseFloat(t[2]), parseFloat(t[3]), parseFloat(t[4]));
					if (vr(i.Length())) {
						let s = this.mesh.AddNormal(i);
						this.triangle.SetNormals(s, s, s)
					}
				}
				return
			}
			if (n === "vertex" && this.triangle !== null) {
				if (t.length >= 4) {
					let i = this.mesh.AddVertex(new Le(parseFloat(t[1]), parseFloat(t[2]), parseFloat(t[3])));
					this.triangle.v0 === -1 ? this.triangle.v0 = i : this.triangle.v1 === -1 ? this.triangle.v1 = i : this.triangle.v2 === -1 && (this.triangle.v2 = i)
				}
				return
			}
			if (n === "endfacet" && this.triangle !== null) {
				this.triangle.v0 !== -1 && this.triangle.v1 !== -1 && this.triangle.v2 !== null && this.mesh.AddTriangle(this.triangle), this.triangle = null;
				return
			}
		}
		ProcessBinary(e) {
			function t(o) {
				let a = new Le;
				return a.x = o.ReadFloat32(), a.y = o.ReadFloat32(), a.z = o.ReadFloat32(), a
			}

			function n(o, a) {
				let c = t(a);
				return o.AddVertex(c)
			}
			let i = new Ci(e, !0);
			i.Skip(80);
			let s = i.ReadUnsignedInteger32();
			for (let o = 0; o < s; o++) {
				let a = t(i),
					c = n(this.mesh, i),
					l = n(this.mesh, i),
					u = n(this.mesh, i);
				i.Skip(2);
				let h = new qt(c, l, u);
				if (vr(a.Length())) {
					let f = this.mesh.AddNormal(a);
					h.SetNormals(f, f, f)
				}
				this.mesh.AddTriangle(h)
			}
		}
	};
	var sh = class extends Ht {
		constructor() {
			super()
		}
		CanImportExtension(e) {
			return e === "bim"
		}
		GetUpDirection() {
			return lt.Z
		}
		ClearContent() {
			this.meshIdToMesh = null, this.colorToMaterial = null
		}
		ResetContent() {
			this.meshIdToMesh = new Map, this.colorToMaterial = new Bi(this.model)
		}
		ImportContent(e, t) {
			let n = fn(e),
				i = null;
			try {
				i = JSON.parse(n)
			} catch {
				this.SetError("Failed to parse bim file."), t();
				return
			}
			for (let s of i.meshes) this.meshIdToMesh.set(s.mesh_id, s);
			this.ImportProperties(i, this.model);
			for (let s of i.elements) {
				let o = this.ImportElement(s);
				o.SetName(s.type), this.ImportProperties(s, o)
			}
			t()
		}
		ImportElement(e) {
			let t = this.colorToMaterial.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a),
				n = this.model.GetRootNode(),
				i = this.meshIdToMesh.get(e.mesh_id),
				s = this.ImportMesh(i, f => e.face_colors ? this.colorToMaterial.GetMaterialIndex(e.face_colors[f * 4 + 0], e.face_colors[f * 4 + 1], e.face_colors[f * 4 + 2], e.face_colors[f * 4 + 3]) : t),
				o = this.model.AddMesh(s),
				a = new Dn;
			a.SetType(zn.MeshNode), a.AddMeshIndex(o);
			let c = new Le(0, 0, 0);
			e.vector && (c = new Le(e.vector.x, e.vector.y, e.vector.z));
			let l = new di(0, 0, 0, 1);
			e.rotation && (l = new di(e.rotation.qx, e.rotation.qy, e.rotation.qz, e.rotation.qw));
			let u = new Le(1, 1, 1),
				h = new kt()
				.ComposeTRS(c, l, u);
			return a.SetTransformation(new Jt(h)), n.AddChildNode(a), s
		}
		ImportMesh(e, t) {
			let n = new Qt;
			for (let i = 0; i < e.coordinates.length; i += 3) n.AddVertex(new Le(e.coordinates[i + 0], e.coordinates[i + 1], e.coordinates[i + 2]));
			for (let i = 0; i < e.indices.length; i += 3) {
				let s = new qt(e.indices[i + 0], e.indices[i + 1], e.indices[i + 2]);
				s.SetMaterial(t(i / 3)), n.AddTriangle(s)
			}
			return n
		}
		ImportProperties(e, t) {
			function n(o, a, c) {
				if (c == null) return;
				let l = new mt(ut.Text, a, c);
				o.AddProperty(l)
			}
			if (!e.info || Dv(e.info)) return;
			let i = e.info,
				s = new On("Info");
			n(s, "Guid", e.guid), n(s, "Type", e.type);
			for (let o in i) Object.prototype.hasOwnProperty.call(i, o) && typeof i[o] == "string" && n(s, o, i[o]);
			t.AddPropertyGroup(s)
		}
	};
	var Ys = class extends Tu {
		constructor(e) {
			super(e)
		}
		parse(e) {
			function t(B) {
				switch (B.image_type) {
					case f:
					case m:
						(B.colormap_length > 256 || B.colormap_size !== 24 || B.colormap_type !== 1) && console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
						break;
					case p:
					case g:
					case d:
					case v:
						B.colormap_type && console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
						break;
					case h:
						console.error("THREE.TGALoader: No data.");
					default:
						console.error('THREE.TGALoader: Invalid type "%s".', B.image_type)
				}(B.width <= 0 || B.height <= 0) && console.error("THREE.TGALoader: Invalid image size."), B.pixel_size !== 8 && B.pixel_size !== 16 && B.pixel_size !== 24 && B.pixel_size !== 32 && console.error('THREE.TGALoader: Invalid pixel size "%s".', B.pixel_size)
			}

			function n(B, Y, J, H, $) {
				let ae, oe, ie = J.pixel_size >> 3,
					U = J.width * J.height * ie;
				if (Y && (oe = $.subarray(H, H += J.colormap_length * (J.colormap_size >> 3))), B) {
					ae = new Uint8Array(U);
					let A, L, j, K = 0,
						Q = new Uint8Array(ie);
					for (; K < U;)
						if (A = $[H++], L = (A & 127) + 1, A & 128) {
							for (j = 0; j < ie; ++j) Q[j] = $[H++];
							for (j = 0; j < L; ++j) ae.set(Q, K + j * ie);
							K += ie * L
						} else {
							for (L *= ie, j = 0; j < L; ++j) ae[K + j] = $[H++];
							K += L
						}
				} else ae = $.subarray(H, H += Y ? J.width * J.height : U);
				return {
					pixel_data: ae,
					palettes: oe
				}
			}

			function i(B, Y, J, H, $, ae, oe, ie, U) {
				let A = U,
					L, j = 0,
					K, Q, se = N.width;
				for (Q = Y; Q !== H; Q += J)
					for (K = $; K !== oe; K += ae, j++) L = ie[j], B[(K + se * Q) * 4 + 3] = 255, B[(K + se * Q) * 4 + 2] = A[L * 3 + 0], B[(K + se * Q) * 4 + 1] = A[L * 3 + 1], B[(K + se * Q) * 4 + 0] = A[L * 3 + 2];
				return B
			}

			function s(B, Y, J, H, $, ae, oe, ie) {
				let U, A = 0,
					L, j, K = N.width;
				for (j = Y; j !== H; j += J)
					for (L = $; L !== oe; L += ae, A += 2) U = ie[A + 0] + (ie[A + 1] << 8), B[(L + K * j) * 4 + 0] = (U & 31744) >> 7, B[(L + K * j) * 4 + 1] = (U & 992) >> 2, B[(L + K * j) * 4 + 2] = (U & 31) << 3, B[(L + K * j) * 4 + 3] = U & 32768 ? 0 : 255;
				return B
			}

			function o(B, Y, J, H, $, ae, oe, ie) {
				let U = 0,
					A, L, j = N.width;
				for (L = Y; L !== H; L += J)
					for (A = $; A !== oe; A += ae, U += 3) B[(A + j * L) * 4 + 3] = 255, B[(A + j * L) * 4 + 2] = ie[U + 0], B[(A + j * L) * 4 + 1] = ie[U + 1], B[(A + j * L) * 4 + 0] = ie[U + 2];
				return B
			}

			function a(B, Y, J, H, $, ae, oe, ie) {
				let U = 0,
					A, L, j = N.width;
				for (L = Y; L !== H; L += J)
					for (A = $; A !== oe; A += ae, U += 4) B[(A + j * L) * 4 + 2] = ie[U + 0], B[(A + j * L) * 4 + 1] = ie[U + 1], B[(A + j * L) * 4 + 0] = ie[U + 2], B[(A + j * L) * 4 + 3] = ie[U + 3];
				return B
			}

			function c(B, Y, J, H, $, ae, oe, ie) {
				let U, A = 0,
					L, j, K = N.width;
				for (j = Y; j !== H; j += J)
					for (L = $; L !== oe; L += ae, A++) U = ie[A], B[(L + K * j) * 4 + 0] = U, B[(L + K * j) * 4 + 1] = U, B[(L + K * j) * 4 + 2] = U, B[(L + K * j) * 4 + 3] = 255;
				return B
			}

			function l(B, Y, J, H, $, ae, oe, ie) {
				let U = 0,
					A, L, j = N.width;
				for (L = Y; L !== H; L += J)
					for (A = $; A !== oe; A += ae, U += 2) B[(A + j * L) * 4 + 0] = ie[U + 0], B[(A + j * L) * 4 + 1] = ie[U + 0], B[(A + j * L) * 4 + 2] = ie[U + 0], B[(A + j * L) * 4 + 3] = ie[U + 1];
				return B
			}

			function u(B, Y, J, H, $) {
				let ae, oe, ie, U, A, L;
				switch ((N.flags & x) >> _) {
					default:
					case C:
						ae = 0, ie = 1, A = Y, oe = 0, U = 1, L = J;
						break;
					case y:
						ae = 0, ie = 1, A = Y, oe = J - 1, U = -1, L = -1;
						break;
					case S:
						ae = Y - 1, ie = -1, A = -1, oe = 0, U = 1, L = J;
						break;
					case w:
						ae = Y - 1, ie = -1, A = -1, oe = J - 1, U = -1, L = -1;
						break
				}
				if (k) switch (N.pixel_size) {
					case 8:
						c(B, oe, U, L, ae, ie, A, H);
						break;
					case 16:
						l(B, oe, U, L, ae, ie, A, H);
						break;
					default:
						console.error("THREE.TGALoader: Format not supported.");
						break
				} else switch (N.pixel_size) {
					case 8:
						i(B, oe, U, L, ae, ie, A, H, $);
						break;
					case 16:
						s(B, oe, U, L, ae, ie, A, H);
						break;
					case 24:
						o(B, oe, U, L, ae, ie, A, H);
						break;
					case 32:
						a(B, oe, U, L, ae, ie, A, H);
						break;
					default:
						console.error("THREE.TGALoader: Format not supported.");
						break
				}
				return B
			}
			let h = 0,
				f = 1,
				p = 2,
				g = 3,
				m = 9,
				d = 10,
				v = 11,
				x = 48,
				_ = 4,
				y = 0,
				w = 1,
				C = 2,
				S = 3;
			e.length < 19 && console.error("THREE.TGALoader: Not enough data to contain header.");
			let b = 0,
				T = new Uint8Array(e),
				N = {
					id_length: T[b++],
					colormap_type: T[b++],
					image_type: T[b++],
					colormap_index: T[b++] | T[b++] << 8,
					colormap_length: T[b++] | T[b++] << 8,
					colormap_size: T[b++],
					origin: [T[b++] | T[b++] << 8, T[b++] | T[b++] << 8],
					width: T[b++] | T[b++] << 8,
					height: T[b++] | T[b++] << 8,
					pixel_size: T[b++],
					flags: T[b++]
				};
			t(N), N.id_length + b > e.length && console.error("THREE.TGALoader: No data."), b += N.id_length;
			let V = !1,
				O = !1,
				k = !1;
			switch (N.image_type) {
				case m:
					V = !0, O = !0;
					break;
				case f:
					O = !0;
					break;
				case d:
					V = !0;
					break;
				case p:
					break;
				case v:
					V = !0, k = !0;
					break;
				case g:
					k = !0;
					break
			}
			let I = new Uint8Array(N.width * N.height * 4),
				q = n(V, O, N, b, T);
			return u(I, N.width, N.height, q.pixel_data, q.palettes), {
				data: I,
				width: N.width,
				height: N.height,
				flipY: !0,
				generateMipmaps: !0,
				minFilter: Er
			}
		}
	};
	var mh = {};
	Ym(mh, {
		AsyncCompress: () => JS,
		AsyncDecompress: () => tE,
		AsyncDeflate: () => ux,
		AsyncGunzip: () => fx,
		AsyncGzip: () => JS,
		AsyncInflate: () => Vp,
		AsyncUnzipInflate: () => fE,
		AsyncUnzlib: () => px,
		AsyncZipDeflate: () => aE,
		AsyncZlib: () => QS,
		Compress: () => Ap,
		DecodeUTF8: () => rE,
		Decompress: () => gx,
		Deflate: () => Ir,
		EncodeUTF8: () => sE,
		Gunzip: () => fh,
		Gzip: () => Ap,
		Inflate: () => mi,
		Unzip: () => dE,
		UnzipInflate: () => hE,
		UnzipPassThrough: () => wx,
		Unzlib: () => ph,
		Zip: () => lE,
		ZipDeflate: () => oE,
		ZipPassThrough: () => Zl,
		Zlib: () => Rp,
		compress: () => $S,
		compressSync: () => Ip,
		decompress: () => nE,
		decompressSync: () => iE,
		deflate: () => hx,
		deflateSync: () => Ql,
		gunzip: () => dx,
		gunzipSync: () => dh,
		gzip: () => $S,
		gzipSync: () => Ip,
		inflate: () => zp,
		inflateSync: () => Ha,
		strFromU8: () => Wp,
		strToU8: () => Ks,
		unzip: () => pE,
		unzipSync: () => qp,
		unzlib: () => mx,
		unzlibSync: () => Da,
		zip: () => cE,
		zipSync: () => uE,
		zlib: () => eE,
		zlibSync: () => Pp
	});
	var zv = {},
		Tp = function(r) {
			return URL.createObjectURL(new Blob([r], {
				type: "text/javascript"
			}))
		},
		jv = function(r) {
			return new Worker(r)
		};
	try {
		URL.revokeObjectURL(Tp(""))
	} catch {
		Tp = function(e) {
			return "data:application/javascript;charset=UTF-8," + encodeURI(e)
		}, jv = function(e) {
			return new Worker(e, {
				type: "module"
			})
		}
	}
	var ZS = function(r, e, t, n, i) {
			var s = jv(zv[e] || (zv[e] = Tp(r)));
			return s.onerror = function(o) {
				return i(o.error, null)
			}, s.onmessage = function(o) {
				return i(null, o.data)
			}, s.postMessage(t, n), s
		},
		Tt = Uint8Array,
		kn = Uint16Array,
		ss = Uint32Array,
		ka = new Tt([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
		Fa = new Tt([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
		Xl = new Tt([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
		qv = function(r, e) {
			for (var t = new kn(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
			for (var i = new ss(t[30]), n = 1; n < 30; ++n)
				for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
			return [t, i]
		},
		Xv = qv(ka, 2),
		Np = Xv[0],
		uh = Xv[1];
	Np[28] = 258, uh[258] = 28;
	var Yv = qv(Fa, 0),
		Zv = Yv[0],
		Sp = Yv[1],
		Yl = new kn(32768);
	for (Ft = 0; Ft < 32768; ++Ft) is = (Ft & 43690) >>> 1 | (Ft & 21845) << 1, is = (is & 52428) >>> 2 | (is & 13107) << 2, is = (is & 61680) >>> 4 | (is & 3855) << 4, Yl[Ft] = ((is & 65280) >>> 8 | (is & 255) << 8) >>> 1;
	var is, Ft, Hi = function(r, e, t) {
			for (var n = r.length, i = 0, s = new kn(e); i < n; ++i) ++s[r[i] - 1];
			var o = new kn(e);
			for (i = 0; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
			var a;
			if (t) {
				a = new kn(1 << e);
				var c = 15 - e;
				for (i = 0; i < n; ++i)
					if (r[i])
						for (var l = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h) a[Yl[h] >>> c] = l
			} else
				for (a = new kn(n), i = 0; i < n; ++i) r[i] && (a[i] = Yl[o[r[i] - 1]++] >>> 15 - r[i]);
			return a
		},
		os = new Tt(288);
	for (Ft = 0; Ft < 144; ++Ft) os[Ft] = 8;
	var Ft;
	for (Ft = 144; Ft < 256; ++Ft) os[Ft] = 9;
	var Ft;
	for (Ft = 256; Ft < 280; ++Ft) os[Ft] = 7;
	var Ft;
	for (Ft = 280; Ft < 288; ++Ft) os[Ft] = 8;
	var Ft, Na = new Tt(32);
	for (Ft = 0; Ft < 32; ++Ft) Na[Ft] = 5;
	var Ft, Kv = Hi(os, 9, 0),
		Jv = Hi(os, 9, 1),
		$v = Hi(Na, 5, 0),
		Qv = Hi(Na, 5, 1),
		ah = function(r) {
			for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
			return e
		},
		zi = function(r, e, t) {
			var n = e / 8 | 0;
			return (r[n] | r[n + 1] << 8) >> (e & 7) & t
		},
		lh = function(r, e) {
			var t = e / 8 | 0;
			return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
		},
		Kl = function(r) {
			return (r / 8 | 0) + (r & 7 && 1)
		},
		Wi = function(r, e, t) {
			(e == null || e < 0) && (e = 0), (t == null || t > r.length) && (t = r.length);
			var n = new(r instanceof kn ? kn : r instanceof ss ? ss : Tt)(t - e);
			return n.set(r.subarray(e, t)), n
		},
		Jl = function(r, e, t) {
			var n = r.length;
			if (!n || t && !t.l && n < 5) return e || new Tt(0);
			var i = !e || t,
				s = !t || t.i;
			t || (t = {}), e || (e = new Tt(n * 3));
			var o = function(L) {
					var j = e.length;
					if (L > j) {
						var K = new Tt(Math.max(j * 2, L));
						K.set(e), e = K
					}
				},
				a = t.f || 0,
				c = t.p || 0,
				l = t.b || 0,
				u = t.l,
				h = t.d,
				f = t.m,
				p = t.n,
				g = n * 8;
			do {
				if (!u) {
					t.f = a = zi(r, c, 1);
					var m = zi(r, c + 1, 3);
					if (c += 3, m)
						if (m == 1) u = Jv, h = Qv, f = 9, p = 5;
						else if (m == 2) {
						var _ = zi(r, c, 31) + 257,
							y = zi(r, c + 10, 15) + 4,
							w = _ + zi(r, c + 5, 31) + 1;
						c += 14;
						for (var C = new Tt(w), S = new Tt(19), b = 0; b < y; ++b) S[Xl[b]] = zi(r, c + b * 3, 7);
						c += y * 3;
						for (var T = ah(S), N = (1 << T) - 1, V = Hi(S, T, 1), b = 0; b < w;) {
							var O = V[zi(r, c, N)];
							c += O & 15;
							var d = O >>> 4;
							if (d < 16) C[b++] = d;
							else {
								var k = 0,
									I = 0;
								for (d == 16 ? (I = 3 + zi(r, c, 3), c += 2, k = C[b - 1]) : d == 17 ? (I = 3 + zi(r, c, 7), c += 3) : d == 18 && (I = 11 + zi(r, c, 127), c += 7); I--;) C[b++] = k
							}
						}
						var q = C.subarray(0, _),
							B = C.subarray(_);
						f = ah(q), p = ah(B), u = Hi(q, f, 1), h = Hi(B, p, 1)
					} else throw "invalid block type";
					else {
						var d = Kl(c) + 4,
							v = r[d - 4] | r[d - 3] << 8,
							x = d + v;
						if (x > n) {
							if (s) throw "unexpected EOF";
							break
						}
						i && o(l + v), e.set(r.subarray(d, x), l), t.b = l += v, t.p = c = x * 8;
						continue
					}
					if (c > g) {
						if (s) throw "unexpected EOF";
						break
					}
				}
				i && o(l + 131072);
				for (var Y = (1 << f) - 1, J = (1 << p) - 1, H = c;; H = c) {
					var k = u[lh(r, c) & Y],
						$ = k >>> 4;
					if (c += k & 15, c > g) {
						if (s) throw "unexpected EOF";
						break
					}
					if (!k) throw "invalid length/literal";
					if ($ < 256) e[l++] = $;
					else if ($ == 256) {
						H = c, u = null;
						break
					} else {
						var ae = $ - 254;
						if ($ > 264) {
							var b = $ - 257,
								oe = ka[b];
							ae = zi(r, c, (1 << oe) - 1) + Np[b], c += oe
						}
						var ie = h[lh(r, c) & J],
							U = ie >>> 4;
						if (!ie) throw "invalid distance";
						c += ie & 15;
						var B = Zv[U];
						if (U > 3) {
							var oe = Fa[U];
							B += lh(r, c) & (1 << oe) - 1, c += oe
						}
						if (c > g) {
							if (s) throw "unexpected EOF";
							break
						}
						i && o(l + 131072);
						for (var A = l + ae; l < A; l += 4) e[l] = e[l - B], e[l + 1] = e[l + 1 - B], e[l + 2] = e[l + 2 - B], e[l + 3] = e[l + 3 - B];
						l = A
					}
				}
				t.l = u, t.p = H, t.b = l, u && (a = 1, t.m = f, t.d = h, t.n = p)
			} while (!a);
			return l == e.length ? e : Wi(e, 0, l)
		},
		Ar = function(r, e, t) {
			t <<= e & 7;
			var n = e / 8 | 0;
			r[n] |= t, r[n + 1] |= t >>> 8
		},
		Pa = function(r, e, t) {
			t <<= e & 7;
			var n = e / 8 | 0;
			r[n] |= t, r[n + 1] |= t >>> 8, r[n + 2] |= t >>> 16
		},
		ch = function(r, e) {
			for (var t = [], n = 0; n < r.length; ++n) r[n] && t.push({
				s: n,
				f: r[n]
			});
			var i = t.length,
				s = t.slice();
			if (!i) return [rs, 0];
			if (i == 1) {
				var o = new Tt(t[0].s + 1);
				return o[t[0].s] = 1, [o, 1]
			}
			t.sort(function(w, C) {
				return w.f - C.f
			}), t.push({
				s: -1,
				f: 25001
			});
			var a = t[0],
				c = t[1],
				l = 0,
				u = 1,
				h = 2;
			for (t[0] = {
				s: -1,
				f: a.f + c.f,
				l: a,
				r: c
			}; u != i - 1;) a = t[t[l].f < t[h].f ? l++ : h++], c = t[l != u && t[l].f < t[h].f ? l++ : h++], t[u++] = {
				s: -1,
				f: a.f + c.f,
				l: a,
				r: c
			};
			for (var f = s[0].s, n = 1; n < i; ++n) s[n].s > f && (f = s[n].s);
			var p = new kn(f + 1),
				g = hh(t[u - 1], p, 0);
			if (g > e) {
				var n = 0,
					m = 0,
					d = g - e,
					v = 1 << d;
				for (s.sort(function(C, S) {
					return p[S.s] - p[C.s] || C.f - S.f
				}); n < i; ++n) {
					var x = s[n].s;
					if (p[x] > e) m += v - (1 << g - p[x]), p[x] = e;
					else break
				}
				for (m >>>= d; m > 0;) {
					var _ = s[n].s;
					p[_] < e ? m -= 1 << e - p[_]++ - 1 : ++n
				}
				for (; n >= 0 && m; --n) {
					var y = s[n].s;
					p[y] == e && (--p[y], ++m)
				}
				g = e
			}
			return [new Tt(p), g]
		},
		hh = function(r, e, t) {
			return r.s == -1 ? Math.max(hh(r.l, e, t + 1), hh(r.r, e, t + 1)) : e[r.s] = t
		},
		Ep = function(r) {
			for (var e = r.length; e && !r[--e];);
			for (var t = new kn(++e), n = 0, i = r[0], s = 1, o = function(c) {
				t[n++] = c
			}, a = 1; a <= e; ++a)
				if (r[a] == i && a != e) ++s;
				else {
					if (!i && s > 2) {
						for (; s > 138; s -= 138) o(32754);
						s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
					} else if (s > 3) {
						for (o(i), --s; s > 6; s -= 6) o(8304);
						s > 2 && (o(s - 3 << 5 | 8208), s = 0)
					}
					for (; s--;) o(i);
					s = 1, i = r[a]
				} return [t.subarray(0, n), e]
		},
		La = function(r, e) {
			for (var t = 0, n = 0; n < e.length; ++n) t += r[n] * e[n];
			return t
		},
		ql = function(r, e, t) {
			var n = t.length,
				i = Kl(e + 2);
			r[i] = n & 255, r[i + 1] = n >>> 8, r[i + 2] = r[i] ^ 255, r[i + 3] = r[i + 1] ^ 255;
			for (var s = 0; s < n; ++s) r[i + s + 4] = t[s];
			return (i + 4 + n) * 8
		},
		Cp = function(r, e, t, n, i, s, o, a, c, l, u) {
			Ar(e, u++, t), ++i[256];
			for (var h = ch(i, 15), f = h[0], p = h[1], g = ch(s, 15), m = g[0], d = g[1], v = Ep(f), x = v[0], _ = v[1], y = Ep(m), w = y[0], C = y[1], S = new kn(19), b = 0; b < x.length; ++b) S[x[b] & 31]++;
			for (var b = 0; b < w.length; ++b) S[w[b] & 31]++;
			for (var T = ch(S, 7), N = T[0], V = T[1], O = 19; O > 4 && !N[Xl[O - 1]]; --O);
			var k = l + 5 << 3,
				I = La(i, os) + La(s, Na) + o,
				q = La(i, f) + La(s, m) + o + 14 + 3 * O + La(S, N) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
			if (k <= I && k <= q) return ql(e, u, r.subarray(c, c + l));
			var B, Y, J, H;
			if (Ar(e, u, 1 + (q < I)), u += 2, q < I) {
				B = Hi(f, p, 0), Y = f, J = Hi(m, d, 0), H = m;
				var $ = Hi(N, V, 0);
				Ar(e, u, _ - 257), Ar(e, u + 5, C - 1), Ar(e, u + 10, O - 4), u += 14;
				for (var b = 0; b < O; ++b) Ar(e, u + 3 * b, N[Xl[b]]);
				u += 3 * O;
				for (var ae = [x, w], oe = 0; oe < 2; ++oe)
					for (var ie = ae[oe], b = 0; b < ie.length; ++b) {
						var U = ie[b] & 31;
						Ar(e, u, $[U]), u += N[U], U > 15 && (Ar(e, u, ie[b] >>> 5 & 127), u += ie[b] >>> 12)
					}
			} else B = Kv, Y = os, J = $v, H = Na;
			for (var b = 0; b < a; ++b)
				if (n[b] > 255) {
					var U = n[b] >>> 18 & 31;
					Pa(e, u, B[U + 257]), u += Y[U + 257], U > 7 && (Ar(e, u, n[b] >>> 23 & 31), u += ka[U]);
					var A = n[b] & 31;
					Pa(e, u, J[A]), u += H[A], A > 3 && (Pa(e, u, n[b] >>> 5 & 8191), u += Fa[A])
				} else Pa(e, u, B[n[b]]), u += Y[n[b]];
			return Pa(e, u, B[256]), u + Y[256]
		},
		ex = new ss([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
		rs = new Tt(0),
		tx = function(r, e, t, n, i, s) {
			var o = r.length,
				a = new Tt(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
				c = a.subarray(n, a.length - i),
				l = 0;
			if (!e || o < 8)
				for (var u = 0; u <= o; u += 65535) {
					var h = u + 65535;
					h < o ? l = ql(c, l, r.subarray(u, h)) : (c[u] = s, l = ql(c, l, r.subarray(u, o)))
				} else {
					for (var f = ex[e - 1], p = f >>> 13, g = f & 8191, m = (1 << t) - 1, d = new kn(32768), v = new kn(m + 1), x = Math.ceil(t / 3), _ = 2 * x, y = function(Ee) {
						return (r[Ee] ^ r[Ee + 1] << x ^ r[Ee + 2] << _) & m
					}, w = new ss(25e3), C = new kn(288), S = new kn(32), b = 0, T = 0, u = 0, N = 0, V = 0, O = 0; u < o; ++u) {
						var k = y(u),
							I = u & 32767,
							q = v[k];
						if (d[I] = q, v[k] = I, V <= u) {
							var B = o - u;
							if ((b > 7e3 || N > 24576) && B > 423) {
								l = Cp(r, c, 0, w, C, S, T, N, O, u - O, l), N = b = T = 0, O = u;
								for (var Y = 0; Y < 286; ++Y) C[Y] = 0;
								for (var Y = 0; Y < 30; ++Y) S[Y] = 0
							}
							var J = 2,
								H = 0,
								$ = g,
								ae = I - q & 32767;
							if (B > 2 && k == y(u - ae))
								for (var oe = Math.min(p, B) - 1, ie = Math.min(32767, u), U = Math.min(258, B); ae <= ie && --$ && I != q;) {
									if (r[u + J] == r[u + J - ae]) {
										for (var A = 0; A < U && r[u + A] == r[u + A - ae]; ++A);
										if (A > J) {
											if (J = A, H = ae, A > oe) break;
											for (var L = Math.min(ae, A - 2), j = 0, Y = 0; Y < L; ++Y) {
												var K = u - ae + Y + 32768 & 32767,
													Q = d[K],
													se = K - Q + 32768 & 32767;
												se > j && (j = se, q = K)
											}
										}
									}
									I = q, q = d[I], ae += I - q + 32768 & 32767
								}
							if (H) {
								w[N++] = 268435456 | uh[J] << 18 | Sp[H];
								var de = uh[J] & 31,
									ue = Sp[H] & 31;
								T += ka[de] + Fa[ue], ++C[257 + de], ++S[ue], V = u + J, ++b
							} else w[N++] = r[u], ++C[r[u]]
						}
					}
					l = Cp(r, c, s, w, C, S, T, N, O, u - O, l), !s && l & 7 && (l = ql(c, l + 1, rs))
				}
			return Wi(a, 0, n + Kl(l) + i)
		},
		nx = function() {
			for (var r = new ss(256), e = 0; e < 256; ++e) {
				for (var t = e, n = 9; --n;) t = (t & 1 && 3988292384) ^ t >>> 1;
				r[e] = t
			}
			return r
		}(),
		Ua = function() {
			var r = -1;
			return {
				p: function(e) {
					for (var t = r, n = 0; n < e.length; ++n) t = nx[t & 255 ^ e[n]] ^ t >>> 8;
					r = t
				},
				d: function() {
					return ~r
				}
			}
		},
		Dp = function() {
			var r = 1,
				e = 0;
			return {
				p: function(t) {
					for (var n = r, i = e, s = t.length, o = 0; o != s;) {
						for (var a = Math.min(o + 2655, s); o < a; ++o) i += n += t[o];
						n = (n & 65535) + 15 * (n >> 16), i = (i & 65535) + 15 * (i >> 16)
					}
					r = n, e = i
				},
				d: function() {
					return r %= 65521, e %= 65521, (r & 255) << 24 | r >>> 8 << 16 | (e & 255) << 8 | e >>> 8
				}
			}
		},
		Ro = function(r, e, t, n, i) {
			return tx(r, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 12 + e.mem, t, n, !i)
		},
		$l = function(r, e) {
			var t = {};
			for (var n in r) t[n] = r[n];
			for (var n in e) t[n] = e[n];
			return t
		},
		Hv = function(r, e, t) {
			for (var n = r(), i = r.toString(), s = i.slice(i.indexOf("[") + 1, i.lastIndexOf("]"))
				.replace(/ /g, "")
				.split(","), o = 0; o < n.length; ++o) {
				var a = n[o],
					c = s[o];
				if (typeof a == "function") {
					e += ";" + c + "=";
					var l = a.toString();
					if (a.prototype)
						if (l.indexOf("[native code]") != -1) {
							var u = l.indexOf(" ", 8) + 1;
							e += l.slice(u, l.indexOf("(", u))
						} else {
							e += l;
							for (var h in a.prototype) e += ";" + c + ".prototype." + h + "=" + a.prototype[h].toString()
						}
					else e += l
				} else t[c] = a
			}
			return [e, t]
		},
		oh = [],
		KS = function(r) {
			var e = [];
			for (var t in r)(r[t] instanceof Tt || r[t] instanceof kn || r[t] instanceof ss) && e.push((r[t] = new r[t].constructor(r[t]))
				.buffer);
			return e
		},
		ix = function(r, e, t, n) {
			var i;
			if (!oh[t]) {
				for (var s = "", o = {}, a = r.length - 1, c = 0; c < a; ++c) i = Hv(r[c], s, o), s = i[0], o = i[1];
				oh[t] = Hv(r[a], s, o)
			}
			var l = $l({}, oh[t][1]);
			return ZS(oh[t][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + e.toString() + "}", t, l, KS(l), n)
		},
		Ba = function() {
			return [Tt, kn, ss, ka, Fa, Xl, Np, Zv, Jv, Qv, Yl, Hi, ah, zi, lh, Kl, Wi, Jl, Ha, Js, Op]
		},
		Ga = function() {
			return [Tt, kn, ss, ka, Fa, Xl, uh, Sp, Kv, os, $v, Na, Yl, ex, rs, Hi, Ar, Pa, ch, hh, Ep, La, ql, Cp, Kl, Wi, tx, Ro, Ql, Js]
		},
		rx = function() {
			return [kp, Up, Gt, Ua, nx]
		},
		sx = function() {
			return [Fp, lx]
		},
		ox = function() {
			return [Bp, Gt, Dp]
		},
		ax = function() {
			return [cx]
		},
		Js = function(r) {
			return postMessage(r, [r.buffer])
		},
		Op = function(r) {
			return r && r.size && new Tt(r.size)
		},
		Va = function(r, e, t, n, i, s) {
			var o = ix(t, n, i, function(a, c) {
				o.terminate(), s(a, c)
			});
			return o.postMessage([r, e], e.consume ? [r.buffer] : []),
				function() {
					o.terminate()
				}
		},
		ji = function(r) {
			return r.ondata = function(e, t) {
					return postMessage([e, t], [e.buffer])
				},
				function(e) {
					return r.push(e.data[0], e.data[1])
				}
		},
		za = function(r, e, t, n, i) {
			var s, o = ix(r, n, i, function(a, c) {
				a ? (o.terminate(), e.ondata.call(e, a)) : (c[1] && o.terminate(), e.ondata.call(e, a, c[0], c[1]))
			});
			o.postMessage(t), e.push = function(a, c) {
				if (s) throw "stream finished";
				if (!e.ondata) throw "no stream handler";
				o.postMessage([a, s = c], [a.buffer])
			}, e.terminate = function() {
				o.terminate()
			}
		},
		ti = function(r, e) {
			return r[e] | r[e + 1] << 8
		},
		cn = function(r, e) {
			return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
		},
		wp = function(r, e) {
			return cn(r, e) + cn(r, e + 4) * 4294967296
		},
		Gt = function(r, e, t) {
			for (; t; ++e) r[e] = t, t >>>= 8
		},
		kp = function(r, e) {
			var t = e.filename;
			if (r[0] = 31, r[1] = 139, r[2] = 8, r[8] = e.level < 2 ? 4 : e.level == 9 ? 2 : 0, r[9] = 3, e.mtime != 0 && Gt(r, 4, Math.floor(new Date(e.mtime || Date.now()) / 1e3)), t) {
				r[3] = 8;
				for (var n = 0; n <= t.length; ++n) r[n + 10] = t.charCodeAt(n)
			}
		},
		Fp = function(r) {
			if (r[0] != 31 || r[1] != 139 || r[2] != 8) throw "invalid gzip data";
			var e = r[3],
				t = 10;
			e & 4 && (t += r[10] | (r[11] << 8) + 2);
			for (var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !r[t++]);
			return t + (e & 2)
		},
		lx = function(r) {
			var e = r.length;
			return (r[e - 4] | r[e - 3] << 8 | r[e - 2] << 16 | r[e - 1] << 24) >>> 0
		},
		Up = function(r) {
			return 10 + (r.filename && r.filename.length + 1 || 0)
		},
		Bp = function(r, e) {
			var t = e.level,
				n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
			r[0] = 120, r[1] = n << 6 | (n ? 32 - 2 * n : 1)
		},
		cx = function(r) {
			if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31) throw "invalid zlib data";
			if (r[1] & 32) throw "invalid zlib data: preset dictionaries not supported"
		};

	function Gp(r, e) {
		return !e && typeof r == "function" && (e = r, r = {}), this.ondata = e, r
	}
	var Ir = function() {
		function r(e, t) {
			!t && typeof e == "function" && (t = e, e = {}), this.ondata = t, this.o = e || {}
		}
		return r.prototype.p = function(e, t) {
			this.ondata(Ro(e, this.o, 0, 0, !t), t)
		}, r.prototype.push = function(e, t) {
			if (this.d) throw "stream finished";
			if (!this.ondata) throw "no stream handler";
			this.d = t, this.p(e, t || !1)
		}, r
	}();
	var ux = function() {
		function r(e, t) {
			za([Ga, function() {
				return [ji, Ir]
			}], this, Gp.call(this, e, t), function(n) {
				var i = new Ir(n.data);
				onmessage = ji(i)
			}, 6)
		}
		return r
	}();

	function hx(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ga], function(n) {
			return Js(Ql(n.data[0], n.data[1]))
		}, 0, t)
	}

	function Ql(r, e) {
		return Ro(r, e || {}, 0, 0)
	}
	var mi = function() {
		function r(e) {
			this.s = {}, this.p = new Tt(0), this.ondata = e
		}
		return r.prototype.e = function(e) {
			if (this.d) throw "stream finished";
			if (!this.ondata) throw "no stream handler";
			var t = this.p.length,
				n = new Tt(t + e.length);
			n.set(this.p), n.set(e, t), this.p = n
		}, r.prototype.c = function(e) {
			this.d = this.s.i = e || !1;
			var t = this.s.b,
				n = Jl(this.p, this.o, this.s);
			this.ondata(Wi(n, t, this.s.b), this.d), this.o = Wi(n, this.s.b - 32768), this.s.b = this.o.length, this.p = Wi(this.p, this.s.p / 8 | 0), this.s.p &= 7
		}, r.prototype.push = function(e, t) {
			this.e(e), this.c(t)
		}, r
	}();
	var Vp = function() {
		function r(e) {
			this.ondata = e, za([Ba, function() {
				return [ji, mi]
			}], this, 0, function() {
				var t = new mi;
				onmessage = ji(t)
			}, 7)
		}
		return r
	}();

	function zp(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ba], function(n) {
			return Js(Ha(n.data[0], Op(n.data[1])))
		}, 1, t)
	}

	function Ha(r, e) {
		return Jl(r, e)
	}
	var Ap = function() {
		function r(e, t) {
			this.c = Ua(), this.l = 0, this.v = 1, Ir.call(this, e, t)
		}
		return r.prototype.push = function(e, t) {
			Ir.prototype.push.call(this, e, t)
		}, r.prototype.p = function(e, t) {
			this.c.p(e), this.l += e.length;
			var n = Ro(e, this.o, this.v && Up(this.o), t && 8, !t);
			this.v && (kp(n, this.o), this.v = 0), t && (Gt(n, n.length - 8, this.c.d()), Gt(n, n.length - 4, this.l)), this.ondata(n, t)
		}, r
	}();
	var JS = function() {
		function r(e, t) {
			za([Ga, rx, function() {
				return [ji, Ir, Ap]
			}], this, Gp.call(this, e, t), function(n) {
				var i = new Ap(n.data);
				onmessage = ji(i)
			}, 8)
		}
		return r
	}();

	function $S(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ga, rx, function() {
			return [Ip]
		}], function(n) {
			return Js(Ip(n.data[0], n.data[1]))
		}, 2, t)
	}

	function Ip(r, e) {
		e || (e = {});
		var t = Ua(),
			n = r.length;
		t.p(r);
		var i = Ro(r, e, Up(e), 8),
			s = i.length;
		return kp(i, e), Gt(i, s - 8, t.d()), Gt(i, s - 4, n), i
	}
	var fh = function() {
		function r(e) {
			this.v = 1, mi.call(this, e)
		}
		return r.prototype.push = function(e, t) {
			if (mi.prototype.e.call(this, e), this.v) {
				var n = this.p.length > 3 ? Fp(this.p) : 4;
				if (n >= this.p.length && !t) return;
				this.p = this.p.subarray(n), this.v = 0
			}
			if (t) {
				if (this.p.length < 8) throw "invalid gzip stream";
				this.p = this.p.subarray(0, -8)
			}
			mi.prototype.c.call(this, t)
		}, r
	}();
	var fx = function() {
		function r(e) {
			this.ondata = e, za([Ba, sx, function() {
				return [ji, mi, fh]
			}], this, 0, function() {
				var t = new fh;
				onmessage = ji(t)
			}, 9)
		}
		return r
	}();

	function dx(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ba, sx, function() {
			return [dh]
		}], function(n) {
			return Js(dh(n.data[0]))
		}, 3, t)
	}

	function dh(r, e) {
		return Jl(r.subarray(Fp(r), -8), e || new Tt(lx(r)))
	}
	var Rp = function() {
		function r(e, t) {
			this.c = Dp(), this.v = 1, Ir.call(this, e, t)
		}
		return r.prototype.push = function(e, t) {
			Ir.prototype.push.call(this, e, t)
		}, r.prototype.p = function(e, t) {
			this.c.p(e);
			var n = Ro(e, this.o, this.v && 2, t && 4, !t);
			this.v && (Bp(n, this.o), this.v = 0), t && Gt(n, n.length - 4, this.c.d()), this.ondata(n, t)
		}, r
	}();
	var QS = function() {
		function r(e, t) {
			za([Ga, ox, function() {
				return [ji, Ir, Rp]
			}], this, Gp.call(this, e, t), function(n) {
				var i = new Rp(n.data);
				onmessage = ji(i)
			}, 10)
		}
		return r
	}();

	function eE(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ga, ox, function() {
			return [Pp]
		}], function(n) {
			return Js(Pp(n.data[0], n.data[1]))
		}, 4, t)
	}

	function Pp(r, e) {
		e || (e = {});
		var t = Dp();
		t.p(r);
		var n = Ro(r, e, 2, 4);
		return Bp(n, e), Gt(n, n.length - 4, t.d()), n
	}
	var ph = function() {
		function r(e) {
			this.v = 1, mi.call(this, e)
		}
		return r.prototype.push = function(e, t) {
			if (mi.prototype.e.call(this, e), this.v) {
				if (this.p.length < 2 && !t) return;
				this.p = this.p.subarray(2), this.v = 0
			}
			if (t) {
				if (this.p.length < 4) throw "invalid zlib stream";
				this.p = this.p.subarray(0, -4)
			}
			mi.prototype.c.call(this, t)
		}, r
	}();
	var px = function() {
		function r(e) {
			this.ondata = e, za([Ba, ax, function() {
				return [ji, mi, ph]
			}], this, 0, function() {
				var t = new ph;
				onmessage = ji(t)
			}, 11)
		}
		return r
	}();

	function mx(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return Va(r, e, [Ba, ax, function() {
			return [Da]
		}], function(n) {
			return Js(Da(n.data[0], Op(n.data[1])))
		}, 5, t)
	}

	function Da(r, e) {
		return Jl((cx(r), r.subarray(2, -4)), e)
	}
	var gx = function() {
		function r(e) {
			this.G = fh, this.I = mi, this.Z = ph, this.ondata = e
		}
		return r.prototype.push = function(e, t) {
			if (!this.ondata) throw "no stream handler";
			if (this.s) this.s.push(e, t);
			else {
				if (this.p && this.p.length) {
					var n = new Tt(this.p.length + e.length);
					n.set(this.p), n.set(e, this.p.length)
				} else this.p = e;
				if (this.p.length > 2) {
					var i = this,
						s = function() {
							i.ondata.apply(i, arguments)
						};
					this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(s) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(s) : new this.Z(s), this.s.push(this.p, t), this.p = null
				}
			}
		}, r
	}();
	var tE = function() {
		function r(e) {
			this.G = fx, this.I = Vp, this.Z = px, this.ondata = e
		}
		return r.prototype.push = function(e, t) {
			gx.prototype.push.call(this, e, t)
		}, r
	}();

	function nE(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		return r[0] == 31 && r[1] == 139 && r[2] == 8 ? dx(r, e, t) : (r[0] & 15) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31 ? zp(r, e, t) : mx(r, e, t)
	}

	function iE(r, e) {
		return r[0] == 31 && r[1] == 139 && r[2] == 8 ? dh(r, e) : (r[0] & 15) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31 ? Ha(r, e) : Da(r, e)
	}
	var Hp = function(r, e, t, n) {
			for (var i in r) {
				var s = r[i],
					o = e + i;
				s instanceof Tt ? t[o] = [s, n] : Array.isArray(s) ? t[o] = [s[0], $l(n, s[1])] : Hp(s, o + "/", t, n)
			}
		},
		Wv = typeof TextEncoder < "u" && new TextEncoder,
		Lp = typeof TextDecoder < "u" && new TextDecoder,
		vx = 0;
	try {
		Lp.decode(rs, {
			stream: !0
		}), vx = 1
	} catch {}
	var xx = function(r) {
			for (var e = "", t = 0;;) {
				var n = r[t++],
					i = (n > 127) + (n > 223) + (n > 239);
				if (t + i > r.length) return [e, Wi(r, t - 1)];
				i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536, e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
			}
		},
		rE = function() {
			function r(e) {
				this.ondata = e, vx ? this.t = new TextDecoder : this.p = rs
			}
			return r.prototype.push = function(e, t) {
				if (!this.ondata) throw "no callback";
				if (t = !!t, this.t) {
					if (this.ondata(this.t.decode(e, {
						stream: !0
					}), t), t) {
						if (this.t.decode()
							.length) throw "invalid utf-8 data";
						this.t = null
					}
					return
				}
				if (!this.p) throw "stream finished";
				var n = new Tt(this.p.length + e.length);
				n.set(this.p), n.set(e, this.p.length);
				var i = xx(n),
					s = i[0],
					o = i[1];
				if (t) {
					if (o.length) throw "invalid utf-8 data";
					this.p = null
				} else this.p = o;
				this.ondata(s, t)
			}, r
		}();
	var sE = function() {
		function r(e) {
			this.ondata = e
		}
		return r.prototype.push = function(e, t) {
			if (!this.ondata) throw "no callback";
			if (this.d) throw "stream finished";
			this.ondata(Ks(e), this.d = t || !1)
		}, r
	}();

	function Ks(r, e) {
		if (e) {
			for (var t = new Tt(r.length), n = 0; n < r.length; ++n) t[n] = r.charCodeAt(n);
			return t
		}
		if (Wv) return Wv.encode(r);
		for (var i = r.length, s = new Tt(r.length + (r.length >> 1)), o = 0, a = function(u) {
			s[o++] = u
		}, n = 0; n < i; ++n) {
			if (o + 5 > s.length) {
				var c = new Tt(o + 8 + (i - n << 1));
				c.set(s), s = c
			}
			var l = r.charCodeAt(n);
			l < 128 || e ? a(l) : l < 2048 ? (a(192 | l >> 6), a(128 | l & 63)) : l > 55295 && l < 57344 ? (l = 65536 + (l & 1023 << 10) | r.charCodeAt(++n) & 1023, a(240 | l >> 18), a(128 | l >> 12 & 63), a(128 | l >> 6 & 63), a(128 | l & 63)) : (a(224 | l >> 12), a(128 | l >> 6 & 63), a(128 | l & 63))
		}
		return Wi(s, 0, o)
	}

	function Wp(r, e) {
		if (e) {
			for (var t = "", n = 0; n < r.length; n += 16384) t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
			return t
		} else {
			if (Lp) return Lp.decode(r);
			var i = xx(r),
				s = i[0],
				o = i[1];
			if (o.length) throw "invalid utf-8 data";
			return s
		}
	}
	var yx = function(r) {
			return r == 1 ? 3 : r < 6 ? 2 : r == 9 ? 1 : 0
		},
		_x = function(r, e) {
			return e + 30 + ti(r, e + 26) + ti(r, e + 28)
		},
		bx = function(r, e, t) {
			var n = ti(r, e + 28),
				i = Wp(r.subarray(e + 46, e + 46 + n), !(ti(r, e + 8) & 2048)),
				s = e + 46 + n,
				o = cn(r, e + 20),
				a = t && o == 4294967295 ? Mx(r, s) : [o, cn(r, e + 24), cn(r, e + 42)],
				c = a[0],
				l = a[1],
				u = a[2];
			return [ti(r, e + 10), c, l, i, s + ti(r, e + 30) + ti(r, e + 32), u]
		},
		Mx = function(r, e) {
			for (; ti(r, e) != 1; e += 4 + ti(r, e + 2));
			return [wp(r, e + 12), wp(r, e + 4), wp(r, e + 20)]
		},
		Zs = function(r) {
			var e = 0;
			if (r)
				for (var t in r) {
					var n = r[t].length;
					if (n > 65535) throw "extra field too long";
					e += n + 4
				}
			return e
		},
		Oa = function(r, e, t, n, i, s, o, a) {
			var c = n.length,
				l = t.extra,
				u = a && a.length,
				h = Zs(l);
			Gt(r, e, o != null ? 33639248 : 67324752), e += 4, o != null && (r[e++] = 20, r[e++] = t.os), r[e] = 20, e += 2, r[e++] = t.flag << 1 | (s == null && 8), r[e++] = i && 8, r[e++] = t.compression & 255, r[e++] = t.compression >> 8;
			var f = new Date(t.mtime == null ? Date.now() : t.mtime),
				p = f.getFullYear() - 1980;
			if (p < 0 || p > 119) throw "date not in range 1980-2099";
			if (Gt(r, e, p << 25 | f.getMonth() + 1 << 21 | f.getDate() << 16 | f.getHours() << 11 | f.getMinutes() << 5 | f.getSeconds() >>> 1), e += 4, s != null && (Gt(r, e, t.crc), Gt(r, e + 4, s), Gt(r, e + 8, t.size)), Gt(r, e + 12, c), Gt(r, e + 14, h), e += 16, o != null && (Gt(r, e, u), Gt(r, e + 6, t.attrs), Gt(r, e + 10, o), e += 14), r.set(n, e), e += c, h)
				for (var g in l) {
					var m = l[g],
						d = m.length;
					Gt(r, e, +g), Gt(r, e + 2, d), r.set(m, e + 4), e += 4 + d
				}
			return u && (r.set(a, e), e += u), e
		},
		jp = function(r, e, t, n, i) {
			Gt(r, e, 101010256), Gt(r, e + 8, t), Gt(r, e + 10, t), Gt(r, e + 12, n), Gt(r, e + 16, i)
		},
		Zl = function() {
			function r(e) {
				this.filename = e, this.c = Ua(), this.size = 0, this.compression = 0
			}
			return r.prototype.process = function(e, t) {
				this.ondata(null, e, t)
			}, r.prototype.push = function(e, t) {
				if (!this.ondata) throw "no callback - add to ZIP archive before pushing";
				this.c.p(e), this.size += e.length, t && (this.crc = this.c.d()), this.process(e, t || !1)
			}, r
		}();
	var oE = function() {
		function r(e, t) {
			var n = this;
			t || (t = {}), Zl.call(this, e), this.d = new Ir(t, function(i, s) {
				n.ondata(null, i, s)
			}), this.compression = 8, this.flag = yx(t.level)
		}
		return r.prototype.process = function(e, t) {
			try {
				this.d.push(e, t)
			} catch (n) {
				this.ondata(n, null, t)
			}
		}, r.prototype.push = function(e, t) {
			Zl.prototype.push.call(this, e, t)
		}, r
	}();
	var aE = function() {
		function r(e, t) {
			var n = this;
			t || (t = {}), Zl.call(this, e), this.d = new ux(t, function(i, s, o) {
				n.ondata(i, s, o)
			}), this.compression = 8, this.flag = yx(t.level), this.terminate = this.d.terminate
		}
		return r.prototype.process = function(e, t) {
			this.d.push(e, t)
		}, r.prototype.push = function(e, t) {
			Zl.prototype.push.call(this, e, t)
		}, r
	}();
	var lE = function() {
		function r(e) {
			this.ondata = e, this.u = [], this.d = 1
		}
		return r.prototype.add = function(e) {
			var t = this;
			if (this.d & 2) throw "stream finished";
			var n = Ks(e.filename),
				i = n.length,
				s = e.comment,
				o = s && Ks(s),
				a = i != e.filename.length || o && s.length != o.length,
				c = i + Zs(e.extra) + 30;
			if (i > 65535) throw "filename too long";
			var l = new Tt(c);
			Oa(l, 0, e, n, a);
			var u = [l],
				h = function() {
					for (var d = 0, v = u; d < v.length; d++) {
						var x = v[d];
						t.ondata(null, x, !1)
					}
					u = []
				},
				f = this.d;
			this.d = 0;
			var p = this.u.length,
				g = $l(e, {
					f: n,
					u: a,
					o,
					t: function() {
						e.terminate && e.terminate()
					},
					r: function() {
						if (h(), f) {
							var d = t.u[p + 1];
							d ? d.r() : t.d = 1
						}
						f = 1
					}
				}),
				m = 0;
			e.ondata = function(d, v, x) {
				if (d) t.ondata(d, v, x), t.terminate();
				else if (m += v.length, u.push(v), x) {
					var _ = new Tt(16);
					Gt(_, 0, 134695760), Gt(_, 4, e.crc), Gt(_, 8, m), Gt(_, 12, e.size), u.push(_), g.c = m, g.b = c + m + 16, g.crc = e.crc, g.size = e.size, f && g.r(), f = 1
				} else f && h()
			}, this.u.push(g)
		}, r.prototype.end = function() {
			var e = this;
			if (this.d & 2) throw this.d & 1 ? "stream finishing" : "stream finished";
			this.d ? this.e() : this.u.push({
				r: function() {
					!(e.d & 1) || (e.u.splice(-1, 1), e.e())
				},
				t: function() {}
			}), this.d = 3
		}, r.prototype.e = function() {
			for (var e = 0, t = 0, n = 0, i = 0, s = this.u; i < s.length; i++) {
				var o = s[i];
				n += 46 + o.f.length + Zs(o.extra) + (o.o ? o.o.length : 0)
			}
			for (var a = new Tt(n + 22), c = 0, l = this.u; c < l.length; c++) {
				var o = l[c];
				Oa(a, e, o, o.f, o.u, o.c, t, o.o), e += 46 + o.f.length + Zs(o.extra) + (o.o ? o.o.length : 0), t += o.b
			}
			jp(a, e, this.u.length, n, t), this.ondata(null, a, !0), this.d = 2
		}, r.prototype.terminate = function() {
			for (var e = 0, t = this.u; e < t.length; e++) {
				var n = t[e];
				n.t()
			}
			this.d = 2
		}, r
	}();

	function cE(r, e, t) {
		if (t || (t = e, e = {}), typeof t != "function") throw "no callback";
		var n = {};
		Hp(r, "", n, e);
		var i = Object.keys(n),
			s = i.length,
			o = 0,
			a = 0,
			c = s,
			l = new Array(s),
			u = [],
			h = function() {
				for (var m = 0; m < u.length; ++m) u[m]()
			},
			f = function() {
				var m = new Tt(a + 22),
					d = o,
					v = a - o;
				a = 0;
				for (var x = 0; x < c; ++x) {
					var _ = l[x];
					try {
						var y = _.c.length;
						Oa(m, a, _, _.f, _.u, y);
						var w = 30 + _.f.length + Zs(_.extra),
							C = a + w;
						m.set(_.c, C), Oa(m, o, _, _.f, _.u, y, a, _.m), o += 16 + w + (_.m ? _.m.length : 0), a = C + y
					} catch (S) {
						return t(S, null)
					}
				}
				jp(m, o, l.length, v, d), t(null, m)
			};
		s || f();
		for (var p = function(m) {
			var d = i[m],
				v = n[d],
				x = v[0],
				_ = v[1],
				y = Ua(),
				w = x.length;
			y.p(x);
			var C = Ks(d),
				S = C.length,
				b = _.comment,
				T = b && Ks(b),
				N = T && T.length,
				V = Zs(_.extra),
				O = _.level == 0 ? 0 : 8,
				k = function(I, q) {
					if (I) h(), t(I, null);
					else {
						var B = q.length;
						l[m] = $l(_, {
							size: w,
							crc: y.d(),
							c: q,
							f: C,
							m: T,
							u: S != d.length || T && b.length != N,
							compression: O
						}), o += 30 + S + V + B, a += 76 + 2 * (S + V) + (N || 0) + B, --s || f()
					}
				};
			if (S > 65535 && k("filename too long", null), !O) k(null, x);
			else if (w < 16e4) try {
				k(null, Ql(x, _))
			} catch (I) {
				k(I, null)
			} else u.push(hx(x, _, k))
		}, g = 0; g < c; ++g) p(g);
		return h
	}

	function uE(r, e) {
		e || (e = {});
		var t = {},
			n = [];
		Hp(r, "", t, e);
		var i = 0,
			s = 0;
		for (var o in t) {
			var a = t[o],
				c = a[0],
				l = a[1],
				u = l.level == 0 ? 0 : 8,
				h = Ks(o),
				f = h.length,
				p = l.comment,
				g = p && Ks(p),
				m = g && g.length,
				d = Zs(l.extra);
			if (f > 65535) throw "filename too long";
			var v = u ? Ql(c, l) : c,
				x = v.length,
				_ = Ua();
			_.p(c), n.push($l(l, {
				size: c.length,
				crc: _.d(),
				c: v,
				f: h,
				m: g,
				u: f != o.length || g && p.length != m,
				o: i,
				compression: u
			})), i += 30 + f + d + x, s += 76 + 2 * (f + d) + (m || 0) + x
		}
		for (var y = new Tt(s + 22), w = i, C = s - i, S = 0; S < n.length; ++S) {
			var h = n[S];
			Oa(y, h.o, h, h.f, h.u, h.c.length);
			var b = 30 + h.f.length + Zs(h.extra);
			y.set(h.c, h.o + b), Oa(y, i, h, h.f, h.u, h.c.length, h.o, h.m), i += 16 + b + (h.m ? h.m.length : 0)
		}
		return jp(y, i, n.length, C, w), y
	}
	var wx = function() {
		function r() {}
		return r.prototype.push = function(e, t) {
			this.ondata(null, e, t)
		}, r.compression = 0, r
	}();
	var hE = function() {
		function r() {
			var e = this;
			this.i = new mi(function(t, n) {
				e.ondata(null, t, n)
			})
		}
		return r.prototype.push = function(e, t) {
			try {
				this.i.push(e, t)
			} catch (n) {
				this.ondata(n, e, t)
			}
		}, r.compression = 8, r
	}();
	var fE = function() {
		function r(e, t) {
			var n = this;
			t < 32e4 ? this.i = new mi(function(i, s) {
				n.ondata(null, i, s)
			}) : (this.i = new Vp(function(i, s, o) {
				n.ondata(i, s, o)
			}), this.terminate = this.i.terminate)
		}
		return r.prototype.push = function(e, t) {
			this.i.terminate && (e = Wi(e, 0)), this.i.push(e, t)
		}, r.compression = 8, r
	}();
	var dE = function() {
		function r(e) {
			this.onfile = e, this.k = [], this.o = {
				0: wx
			}, this.p = rs
		}
		return r.prototype.push = function(e, t) {
			var n = this;
			if (!this.onfile) throw "no callback";
			if (!this.p) throw "stream finished";
			if (this.c > 0) {
				var i = Math.min(this.c, e.length),
					s = e.subarray(0, i);
				if (this.c -= i, this.d ? this.d.push(s, !this.c) : this.k[0].push(s), e = e.subarray(i), e.length) return this.push(e, t)
			} else {
				var o = 0,
					a = 0,
					c = void 0,
					l = void 0;
				this.p.length ? e.length ? (l = new Tt(this.p.length + e.length), l.set(this.p), l.set(e, this.p.length)) : l = this.p : l = e;
				for (var u = l.length, h = this.c, f = h && this.d, p = function() {
					var v, x = cn(l, a);
					if (x == 67324752) {
						o = 1, c = a, g.d = null, g.c = 0;
						var _ = ti(l, a + 6),
							y = ti(l, a + 8),
							w = _ & 2048,
							C = _ & 8,
							S = ti(l, a + 26),
							b = ti(l, a + 28);
						if (u > a + 30 + S + b) {
							var T = [];
							g.k.unshift(T), o = 2;
							var N = cn(l, a + 18),
								V = cn(l, a + 22),
								O = Wp(l.subarray(a + 30, a += 30 + S), !w);
							N == 4294967295 ? (v = C ? [-2] : Mx(l, a), N = v[0], V = v[1]) : C && (N = -1), a += b, g.c = N;
							var k, I = {
								name: O,
								compression: y,
								start: function() {
									if (!I.ondata) throw "no callback";
									if (!N) I.ondata(null, rs, !0);
									else {
										var q = n.o[y];
										if (!q) throw "unknown compression type " + y;
										k = N < 0 ? new q(O) : new q(O, N, V), k.ondata = function(H, $, ae) {
											I.ondata(H, $, ae)
										};
										for (var B = 0, Y = T; B < Y.length; B++) {
											var J = Y[B];
											k.push(J, !1)
										}
										n.k[0] == T && n.c ? n.d = k : k.push(rs, !0)
									}
								},
								terminate: function() {
									k && k.terminate && k.terminate()
								}
							};
							N >= 0 && (I.size = N, I.originalSize = V), g.onfile(I)
						}
						return "break"
					} else if (h) {
						if (x == 134695760) return c = a += 12 + (h == -2 && 8), o = 3, g.c = 0, "break";
						if (x == 33639248) return c = a -= 4, o = 3, g.c = 0, "break"
					}
				}, g = this; a < u - 4; ++a) {
					var m = p();
					if (m === "break") break
				}
				if (this.p = rs, h < 0) {
					var d = o ? l.subarray(0, c - 12 - (h == -2 && 8) - (cn(l, c - 16) == 134695760 && 4)) : l.subarray(0, a);
					f ? f.push(d, !!o) : this.k[+(o == 2)].push(d)
				}
				if (o & 2) return this.push(l.subarray(a), t);
				this.p = l.subarray(a)
			}
			if (t) {
				if (this.c) throw "invalid zip file";
				this.p = null
			}
		}, r.prototype.register = function(e) {
			this.o[e.compression] = e
		}, r
	}();

	function pE(r, e) {
		if (typeof e != "function") throw "no callback";
		for (var t = [], n = function() {
			for (var f = 0; f < t.length; ++f) t[f]()
		}, i = {}, s = r.length - 22; cn(r, s) != 101010256; --s)
			if (!s || r.length - s > 65558) {
				e("invalid zip file", null);
				return
			} var o = ti(r, s + 8);
		o || e(null, {});
		var a = o,
			c = cn(r, s + 16),
			l = c == 4294967295;
		if (l) {
			if (s = cn(r, s - 12), cn(r, s) != 101075792) {
				e("invalid zip file", null);
				return
			}
			a = o = cn(r, s + 32), c = cn(r, s + 48)
		}
		for (var u = function(f) {
			var p = bx(r, c, l),
				g = p[0],
				m = p[1],
				d = p[2],
				v = p[3],
				x = p[4],
				_ = p[5],
				y = _x(r, _);
			c = x;
			var w = function(S, b) {
				S ? (n(), e(S, null)) : (i[v] = b, --o || e(null, i))
			};
			if (!g) w(null, Wi(r, y, y + m));
			else if (g == 8) {
				var C = r.subarray(y, y + m);
				if (m < 32e4) try {
					w(null, Ha(C, new Tt(d)))
				} catch (S) {
					w(S, null)
				} else t.push(zp(C, {
					size: d
				}, w))
			} else w("unknown compression type " + g, null)
		}, h = 0; h < a; ++h) u(h);
		return n
	}

	function qp(r) {
		for (var e = {}, t = r.length - 22; cn(r, t) != 101010256; --t)
			if (!t || r.length - t > 65558) throw "invalid zip file";
		var n = ti(r, t + 8);
		if (!n) return {};
		var i = cn(r, t + 16),
			s = i == 4294967295;
		if (s) {
			if (t = cn(r, t - 12), cn(r, t) != 101075792) throw "invalid zip file";
			n = cn(r, t + 32), i = cn(r, t + 48)
		}
		for (var o = 0; o < n; ++o) {
			var a = bx(r, i, s),
				c = a[0],
				l = a[1],
				u = a[2],
				h = a[3],
				f = a[4],
				p = a[5],
				g = _x(r, p);
			if (i = f, !c) e[h] = Wi(r, g, g + l);
			else if (c == 8) e[h] = Ha(r.subarray(g, g + l), new Tt(u));
			else throw "unknown compression type " + c
		}
		return e
	}

	function Tx(r, e, t) {
		let n = t.length - r - 1;
		if (e >= t[n]) return n - 1;
		if (e <= t[r]) return r;
		let i = r,
			s = n,
			o = Math.floor((i + s) / 2);
		for (; e < t[o] || e >= t[o + 1];) e < t[o] ? s = o : i = o, o = Math.floor((i + s) / 2);
		return o
	}

	function mE(r, e, t, n) {
		let i = [],
			s = [],
			o = [];
		i[0] = 1;
		for (let a = 1; a <= t; ++a) {
			s[a] = e - n[r + 1 - a], o[a] = n[r + a] - e;
			let c = 0;
			for (let l = 0; l < a; ++l) {
				let u = o[l + 1],
					h = s[a - l],
					f = i[l] / (u + h);
				i[l] = c + u * f, c = h * f
			}
			i[a] = c
		}
		return i
	}

	function Sx(r, e, t, n) {
		let i = Tx(r, n, e),
			s = mE(i, n, r, e),
			o = new wt(0, 0, 0, 0);
		for (let a = 0; a <= r; ++a) {
			let c = t[i - r + a],
				l = s[a],
				u = c.w * l;
			o.x += c.x * u, o.y += c.y * u, o.z += c.z * u, o.w += c.w * l
		}
		return o
	}

	function gE(r, e, t, n, i) {
		let s = [];
		for (let h = 0; h <= t; ++h) s[h] = 0;
		let o = [];
		for (let h = 0; h <= n; ++h) o[h] = s.slice(0);
		let a = [];
		for (let h = 0; h <= t; ++h) a[h] = s.slice(0);
		a[0][0] = 1;
		let c = s.slice(0),
			l = s.slice(0);
		for (let h = 1; h <= t; ++h) {
			c[h] = e - i[r + 1 - h], l[h] = i[r + h] - e;
			let f = 0;
			for (let p = 0; p < h; ++p) {
				let g = l[p + 1],
					m = c[h - p];
				a[h][p] = g + m;
				let d = a[p][h - 1] / a[h][p];
				a[p][h] = f + g * d, f = m * d
			}
			a[h][h] = f
		}
		for (let h = 0; h <= t; ++h) o[0][h] = a[h][t];
		for (let h = 0; h <= t; ++h) {
			let f = 0,
				p = 1,
				g = [];
			for (let m = 0; m <= t; ++m) g[m] = s.slice(0);
			g[0][0] = 1;
			for (let m = 1; m <= n; ++m) {
				let d = 0,
					v = h - m,
					x = t - m;
				h >= m && (g[p][0] = g[f][0] / a[x + 1][v], d = g[p][0] * a[v][x]);
				let _ = v >= -1 ? 1 : -v,
					y = h - 1 <= x ? m - 1 : t - h;
				for (let C = _; C <= y; ++C) g[p][C] = (g[f][C] - g[f][C - 1]) / a[x + 1][v + C], d += g[p][C] * a[v + C][x];
				h <= x && (g[p][m] = -g[f][m - 1] / a[x + 1][h], d += g[p][m] * a[h][x]), o[m][h] = d;
				let w = f;
				f = p, p = w
			}
		}
		let u = t;
		for (let h = 1; h <= n; ++h) {
			for (let f = 0; f <= t; ++f) o[h][f] *= u;
			u *= t - h
		}
		return o
	}

	function vE(r, e, t, n, i) {
		let s = i < r ? i : r,
			o = [],
			a = Tx(r, n, e),
			c = gE(a, n, r, s, e),
			l = [];
		for (let u = 0; u < t.length; ++u) {
			let h = t[u].clone(),
				f = h.w;
			h.x *= f, h.y *= f, h.z *= f, l[u] = h
		}
		for (let u = 0; u <= s; ++u) {
			let h = l[a - r].clone()
				.multiplyScalar(c[u][0]);
			for (let f = 1; f <= r; ++f) h.add(l[a - r + f].clone()
				.multiplyScalar(c[u][f]));
			o[u] = h
		}
		for (let u = s + 1; u <= i + 1; ++u) o[u] = new wt(0, 0, 0);
		return o
	}

	function xE(r, e) {
		let t = 1;
		for (let i = 2; i <= r; ++i) t *= i;
		let n = 1;
		for (let i = 2; i <= e; ++i) n *= i;
		for (let i = 2; i <= r - e; ++i) n *= i;
		return t / n
	}

	function yE(r) {
		let e = r.length,
			t = [],
			n = [];
		for (let s = 0; s < e; ++s) {
			let o = r[s];
			t[s] = new ne(o.x, o.y, o.z), n[s] = o.w
		}
		let i = [];
		for (let s = 0; s < e; ++s) {
			let o = t[s].clone();
			for (let a = 1; a <= s; ++a) o.sub(i[s - a].clone()
				.multiplyScalar(xE(s, a) * n[a]));
			i[s] = o.divideScalar(n[0])
		}
		return i
	}

	function Ex(r, e, t, n, i) {
		let s = vE(r, e, t, n, i);
		return yE(s)
	}
	var ec = class extends Rl {
		constructor(e, t, n, i, s) {
			super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = s || this.knots.length - 1;
			for (let o = 0; o < n.length; ++o) {
				let a = n[o];
				this.controlPoints[o] = new wt(a.x, a.y, a.z, a.w)
			}
		}
		getPoint(e, t = new ne) {
			let n = t,
				i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
				s = Sx(this.degree, this.knots, this.controlPoints, i);
			return s.w !== 1 && s.divideScalar(s.w), n.set(s.x, s.y, s.z)
		}
		getTangent(e, t = new ne) {
			let n = t,
				i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
				s = Ex(this.degree, this.knots, this.controlPoints, i, 1);
			return n.copy(s[1])
				.normalize(), n
		}
	};
	var Mt, un, gi, vh = class extends ei {
			constructor(e) {
				super(e)
			}
			load(e, t, n, i) {
				let s = this,
					o = s.path === "" ? fi.extractUrlBase(e) : s.path,
					a = new ar(this.manager);
				a.setPath(s.path), a.setResponseType("arraybuffer"), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(c) {
					try {
						t(s.parse(c, o))
					} catch (l) {
						i ? i(l) : console.error(l), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e, t) {
				if (bE(e)) Mt = new Qp()
					.parse(e);
				else {
					let i = Px(e);
					if (!ME(i)) throw new Error("THREE.FBXLoader: Unknown format.");
					if (Cx(i) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + Cx(i));
					Mt = new $p()
						.parse(i)
				}
				let n = new Fi(this.manager)
					.setPath(this.resourcePath || t)
					.setCrossOrigin(this.crossOrigin);
				return new Zp(n, this.manager)
					.parse(Mt)
			}
		},
		Zp = class {
			constructor(e, t) {
				this.textureLoader = e, this.manager = t
			}
			parse() {
				un = this.parseConnections();
				let e = this.parseImages(),
					t = this.parseTextures(e),
					n = this.parseMaterials(t),
					i = this.parseDeformers(),
					s = new Kp()
					.parse(i);
				return this.parseScene(i, s, n), gi
			}
			parseConnections() {
				let e = new Map;
				return "Connections" in Mt && Mt.Connections.connections.forEach(function(n) {
					let i = n[0],
						s = n[1],
						o = n[2];
					e.has(i) || e.set(i, {
						parents: [],
						children: []
					});
					let a = {
						ID: s,
						relationship: o
					};
					e.get(i)
						.parents.push(a), e.has(s) || e.set(s, {
							parents: [],
							children: []
						});
					let c = {
						ID: i,
						relationship: o
					};
					e.get(s)
						.children.push(c)
				}), e
			}
			parseImages() {
				let e = {},
					t = {};
				if ("Video" in Mt.Objects) {
					let n = Mt.Objects.Video;
					for (let i in n) {
						let s = n[i],
							o = parseInt(i);
						if (e[o] = s.RelativeFilename || s.Filename, "Content" in s) {
							let a = s.Content instanceof ArrayBuffer && s.Content.byteLength > 0,
								c = typeof s.Content == "string" && s.Content !== "";
							if (a || c) {
								let l = this.parseImage(n[i]);
								t[s.RelativeFilename || s.Filename] = l
							}
						}
					}
				}
				for (let n in e) {
					let i = e[n];
					t[i] !== void 0 ? e[n] = t[i] : e[n] = e[n].split("\\")
						.pop()
				}
				return e
			}
			parseImage(e) {
				let t = e.Content,
					n = e.RelativeFilename || e.Filename,
					i = n.slice(n.lastIndexOf(".") + 1)
					.toLowerCase(),
					s;
				switch (i) {
					case "bmp":
						s = "image/bmp";
						break;
					case "jpg":
					case "jpeg":
						s = "image/jpeg";
						break;
					case "png":
						s = "image/png";
						break;
					case "tif":
						s = "image/tiff";
						break;
					case "tga":
						this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", n), s = "image/tga";
						break;
					default:
						console.warn('FBXLoader: Image type "' + i + '" is not supported.');
						return
				}
				if (typeof t == "string") return "data:" + s + ";base64," + t; {
					let o = new Uint8Array(t);
					return window.URL.createObjectURL(new Blob([o], {
						type: s
					}))
				}
			}
			parseTextures(e) {
				let t = new Map;
				if ("Texture" in Mt.Objects) {
					let n = Mt.Objects.Texture;
					for (let i in n) {
						let s = this.parseTexture(n[i], e);
						t.set(parseInt(i), s)
					}
				}
				return t
			}
			parseTexture(e, t) {
				let n = this.loadTexture(e, t);
				n.ID = e.id, n.name = e.attrName;
				let i = e.WrapModeU,
					s = e.WrapModeV,
					o = i !== void 0 ? i.value : 0,
					a = s !== void 0 ? s.value : 0;
				if (n.wrapS = o === 0 ? en : Xt, n.wrapT = a === 0 ? en : Xt, "Scaling" in e) {
					let c = e.Scaling.value;
					n.repeat.x = c[0], n.repeat.y = c[1]
				}
				if ("Translation" in e) {
					let c = e.Translation.value;
					n.offset.x = c[0], n.offset.y = c[1]
				}
				return n
			}
			loadTexture(e, t) {
				let n, i = this.textureLoader.path,
					s = un.get(e.id)
					.children;
				s !== void 0 && s.length > 0 && t[s[0].ID] !== void 0 && (n = t[s[0].ID], (n.indexOf("blob:") === 0 || n.indexOf("data:") === 0) && this.textureLoader.setPath(void 0));
				let o, a = e.FileName.slice(-3)
					.toLowerCase();
				if (a === "tga") {
					let c = this.manager.getHandler(".tga");
					c === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Pn) : (c.setPath(this.textureLoader.path), o = c.load(n))
				} else a === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Pn) : o = this.textureLoader.load(n);
				return this.textureLoader.setPath(i), o
			}
			parseMaterials(e) {
				let t = new Map;
				if ("Material" in Mt.Objects) {
					let n = Mt.Objects.Material;
					for (let i in n) {
						let s = this.parseMaterial(n[i], e);
						s !== null && t.set(parseInt(i), s)
					}
				}
				return t
			}
			parseMaterial(e, t) {
				let n = e.id,
					i = e.attrName,
					s = e.ShadingModel;
				if (typeof s == "object" && (s = s.value), !un.has(n)) return null;
				let o = this.parseParameters(e, t, n),
					a;
				switch (s.toLowerCase()) {
					case "phong":
						a = new an;
						break;
					case "lambert":
						a = new ba;
						break;
					default:
						console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', s), a = new an;
						break
				}
				return a.setValues(o), a.name = i, a
			}
			parseParameters(e, t, n) {
				let i = {};
				e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = new Xe()
					.fromArray(e.Diffuse.value) : e.DiffuseColor && (e.DiffuseColor.type === "Color" || e.DiffuseColor.type === "ColorRGB") && (i.color = new Xe()
						.fromArray(e.DiffuseColor.value)), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = new Xe()
					.fromArray(e.Emissive.value) : e.EmissiveColor && (e.EmissiveColor.type === "Color" || e.EmissiveColor.type === "ColorRGB") && (i.emissive = new Xe()
						.fromArray(e.EmissiveColor.value)), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = new Xe()
					.fromArray(e.Specular.value) : e.SpecularColor && e.SpecularColor.type === "Color" && (i.specular = new Xe()
						.fromArray(e.SpecularColor.value));
				let s = this;
				return un.get(n)
					.children.forEach(function(o) {
						let a = o.relationship;
						switch (a) {
							case "Bump":
								i.bumpMap = s.getTexture(t, o.ID);
								break;
							case "Maya|TEX_ao_map":
								i.aoMap = s.getTexture(t, o.ID);
								break;
							case "DiffuseColor":
							case "Maya|TEX_color_map":
								i.map = s.getTexture(t, o.ID), i.map !== void 0 && (i.map.encoding = Pt);
								break;
							case "DisplacementColor":
								i.displacementMap = s.getTexture(t, o.ID);
								break;
							case "EmissiveColor":
								i.emissiveMap = s.getTexture(t, o.ID), i.emissiveMap !== void 0 && (i.emissiveMap.encoding = Pt);
								break;
							case "NormalMap":
							case "Maya|TEX_normal_map":
								i.normalMap = s.getTexture(t, o.ID);
								break;
							case "ReflectionColor":
								i.envMap = s.getTexture(t, o.ID), i.envMap !== void 0 && (i.envMap.mapping = Ml, i.envMap.encoding = Pt);
								break;
							case "SpecularColor":
								i.specularMap = s.getTexture(t, o.ID), i.specularMap !== void 0 && (i.specularMap.encoding = Pt);
								break;
							case "TransparentColor":
							case "TransparencyFactor":
								i.alphaMap = s.getTexture(t, o.ID), i.transparent = !0;
								break;
							case "AmbientColor":
							case "ShininessExponent":
							case "SpecularFactor":
							case "VectorDisplacementColor":
							default:
								console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", a);
								break
						}
					}), i
			}
			getTexture(e, t) {
				return "LayeredTexture" in Mt.Objects && t in Mt.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = un.get(t)
					.children[0].ID), e.get(t)
			}
			parseDeformers() {
				let e = {},
					t = {};
				if ("Deformer" in Mt.Objects) {
					let n = Mt.Objects.Deformer;
					for (let i in n) {
						let s = n[i],
							o = un.get(parseInt(i));
						if (s.attrType === "Skin") {
							let a = this.parseSkeleton(o, n);
							a.ID = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), a.geometryID = o.parents[0].ID, e[i] = a
						} else if (s.attrType === "BlendShape") {
							let a = {
								id: i
							};
							a.rawTargets = this.parseMorphTargets(o, n), a.id = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[i] = a
						}
					}
				}
				return {
					skeletons: e,
					morphTargets: t
				}
			}
			parseSkeleton(e, t) {
				let n = [];
				return e.children.forEach(function(i) {
					let s = t[i.ID];
					if (s.attrType !== "Cluster") return;
					let o = {
						ID: i.ID,
						indices: [],
						weights: [],
						transformLink: new ke()
							.fromArray(s.TransformLink.a)
					};
					"Indexes" in s && (o.indices = s.Indexes.a, o.weights = s.Weights.a), n.push(o)
				}), {
					rawBones: n,
					bones: []
				}
			}
			parseMorphTargets(e, t) {
				let n = [];
				for (let i = 0; i < e.children.length; i++) {
					let s = e.children[i],
						o = t[s.ID],
						a = {
							name: o.attrName,
							initialWeight: o.DeformPercent,
							id: o.id,
							fullWeights: o.FullWeights.a
						};
					if (o.attrType !== "BlendShapeChannel") return;
					a.geoID = un.get(parseInt(s.ID))
						.children.filter(function(c) {
							return c.relationship === void 0
						})[0].ID, n.push(a)
				}
				return n
			}
			parseScene(e, t, n) {
				gi = new _n;
				let i = this.parseModels(e.skeletons, t, n),
					s = Mt.Objects.Model,
					o = this;
				i.forEach(function(c) {
					let l = s[c.ID];
					o.setLookAtProperties(c, l), un.get(c.ID)
						.parents.forEach(function(h) {
							let f = i.get(h.ID);
							f !== void 0 && f.add(c)
						}), c.parent === null && gi.add(c)
				}), this.bindSkeleton(e.skeletons, t, i), this.createAmbientLight(), gi.traverse(function(c) {
					if (c.userData.transformData) {
						c.parent && (c.userData.transformData.parentMatrix = c.parent.matrix, c.userData.transformData.parentMatrixWorld = c.parent.matrixWorld);
						let l = Ix(c.userData.transformData);
						c.applyMatrix4(l), c.updateWorldMatrix()
					}
				});
				let a = new Jp()
					.parse();
				gi.children.length === 1 && gi.children[0].isGroup && (gi.children[0].animations = a, gi = gi.children[0]), gi.animations = a
			}
			parseModels(e, t, n) {
				let i = new Map,
					s = Mt.Objects.Model;
				for (let o in s) {
					let a = parseInt(o),
						c = s[o],
						l = un.get(a),
						u = this.buildSkeleton(l, e, a, c.attrName);
					if (!u) {
						switch (c.attrType) {
							case "Camera":
								u = this.createCamera(l);
								break;
							case "Light":
								u = this.createLight(l);
								break;
							case "Mesh":
								u = this.createMesh(l, t, n);
								break;
							case "NurbsCurve":
								u = this.createCurve(l, t);
								break;
							case "LimbNode":
							case "Root":
								u = new Ps;
								break;
							case "Null":
							default:
								u = new _n;
								break
						}
						u.name = c.attrName ? Ct.sanitizeNodeName(c.attrName) : "", u.ID = a
					}
					this.getTransformData(u, c), i.set(a, u)
				}
				return i
			}
			buildSkeleton(e, t, n, i) {
				let s = null;
				return e.parents.forEach(function(o) {
					for (let a in t) {
						let c = t[a];
						c.rawBones.forEach(function(l, u) {
							if (l.ID === o.ID) {
								let h = s;
								s = new Ps, s.matrixWorld.copy(l.transformLink), s.name = i ? Ct.sanitizeNodeName(i) : "", s.ID = n, c.bones[u] = s, h !== null && s.add(h)
							}
						})
					}
				}), s
			}
			createCamera(e) {
				let t, n;
				if (e.children.forEach(function(i) {
					let s = Mt.Objects.NodeAttribute[i.ID];
					s !== void 0 && (n = s)
				}), n === void 0) t = new yt;
				else {
					let i = 0;
					n.CameraProjectionType !== void 0 && n.CameraProjectionType.value === 1 && (i = 1);
					let s = 1;
					n.NearPlane !== void 0 && (s = n.NearPlane.value / 1e3);
					let o = 1e3;
					n.FarPlane !== void 0 && (o = n.FarPlane.value / 1e3);
					let a = window.innerWidth,
						c = window.innerHeight;
					n.AspectWidth !== void 0 && n.AspectHeight !== void 0 && (a = n.AspectWidth.value, c = n.AspectHeight.value);
					let l = a / c,
						u = 45;
					n.FieldOfView !== void 0 && (u = n.FieldOfView.value);
					let h = n.FocalLength ? n.FocalLength.value : null;
					switch (i) {
						case 0:
							t = new Kt(u, l, s, o), h !== null && t.setFocalLength(h);
							break;
						case 1:
							t = new Mr(-a / 2, a / 2, c / 2, -c / 2, s, o);
							break;
						default:
							console.warn("THREE.FBXLoader: Unknown camera type " + i + "."), t = new yt;
							break
					}
				}
				return t
			}
			createLight(e) {
				let t, n;
				if (e.children.forEach(function(i) {
					let s = Mt.Objects.NodeAttribute[i.ID];
					s !== void 0 && (n = s)
				}), n === void 0) t = new yt;
				else {
					let i;
					n.LightType === void 0 ? i = 0 : i = n.LightType.value;
					let s = 16777215;
					n.Color !== void 0 && (s = new Xe()
						.fromArray(n.Color.value));
					let o = n.Intensity === void 0 ? 1 : n.Intensity.value / 100;
					n.CastLightOnObject !== void 0 && n.CastLightOnObject.value === 0 && (o = 0);
					let a = 0;
					n.FarAttenuationEnd !== void 0 && (n.EnableFarAttenuation !== void 0 && n.EnableFarAttenuation.value === 0 ? a = 0 : a = n.FarAttenuationEnd.value);
					let c = 1;
					switch (i) {
						case 0:
							t = new Co(s, o, a, c);
							break;
						case 1:
							t = new Tr(s, o);
							break;
						case 2:
							let l = Math.PI / 3;
							n.InnerAngle !== void 0 && (l = Vn.degToRad(n.InnerAngle.value));
							let u = 0;
							n.OuterAngle !== void 0 && (u = Vn.degToRad(n.OuterAngle.value), u = Math.max(u, 1)), t = new Ta(s, o, a, l, u, c);
							break;
						default:
							console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new Co(s, o);
							break
					}
					n.CastShadows !== void 0 && n.CastShadows.value === 1 && (t.castShadow = !0)
				}
				return t
			}
			createMesh(e, t, n) {
				let i, s = null,
					o = null,
					a = [];
				return e.children.forEach(function(c) {
					t.has(c.ID) && (s = t.get(c.ID)), n.has(c.ID) && a.push(n.get(c.ID))
				}), a.length > 1 ? o = a : a.length > 0 ? o = a[0] : (o = new an({
					color: 13421772
				}), a.push(o)), "color" in s.attributes && a.forEach(function(c) {
					c.vertexColors = !0
				}), s.FBX_Deformer ? (i = new va(s, o), i.normalizeSkinWeights()) : i = new zt(s, o), i
			}
			createCurve(e, t) {
				let n = e.children.reduce(function(s, o) {
						return t.has(o.ID) && (s = t.get(o.ID)), s
					}, null),
					i = new Si({
						color: 3342591,
						linewidth: 1
					});
				return new Qr(n, i)
			}
			getTransformData(e, t) {
				let n = {};
				"InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), "RotationOrder" in t ? n.eulerOrder = Rx(t.RotationOrder.value) : n.eulerOrder = "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n
			}
			setLookAtProperties(e, t) {
				"LookAtProperty" in t && un.get(e.ID)
					.children.forEach(function(i) {
						if (i.relationship === "LookAtProperty") {
							let s = Mt.Objects.Model[i.ID];
							if ("Lcl_Translation" in s) {
								let o = s.Lcl_Translation.value;
								e.target !== void 0 ? (e.target.position.fromArray(o), gi.add(e.target)) : e.lookAt(new ne()
									.fromArray(o))
							}
						}
					})
			}
			bindSkeleton(e, t, n) {
				let i = this.parsePoseNodes();
				for (let s in e) {
					let o = e[s];
					un.get(parseInt(o.ID))
						.parents.forEach(function(c) {
							if (t.has(c.ID)) {
								let l = c.ID;
								un.get(l)
									.parents.forEach(function(h) {
										n.has(h.ID) && n.get(h.ID)
											.bind(new Ls(o.bones), i[h.ID])
									})
							}
						})
				}
			}
			parsePoseNodes() {
				let e = {};
				if ("Pose" in Mt.Objects) {
					let t = Mt.Objects.Pose;
					for (let n in t)
						if (t[n].attrType === "BindPose" && t[n].NbPoseNodes > 0) {
							let i = t[n].PoseNode;
							Array.isArray(i) ? i.forEach(function(s) {
									e[s.Node] = new ke()
										.fromArray(s.Matrix.a)
								}) : e[i.Node] = new ke()
								.fromArray(i.Matrix.a)
						}
				}
				return e
			}
			createAmbientLight() {
				if ("GlobalSettings" in Mt && "AmbientColor" in Mt.GlobalSettings) {
					let e = Mt.GlobalSettings.AmbientColor.value,
						t = e[0],
						n = e[1],
						i = e[2];
					if (t !== 0 || n !== 0 || i !== 0) {
						let s = new Xe(t, n, i);
						gi.add(new Sr(s, 1))
					}
				}
			}
		},
		Kp = class {
			parse(e) {
				let t = new Map;
				if ("Geometry" in Mt.Objects) {
					let n = Mt.Objects.Geometry;
					for (let i in n) {
						let s = un.get(parseInt(i)),
							o = this.parseGeometry(s, n[i], e);
						t.set(parseInt(i), o)
					}
				}
				return t
			}
			parseGeometry(e, t, n) {
				switch (t.attrType) {
					case "Mesh":
						return this.parseMeshGeometry(e, t, n);
					case "NurbsCurve":
						return this.parseNurbsGeometry(t)
				}
			}
			parseMeshGeometry(e, t, n) {
				let i = n.skeletons,
					s = [],
					o = e.parents.map(function(h) {
						return Mt.Objects.Model[h.ID]
					});
				if (o.length === 0) return;
				let a = e.children.reduce(function(h, f) {
					return i[f.ID] !== void 0 && (h = i[f.ID]), h
				}, null);
				e.children.forEach(function(h) {
					n.morphTargets[h.ID] !== void 0 && s.push(n.morphTargets[h.ID])
				});
				let c = o[0],
					l = {};
				"RotationOrder" in c && (l.eulerOrder = Rx(c.RotationOrder.value)), "InheritType" in c && (l.inheritType = parseInt(c.InheritType.value)), "GeometricTranslation" in c && (l.translation = c.GeometricTranslation.value), "GeometricRotation" in c && (l.rotation = c.GeometricRotation.value), "GeometricScaling" in c && (l.scale = c.GeometricScaling.value);
				let u = Ix(l);
				return this.genGeometry(t, a, s, u)
			}
			genGeometry(e, t, n, i) {
				let s = new bt;
				e.attrName && (s.name = e.attrName);
				let o = this.parseGeoNode(e, t),
					a = this.genBuffers(o),
					c = new ze(a.vertex, 3);
				if (c.applyMatrix4(i), s.setAttribute("position", c), a.colors.length > 0 && s.setAttribute("color", new ze(a.colors, 3)), t && (s.setAttribute("skinIndex", new ma(a.weightsIndices, 4)), s.setAttribute("skinWeight", new ze(a.vertexWeights, 4)), s.FBX_Deformer = t), a.normal.length > 0) {
					let l = new Jn()
						.getNormalMatrix(i),
						u = new ze(a.normal, 3);
					u.applyNormalMatrix(l), s.setAttribute("normal", u)
				}
				if (a.uvs.forEach(function(l, u) {
					let h = "uv" + (u + 1)
						.toString();
					u === 0 && (h = "uv"), s.setAttribute(h, new ze(a.uvs[u], 2))
				}), o.material && o.material.mappingType !== "AllSame") {
					let l = a.materialIndex[0],
						u = 0;
					if (a.materialIndex.forEach(function(h, f) {
						h !== l && (s.addGroup(u, f - u, l), l = h, u = f)
					}), s.groups.length > 0) {
						let h = s.groups[s.groups.length - 1],
							f = h.start + h.count;
						f !== a.materialIndex.length && s.addGroup(f, a.materialIndex.length - f, l)
					}
					s.groups.length === 0 && s.addGroup(0, a.materialIndex.length, a.materialIndex[0])
				}
				return this.addMorphTargets(s, e, n, i), s
			}
			parseGeoNode(e, t) {
				let n = {};
				if (n.vertexPositions = e.Vertices !== void 0 ? e.Vertices.a : [], n.vertexIndices = e.PolygonVertexIndex !== void 0 ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
					n.uv = [];
					let i = 0;
					for (; e.LayerElementUV[i];) e.LayerElementUV[i].UV && n.uv.push(this.parseUVs(e.LayerElementUV[i])), i++
				}
				return n.weightTable = {}, t !== null && (n.skeleton = t, t.rawBones.forEach(function(i, s) {
					i.indices.forEach(function(o, a) {
						n.weightTable[o] === void 0 && (n.weightTable[o] = []), n.weightTable[o].push({
							id: s,
							weight: i.weights[a]
						})
					})
				})), n
			}
			genBuffers(e) {
				let t = {
						vertex: [],
						normal: [],
						colors: [],
						uvs: [],
						materialIndex: [],
						vertexWeights: [],
						weightsIndices: []
					},
					n = 0,
					i = 0,
					s = !1,
					o = [],
					a = [],
					c = [],
					l = [],
					u = [],
					h = [],
					f = this;
				return e.vertexIndices.forEach(function(p, g) {
					let m, d = !1;
					p < 0 && (p = p ^ -1, d = !0);
					let v = [],
						x = [];
					if (o.push(p * 3, p * 3 + 1, p * 3 + 2), e.color) {
						let _ = gh(g, n, p, e.color);
						c.push(_[0], _[1], _[2])
					}
					if (e.skeleton) {
						if (e.weightTable[p] !== void 0 && e.weightTable[p].forEach(function(_) {
							x.push(_.weight), v.push(_.id)
						}), x.length > 4) {
							s || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), s = !0);
							let _ = [0, 0, 0, 0],
								y = [0, 0, 0, 0];
							x.forEach(function(w, C) {
								let S = w,
									b = v[C];
								y.forEach(function(T, N, V) {
									if (S > T) {
										V[N] = S, S = T;
										let O = _[N];
										_[N] = b, b = O
									}
								})
							}), v = _, x = y
						}
						for (; x.length < 4;) x.push(0), v.push(0);
						for (let _ = 0; _ < 4; ++_) u.push(x[_]), h.push(v[_])
					}
					if (e.normal) {
						let _ = gh(g, n, p, e.normal);
						a.push(_[0], _[1], _[2])
					}
					e.material && e.material.mappingType !== "AllSame" && (m = gh(g, n, p, e.material)[0], m < 0 && (console.warn("THREE.FBXLoader: Invalid material index:", m), m = 0)), e.uv && e.uv.forEach(function(_, y) {
						let w = gh(g, n, p, _);
						l[y] === void 0 && (l[y] = []), l[y].push(w[0]), l[y].push(w[1])
					}), i++, d && (f.genFace(t, e, o, m, a, c, l, u, h, i), n++, i = 0, o = [], a = [], c = [], l = [], u = [], h = [])
				}), t
			}
			genFace(e, t, n, i, s, o, a, c, l, u) {
				for (let h = 2; h < u; h++) e.vertex.push(t.vertexPositions[n[0]]), e.vertex.push(t.vertexPositions[n[1]]), e.vertex.push(t.vertexPositions[n[2]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 1]]), e.vertex.push(t.vertexPositions[n[(h - 1) * 3 + 2]]), e.vertex.push(t.vertexPositions[n[h * 3]]), e.vertex.push(t.vertexPositions[n[h * 3 + 1]]), e.vertex.push(t.vertexPositions[n[h * 3 + 2]]), t.skeleton && (e.vertexWeights.push(c[0]), e.vertexWeights.push(c[1]), e.vertexWeights.push(c[2]), e.vertexWeights.push(c[3]), e.vertexWeights.push(c[(h - 1) * 4]), e.vertexWeights.push(c[(h - 1) * 4 + 1]), e.vertexWeights.push(c[(h - 1) * 4 + 2]), e.vertexWeights.push(c[(h - 1) * 4 + 3]), e.vertexWeights.push(c[h * 4]), e.vertexWeights.push(c[h * 4 + 1]), e.vertexWeights.push(c[h * 4 + 2]), e.vertexWeights.push(c[h * 4 + 3]), e.weightsIndices.push(l[0]), e.weightsIndices.push(l[1]), e.weightsIndices.push(l[2]), e.weightsIndices.push(l[3]), e.weightsIndices.push(l[(h - 1) * 4]), e.weightsIndices.push(l[(h - 1) * 4 + 1]), e.weightsIndices.push(l[(h - 1) * 4 + 2]), e.weightsIndices.push(l[(h - 1) * 4 + 3]), e.weightsIndices.push(l[h * 4]), e.weightsIndices.push(l[h * 4 + 1]), e.weightsIndices.push(l[h * 4 + 2]), e.weightsIndices.push(l[h * 4 + 3])), t.color && (e.colors.push(o[0]), e.colors.push(o[1]), e.colors.push(o[2]), e.colors.push(o[(h - 1) * 3]), e.colors.push(o[(h - 1) * 3 + 1]), e.colors.push(o[(h - 1) * 3 + 2]), e.colors.push(o[h * 3]), e.colors.push(o[h * 3 + 1]), e.colors.push(o[h * 3 + 2])), t.material && t.material.mappingType !== "AllSame" && (e.materialIndex.push(i), e.materialIndex.push(i), e.materialIndex.push(i)), t.normal && (e.normal.push(s[0]), e.normal.push(s[1]), e.normal.push(s[2]), e.normal.push(s[(h - 1) * 3]), e.normal.push(s[(h - 1) * 3 + 1]), e.normal.push(s[(h - 1) * 3 + 2]), e.normal.push(s[h * 3]), e.normal.push(s[h * 3 + 1]), e.normal.push(s[h * 3 + 2])), t.uv && t.uv.forEach(function(f, p) {
					e.uvs[p] === void 0 && (e.uvs[p] = []), e.uvs[p].push(a[p][0]), e.uvs[p].push(a[p][1]), e.uvs[p].push(a[p][(h - 1) * 2]), e.uvs[p].push(a[p][(h - 1) * 2 + 1]), e.uvs[p].push(a[p][h * 2]), e.uvs[p].push(a[p][h * 2 + 1])
				})
			}
			addMorphTargets(e, t, n, i) {
				if (n.length === 0) return;
				e.morphTargetsRelative = !0, e.morphAttributes.position = [];
				let s = this;
				n.forEach(function(o) {
					o.rawTargets.forEach(function(a) {
						let c = Mt.Objects.Geometry[a.geoID];
						c !== void 0 && s.genMorphGeometry(e, t, c, i, a.name)
					})
				})
			}
			genMorphGeometry(e, t, n, i, s) {
				let o = t.PolygonVertexIndex !== void 0 ? t.PolygonVertexIndex.a : [],
					a = n.Vertices !== void 0 ? n.Vertices.a : [],
					c = n.Indexes !== void 0 ? n.Indexes.a : [],
					l = e.attributes.position.count * 3,
					u = new Float32Array(l);
				for (let g = 0; g < c.length; g++) {
					let m = c[g] * 3;
					u[m] = a[g * 3], u[m + 1] = a[g * 3 + 1], u[m + 2] = a[g * 3 + 2]
				}
				let h = {
						vertexIndices: o,
						vertexPositions: u
					},
					f = this.genBuffers(h),
					p = new ze(f.vertex, 3);
				p.name = s || n.attrName, p.applyMatrix4(i), e.morphAttributes.position.push(p)
			}
			parseNormals(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.Normals.a,
					s = [];
				return n === "IndexToDirect" && ("NormalIndex" in e ? s = e.NormalIndex.a : "NormalsIndex" in e && (s = e.NormalsIndex.a)), {
					dataSize: 3,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseUVs(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.UV.a,
					s = [];
				return n === "IndexToDirect" && (s = e.UVIndex.a), {
					dataSize: 2,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseVertexColors(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType,
					i = e.Colors.a,
					s = [];
				return n === "IndexToDirect" && (s = e.ColorIndex.a), {
					dataSize: 4,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseMaterialIndices(e) {
				let t = e.MappingInformationType,
					n = e.ReferenceInformationType;
				if (t === "NoMappingInformation") return {
					dataSize: 1,
					buffer: [0],
					indices: [0],
					mappingType: "AllSame",
					referenceType: n
				};
				let i = e.Materials.a,
					s = [];
				for (let o = 0; o < i.length; ++o) s.push(o);
				return {
					dataSize: 1,
					buffer: i,
					indices: s,
					mappingType: t,
					referenceType: n
				}
			}
			parseNurbsGeometry(e) {
				if (ec === void 0) return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."), new bt;
				let t = parseInt(e.Order);
				if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new bt;
				let n = t - 1,
					i = e.KnotVector.a,
					s = [],
					o = e.Points.a;
				for (let h = 0, f = o.length; h < f; h += 4) s.push(new wt()
					.fromArray(o, h));
				let a, c;
				if (e.Form === "Closed") s.push(s[0]);
				else if (e.Form === "Periodic") {
					a = n, c = i.length - 1 - a;
					for (let h = 0; h < n; ++h) s.push(s[h])
				}
				let u = new ec(n, i, s, a, c)
					.getPoints(s.length * 12);
				return new bt()
					.setFromPoints(u)
			}
		},
		Jp = class {
			parse() {
				let e = [],
					t = this.parseClips();
				if (t !== void 0)
					for (let n in t) {
						let i = t[n],
							s = this.addClip(i);
						e.push(s)
					}
				return e
			}
			parseClips() {
				if (Mt.Objects.AnimationCurve === void 0) return;
				let e = this.parseAnimationCurveNodes();
				this.parseAnimationCurves(e);
				let t = this.parseAnimationLayers(e);
				return this.parseAnimStacks(t)
			}
			parseAnimationCurveNodes() {
				let e = Mt.Objects.AnimationCurveNode,
					t = new Map;
				for (let n in e) {
					let i = e[n];
					if (i.attrName.match(/S|R|T|DeformPercent/) !== null) {
						let s = {
							id: i.id,
							attr: i.attrName,
							curves: {}
						};
						t.set(s.id, s)
					}
				}
				return t
			}
			parseAnimationCurves(e) {
				let t = Mt.Objects.AnimationCurve;
				for (let n in t) {
					let i = {
							id: t[n].id,
							times: t[n].KeyTime.a.map(wE),
							values: t[n].KeyValueFloat.a
						},
						s = un.get(i.id);
					if (s !== void 0) {
						let o = s.parents[0].ID,
							a = s.parents[0].relationship;
						a.match(/X/) ? e.get(o)
							.curves.x = i : a.match(/Y/) ? e.get(o)
							.curves.y = i : a.match(/Z/) ? e.get(o)
							.curves.z = i : a.match(/d|DeformPercent/) && e.has(o) && (e.get(o)
								.curves.morph = i)
					}
				}
			}
			parseAnimationLayers(e) {
				let t = Mt.Objects.AnimationLayer,
					n = new Map;
				for (let i in t) {
					let s = [],
						o = un.get(parseInt(i));
					o !== void 0 && (o.children.forEach(function(c, l) {
						if (e.has(c.ID)) {
							let u = e.get(c.ID);
							if (u.curves.x !== void 0 || u.curves.y !== void 0 || u.curves.z !== void 0) {
								if (s[l] === void 0) {
									let h = un.get(c.ID)
										.parents.filter(function(f) {
											return f.relationship !== void 0
										})[0].ID;
									if (h !== void 0) {
										let f = Mt.Objects.Model[h.toString()];
										if (f === void 0) {
											console.warn("THREE.FBXLoader: Encountered a unused curve.", c);
											return
										}
										let p = {
											modelName: f.attrName ? Ct.sanitizeNodeName(f.attrName) : "",
											ID: f.id,
											initialPosition: [0, 0, 0],
											initialRotation: [0, 0, 0],
											initialScale: [1, 1, 1]
										};
										gi.traverse(function(g) {
											g.ID === f.id && (p.transform = g.matrix, g.userData.transformData && (p.eulerOrder = g.userData.transformData.eulerOrder))
										}), p.transform || (p.transform = new ke), "PreRotation" in f && (p.preRotation = f.PreRotation.value), "PostRotation" in f && (p.postRotation = f.PostRotation.value), s[l] = p
									}
								}
								s[l] && (s[l][u.attr] = u)
							} else if (u.curves.morph !== void 0) {
								if (s[l] === void 0) {
									let h = un.get(c.ID)
										.parents.filter(function(v) {
											return v.relationship !== void 0
										})[0].ID,
										f = un.get(h)
										.parents[0].ID,
										p = un.get(f)
										.parents[0].ID,
										g = un.get(p)
										.parents[0].ID,
										m = Mt.Objects.Model[g],
										d = {
											modelName: m.attrName ? Ct.sanitizeNodeName(m.attrName) : "",
											morphName: Mt.Objects.Deformer[h].attrName
										};
									s[l] = d
								}
								s[l][u.attr] = u
							}
						}
					}), n.set(parseInt(i), s))
				}
				return n
			}
			parseAnimStacks(e) {
				let t = Mt.Objects.AnimationStack,
					n = {};
				for (let i in t) {
					let s = un.get(parseInt(i))
						.children;
					s.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
					let o = e.get(s[0].ID);
					n[i] = {
						name: t[i].attrName,
						layer: o
					}
				}
				return n
			}
			addClip(e) {
				let t = [],
					n = this;
				return e.layer.forEach(function(i) {
					t = t.concat(n.generateTracks(i))
				}), new Eo(e.name, -1, t)
			}
			generateTracks(e) {
				let t = [],
					n = new ne,
					i = new mn,
					s = new ne;
				if (e.transform && e.transform.decompose(n, i, s), n = n.toArray(), i = new Ln()
					.setFromQuaternion(i, e.eulerOrder)
					.toArray(), s = s.toArray(), e.T !== void 0 && Object.keys(e.T.curves)
					.length > 0) {
					let o = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
					o !== void 0 && t.push(o)
				}
				if (e.R !== void 0 && Object.keys(e.R.curves)
					.length > 0) {
					let o = this.generateRotationTrack(e.modelName, e.R.curves, i, e.preRotation, e.postRotation, e.eulerOrder);
					o !== void 0 && t.push(o)
				}
				if (e.S !== void 0 && Object.keys(e.S.curves)
					.length > 0) {
					let o = this.generateVectorTrack(e.modelName, e.S.curves, s, "scale");
					o !== void 0 && t.push(o)
				}
				if (e.DeformPercent !== void 0) {
					let o = this.generateMorphTrack(e);
					o !== void 0 && t.push(o)
				}
				return t
			}
			generateVectorTrack(e, t, n, i) {
				let s = this.getTimesForAllAxes(t),
					o = this.getKeyframeTrackValues(s, t, n);
				return new or(e + "." + i, s, o)
			}
			generateRotationTrack(e, t, n, i, s, o) {
				t.x !== void 0 && (this.interpolateRotations(t.x), t.x.values = t.x.values.map(Vn.degToRad)), t.y !== void 0 && (this.interpolateRotations(t.y), t.y.values = t.y.values.map(Vn.degToRad)), t.z !== void 0 && (this.interpolateRotations(t.z), t.z.values = t.z.values.map(Vn.degToRad));
				let a = this.getTimesForAllAxes(t),
					c = this.getKeyframeTrackValues(a, t, n);
				i !== void 0 && (i = i.map(Vn.degToRad), i.push(o), i = new Ln()
					.fromArray(i), i = new mn()
					.setFromEuler(i)), s !== void 0 && (s = s.map(Vn.degToRad), s.push(o), s = new Ln()
					.fromArray(s), s = new mn()
					.setFromEuler(s)
					.invert());
				let l = new mn,
					u = new Ln,
					h = [];
				for (let f = 0; f < c.length; f += 3) u.set(c[f], c[f + 1], c[f + 2], o), l.setFromEuler(u), i !== void 0 && l.premultiply(i), s !== void 0 && l.multiply(s), l.toArray(h, f / 3 * 4);
				return new sr(e + ".quaternion", a, h)
			}
			generateMorphTrack(e) {
				let t = e.DeformPercent.curves.morph,
					n = t.values.map(function(s) {
						return s / 100
					}),
					i = gi.getObjectByName(e.modelName)
					.morphTargetDictionary[e.morphName];
				return new Us(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, n)
			}
			getTimesForAllAxes(e) {
				let t = [];
				if (e.x !== void 0 && (t = t.concat(e.x.times)), e.y !== void 0 && (t = t.concat(e.y.times)), e.z !== void 0 && (t = t.concat(e.z.times)), t = t.sort(function(n, i) {
					return n - i
				}), t.length > 1) {
					let n = 1,
						i = t[0];
					for (let s = 1; s < t.length; s++) {
						let o = t[s];
						o !== i && (t[n] = o, i = o, n++)
					}
					t = t.slice(0, n)
				}
				return t
			}
			getKeyframeTrackValues(e, t, n) {
				let i = n,
					s = [],
					o = -1,
					a = -1,
					c = -1;
				return e.forEach(function(l) {
					if (t.x && (o = t.x.times.indexOf(l)), t.y && (a = t.y.times.indexOf(l)), t.z && (c = t.z.times.indexOf(l)), o !== -1) {
						let u = t.x.values[o];
						s.push(u), i[0] = u
					} else s.push(i[0]);
					if (a !== -1) {
						let u = t.y.values[a];
						s.push(u), i[1] = u
					} else s.push(i[1]);
					if (c !== -1) {
						let u = t.z.values[c];
						s.push(u), i[2] = u
					} else s.push(i[2])
				}), s
			}
			interpolateRotations(e) {
				for (let t = 1; t < e.values.length; t++) {
					let n = e.values[t - 1],
						i = e.values[t] - n,
						s = Math.abs(i);
					if (s >= 180) {
						let o = s / 180,
							a = i / o,
							c = n + a,
							l = e.times[t - 1],
							h = (e.times[t] - l) / o,
							f = l + h,
							p = [],
							g = [];
						for (; f < e.times[t];) p.push(f), f += h, g.push(c), c += a;
						e.times = Ax(e.times, t, p), e.values = Ax(e.values, t, g)
					}
				}
			}
		},
		$p = class {
			getPrevNode() {
				return this.nodeStack[this.currentIndent - 2]
			}
			getCurrentNode() {
				return this.nodeStack[this.currentIndent - 1]
			}
			getCurrentProp() {
				return this.currentProp
			}
			pushStack(e) {
				this.nodeStack.push(e), this.currentIndent += 1
			}
			popStack() {
				this.nodeStack.pop(), this.currentIndent -= 1
			}
			setCurrentProp(e, t) {
				this.currentProp = e, this.currentPropName = t
			}
			parse(e) {
				this.currentIndent = 0, this.allNodes = new yh, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
				let t = this,
					n = e.split(/[\r\n]+/);
				return n.forEach(function(i, s) {
					let o = i.match(/^[\s\t]*;/),
						a = i.match(/^[\s\t]*$/);
					if (o || a) return;
					let c = i.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
						l = i.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
						u = i.match("^\\t{" + (t.currentIndent - 1) + "}}");
					c ? t.parseNodeBegin(i, c) : l ? t.parseNodeProperty(i, l, n[++s]) : u ? t.popStack() : i.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(i)
				}), this.allNodes
			}
			parseNodeBegin(e, t) {
				let n = t[1].trim()
					.replace(/^"/, "")
					.replace(/"$/, ""),
					i = t[2].split(",")
					.map(function(c) {
						return c.trim()
							.replace(/^"/, "")
							.replace(/"$/, "")
					}),
					s = {
						name: n
					},
					o = this.parseNodeAttr(i),
					a = this.getCurrentNode();
				this.currentIndent === 0 ? this.allNodes.add(n, s) : n in a ? (n === "PoseNode" ? a.PoseNode.push(s) : a[n].id !== void 0 && (a[n] = {}, a[n][a[n].id] = a[n]), o.id !== "" && (a[n][o.id] = s)) : typeof o.id == "number" ? (a[n] = {}, a[n][o.id] = s) : n !== "Properties70" && (n === "PoseNode" ? a[n] = [s] : a[n] = s), typeof o.id == "number" && (s.id = o.id), o.name !== "" && (s.attrName = o.name), o.type !== "" && (s.attrType = o.type), this.pushStack(s)
			}
			parseNodeAttr(e) {
				let t = e[0];
				e[0] !== "" && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
				let n = "",
					i = "";
				return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), i = e[2]), {
					id: t,
					name: n,
					type: i
				}
			}
			parseNodeProperty(e, t, n) {
				let i = t[1].replace(/^"/, "")
					.replace(/"$/, "")
					.trim(),
					s = t[2].replace(/^"/, "")
					.replace(/"$/, "")
					.trim();
				i === "Content" && s === "," && (s = n.replace(/"/g, "")
					.replace(/,$/, "")
					.trim());
				let o = this.getCurrentNode();
				if (o.name === "Properties70") {
					this.parseNodeSpecialProperty(e, i, s);
					return
				}
				if (i === "C") {
					let c = s.split(",")
						.slice(1),
						l = parseInt(c[0]),
						u = parseInt(c[1]),
						h = s.split(",")
						.slice(3);
					h = h.map(function(f) {
						return f.trim()
							.replace(/^"/, "")
					}), i = "connections", s = [l, u], SE(s, h), o[i] === void 0 && (o[i] = [])
				}
				i === "Node" && (o.id = s), i in o && Array.isArray(o[i]) ? o[i].push(s) : i !== "a" ? o[i] = s : o.a = s, this.setCurrentProp(o, i), i === "a" && s.slice(-1) !== "," && (o.a = Yp(s))
			}
			parseNodePropertyContinued(e) {
				let t = this.getCurrentNode();
				t.a += e, e.slice(-1) !== "," && (t.a = Yp(t.a))
			}
			parseNodeSpecialProperty(e, t, n) {
				let i = n.split('",')
					.map(function(u) {
						return u.trim()
							.replace(/^\"/, "")
							.replace(/\s/, "_")
					}),
					s = i[0],
					o = i[1],
					a = i[2],
					c = i[3],
					l = i[4];
				switch (o) {
					case "int":
					case "enum":
					case "bool":
					case "ULongLong":
					case "double":
					case "Number":
					case "FieldOfView":
						l = parseFloat(l);
						break;
					case "Color":
					case "ColorRGB":
					case "Vector3D":
					case "Lcl_Translation":
					case "Lcl_Rotation":
					case "Lcl_Scaling":
						l = Yp(l);
						break
				}
				this.getPrevNode()[s] = {
					type: o,
					type2: a,
					flag: c,
					value: l
				}, this.setCurrentProp(this.getPrevNode(), s)
			}
		},
		Qp = class {
			parse(e) {
				let t = new xh(e);
				t.skip(23);
				let n = t.getUint32();
				if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
				let i = new yh;
				for (; !this.endOfContent(t);) {
					let s = this.parseNode(t, n);
					s !== null && i.add(s.name, s)
				}
				return i
			}
			endOfContent(e) {
				return e.size() % 16 === 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
			}
			parseNode(e, t) {
				let n = {},
					i = t >= 7500 ? e.getUint64() : e.getUint32(),
					s = t >= 7500 ? e.getUint64() : e.getUint32();
				t >= 7500 ? e.getUint64() : e.getUint32();
				let o = e.getUint8(),
					a = e.getString(o);
				if (i === 0) return null;
				let c = [];
				for (let f = 0; f < s; f++) c.push(this.parseProperty(e));
				let l = c.length > 0 ? c[0] : "",
					u = c.length > 1 ? c[1] : "",
					h = c.length > 2 ? c[2] : "";
				for (n.singleProperty = s === 1 && e.getOffset() === i; i > e.getOffset();) {
					let f = this.parseNode(e, t);
					f !== null && this.parseSubNode(a, n, f)
				}
				return n.propertyList = c, typeof l == "number" && (n.id = l), u !== "" && (n.attrName = u), h !== "" && (n.attrType = h), a !== "" && (n.name = a), n
			}
			parseSubNode(e, t, n) {
				if (n.singleProperty === !0) {
					let i = n.propertyList[0];
					Array.isArray(i) ? (t[n.name] = n, n.a = i) : t[n.name] = i
				} else if (e === "Connections" && n.name === "C") {
					let i = [];
					n.propertyList.forEach(function(s, o) {
						o !== 0 && i.push(s)
					}), t.connections === void 0 && (t.connections = []), t.connections.push(i)
				} else if (n.name === "Properties70") Object.keys(n)
					.forEach(function(s) {
						t[s] = n[s]
					});
				else if (e === "Properties70" && n.name === "P") {
					let i = n.propertyList[0],
						s = n.propertyList[1],
						o = n.propertyList[2],
						a = n.propertyList[3],
						c;
					i.indexOf("Lcl ") === 0 && (i = i.replace("Lcl ", "Lcl_")), s.indexOf("Lcl ") === 0 && (s = s.replace("Lcl ", "Lcl_")), s === "Color" || s === "ColorRGB" || s === "Vector" || s === "Vector3D" || s.indexOf("Lcl_") === 0 ? c = [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : c = n.propertyList[4], t[i] = {
						type: s,
						type2: o,
						flag: a,
						value: c
					}
				} else t[n.name] === void 0 ? typeof n.id == "number" ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : n.name === "PoseNode" ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : t[n.name][n.id] === void 0 && (t[n.name][n.id] = n)
			}
			parseProperty(e) {
				let t = e.getString(1),
					n;
				switch (t) {
					case "C":
						return e.getBoolean();
					case "D":
						return e.getFloat64();
					case "F":
						return e.getFloat32();
					case "I":
						return e.getInt32();
					case "L":
						return e.getInt64();
					case "R":
						return n = e.getUint32(), e.getArrayBuffer(n);
					case "S":
						return n = e.getUint32(), e.getString(n);
					case "Y":
						return e.getInt16();
					case "b":
					case "c":
					case "d":
					case "f":
					case "i":
					case "l":
						let i = e.getUint32(),
							s = e.getUint32(),
							o = e.getUint32();
						if (s === 0) switch (t) {
							case "b":
							case "c":
								return e.getBooleanArray(i);
							case "d":
								return e.getFloat64Array(i);
							case "f":
								return e.getFloat32Array(i);
							case "i":
								return e.getInt32Array(i);
							case "l":
								return e.getInt64Array(i)
						}
						typeof mh > "u" && console.error("THREE.FBXLoader: External library fflate.min.js required.");
						let a = Da(new Uint8Array(e.getArrayBuffer(o))),
							c = new xh(a.buffer);
						switch (t) {
							case "b":
							case "c":
								return c.getBooleanArray(i);
							case "d":
								return c.getFloat64Array(i);
							case "f":
								return c.getFloat32Array(i);
							case "i":
								return c.getInt32Array(i);
							case "l":
								return c.getInt64Array(i)
						}
						break;
					default:
						throw new Error("THREE.FBXLoader: Unknown property type " + t)
				}
			}
		},
		xh = class {
			constructor(e, t) {
				this.dv = new DataView(e), this.offset = 0, this.littleEndian = t !== void 0 ? t : !0
			}
			getOffset() {
				return this.offset
			}
			size() {
				return this.dv.buffer.byteLength
			}
			skip(e) {
				this.offset += e
			}
			getBoolean() {
				return (this.getUint8() & 1) === 1
			}
			getBooleanArray(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getBoolean());
				return t
			}
			getUint8() {
				let e = this.dv.getUint8(this.offset);
				return this.offset += 1, e
			}
			getInt16() {
				let e = this.dv.getInt16(this.offset, this.littleEndian);
				return this.offset += 2, e
			}
			getInt32() {
				let e = this.dv.getInt32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getInt32Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getInt32());
				return t
			}
			getUint32() {
				let e = this.dv.getUint32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getInt64() {
				let e, t;
				return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t & 2147483648 ? (t = ~t & 4294967295, e = ~e & 4294967295, e === 4294967295 && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(t * 4294967296 + e)) : t * 4294967296 + e
			}
			getInt64Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getInt64());
				return t
			}
			getUint64() {
				let e, t;
				return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), t * 4294967296 + e
			}
			getFloat32() {
				let e = this.dv.getFloat32(this.offset, this.littleEndian);
				return this.offset += 4, e
			}
			getFloat32Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getFloat32());
				return t
			}
			getFloat64() {
				let e = this.dv.getFloat64(this.offset, this.littleEndian);
				return this.offset += 8, e
			}
			getFloat64Array(e) {
				let t = [];
				for (let n = 0; n < e; n++) t.push(this.getFloat64());
				return t
			}
			getArrayBuffer(e) {
				let t = this.dv.buffer.slice(this.offset, this.offset + e);
				return this.offset += e, t
			}
			getString(e) {
				let t = [];
				for (let i = 0; i < e; i++) t[i] = this.getUint8();
				let n = t.indexOf(0);
				return n >= 0 && (t = t.slice(0, n)), fi.decodeText(new Uint8Array(t))
			}
		},
		yh = class {
			add(e, t) {
				this[e] = t
			}
		};

	function bE(r) {
		let e = "Kaydara FBX Binary  \0";
		return r.byteLength >= e.length && e === Px(r, 0, e.length)
	}

	function ME(r) {
		let e = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"],
			t = 0;

		function n(i) {
			let s = r[i - 1];
			return r = r.slice(t + i), t++, s
		}
		for (let i = 0; i < e.length; ++i)
			if (n(1) === e[i]) return !1;
		return !0
	}

	function Cx(r) {
		let e = /FBXVersion: (\d+)/,
			t = r.match(e);
		if (t) return parseInt(t[1]);
		throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
	}

	function wE(r) {
		return r / 46186158e3
	}
	var TE = [];

	function gh(r, e, t, n) {
		let i;
		switch (n.mappingType) {
			case "ByPolygonVertex":
				i = r;
				break;
			case "ByPolygon":
				i = e;
				break;
			case "ByVertice":
				i = t;
				break;
			case "AllSame":
				i = n.indices[0];
				break;
			default:
				console.warn("THREE.FBXLoader: unknown attribute mapping type " + n.mappingType)
		}
		n.referenceType === "IndexToDirect" && (i = n.indices[i]);
		let s = i * n.dataSize,
			o = s + n.dataSize;
		return EE(TE, n.buffer, s, o)
	}
	var Xp = new Ln,
		Wa = new ne;

	function Ix(r) {
		let e = new ke,
			t = new ke,
			n = new ke,
			i = new ke,
			s = new ke,
			o = new ke,
			a = new ke,
			c = new ke,
			l = new ke,
			u = new ke,
			h = new ke,
			f = new ke,
			p = r.inheritType ? r.inheritType : 0;
		if (r.translation && e.setPosition(Wa.fromArray(r.translation)), r.preRotation) {
			let N = r.preRotation.map(Vn.degToRad);
			N.push(r.eulerOrder || Ln.DefaultOrder), t.makeRotationFromEuler(Xp.fromArray(N))
		}
		if (r.rotation) {
			let N = r.rotation.map(Vn.degToRad);
			N.push(r.eulerOrder || Ln.DefaultOrder), n.makeRotationFromEuler(Xp.fromArray(N))
		}
		if (r.postRotation) {
			let N = r.postRotation.map(Vn.degToRad);
			N.push(r.eulerOrder || Ln.DefaultOrder), i.makeRotationFromEuler(Xp.fromArray(N)), i.invert()
		}
		r.scale && s.scale(Wa.fromArray(r.scale)), r.scalingOffset && a.setPosition(Wa.fromArray(r.scalingOffset)), r.scalingPivot && o.setPosition(Wa.fromArray(r.scalingPivot)), r.rotationOffset && c.setPosition(Wa.fromArray(r.rotationOffset)), r.rotationPivot && l.setPosition(Wa.fromArray(r.rotationPivot)), r.parentMatrixWorld && (h.copy(r.parentMatrix), u.copy(r.parentMatrixWorld));
		let g = t.clone()
			.multiply(n)
			.multiply(i),
			m = new ke;
		m.extractRotation(u);
		let d = new ke;
		d.copyPosition(u);
		let v = d.clone()
			.invert()
			.multiply(u),
			x = m.clone()
			.invert()
			.multiply(v),
			_ = s,
			y = new ke;
		if (p === 0) y.copy(m)
			.multiply(g)
			.multiply(x)
			.multiply(_);
		else if (p === 1) y.copy(m)
			.multiply(x)
			.multiply(g)
			.multiply(_);
		else {
			let V = new ke()
				.scale(new ne()
					.setFromMatrixScale(h))
				.clone()
				.invert(),
				O = x.clone()
				.multiply(V);
			y.copy(m)
				.multiply(g)
				.multiply(O)
				.multiply(_)
		}
		let w = l.clone()
			.invert(),
			C = o.clone()
			.invert(),
			S = e.clone()
			.multiply(c)
			.multiply(l)
			.multiply(t)
			.multiply(n)
			.multiply(i)
			.multiply(w)
			.multiply(a)
			.multiply(o)
			.multiply(s)
			.multiply(C),
			b = new ke()
			.copyPosition(S),
			T = u.clone()
			.multiply(b);
		return f.copyPosition(T), S = f.clone()
			.multiply(y), S.premultiply(u.invert()), S
	}

	function Rx(r) {
		r = r || 0;
		let e = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
		return r === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), e[0]) : e[r]
	}

	function Yp(r) {
		return r.split(",")
			.map(function(t) {
				return parseFloat(t)
			})
	}

	function Px(r, e, t) {
		return e === void 0 && (e = 0), t === void 0 && (t = r.byteLength), fi.decodeText(new Uint8Array(r, e, t))
	}

	function SE(r, e) {
		for (let t = 0, n = r.length, i = e.length; t < i; t++, n++) r[n] = e[t]
	}

	function EE(r, e, t, n) {
		for (let i = t, s = 0; i < n; i++, s++) r[s] = e[i];
		return r
	}

	function Ax(r, e, t) {
		return r.slice(0, e)
			.concat(t)
			.concat(r.slice(e))
	}
	var _h = class extends ei {
		constructor(e) {
			super(e)
		}
		load(e, t, n, i) {
			let s = this,
				o = s.path === "" ? fi.extractUrlBase(e) : s.path,
				a = new ar(s.manager);
			a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(c) {
				try {
					t(s.parse(c, o))
				} catch (l) {
					i ? i(l) : console.error(l), s.manager.itemError(e)
				}
			}, n, i)
		}
		parse(e, t) {
			function n(P, R) {
				let G = [],
					F = P.childNodes;
				for (let z = 0, me = F.length; z < me; z++) {
					let be = F[z];
					be.nodeName === R && G.push(be)
				}
				return G
			}

			function i(P) {
				if (P.length === 0) return [];
				let R = P.trim()
					.split(/\s+/),
					G = new Array(R.length);
				for (let F = 0, z = R.length; F < z; F++) G[F] = R[F];
				return G
			}

			function s(P) {
				if (P.length === 0) return [];
				let R = P.trim()
					.split(/\s+/),
					G = new Array(R.length);
				for (let F = 0, z = R.length; F < z; F++) G[F] = parseFloat(R[F]);
				return G
			}

			function o(P) {
				if (P.length === 0) return [];
				let R = P.trim()
					.split(/\s+/),
					G = new Array(R.length);
				for (let F = 0, z = R.length; F < z; F++) G[F] = parseInt(R[F]);
				return G
			}

			function a(P) {
				return P.substring(1)
			}

			function c() {
				return "three_default_" + gy++
			}

			function l(P) {
				return Object.keys(P)
					.length === 0
			}

			function u(P) {
				return {
					unit: h(n(P, "unit")[0]),
					upAxis: f(n(P, "up_axis")[0])
				}
			}

			function h(P) {
				return P !== void 0 && P.hasAttribute("meter") === !0 ? parseFloat(P.getAttribute("meter")) : 1
			}

			function f(P) {
				return P !== void 0 ? P.textContent : "Y_UP"
			}

			function p(P, R, G, F) {
				let z = n(P, R)[0];
				if (z !== void 0) {
					let me = n(z, G);
					for (let be = 0; be < me.length; be++) F(me[be])
				}
			}

			function g(P, R) {
				for (let G in P) {
					let F = P[G];
					F.build = R(P[G])
				}
			}

			function m(P, R) {
				return P.build !== void 0 || (P.build = R(P)), P.build
			}

			function d(P) {
				let R = {
						sources: {},
						samplers: {},
						channels: {}
					},
					G = !1;
				for (let F = 0, z = P.childNodes.length; F < z; F++) {
					let me = P.childNodes[F];
					if (me.nodeType !== 1) continue;
					let be;
					switch (me.nodeName) {
						case "source":
							be = me.getAttribute("id"), R.sources[be] = we(me);
							break;
						case "sampler":
							be = me.getAttribute("id"), R.samplers[be] = v(me);
							break;
						case "channel":
							be = me.getAttribute("target"), R.channels[be] = x(me);
							break;
						case "animation":
							d(me), G = !0;
							break;
						default:
							console.log(me)
					}
				}
				G === !1 && (at.animations[P.getAttribute("id") || Vn.generateUUID()] = R)
			}

			function v(P) {
				let R = {
					inputs: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "input":
							let me = a(z.getAttribute("source")),
								be = z.getAttribute("semantic");
							R.inputs[be] = me;
							break
					}
				}
				return R
			}

			function x(P) {
				let R = {},
					F = P.getAttribute("target")
					.split("/"),
					z = F.shift(),
					me = F.shift(),
					be = me.indexOf("(") !== -1,
					Be = me.indexOf(".") !== -1;
				if (Be) F = me.split("."), me = F.shift(), R.member = F.shift();
				else if (be) {
					let Pe = me.split("(");
					me = Pe.shift();
					for (let Ge = 0; Ge < Pe.length; Ge++) Pe[Ge] = parseInt(Pe[Ge].replace(/\)/, ""));
					R.indices = Pe
				}
				return R.id = z, R.sid = me, R.arraySyntax = be, R.memberSyntax = Be, R.sampler = a(P.getAttribute("source")), R
			}

			function _(P) {
				let R = [],
					G = P.channels,
					F = P.samplers,
					z = P.sources;
				for (let me in G)
					if (G.hasOwnProperty(me)) {
						let be = G[me],
							Be = F[be.sampler],
							Pe = Be.inputs.INPUT,
							Ge = Be.inputs.OUTPUT,
							Je = z[Pe],
							Ae = z[Ge],
							et = w(be, Je, Ae);
						N(et, R)
					} return R
			}

			function y(P) {
				return m(at.animations[P], _)
			}

			function w(P, R, G) {
				let F = at.nodes[P.id],
					z = oi(F.id),
					me = F.transforms[P.sid],
					be = F.matrix.clone()
					.transpose(),
					Be, Pe, Ge, Je, Ae, et, qe = {};
				switch (me) {
					case "matrix":
						for (Ge = 0, Je = R.array.length; Ge < Je; Ge++)
							if (Be = R.array[Ge], Pe = Ge * G.stride, qe[Be] === void 0 && (qe[Be] = {}), P.arraySyntax === !0) {
								let nn = G.array[Pe],
									Vt = P.indices[0] + 4 * P.indices[1];
								qe[Be][Vt] = nn
							} else
								for (Ae = 0, et = G.stride; Ae < et; Ae++) qe[Be][Ae] = G.array[Pe + Ae];
						break;
					case "translate":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', me);
						break;
					case "rotate":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', me);
						break;
					case "scale":
						console.warn('THREE.ColladaLoader: Animation transform type "%s" not yet implemented.', me);
						break
				}
				let rt = C(qe, be);
				return {
					name: z.uuid,
					keyframes: rt
				}
			}

			function C(P, R) {
				let G = [];
				for (let z in P) G.push({
					time: parseFloat(z),
					value: P[z]
				});
				G.sort(F);
				for (let z = 0; z < 16; z++) V(G, z, R.elements[z]);
				return G;

				function F(z, me) {
					return z.time - me.time
				}
			}
			let S = new ne,
				b = new ne,
				T = new mn;

			function N(P, R) {
				let G = P.keyframes,
					F = P.name,
					z = [],
					me = [],
					be = [],
					Be = [];
				for (let Pe = 0, Ge = G.length; Pe < Ge; Pe++) {
					let Je = G[Pe],
						Ae = Je.time,
						et = Je.value;
					hn.fromArray(et)
						.transpose(), hn.decompose(S, T, b), z.push(Ae), me.push(S.x, S.y, S.z), be.push(T.x, T.y, T.z, T.w), Be.push(b.x, b.y, b.z)
				}
				return me.length > 0 && R.push(new or(F + ".position", z, me)), be.length > 0 && R.push(new sr(F + ".quaternion", z, be)), Be.length > 0 && R.push(new or(F + ".scale", z, Be)), R
			}

			function V(P, R, G) {
				let F, z = !0,
					me, be;
				for (me = 0, be = P.length; me < be; me++) F = P[me], F.value[R] === void 0 ? F.value[R] = null : z = !1;
				if (z === !0)
					for (me = 0, be = P.length; me < be; me++) F = P[me], F.value[R] = G;
				else O(P, R)
			}

			function O(P, R) {
				let G, F;
				for (let z = 0, me = P.length; z < me; z++) {
					let be = P[z];
					if (be.value[R] === null) {
						if (G = k(P, z, R), F = I(P, z, R), G === null) {
							be.value[R] = F.value[R];
							continue
						}
						if (F === null) {
							be.value[R] = G.value[R];
							continue
						}
						q(be, G, F, R)
					}
				}
			}

			function k(P, R, G) {
				for (; R >= 0;) {
					let F = P[R];
					if (F.value[G] !== null) return F;
					R--
				}
				return null
			}

			function I(P, R, G) {
				for (; R < P.length;) {
					let F = P[R];
					if (F.value[G] !== null) return F;
					R++
				}
				return null
			}

			function q(P, R, G, F) {
				if (G.time - R.time === 0) {
					P.value[F] = R.value[F];
					return
				}
				P.value[F] = (P.time - R.time) * (G.value[F] - R.value[F]) / (G.time - R.time) + R.value[F]
			}

			function B(P) {
				let R = {
					name: P.getAttribute("id") || "default",
					start: parseFloat(P.getAttribute("start") || 0),
					end: parseFloat(P.getAttribute("end") || 0),
					animations: []
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "instance_animation":
							R.animations.push(a(z.getAttribute("url")));
							break
					}
				}
				at.clips[P.getAttribute("id")] = R
			}

			function Y(P) {
				let R = [],
					G = P.name,
					F = P.end - P.start || -1,
					z = P.animations;
				for (let me = 0, be = z.length; me < be; me++) {
					let Be = y(z[me]);
					for (let Pe = 0, Ge = Be.length; Pe < Ge; Pe++) R.push(Be[Pe])
				}
				return new Eo(G, F, R)
			}

			function J(P) {
				return m(at.clips[P], Y)
			}

			function H(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "skin":
							R.id = a(z.getAttribute("source")), R.skin = $(z);
							break;
						case "morph":
							R.id = a(z.getAttribute("source")), console.warn("THREE.ColladaLoader: Morph target animation not supported yet.");
							break
					}
				}
				at.controllers[P.getAttribute("id")] = R
			}

			function $(P) {
				let R = {
					sources: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "bind_shape_matrix":
							R.bindShapeMatrix = s(z.textContent);
							break;
						case "source":
							let me = z.getAttribute("id");
							R.sources[me] = we(z);
							break;
						case "joints":
							R.joints = ae(z);
							break;
						case "vertex_weights":
							R.vertexWeights = oe(z);
							break
					}
				}
				return R
			}

			function ae(P) {
				let R = {
					inputs: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "input":
							let me = z.getAttribute("semantic"),
								be = a(z.getAttribute("source"));
							R.inputs[me] = be;
							break
					}
				}
				return R
			}

			function oe(P) {
				let R = {
					inputs: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "input":
							let me = z.getAttribute("semantic"),
								be = a(z.getAttribute("source")),
								Be = parseInt(z.getAttribute("offset"));
							R.inputs[me] = {
								id: be,
								offset: Be
							};
							break;
						case "vcount":
							R.vcount = o(z.textContent);
							break;
						case "v":
							R.v = o(z.textContent);
							break
					}
				}
				return R
			}

			function ie(P) {
				let R = {
						id: P.id
					},
					G = at.geometries[R.id];
				return P.skin !== void 0 && (R.skin = U(P.skin), G.sources.skinIndices = R.skin.indices, G.sources.skinWeights = R.skin.weights), R
			}

			function U(P) {
				let G = {
						joints: [],
						indices: {
							array: [],
							stride: 4
						},
						weights: {
							array: [],
							stride: 4
						}
					},
					F = P.sources,
					z = P.vertexWeights,
					me = z.vcount,
					be = z.v,
					Be = z.inputs.JOINT.offset,
					Pe = z.inputs.WEIGHT.offset,
					Ge = P.sources[P.joints.inputs.JOINT],
					Je = P.sources[P.joints.inputs.INV_BIND_MATRIX],
					Ae = F[z.inputs.WEIGHT.id].array,
					et = 0,
					qe, rt, Qe;
				for (qe = 0, Qe = me.length; qe < Qe; qe++) {
					let Vt = me[qe],
						Lt = [];
					for (rt = 0; rt < Vt; rt++) {
						let Nt = be[et + Be],
							kr = be[et + Pe],
							ai = Ae[kr];
						Lt.push({
							index: Nt,
							weight: ai
						}), et += 2
					}
					for (Lt.sort(nn), rt = 0; rt < 4; rt++) {
						let Nt = Lt[rt];
						Nt !== void 0 ? (G.indices.array.push(Nt.index), G.weights.array.push(Nt.weight)) : (G.indices.array.push(0), G.weights.array.push(0))
					}
				}
				for (P.bindShapeMatrix ? G.bindMatrix = new ke()
					.fromArray(P.bindShapeMatrix)
					.transpose() : G.bindMatrix = new ke()
					.identity(), qe = 0, Qe = Ge.array.length; qe < Qe; qe++) {
					let Vt = Ge.array[qe],
						Lt = new ke()
						.fromArray(Je.array, qe * Je.stride)
						.transpose();
					G.joints.push({
						name: Vt,
						boneInverse: Lt
					})
				}
				return G;

				function nn(Vt, Lt) {
					return Lt.weight - Vt.weight
				}
			}

			function A(P) {
				return m(at.controllers[P], ie)
			}

			function L(P) {
				let R = {
					init_from: n(P, "init_from")[0].textContent
				};
				at.images[P.getAttribute("id")] = R
			}

			function j(P) {
				return P.build !== void 0 ? P.build : P.init_from
			}

			function K(P) {
				let R = at.images[P];
				return R !== void 0 ? m(R, j) : (console.warn("THREE.ColladaLoader: Couldn't find image with ID:", P), null)
			}

			function Q(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "profile_COMMON":
							R.profile = se(z);
							break
					}
				}
				at.effects[P.getAttribute("id")] = R
			}

			function se(P) {
				let R = {
					surfaces: {},
					samplers: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "newparam":
							de(z, R);
							break;
						case "technique":
							R.technique = Ee(z);
							break;
						case "extra":
							R.extra = ot(z);
							break
					}
				}
				return R
			}

			function de(P, R) {
				let G = P.getAttribute("sid");
				for (let F = 0, z = P.childNodes.length; F < z; F++) {
					let me = P.childNodes[F];
					if (me.nodeType === 1) switch (me.nodeName) {
						case "surface":
							R.surfaces[G] = ue(me);
							break;
						case "sampler2D":
							R.samplers[G] = xe(me);
							break
					}
				}
			}

			function ue(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "init_from":
							R.init_from = z.textContent;
							break
					}
				}
				return R
			}

			function xe(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "source":
							R.source = z.textContent;
							break
					}
				}
				return R
			}

			function Ee(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "constant":
						case "lambert":
						case "blinn":
						case "phong":
							R.type = z.nodeName, R.parameters = De(z);
							break;
						case "extra":
							R.extra = ot(z);
							break
					}
				}
				return R
			}

			function De(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "emission":
						case "diffuse":
						case "specular":
						case "bump":
						case "ambient":
						case "shininess":
						case "transparency":
							R[z.nodeName] = ht(z);
							break;
						case "transparent":
							R[z.nodeName] = {
								opaque: z.hasAttribute("opaque") ? z.getAttribute("opaque") : "A_ONE",
								data: ht(z)
							};
							break
					}
				}
				return R
			}

			function ht(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "color":
							R[z.nodeName] = s(z.textContent);
							break;
						case "float":
							R[z.nodeName] = parseFloat(z.textContent);
							break;
						case "texture":
							R[z.nodeName] = {
								id: z.getAttribute("texture"),
								extra: ct(z)
							};
							break
					}
				}
				return R
			}

			function ct(P) {
				let R = {
					technique: {}
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "extra":
							He(z, R);
							break
					}
				}
				return R
			}

			function He(P, R) {
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "technique":
							Ve(z, R);
							break
					}
				}
			}

			function Ve(P, R) {
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "repeatU":
						case "repeatV":
						case "offsetU":
						case "offsetV":
							R.technique[z.nodeName] = parseFloat(z.textContent);
							break;
						case "wrapU":
						case "wrapV":
							z.textContent.toUpperCase() === "TRUE" ? R.technique[z.nodeName] = 1 : z.textContent.toUpperCase() === "FALSE" ? R.technique[z.nodeName] = 0 : R.technique[z.nodeName] = parseInt(z.textContent);
							break;
						case "bump":
							R[z.nodeName] = E(z);
							break
					}
				}
			}

			function ot(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "technique":
							R.technique = it(z);
							break
					}
				}
				return R
			}

			function it(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "double_sided":
							R[z.nodeName] = parseInt(z.textContent);
							break;
						case "bump":
							R[z.nodeName] = E(z);
							break
					}
				}
				return R
			}

			function E(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "texture":
							R[z.nodeName] = {
								id: z.getAttribute("texture"),
								texcoord: z.getAttribute("texcoord"),
								extra: ct(z)
							};
							break
					}
				}
				return R
			}

			function M(P) {
				return P
			}

			function D(P) {
				return m(at.effects[P], M)
			}

			function X(P) {
				let R = {
					name: P.getAttribute("name")
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "instance_effect":
							R.url = a(z.getAttribute("url"));
							break
					}
				}
				at.materials[P.getAttribute("id")] = R
			}

			function W(P) {
				let R, G = P.slice((P.lastIndexOf(".") - 1 >>> 0) + 2);
				switch (G = G.toLowerCase(), G) {
					case "tga":
						R = yf;
						break;
					default:
						R = jm
				}
				return R
			}

			function te(P) {
				let R = D(P.url),
					G = R.profile.technique,
					F;
				switch (G.type) {
					case "phong":
					case "blinn":
						F = new an;
						break;
					case "lambert":
						F = new ba;
						break;
					default:
						F = new Oi;
						break
				}
				F.name = P.name || "";

				function z(Pe, Ge = null) {
					let Je = R.profile.samplers[Pe.id],
						Ae = null;
					if (Je !== void 0) {
						let et = R.profile.surfaces[Je.source];
						Ae = K(et.init_from)
					} else console.warn("THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530)."), Ae = K(Pe.id);
					if (Ae !== null) {
						let et = W(Ae);
						if (et !== void 0) {
							let qe = et.load(Ae),
								rt = Pe.extra;
							if (rt !== void 0 && rt.technique !== void 0 && l(rt.technique) === !1) {
								let Qe = rt.technique;
								qe.wrapS = Qe.wrapU ? en : Xt, qe.wrapT = Qe.wrapV ? en : Xt, qe.offset.set(Qe.offsetU || 0, Qe.offsetV || 0), qe.repeat.set(Qe.repeatU || 1, Qe.repeatV || 1)
							} else qe.wrapS = en, qe.wrapT = en;
							return Ge !== null && (qe.encoding = Ge), qe
						} else return console.warn("THREE.ColladaLoader: Loader for texture %s not found.", Ae), null
					} else return console.warn("THREE.ColladaLoader: Couldn't create texture with ID:", Pe.id), null
				}
				let me = G.parameters;
				for (let Pe in me) {
					let Ge = me[Pe];
					switch (Pe) {
						case "diffuse":
							Ge.color && F.color.fromArray(Ge.color), Ge.texture && (F.map = z(Ge.texture, Pt));
							break;
						case "specular":
							Ge.color && F.specular && F.specular.fromArray(Ge.color), Ge.texture && (F.specularMap = z(Ge.texture));
							break;
						case "bump":
							Ge.texture && (F.normalMap = z(Ge.texture));
							break;
						case "ambient":
							Ge.texture && (F.lightMap = z(Ge.texture, Pt));
							break;
						case "shininess":
							Ge.float && F.shininess && (F.shininess = Ge.float);
							break;
						case "emission":
							Ge.color && F.emissive && F.emissive.fromArray(Ge.color), Ge.texture && (F.emissiveMap = z(Ge.texture, Pt));
							break
					}
				}
				F.color.convertSRGBToLinear(), F.specular && F.specular.convertSRGBToLinear(), F.emissive && F.emissive.convertSRGBToLinear();
				let be = me.transparent,
					Be = me.transparency;
				if (Be === void 0 && be && (Be = {
					float: 1
				}), be === void 0 && Be && (be = {
					opaque: "A_ONE",
					data: {
						color: [1, 1, 1, 1]
					}
				}), be && Be)
					if (be.data.texture) F.transparent = !0;
					else {
						let Pe = be.data.color;
						switch (be.opaque) {
							case "A_ONE":
								F.opacity = Pe[3] * Be.float;
								break;
							case "RGB_ZERO":
								F.opacity = 1 - Pe[0] * Be.float;
								break;
							case "A_ZERO":
								F.opacity = 1 - Pe[3] * Be.float;
								break;
							case "RGB_ONE":
								F.opacity = Pe[0] * Be.float;
								break;
							default:
								console.warn('THREE.ColladaLoader: Invalid opaque type "%s" of transparent tag.', be.opaque)
						}
						F.opacity < 1 && (F.transparent = !0)
					} if (G.extra !== void 0 && G.extra.technique !== void 0) {
					let Pe = G.extra.technique;
					for (let Ge in Pe) {
						let Je = Pe[Ge];
						switch (Ge) {
							case "double_sided":
								F.side = Je === 1 ? Bn : _r;
								break;
							case "bump":
								F.normalMap = z(Je.texture), F.normalScale = new st(1, 1);
								break
						}
					}
				}
				return F
			}

			function ce(P) {
				return m(at.materials[P], te)
			}

			function le(P) {
				let R = {
					name: P.getAttribute("name")
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "optics":
							R.optics = ee(z);
							break
					}
				}
				at.cameras[P.getAttribute("id")] = R
			}

			function ee(P) {
				for (let R = 0; R < P.childNodes.length; R++) {
					let G = P.childNodes[R];
					switch (G.nodeName) {
						case "technique_common":
							return pe(G)
					}
				}
				return {}
			}

			function pe(P) {
				let R = {};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					switch (F.nodeName) {
						case "perspective":
						case "orthographic":
							R.technique = F.nodeName, R.parameters = ve(F);
							break
					}
				}
				return R
			}

			function ve(P) {
				let R = {};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					switch (F.nodeName) {
						case "xfov":
						case "yfov":
						case "xmag":
						case "ymag":
						case "znear":
						case "zfar":
						case "aspect_ratio":
							R[F.nodeName] = parseFloat(F.textContent);
							break
					}
				}
				return R
			}

			function Se(P) {
				let R;
				switch (P.optics.technique) {
					case "perspective":
						R = new Kt(P.optics.parameters.yfov, P.optics.parameters.aspect_ratio, P.optics.parameters.znear, P.optics.parameters.zfar);
						break;
					case "orthographic":
						let G = P.optics.parameters.ymag,
							F = P.optics.parameters.xmag,
							z = P.optics.parameters.aspect_ratio;
						F = F === void 0 ? G * z : F, G = G === void 0 ? F / z : G, F *= .5, G *= .5, R = new Mr(-F, F, G, -G, P.optics.parameters.znear, P.optics.parameters.zfar);
						break;
					default:
						R = new Kt;
						break
				}
				return R.name = P.name || "", R
			}

			function Re(P) {
				let R = at.cameras[P];
				return R !== void 0 ? m(R, Se) : (console.warn("THREE.ColladaLoader: Couldn't find camera with ID:", P), null)
			}

			function We(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "technique_common":
							R = Ye(z);
							break
					}
				}
				at.lights[P.getAttribute("id")] = R
			}

			function Ye(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "directional":
						case "point":
						case "spot":
						case "ambient":
							R.technique = z.nodeName, R.parameters = re(z)
					}
				}
				return R
			}

			function re(P) {
				let R = {};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "color":
							let me = s(z.textContent);
							R.color = new Xe()
								.fromArray(me)
								.convertSRGBToLinear();
							break;
						case "falloff_angle":
							R.falloffAngle = parseFloat(z.textContent);
							break;
						case "quadratic_attenuation":
							let be = parseFloat(z.textContent);
							R.distance = be ? Math.sqrt(1 / be) : 0;
							break
					}
				}
				return R
			}

			function Ce(P) {
				let R;
				switch (P.technique) {
					case "directional":
						R = new Tr;
						break;
					case "point":
						R = new Co;
						break;
					case "spot":
						R = new Ta;
						break;
					case "ambient":
						R = new Sr;
						break
				}
				return P.parameters.color && R.color.copy(P.parameters.color), P.parameters.distance && (R.distance = P.parameters.distance), R
			}

			function Te(P) {
				let R = at.lights[P];
				return R !== void 0 ? m(R, Ce) : (console.warn("THREE.ColladaLoader: Couldn't find light with ID:", P), null)
			}

			function ge(P) {
				let R = {
						name: P.getAttribute("name"),
						sources: {},
						vertices: {},
						primitives: []
					},
					G = n(P, "mesh")[0];
				if (G !== void 0) {
					for (let F = 0; F < G.childNodes.length; F++) {
						let z = G.childNodes[F];
						if (z.nodeType !== 1) continue;
						let me = z.getAttribute("id");
						switch (z.nodeName) {
							case "source":
								R.sources[me] = we(z);
								break;
							case "vertices":
								R.vertices = Oe(z);
								break;
							case "polygons":
								console.warn("THREE.ColladaLoader: Unsupported primitive type: ", z.nodeName);
								break;
							case "lines":
							case "linestrips":
							case "polylist":
							case "triangles":
								R.primitives.push($e(z));
								break;
							default:
								console.log(z)
						}
					}
					at.geometries[P.getAttribute("id")] = R
				}
			}

			function we(P) {
				let R = {
					array: [],
					stride: 3
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "float_array":
							R.array = s(F.textContent);
							break;
						case "Name_array":
							R.array = i(F.textContent);
							break;
						case "technique_common":
							let z = n(F, "accessor")[0];
							z !== void 0 && (R.stride = parseInt(z.getAttribute("stride")));
							break
					}
				}
				return R
			}

			function Oe(P) {
				let R = {};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					F.nodeType === 1 && (R[F.getAttribute("semantic")] = a(F.getAttribute("source")))
				}
				return R
			}

			function $e(P) {
				let R = {
					type: P.nodeName,
					material: P.getAttribute("material"),
					count: parseInt(P.getAttribute("count")),
					inputs: {},
					stride: 0,
					hasUV: !1
				};
				for (let G = 0, F = P.childNodes.length; G < F; G++) {
					let z = P.childNodes[G];
					if (z.nodeType === 1) switch (z.nodeName) {
						case "input":
							let me = a(z.getAttribute("source")),
								be = z.getAttribute("semantic"),
								Be = parseInt(z.getAttribute("offset")),
								Pe = parseInt(z.getAttribute("set")),
								Ge = Pe > 0 ? be + Pe : be;
							R.inputs[Ge] = {
								id: me,
								offset: Be
							}, R.stride = Math.max(R.stride, Be + 1), be === "TEXCOORD" && (R.hasUV = !0);
							break;
						case "vcount":
							R.vcount = o(z.textContent);
							break;
						case "p":
							R.p = o(z.textContent);
							break
					}
				}
				return R
			}

			function vt(P) {
				let R = {};
				for (let G = 0; G < P.length; G++) {
					let F = P[G];
					R[F.type] === void 0 && (R[F.type] = []), R[F.type].push(F)
				}
				return R
			}

			function Wt(P) {
				let R = 0;
				for (let G = 0, F = P.length; G < F; G++) P[G].hasUV === !0 && R++;
				R > 0 && R < P.length && (P.uvsNeedsFix = !0)
			}

			function Ze(P) {
				let R = {},
					G = P.sources,
					F = P.vertices,
					z = P.primitives;
				if (z.length === 0) return {};
				let me = vt(z);
				for (let be in me) {
					let Be = me[be];
					Wt(Be), R[be] = Fe(Be, G, F)
				}
				return R
			}

			function Fe(P, R, G) {
				let F = {},
					z = {
						array: [],
						stride: 0
					},
					me = {
						array: [],
						stride: 0
					},
					be = {
						array: [],
						stride: 0
					},
					Be = {
						array: [],
						stride: 0
					},
					Pe = {
						array: [],
						stride: 0
					},
					Ge = {
						array: [],
						stride: 4
					},
					Je = {
						array: [],
						stride: 4
					},
					Ae = new bt,
					et = [],
					qe = 0;
				for (let rt = 0; rt < P.length; rt++) {
					let Qe = P[rt],
						nn = Qe.inputs,
						Vt = 0;
					switch (Qe.type) {
						case "lines":
						case "linestrips":
							Vt = Qe.count * 2;
							break;
						case "triangles":
							Vt = Qe.count * 3;
							break;
						case "polylist":
							for (let Lt = 0; Lt < Qe.count; Lt++) {
								let Nt = Qe.vcount[Lt];
								switch (Nt) {
									case 3:
										Vt += 3;
										break;
									case 4:
										Vt += 6;
										break;
									default:
										Vt += (Nt - 2) * 3;
										break
								}
							}
							break;
						default:
							console.warn("THREE.ColladaLoader: Unknow primitive type:", Qe.type)
					}
					Ae.addGroup(qe, Vt, rt), qe += Vt, Qe.material && et.push(Qe.material);
					for (let Lt in nn) {
						let Nt = nn[Lt];
						switch (Lt) {
							case "VERTEX":
								for (let kr in G) {
									let ai = G[kr];
									switch (kr) {
										case "POSITION":
											let Uo = z.array.length;
											if (Ie(Qe, R[ai], Nt.offset, z.array), z.stride = R[ai].stride, R.skinWeights && R.skinIndices && (Ie(Qe, R.skinIndices, Nt.offset, Ge.array), Ie(Qe, R.skinWeights, Nt.offset, Je.array)), Qe.hasUV === !1 && P.uvsNeedsFix === !0) {
												let vy = (z.array.length - Uo) / z.stride;
												for (let Xm = 0; Xm < vy; Xm++) be.array.push(0, 0)
											}
											break;
										case "NORMAL":
											Ie(Qe, R[ai], Nt.offset, me.array), me.stride = R[ai].stride;
											break;
										case "COLOR":
											Ie(Qe, R[ai], Nt.offset, Pe.array), Pe.stride = R[ai].stride;
											break;
										case "TEXCOORD":
											Ie(Qe, R[ai], Nt.offset, be.array), be.stride = R[ai].stride;
											break;
										case "TEXCOORD1":
											Ie(Qe, R[ai], Nt.offset, Be.array), be.stride = R[ai].stride;
											break;
										default:
											console.warn('THREE.ColladaLoader: Semantic "%s" not handled in geometry build process.', kr)
									}
								}
								break;
							case "NORMAL":
								Ie(Qe, R[Nt.id], Nt.offset, me.array), me.stride = R[Nt.id].stride;
								break;
							case "COLOR":
								Ie(Qe, R[Nt.id], Nt.offset, Pe.array, !0), Pe.stride = R[Nt.id].stride;
								break;
							case "TEXCOORD":
								Ie(Qe, R[Nt.id], Nt.offset, be.array), be.stride = R[Nt.id].stride;
								break;
							case "TEXCOORD1":
								Ie(Qe, R[Nt.id], Nt.offset, Be.array), Be.stride = R[Nt.id].stride;
								break
						}
					}
				}
				return z.array.length > 0 && Ae.setAttribute("position", new ze(z.array, z.stride)), me.array.length > 0 && Ae.setAttribute("normal", new ze(me.array, me.stride)), Pe.array.length > 0 && Ae.setAttribute("color", new ze(Pe.array, Pe.stride)), be.array.length > 0 && Ae.setAttribute("uv", new ze(be.array, be.stride)), Be.array.length > 0 && Ae.setAttribute("uv2", new ze(Be.array, Be.stride)), Ge.array.length > 0 && Ae.setAttribute("skinIndex", new ze(Ge.array, Ge.stride)), Je.array.length > 0 && Ae.setAttribute("skinWeight", new ze(Je.array, Je.stride)), F.data = Ae, F.type = P[0].type, F.materialKeys = et, F
			}

			function Ie(P, R, G, F, z = !1) {
				let me = P.p,
					be = P.stride,
					Be = P.vcount;

				function Pe(Ae) {
					let et = me[Ae + G] * Je,
						qe = et + Je;
					for (; et < qe; et++) F.push(Ge[et]);
					if (z) {
						let rt = F.length - Je - 1;
						mc.setRGB(F[rt + 0], F[rt + 1], F[rt + 2])
							.convertSRGBToLinear(), F[rt + 0] = mc.r, F[rt + 1] = mc.g, F[rt + 2] = mc.b
					}
				}
				let Ge = R.array,
					Je = R.stride;
				if (P.vcount !== void 0) {
					let Ae = 0;
					for (let et = 0, qe = Be.length; et < qe; et++) {
						let rt = Be[et];
						if (rt === 4) {
							let Qe = Ae + be * 0,
								nn = Ae + be * 1,
								Vt = Ae + be * 2,
								Lt = Ae + be * 3;
							Pe(Qe), Pe(nn), Pe(Lt), Pe(nn), Pe(Vt), Pe(Lt)
						} else if (rt === 3) {
							let Qe = Ae + be * 0,
								nn = Ae + be * 1,
								Vt = Ae + be * 2;
							Pe(Qe), Pe(nn), Pe(Vt)
						} else if (rt > 4)
							for (let Qe = 1, nn = rt - 2; Qe <= nn; Qe++) {
								let Vt = Ae + be * 0,
									Lt = Ae + be * Qe,
									Nt = Ae + be * (Qe + 1);
								Pe(Vt), Pe(Lt), Pe(Nt)
							}
						Ae += be * rt
					}
				} else
					for (let Ae = 0, et = me.length; Ae < et; Ae += be) Pe(Ae)
			}

			function Ue(P) {
				return m(at.geometries[P], Ze)
			}

			function je(P) {
				let R = {
					name: P.getAttribute("name") || "",
					joints: {},
					links: []
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "technique_common":
							Ii(F, R);
							break
					}
				}
				at.kinematicsModels[P.getAttribute("id")] = R
			}

			function Ke(P) {
				return P.build !== void 0 ? P.build : P
			}

			function jt(P) {
				return m(at.kinematicsModels[P], Ke)
			}

			function Ii(P, R) {
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "joint":
							R.joints[F.getAttribute("sid")] = Ri(F);
							break;
						case "link":
							R.links.push(fe(F));
							break
					}
				}
			}

			function Ri(P) {
				let R;
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "prismatic":
						case "revolute":
							R = Z(F);
							break
					}
				}
				return R
			}

			function Z(P) {
				let R = {
					sid: P.getAttribute("sid"),
					name: P.getAttribute("name") || "",
					axis: new ne,
					limits: {
						min: 0,
						max: 0
					},
					type: P.nodeName,
					static: !1,
					zeroPosition: 0,
					middlePosition: 0
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "axis":
							let z = s(F.textContent);
							R.axis.fromArray(z);
							break;
						case "limits":
							let me = F.getElementsByTagName("max")[0],
								be = F.getElementsByTagName("min")[0];
							R.limits.max = parseFloat(me.textContent), R.limits.min = parseFloat(be.textContent);
							break
					}
				}
				return R.limits.min >= R.limits.max && (R.static = !0), R.middlePosition = (R.limits.min + R.limits.max) / 2, R
			}

			function fe(P) {
				let R = {
					sid: P.getAttribute("sid"),
					name: P.getAttribute("name") || "",
					attachments: [],
					transforms: []
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "attachment_full":
							R.attachments.push(ye(F));
							break;
						case "matrix":
						case "translate":
						case "rotate":
							R.transforms.push(he(F));
							break
					}
				}
				return R
			}

			function ye(P) {
				let R = {
					joint: P.getAttribute("joint")
						.split("/")
						.pop(),
					transforms: [],
					links: []
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "link":
							R.links.push(fe(F));
							break;
						case "matrix":
						case "translate":
						case "rotate":
							R.transforms.push(he(F));
							break
					}
				}
				return R
			}

			function he(P) {
				let R = {
						type: P.nodeName
					},
					G = s(P.textContent);
				switch (R.type) {
					case "matrix":
						R.obj = new ke, R.obj.fromArray(G)
							.transpose();
						break;
					case "translate":
						R.obj = new ne, R.obj.fromArray(G);
						break;
					case "rotate":
						R.obj = new ne, R.obj.fromArray(G), R.angle = Vn.degToRad(G[3]);
						break
				}
				return R
			}

			function Me(P) {
				let R = {
					name: P.getAttribute("name") || "",
					rigidBodies: {}
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "rigid_body":
							R.rigidBodies[F.getAttribute("name")] = {}, tt(F, R.rigidBodies[F.getAttribute("name")]);
							break
					}
				}
				at.physicsModels[P.getAttribute("id")] = R
			}

			function tt(P, R) {
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "technique_common":
							ft(F, R);
							break
					}
				}
			}

			function ft(P, R) {
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "inertia":
							R.inertia = s(F.textContent);
							break;
						case "mass":
							R.mass = s(F.textContent)[0];
							break
					}
				}
			}

			function xt(P) {
				let R = {
					bindJointAxis: []
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "bind_joint_axis":
							R.bindJointAxis.push(dt(F));
							break
					}
				}
				at.kinematicsScenes[a(P.getAttribute("url"))] = R
			}

			function dt(P) {
				let R = {
					target: P.getAttribute("target")
						.split("/")
						.pop()
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType === 1) switch (F.nodeName) {
						case "axis":
							let z = F.getElementsByTagName("param")[0];
							R.axis = z.textContent;
							let me = R.axis.split("inst_")
								.pop()
								.split("axis")[0];
							R.jointIndex = me.substring(0, me.length - 1);
							break
					}
				}
				return R
			}

			function Ot(P) {
				return P.build !== void 0 ? P.build : P
			}

			function St(P) {
				return m(at.kinematicsScenes[P], Ot)
			}

			function Et() {
				let P = Object.keys(at.kinematicsModels)[0],
					R = Object.keys(at.kinematicsScenes)[0],
					G = Object.keys(at.visualScenes)[0];
				if (P === void 0 || R === void 0) return;
				let F = jt(P),
					z = St(R),
					me = dc(G),
					be = z.bindJointAxis,
					Be = {};
				for (let Je = 0, Ae = be.length; Je < Ae; Je++) {
					let et = be[Je],
						qe = gn.querySelector('[sid="' + et.target + '"]');
					if (qe) {
						let rt = qe.parentElement;
						Pe(et.jointIndex, rt)
					}
				}

				function Pe(Je, Ae) {
					let et = Ae.getAttribute("name"),
						qe = F.joints[Je];
					me.traverse(function(rt) {
						rt.name === et && (Be[Je] = {
							object: rt,
							transforms: $t(Ae),
							joint: qe,
							position: qe.zeroPosition
						})
					})
				}
				let Ge = new ke;
				qm = {
					joints: F && F.joints,
					getJointValue: function(Je) {
						let Ae = Be[Je];
						if (Ae) return Ae.position;
						console.warn("THREE.ColladaLoader: Joint " + Je + " doesn't exist.")
					},
					setJointValue: function(Je, Ae) {
						let et = Be[Je];
						if (et) {
							let qe = et.joint;
							if (Ae > qe.limits.max || Ae < qe.limits.min) console.warn("THREE.ColladaLoader: Joint " + Je + " value " + Ae + " outside of limits (min: " + qe.limits.min + ", max: " + qe.limits.max + ").");
							else if (qe.static) console.warn("THREE.ColladaLoader: Joint " + Je + " is static.");
							else {
								let rt = et.object,
									Qe = qe.axis,
									nn = et.transforms;
								hn.identity();
								for (let Vt = 0; Vt < nn.length; Vt++) {
									let Lt = nn[Vt];
									if (Lt.sid && Lt.sid.indexOf(Je) !== -1) switch (qe.type) {
										case "revolute":
											hn.multiply(Ge.makeRotationAxis(Qe, Vn.degToRad(Ae)));
											break;
										case "prismatic":
											hn.multiply(Ge.makeTranslation(Qe.x * Ae, Qe.y * Ae, Qe.z * Ae));
											break;
										default:
											console.warn("THREE.ColladaLoader: Unknown joint type: " + qe.type);
											break
									} else switch (Lt.type) {
										case "matrix":
											hn.multiply(Lt.obj);
											break;
										case "translate":
											hn.multiply(Ge.makeTranslation(Lt.obj.x, Lt.obj.y, Lt.obj.z));
											break;
										case "scale":
											hn.scale(Lt.obj);
											break;
										case "rotate":
											hn.multiply(Ge.makeRotationAxis(Lt.obj, Lt.angle));
											break
									}
								}
								rt.matrix.copy(hn), rt.matrix.decompose(rt.position, rt.quaternion, rt.scale), Be[Je].position = Ae
							}
						} else console.log("THREE.ColladaLoader: " + Je + " does not exist.")
					}
				}
			}

			function $t(P) {
				let R = [],
					G = gn.querySelector('[id="' + P.id + '"]');
				for (let F = 0; F < G.childNodes.length; F++) {
					let z = G.childNodes[F];
					if (z.nodeType !== 1) continue;
					let me, be;
					switch (z.nodeName) {
						case "matrix":
							me = s(z.textContent);
							let Be = new ke()
								.fromArray(me)
								.transpose();
							R.push({
								sid: z.getAttribute("sid"),
								type: z.nodeName,
								obj: Be
							});
							break;
						case "translate":
						case "scale":
							me = s(z.textContent), be = new ne()
								.fromArray(me), R.push({
									sid: z.getAttribute("sid"),
									type: z.nodeName,
									obj: be
								});
							break;
						case "rotate":
							me = s(z.textContent), be = new ne()
								.fromArray(me);
							let Pe = Vn.degToRad(me[3]);
							R.push({
								sid: z.getAttribute("sid"),
								type: z.nodeName,
								obj: be,
								angle: Pe
							});
							break
					}
				}
				return R
			}

			function Or(P) {
				let R = P.getElementsByTagName("node");
				for (let G = 0; G < R.length; G++) {
					let F = R[G];
					F.hasAttribute("id") === !1 && F.setAttribute("id", c())
				}
			}
			let hn = new ke,
				bi = new ne;

			function ri(P) {
				let R = {
					name: P.getAttribute("name") || "",
					type: P.getAttribute("type"),
					id: P.getAttribute("id"),
					sid: P.getAttribute("sid"),
					matrix: new ke,
					nodes: [],
					instanceCameras: [],
					instanceControllers: [],
					instanceLights: [],
					instanceGeometries: [],
					instanceNodes: [],
					transforms: {}
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					if (F.nodeType !== 1) continue;
					let z;
					switch (F.nodeName) {
						case "node":
							R.nodes.push(F.getAttribute("id")), ri(F);
							break;
						case "instance_camera":
							R.instanceCameras.push(a(F.getAttribute("url")));
							break;
						case "instance_controller":
							R.instanceControllers.push(It(F));
							break;
						case "instance_light":
							R.instanceLights.push(a(F.getAttribute("url")));
							break;
						case "instance_geometry":
							R.instanceGeometries.push(It(F));
							break;
						case "instance_node":
							R.instanceNodes.push(a(F.getAttribute("url")));
							break;
						case "matrix":
							z = s(F.textContent), R.matrix.multiply(hn.fromArray(z)
								.transpose()), R.transforms[F.getAttribute("sid")] = F.nodeName;
							break;
						case "translate":
							z = s(F.textContent), bi.fromArray(z), R.matrix.multiply(hn.makeTranslation(bi.x, bi.y, bi.z)), R.transforms[F.getAttribute("sid")] = F.nodeName;
							break;
						case "rotate":
							z = s(F.textContent);
							let me = Vn.degToRad(z[3]);
							R.matrix.multiply(hn.makeRotationAxis(bi.fromArray(z), me)), R.transforms[F.getAttribute("sid")] = F.nodeName;
							break;
						case "scale":
							z = s(F.textContent), R.matrix.scale(bi.fromArray(z)), R.transforms[F.getAttribute("sid")] = F.nodeName;
							break;
						case "extra":
							break;
						default:
							console.log(F)
					}
				}
				return En(R.id) ? console.warn("THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.", R.id) : at.nodes[R.id] = R, R
			}

			function It(P) {
				let R = {
					id: a(P.getAttribute("url")),
					materials: {},
					skeletons: []
				};
				for (let G = 0; G < P.childNodes.length; G++) {
					let F = P.childNodes[G];
					switch (F.nodeName) {
						case "bind_material":
							let z = F.getElementsByTagName("instance_material");
							for (let me = 0; me < z.length; me++) {
								let be = z[me],
									Be = be.getAttribute("symbol"),
									Pe = be.getAttribute("target");
								R.materials[Be] = a(Pe)
							}
							break;
						case "skeleton":
							R.skeletons.push(a(F.textContent));
							break;
						default:
							break
					}
				}
				return R
			}

			function fs(P, R) {
				let G = [],
					F = [],
					z, me, be;
				for (z = 0; z < P.length; z++) {
					let Ge = P[z],
						Je;
					if (En(Ge)) Je = oi(Ge), tn(Je, R, G);
					else if (al(Ge)) {
						let et = at.visualScenes[Ge].children;
						for (let qe = 0; qe < et.length; qe++) {
							let rt = et[qe];
							if (rt.type === "JOINT") {
								let Qe = oi(rt.id);
								tn(Qe, R, G)
							}
						}
					} else console.error("THREE.ColladaLoader: Unable to find root bone of skeleton with ID:", Ge)
				}
				for (z = 0; z < R.length; z++)
					for (me = 0; me < G.length; me++)
						if (be = G[me], be.bone.name === R[z].name) {
							F[z] = be, be.processed = !0;
							break
						} for (z = 0; z < G.length; z++) be = G[z], be.processed === !1 && (F.push(be), be.processed = !0);
				let Be = [],
					Pe = [];
				for (z = 0; z < F.length; z++) be = F[z], Be.push(be.bone), Pe.push(be.boneInverse);
				return new Ls(Be, Pe)
			}

			function tn(P, R, G) {
				P.traverse(function(F) {
					if (F.isBone === !0) {
						let z;
						for (let me = 0; me < R.length; me++) {
							let be = R[me];
							if (be.name === F.name) {
								z = be.boneInverse;
								break
							}
						}
						z === void 0 && (z = new ke), G.push({
							bone: F,
							boneInverse: z,
							processed: !1
						})
					}
				})
			}

			function si(P) {
				let R = [],
					G = P.matrix,
					F = P.nodes,
					z = P.type,
					me = P.instanceCameras,
					be = P.instanceControllers,
					Be = P.instanceLights,
					Pe = P.instanceGeometries,
					Ge = P.instanceNodes;
				for (let Ae = 0, et = F.length; Ae < et; Ae++) R.push(oi(F[Ae]));
				for (let Ae = 0, et = me.length; Ae < et; Ae++) {
					let qe = Re(me[Ae]);
					qe !== null && R.push(qe.clone())
				}
				for (let Ae = 0, et = be.length; Ae < et; Ae++) {
					let qe = be[Ae],
						rt = A(qe.id),
						Qe = Ue(rt.id),
						nn = Fo(Qe, qe.materials),
						Vt = qe.skeletons,
						Lt = rt.skin.joints,
						Nt = fs(Vt, Lt);
					for (let kr = 0, ai = nn.length; kr < ai; kr++) {
						let Uo = nn[kr];
						Uo.isSkinnedMesh && (Uo.bind(Nt, rt.skin.bindMatrix), Uo.normalizeSkinWeights()), R.push(Uo)
					}
				}
				for (let Ae = 0, et = Be.length; Ae < et; Ae++) {
					let qe = Te(Be[Ae]);
					qe !== null && R.push(qe.clone())
				}
				for (let Ae = 0, et = Pe.length; Ae < et; Ae++) {
					let qe = Pe[Ae],
						rt = Ue(qe.id),
						Qe = Fo(rt, qe.materials);
					for (let nn = 0, Vt = Qe.length; nn < Vt; nn++) R.push(Qe[nn])
				}
				for (let Ae = 0, et = Ge.length; Ae < et; Ae++) R.push(oi(Ge[Ae])
					.clone());
				let Je;
				if (F.length === 0 && R.length === 1) Je = R[0];
				else {
					Je = z === "JOINT" ? new Ps : new _n;
					for (let Ae = 0; Ae < R.length; Ae++) Je.add(R[Ae])
				}
				return Je.name = z === "JOINT" ? P.sid : P.name, Je.matrix.copy(G), Je.matrix.decompose(Je.position, Je.quaternion, Je.scale), Je
			}
			let gr = new Oi({
				color: 16711935
			});

			function io(P, R) {
				let G = [];
				for (let F = 0, z = P.length; F < z; F++) {
					let me = R[P[F]];
					me === void 0 ? (console.warn("THREE.ColladaLoader: Material with key %s not found. Apply fallback material.", P[F]), G.push(gr)) : G.push(ce(me))
				}
				return G
			}

			function Fo(P, R) {
				let G = [];
				for (let F in P) {
					let z = P[F],
						me = io(z.materialKeys, R);
					me.length === 0 && (F === "lines" || F === "linestrips" ? me.push(new Si) : me.push(new an));
					let be = z.data.attributes.skinIndex !== void 0,
						Be = me.length === 1 ? me[0] : me,
						Pe;
					switch (F) {
						case "lines":
							Pe = new Ns(z.data, Be);
							break;
						case "linestrips":
							Pe = new Qr(z.data, Be);
							break;
						case "triangles":
						case "polylist":
							be ? Pe = new va(z.data, Be) : Pe = new zt(z.data, Be);
							break
					}
					G.push(Pe)
				}
				return G
			}

			function En(P) {
				return at.nodes[P] !== void 0
			}

			function oi(P) {
				return m(at.nodes[P], si)
			}

			function ol(P) {
				let R = {
					name: P.getAttribute("name"),
					children: []
				};
				Or(P);
				let G = n(P, "node");
				for (let F = 0; F < G.length; F++) R.children.push(ri(G[F]));
				at.visualScenes[P.getAttribute("id")] = R
			}

			function jn(P) {
				let R = new _n;
				R.name = P.name;
				let G = P.children;
				for (let F = 0; F < G.length; F++) {
					let z = G[F];
					R.add(oi(z.id))
				}
				return R
			}

			function al(P) {
				return at.visualScenes[P] !== void 0
			}

			function dc(P) {
				return m(at.visualScenes[P], jn)
			}

			function pc(P) {
				let R = n(P, "instance_visual_scene")[0];
				return dc(a(R.getAttribute("url")))
			}

			function dy() {
				let P = at.clips;
				if (l(P) === !0) {
					if (l(at.animations) === !1) {
						let R = [];
						for (let G in at.animations) {
							let F = y(G);
							for (let z = 0, me = F.length; z < me; z++) R.push(F[z])
						}
						gc.push(new Eo("default", -1, R))
					}
				} else
					for (let R in P) gc.push(J(R))
			}

			function py(P) {
				let R = "",
					G = [P];
				for (; G.length;) {
					let F = G.shift();
					F.nodeType === Node.TEXT_NODE ? R += F.textContent : (R += `
`, G.push.apply(G, F.childNodes))
				}
				return R.trim()
			}
			if (e.length === 0) return {
				scene: new wr
			};
			let Hm = new DOMParser()
				.parseFromString(e, "application/xml"),
				gn = n(Hm, "COLLADA")[0],
				xf = Hm.getElementsByTagName("parsererror")[0];
			if (xf !== void 0) {
				let P = n(xf, "div")[0],
					R;
				return P ? R = P.textContent : R = py(xf), console.error(`THREE.ColladaLoader: Failed to parse collada file.
`, R), null
			}
			let my = gn.getAttribute("version");
			console.log("THREE.ColladaLoader: File version", my);
			let Wm = u(n(gn, "asset")[0]),
				jm = new Fi(this.manager);
			jm.setPath(this.resourcePath || t)
				.setCrossOrigin(this.crossOrigin);
			let yf;
			Ys && (yf = new Ys(this.manager), yf.setPath(this.resourcePath || t));
			let mc = new Xe,
				gc = [],
				qm = {},
				gy = 0,
				at = {
					animations: {},
					clips: {},
					controllers: {},
					images: {},
					effects: {},
					materials: {},
					cameras: {},
					lights: {},
					geometries: {},
					nodes: {},
					visualScenes: {},
					kinematicsModels: {},
					physicsModels: {},
					kinematicsScenes: {}
				};
			p(gn, "library_animations", "animation", d), p(gn, "library_animation_clips", "animation_clip", B), p(gn, "library_controllers", "controller", H), p(gn, "library_images", "image", L), p(gn, "library_effects", "effect", Q), p(gn, "library_materials", "material", X), p(gn, "library_cameras", "camera", le), p(gn, "library_lights", "light", We), p(gn, "library_geometries", "geometry", ge), p(gn, "library_nodes", "node", ri), p(gn, "library_visual_scenes", "visual_scene", ol), p(gn, "library_kinematics_models", "kinematics_model", je), p(gn, "library_physics_models", "physics_model", Me), p(gn, "scene", "instance_kinematics_scene", xt), g(at.animations, _), g(at.clips, Y), g(at.controllers, ie), g(at.images, j), g(at.effects, M), g(at.materials, te), g(at.cameras, Se), g(at.lights, Ce), g(at.geometries, Ze), g(at.visualScenes, jn), dy(), Et();
			let vc = pc(n(gn, "scene")[0]);
			return vc.animations = gc, Wm.upAxis === "Z_UP" && (console.warn("THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289."), vc.quaternion.setFromEuler(new Ln(-Math.PI / 2, 0, 0))), vc.scale.multiplyScalar(Wm.unit), {
				get animations() {
					return console.warn("THREE.ColladaLoader: Please access animations over scene.animations now."), gc
				},
				kinematics: qm,
				library: at,
				scene: vc
			}
		}
	};
	var gt = (r, e) => () => (e || (e = {
			exports: {}
		}, r(e.exports, e)), e.exports),
		Lx = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.VERSION = void 0, r.VERSION = "9.0.1"
		}),
		Ut = gt((exports, module) => {
			"use strict";
			var __spreadArray = exports && exports.__spreadArray || function(r, e) {
				for (var t = 0, n = e.length, i = r.length; t < n; t++, i++) r[i] = e[t];
				return r
			};
			Object.defineProperty(exports, "__esModule", {
				value: !0
			}), exports.toFastProperties = exports.timer = exports.peek = exports.isES2015MapSupported = exports.PRINT_WARNING = exports.PRINT_ERROR = exports.packArray = exports.IDENTITY = exports.NOOP = exports.merge = exports.groupBy = exports.defaults = exports.assignNoOverwrite = exports.assign = exports.zipObject = exports.sortBy = exports.indexOf = exports.some = exports.difference = exports.every = exports.isObject = exports.isRegExp = exports.isArray = exports.partial = exports.uniq = exports.compact = exports.reduce = exports.findAll = exports.find = exports.cloneObj = exports.cloneArr = exports.contains = exports.has = exports.pick = exports.reject = exports.filter = exports.dropRight = exports.drop = exports.isFunction = exports.isUndefined = exports.isString = exports.forEach = exports.last = exports.first = exports.flatten = exports.map = exports.mapValues = exports.values = exports.keys = exports.isEmpty = void 0;

			function isEmpty(r) {
				return r && r.length === 0
			}
			exports.isEmpty = isEmpty;

			function keys(r) {
				return r == null ? [] : Object.keys(r)
			}
			exports.keys = keys;

			function values(r) {
				for (var e = [], t = Object.keys(r), n = 0; n < t.length; n++) e.push(r[t[n]]);
				return e
			}
			exports.values = values;

			function mapValues(r, e) {
				for (var t = [], n = keys(r), i = 0; i < n.length; i++) {
					var s = n[i];
					t.push(e.call(null, r[s], s))
				}
				return t
			}
			exports.mapValues = mapValues;

			function map(r, e) {
				for (var t = [], n = 0; n < r.length; n++) t.push(e.call(null, r[n], n));
				return t
			}
			exports.map = map;

			function flatten(r) {
				for (var e = [], t = 0; t < r.length; t++) {
					var n = r[t];
					Array.isArray(n) ? e = e.concat(flatten(n)) : e.push(n)
				}
				return e
			}
			exports.flatten = flatten;

			function first(r) {
				return isEmpty(r) ? void 0 : r[0]
			}
			exports.first = first;

			function last(r) {
				var e = r && r.length;
				return e ? r[e - 1] : void 0
			}
			exports.last = last;

			function forEach(r, e) {
				if (Array.isArray(r))
					for (var t = 0; t < r.length; t++) e.call(null, r[t], t);
				else if (isObject(r))
					for (var n = keys(r), t = 0; t < n.length; t++) {
						var i = n[t],
							s = r[i];
						e.call(null, s, i)
					} else throw Error("non exhaustive match")
			}
			exports.forEach = forEach;

			function isString(r) {
				return typeof r == "string"
			}
			exports.isString = isString;

			function isUndefined(r) {
				return r === void 0
			}
			exports.isUndefined = isUndefined;

			function isFunction(r) {
				return r instanceof Function
			}
			exports.isFunction = isFunction;

			function drop(r, e) {
				return e === void 0 && (e = 1), r.slice(e, r.length)
			}
			exports.drop = drop;

			function dropRight(r, e) {
				return e === void 0 && (e = 1), r.slice(0, r.length - e)
			}
			exports.dropRight = dropRight;

			function filter(r, e) {
				var t = [];
				if (Array.isArray(r))
					for (var n = 0; n < r.length; n++) {
						var i = r[n];
						e.call(null, i) && t.push(i)
					}
				return t
			}
			exports.filter = filter;

			function reject(r, e) {
				return filter(r, function(t) {
					return !e(t)
				})
			}
			exports.reject = reject;

			function pick(r, e) {
				for (var t = Object.keys(r), n = {}, i = 0; i < t.length; i++) {
					var s = t[i],
						o = r[s];
					e(o) && (n[s] = o)
				}
				return n
			}
			exports.pick = pick;

			function has(r, e) {
				return isObject(r) ? r.hasOwnProperty(e) : !1
			}
			exports.has = has;

			function contains(r, e) {
				return find(r, function(t) {
					return t === e
				}) !== void 0
			}
			exports.contains = contains;

			function cloneArr(r) {
				for (var e = [], t = 0; t < r.length; t++) e.push(r[t]);
				return e
			}
			exports.cloneArr = cloneArr;

			function cloneObj(r) {
				var e = {};
				for (var t in r) Object.prototype.hasOwnProperty.call(r, t) && (e[t] = r[t]);
				return e
			}
			exports.cloneObj = cloneObj;

			function find(r, e) {
				for (var t = 0; t < r.length; t++) {
					var n = r[t];
					if (e.call(null, n)) return n
				}
			}
			exports.find = find;

			function findAll(r, e) {
				for (var t = [], n = 0; n < r.length; n++) {
					var i = r[n];
					e.call(null, i) && t.push(i)
				}
				return t
			}
			exports.findAll = findAll;

			function reduce(r, e, t) {
				for (var n = Array.isArray(r), i = n ? r : values(r), s = n ? [] : keys(r), o = t, a = 0; a < i.length; a++) o = e.call(null, o, i[a], n ? a : s[a]);
				return o
			}
			exports.reduce = reduce;

			function compact(r) {
				return reject(r, function(e) {
					return e == null
				})
			}
			exports.compact = compact;

			function uniq(r, e) {
				e === void 0 && (e = function(n) {
					return n
				});
				var t = [];
				return reduce(r, function(n, i) {
					var s = e(i);
					return contains(t, s) ? n : (t.push(s), n.concat(i))
				}, [])
			}
			exports.uniq = uniq;

			function partial(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				var n = [null],
					i = n.concat(e);
				return Function.bind.apply(r, i)
			}
			exports.partial = partial;

			function isArray(r) {
				return Array.isArray(r)
			}
			exports.isArray = isArray;

			function isRegExp(r) {
				return r instanceof RegExp
			}
			exports.isRegExp = isRegExp;

			function isObject(r) {
				return r instanceof Object
			}
			exports.isObject = isObject;

			function every(r, e) {
				for (var t = 0; t < r.length; t++)
					if (!e(r[t], t)) return !1;
				return !0
			}
			exports.every = every;

			function difference(r, e) {
				return reject(r, function(t) {
					return contains(e, t)
				})
			}
			exports.difference = difference;

			function some(r, e) {
				for (var t = 0; t < r.length; t++)
					if (e(r[t])) return !0;
				return !1
			}
			exports.some = some;

			function indexOf(r, e) {
				for (var t = 0; t < r.length; t++)
					if (r[t] === e) return t;
				return -1
			}
			exports.indexOf = indexOf;

			function sortBy(r, e) {
				var t = cloneArr(r);
				return t.sort(function(n, i) {
					return e(n) - e(i)
				}), t
			}
			exports.sortBy = sortBy;

			function zipObject(r, e) {
				if (r.length !== e.length) throw Error("can't zipObject with different number of keys and values!");
				for (var t = {}, n = 0; n < r.length; n++) t[r[n]] = e[n];
				return t
			}
			exports.zipObject = zipObject;

			function assign(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				for (var n = 0; n < e.length; n++)
					for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
						var a = s[o];
						r[a] = i[a]
					}
				return r
			}
			exports.assign = assign;

			function assignNoOverwrite(r) {
				for (var e = [], t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
				for (var n = 0; n < e.length; n++)
					for (var i = e[n], s = keys(i), o = 0; o < s.length; o++) {
						var a = s[o];
						has(r, a) || (r[a] = i[a])
					}
				return r
			}
			exports.assignNoOverwrite = assignNoOverwrite;

			function defaults() {
				for (var r = [], e = 0; e < arguments.length; e++) r[e] = arguments[e];
				return assignNoOverwrite.apply(void 0, __spreadArray([{}], r))
			}
			exports.defaults = defaults;

			function groupBy(r, e) {
				var t = {};
				return forEach(r, function(n) {
					var i = e(n),
						s = t[i];
					s ? s.push(n) : t[i] = [n]
				}), t
			}
			exports.groupBy = groupBy;

			function merge(r, e) {
				for (var t = cloneObj(r), n = keys(e), i = 0; i < n.length; i++) {
					var s = n[i],
						o = e[s];
					t[s] = o
				}
				return t
			}
			exports.merge = merge;

			function NOOP() {}
			exports.NOOP = NOOP;

			function IDENTITY(r) {
				return r
			}
			exports.IDENTITY = IDENTITY;

			function packArray(r) {
				for (var e = [], t = 0; t < r.length; t++) {
					var n = r[t];
					e.push(n !== void 0 ? n : void 0)
				}
				return e
			}
			exports.packArray = packArray;

			function PRINT_ERROR(r) {
				console && console.error && console.error("Error: " + r)
			}
			exports.PRINT_ERROR = PRINT_ERROR;

			function PRINT_WARNING(r) {
				console && console.warn && console.warn("Warning: " + r)
			}
			exports.PRINT_WARNING = PRINT_WARNING;

			function isES2015MapSupported() {
				return typeof Map == "function"
			}
			exports.isES2015MapSupported = isES2015MapSupported;

			function peek(r) {
				return r[r.length - 1]
			}
			exports.peek = peek;

			function timer(r) {
				var e = new Date()
					.getTime(),
					t = r(),
					n = new Date()
					.getTime(),
					i = n - e;
				return {
					time: i,
					value: t
				}
			}
			exports.timer = timer;

			function toFastProperties(toBecomeFast) {
				function FakeConstructor() {}
				FakeConstructor.prototype = toBecomeFast;
				var fakeInstance = new FakeConstructor;

				function fakeAccess() {
					return typeof fakeInstance.bar
				}
				return fakeAccess(), fakeAccess(), toBecomeFast
			}
			exports.toFastProperties = toFastProperties
		}),
		em = gt((r, e) => {
			(function(t, n) {
				typeof define == "function" && define.amd ? define([], n) : typeof e == "object" && e.exports ? e.exports = n() : t.regexpToAst = n()
			})(typeof self < "u" ? self : r, function() {
				function t() {}
				t.prototype.saveState = function() {
					return {
						idx: this.idx,
						input: this.input,
						groupIdx: this.groupIdx
					}
				}, t.prototype.restoreState = function(d) {
					this.idx = d.idx, this.input = d.input, this.groupIdx = d.groupIdx
				}, t.prototype.pattern = function(d) {
					this.idx = 0, this.input = d, this.groupIdx = 0, this.consumeChar("/");
					var v = this.disjunction();
					this.consumeChar("/");
					for (var x = {
						type: "Flags",
						loc: {
							begin: this.idx,
							end: d.length
						},
						global: !1,
						ignoreCase: !1,
						multiLine: !1,
						unicode: !1,
						sticky: !1
					}; this.isRegExpFlag();) switch (this.popChar()) {
						case "g":
							c(x, "global");
							break;
						case "i":
							c(x, "ignoreCase");
							break;
						case "m":
							c(x, "multiLine");
							break;
						case "u":
							c(x, "unicode");
							break;
						case "y":
							c(x, "sticky");
							break
					}
					if (this.idx !== this.input.length) throw Error("Redundant input: " + this.input.substring(this.idx));
					return {
						type: "Pattern",
						flags: x,
						value: v,
						loc: this.loc(0)
					}
				}, t.prototype.disjunction = function() {
					var d = [],
						v = this.idx;
					for (d.push(this.alternative()); this.peekChar() === "|";) this.consumeChar("|"), d.push(this.alternative());
					return {
						type: "Disjunction",
						value: d,
						loc: this.loc(v)
					}
				}, t.prototype.alternative = function() {
					for (var d = [], v = this.idx; this.isTerm();) d.push(this.term());
					return {
						type: "Alternative",
						value: d,
						loc: this.loc(v)
					}
				}, t.prototype.term = function() {
					return this.isAssertion() ? this.assertion() : this.atom()
				}, t.prototype.assertion = function() {
					var d = this.idx;
					switch (this.popChar()) {
						case "^":
							return {
								type: "StartAnchor",
								loc: this.loc(d)
							};
						case "$":
							return {
								type: "EndAnchor",
								loc: this.loc(d)
							};
						case "\\":
							switch (this.popChar()) {
								case "b":
									return {
										type: "WordBoundary",
										loc: this.loc(d)
									};
								case "B":
									return {
										type: "NonWordBoundary",
										loc: this.loc(d)
									}
							}
							throw Error("Invalid Assertion Escape");
						case "(":
							this.consumeChar("?");
							var v;
							switch (this.popChar()) {
								case "=":
									v = "Lookahead";
									break;
								case "!":
									v = "NegativeLookahead";
									break
							}
							l(v);
							var x = this.disjunction();
							return this.consumeChar(")"), {
								type: v,
								value: x,
								loc: this.loc(d)
							}
					}
					u()
				}, t.prototype.quantifier = function(d) {
					var v, x = this.idx;
					switch (this.popChar()) {
						case "*":
							v = {
								atLeast: 0,
								atMost: 1 / 0
							};
							break;
						case "+":
							v = {
								atLeast: 1,
								atMost: 1 / 0
							};
							break;
						case "?":
							v = {
								atLeast: 0,
								atMost: 1
							};
							break;
						case "{":
							var _ = this.integerIncludingZero();
							switch (this.popChar()) {
								case "}":
									v = {
										atLeast: _,
										atMost: _
									};
									break;
								case ",":
									var y;
									this.isDigit() ? (y = this.integerIncludingZero(), v = {
										atLeast: _,
										atMost: y
									}) : v = {
										atLeast: _,
										atMost: 1 / 0
									}, this.consumeChar("}");
									break
							}
							if (d === !0 && v === void 0) return;
							l(v);
							break
					}
					if (!(d === !0 && v === void 0)) return l(v), this.peekChar(0) === "?" ? (this.consumeChar("?"), v.greedy = !1) : v.greedy = !0, v.type = "Quantifier", v.loc = this.loc(x), v
				}, t.prototype.atom = function() {
					var d, v = this.idx;
					switch (this.peekChar()) {
						case ".":
							d = this.dotAll();
							break;
						case "\\":
							d = this.atomEscape();
							break;
						case "[":
							d = this.characterClass();
							break;
						case "(":
							d = this.group();
							break
					}
					return d === void 0 && this.isPatternCharacter() && (d = this.patternCharacter()), l(d), d.loc = this.loc(v), this.isQuantifier() && (d.quantifier = this.quantifier()), d
				}, t.prototype.dotAll = function() {
					return this.consumeChar("."), {
						type: "Set",
						complement: !0,
						value: [o(`
`), o("\r"), o("\u2028"), o("\u2029")]
					}
				}, t.prototype.atomEscape = function() {
					switch (this.consumeChar("\\"), this.peekChar()) {
						case "1":
						case "2":
						case "3":
						case "4":
						case "5":
						case "6":
						case "7":
						case "8":
						case "9":
							return this.decimalEscapeAtom();
						case "d":
						case "D":
						case "s":
						case "S":
						case "w":
						case "W":
							return this.characterClassEscape();
						case "f":
						case "n":
						case "r":
						case "t":
						case "v":
							return this.controlEscapeAtom();
						case "c":
							return this.controlLetterEscapeAtom();
						case "0":
							return this.nulCharacterAtom();
						case "x":
							return this.hexEscapeSequenceAtom();
						case "u":
							return this.regExpUnicodeEscapeSequenceAtom();
						default:
							return this.identityEscapeAtom()
					}
				}, t.prototype.decimalEscapeAtom = function() {
					var d = this.positiveInteger();
					return {
						type: "GroupBackReference",
						value: d
					}
				}, t.prototype.characterClassEscape = function() {
					var d, v = !1;
					switch (this.popChar()) {
						case "d":
							d = f;
							break;
						case "D":
							d = f, v = !0;
							break;
						case "s":
							d = g;
							break;
						case "S":
							d = g, v = !0;
							break;
						case "w":
							d = p;
							break;
						case "W":
							d = p, v = !0;
							break
					}
					return l(d), {
						type: "Set",
						value: d,
						complement: v
					}
				}, t.prototype.controlEscapeAtom = function() {
					var d;
					switch (this.popChar()) {
						case "f":
							d = o("\f");
							break;
						case "n":
							d = o(`
`);
							break;
						case "r":
							d = o("\r");
							break;
						case "t":
							d = o("	");
							break;
						case "v":
							d = o("\v");
							break
					}
					return l(d), {
						type: "Character",
						value: d
					}
				}, t.prototype.controlLetterEscapeAtom = function() {
					this.consumeChar("c");
					var d = this.popChar();
					if (/[a-zA-Z]/.test(d) === !1) throw Error("Invalid ");
					var v = d.toUpperCase()
						.charCodeAt(0) - 64;
					return {
						type: "Character",
						value: v
					}
				}, t.prototype.nulCharacterAtom = function() {
					return this.consumeChar("0"), {
						type: "Character",
						value: o("\0")
					}
				}, t.prototype.hexEscapeSequenceAtom = function() {
					return this.consumeChar("x"), this.parseHexDigits(2)
				}, t.prototype.regExpUnicodeEscapeSequenceAtom = function() {
					return this.consumeChar("u"), this.parseHexDigits(4)
				}, t.prototype.identityEscapeAtom = function() {
					var d = this.popChar();
					return {
						type: "Character",
						value: o(d)
					}
				}, t.prototype.classPatternCharacterAtom = function() {
					switch (this.peekChar()) {
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
						case "\\":
						case "]":
							throw Error("TBD");
						default:
							var d = this.popChar();
							return {
								type: "Character",
								value: o(d)
							}
					}
				}, t.prototype.characterClass = function() {
					var d = [],
						v = !1;
					for (this.consumeChar("["), this.peekChar(0) === "^" && (this.consumeChar("^"), v = !0); this.isClassAtom();) {
						var x = this.classAtom(),
							_ = x.type === "Character";
						if (_ && this.isRangeDash()) {
							this.consumeChar("-");
							var y = this.classAtom(),
								w = y.type === "Character";
							if (w) {
								if (y.value < x.value) throw Error("Range out of order in character class");
								d.push({
									from: x.value,
									to: y.value
								})
							} else a(x.value, d), d.push(o("-")), a(y.value, d)
						} else a(x.value, d)
					}
					return this.consumeChar("]"), {
						type: "Set",
						complement: v,
						value: d
					}
				}, t.prototype.classAtom = function() {
					switch (this.peekChar()) {
						case "]":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							throw Error("TBD");
						case "\\":
							return this.classEscape();
						default:
							return this.classPatternCharacterAtom()
					}
				}, t.prototype.classEscape = function() {
					switch (this.consumeChar("\\"), this.peekChar()) {
						case "b":
							return this.consumeChar("b"), {
								type: "Character",
								value: o("\b")
							};
						case "d":
						case "D":
						case "s":
						case "S":
						case "w":
						case "W":
							return this.characterClassEscape();
						case "f":
						case "n":
						case "r":
						case "t":
						case "v":
							return this.controlEscapeAtom();
						case "c":
							return this.controlLetterEscapeAtom();
						case "0":
							return this.nulCharacterAtom();
						case "x":
							return this.hexEscapeSequenceAtom();
						case "u":
							return this.regExpUnicodeEscapeSequenceAtom();
						default:
							return this.identityEscapeAtom()
					}
				}, t.prototype.group = function() {
					var d = !0;
					switch (this.consumeChar("("), this.peekChar(0)) {
						case "?":
							this.consumeChar("?"), this.consumeChar(":"), d = !1;
							break;
						default:
							this.groupIdx++;
							break
					}
					var v = this.disjunction();
					this.consumeChar(")");
					var x = {
						type: "Group",
						capturing: d,
						value: v
					};
					return d && (x.idx = this.groupIdx), x
				}, t.prototype.positiveInteger = function() {
					var d = this.popChar();
					if (s.test(d) === !1) throw Error("Expecting a positive integer");
					for (; i.test(this.peekChar(0));) d += this.popChar();
					return parseInt(d, 10)
				}, t.prototype.integerIncludingZero = function() {
					var d = this.popChar();
					if (i.test(d) === !1) throw Error("Expecting an integer");
					for (; i.test(this.peekChar(0));) d += this.popChar();
					return parseInt(d, 10)
				}, t.prototype.patternCharacter = function() {
					var d = this.popChar();
					switch (d) {
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
						case "^":
						case "$":
						case "\\":
						case ".":
						case "*":
						case "+":
						case "?":
						case "(":
						case ")":
						case "[":
						case "|":
							throw Error("TBD");
						default:
							return {
								type: "Character",
								value: o(d)
							}
					}
				}, t.prototype.isRegExpFlag = function() {
					switch (this.peekChar(0)) {
						case "g":
						case "i":
						case "m":
						case "u":
						case "y":
							return !0;
						default:
							return !1
					}
				}, t.prototype.isRangeDash = function() {
					return this.peekChar() === "-" && this.isClassAtom(1)
				}, t.prototype.isDigit = function() {
					return i.test(this.peekChar(0))
				}, t.prototype.isClassAtom = function(d) {
					switch (d === void 0 && (d = 0), this.peekChar(d)) {
						case "]":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							return !1;
						default:
							return !0
					}
				}, t.prototype.isTerm = function() {
					return this.isAtom() || this.isAssertion()
				}, t.prototype.isAtom = function() {
					if (this.isPatternCharacter()) return !0;
					switch (this.peekChar(0)) {
						case ".":
						case "\\":
						case "[":
						case "(":
							return !0;
						default:
							return !1
					}
				}, t.prototype.isAssertion = function() {
					switch (this.peekChar(0)) {
						case "^":
						case "$":
							return !0;
						case "\\":
							switch (this.peekChar(1)) {
								case "b":
								case "B":
									return !0;
								default:
									return !1
							}
						case "(":
							return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
						default:
							return !1
					}
				}, t.prototype.isQuantifier = function() {
					var d = this.saveState();
					try {
						return this.quantifier(!0) !== void 0
					} catch {
						return !1
					} finally {
						this.restoreState(d)
					}
				}, t.prototype.isPatternCharacter = function() {
					switch (this.peekChar()) {
						case "^":
						case "$":
						case "\\":
						case ".":
						case "*":
						case "+":
						case "?":
						case "(":
						case ")":
						case "[":
						case "|":
						case "/":
						case `
`:
						case "\r":
						case "\u2028":
						case "\u2029":
							return !1;
						default:
							return !0
					}
				}, t.prototype.parseHexDigits = function(d) {
					for (var v = "", x = 0; x < d; x++) {
						var _ = this.popChar();
						if (n.test(_) === !1) throw Error("Expecting a HexDecimal digits");
						v += _
					}
					var y = parseInt(v, 16);
					return {
						type: "Character",
						value: y
					}
				}, t.prototype.peekChar = function(d) {
					return d === void 0 && (d = 0), this.input[this.idx + d]
				}, t.prototype.popChar = function() {
					var d = this.peekChar(0);
					return this.consumeChar(), d
				}, t.prototype.consumeChar = function(d) {
					if (d !== void 0 && this.input[this.idx] !== d) throw Error("Expected: '" + d + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
					if (this.idx >= this.input.length) throw Error("Unexpected end of input");
					this.idx++
				}, t.prototype.loc = function(d) {
					return {
						begin: d,
						end: this.idx
					}
				};
				var n = /[0-9a-fA-F]/,
					i = /[0-9]/,
					s = /[1-9]/;

				function o(d) {
					return d.charCodeAt(0)
				}

				function a(d, v) {
					d.length !== void 0 ? d.forEach(function(x) {
						v.push(x)
					}) : v.push(d)
				}

				function c(d, v) {
					if (d[v] === !0) throw "duplicate flag " + v;
					d[v] = !0
				}

				function l(d) {
					if (d === void 0) throw Error("Internal Error - Should never get here!")
				}

				function u() {
					throw Error("Internal Error - Should never get here!")
				}
				var h, f = [];
				for (h = o("0"); h <= o("9"); h++) f.push(h);
				var p = [o("_")].concat(f);
				for (h = o("a"); h <= o("z"); h++) p.push(h);
				for (h = o("A"); h <= o("Z"); h++) p.push(h);
				var g = [o(" "), o("\f"), o(`
`), o("\r"), o("	"), o("\v"), o("	"), o("\xA0"), o("\u1680"), o("\u2000"), o("\u2001"), o("\u2002"), o("\u2003"), o("\u2004"), o("\u2005"), o("\u2006"), o("\u2007"), o("\u2008"), o("\u2009"), o("\u200A"), o("\u2028"), o("\u2029"), o("\u202F"), o("\u205F"), o("\u3000"), o("\uFEFF")];

				function m() {}
				return m.prototype.visitChildren = function(d) {
					for (var v in d) {
						var x = d[v];
						d.hasOwnProperty(v) && (x.type !== void 0 ? this.visit(x) : Array.isArray(x) && x.forEach(function(_) {
							this.visit(_)
						}, this))
					}
				}, m.prototype.visit = function(d) {
					switch (d.type) {
						case "Pattern":
							this.visitPattern(d);
							break;
						case "Flags":
							this.visitFlags(d);
							break;
						case "Disjunction":
							this.visitDisjunction(d);
							break;
						case "Alternative":
							this.visitAlternative(d);
							break;
						case "StartAnchor":
							this.visitStartAnchor(d);
							break;
						case "EndAnchor":
							this.visitEndAnchor(d);
							break;
						case "WordBoundary":
							this.visitWordBoundary(d);
							break;
						case "NonWordBoundary":
							this.visitNonWordBoundary(d);
							break;
						case "Lookahead":
							this.visitLookahead(d);
							break;
						case "NegativeLookahead":
							this.visitNegativeLookahead(d);
							break;
						case "Character":
							this.visitCharacter(d);
							break;
						case "Set":
							this.visitSet(d);
							break;
						case "Group":
							this.visitGroup(d);
							break;
						case "GroupBackReference":
							this.visitGroupBackReference(d);
							break;
						case "Quantifier":
							this.visitQuantifier(d);
							break
					}
					this.visitChildren(d)
				}, m.prototype.visitPattern = function(d) {}, m.prototype.visitFlags = function(d) {}, m.prototype.visitDisjunction = function(d) {}, m.prototype.visitAlternative = function(d) {}, m.prototype.visitStartAnchor = function(d) {}, m.prototype.visitEndAnchor = function(d) {}, m.prototype.visitWordBoundary = function(d) {}, m.prototype.visitNonWordBoundary = function(d) {}, m.prototype.visitLookahead = function(d) {}, m.prototype.visitNegativeLookahead = function(d) {}, m.prototype.visitCharacter = function(d) {}, m.prototype.visitSet = function(d) {}, m.prototype.visitGroup = function(d) {}, m.prototype.visitGroupBackReference = function(d) {}, m.prototype.visitQuantifier = function(d) {}, {
					RegExpParser: t,
					BaseRegExpVisitor: m,
					VERSION: "0.5.0"
				}
			})
		}),
		tm = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.clearRegExpParserCache = r.getRegExpAst = void 0;
			var e = em(),
				t = {},
				n = new e.RegExpParser;

			function i(o) {
				var a = o.toString();
				if (t.hasOwnProperty(a)) return t[a];
				var c = n.pattern(a);
				return t[a] = c, c
			}
			r.getRegExpAst = i;

			function s() {
				t = {}
			}
			r.clearRegExpParserCache = s
		}),
		CE = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var m = function(d, v) {
					return m = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(x, _) {
						x.__proto__ = _
					} || function(x, _) {
						for (var y in _) Object.prototype.hasOwnProperty.call(_, y) && (x[y] = _[y])
					}, m(d, v)
				};
				return function(d, v) {
					if (typeof v != "function" && v !== null) throw new TypeError("Class extends value " + String(v) + " is not a constructor or null");
					m(d, v);

					function x() {
						this.constructor = d
					}
					d.prototype = v === null ? Object.create(v) : (x.prototype = v.prototype, new x)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.canMatchCharCode = r.firstCharOptimizedIndices = r.getOptimizedStartCodesIndices = r.failedOptimizationPrefixMsg = void 0;
			var t = em(),
				n = Ut(),
				i = tm(),
				s = Nx(),
				o = "Complement Sets are not supported for first char optimization";
			r.failedOptimizationPrefixMsg = `Unable to use "first char" lexer optimizations:
`;

			function a(m, d) {
				d === void 0 && (d = !1);
				try {
					var v = i.getRegExpAst(m),
						x = c(v.value, {}, v.flags.ignoreCase);
					return x
				} catch (y) {
					if (y.message === o) d && n.PRINT_WARNING("" + r.failedOptimizationPrefixMsg + ("	Unable to optimize: < " + m.toString() + ` >
`) + `	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
					else {
						var _ = "";
						d && (_ = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`), n.PRINT_ERROR(r.failedOptimizationPrefixMsg + `
` + ("	Failed parsing: < " + m.toString() + ` >
`) + ("	Using the regexp-to-ast library version: " + t.VERSION + `
`) + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + _)
					}
				}
				return []
			}
			r.getOptimizedStartCodesIndices = a;

			function c(m, d, v) {
				switch (m.type) {
					case "Disjunction":
						for (var x = 0; x < m.value.length; x++) c(m.value[x], d, v);
						break;
					case "Alternative":
						for (var _ = m.value, x = 0; x < _.length; x++) {
							var y = _[x];
							switch (y.type) {
								case "EndAnchor":
								case "GroupBackReference":
								case "Lookahead":
								case "NegativeLookahead":
								case "StartAnchor":
								case "WordBoundary":
								case "NonWordBoundary":
									continue
							}
							var w = y;
							switch (w.type) {
								case "Character":
									l(w.value, d, v);
									break;
								case "Set":
									if (w.complement === !0) throw Error(o);
									n.forEach(w.value, function(b) {
										if (typeof b == "number") l(b, d, v);
										else {
											var T = b;
											if (v === !0)
												for (var N = T.from; N <= T.to; N++) l(N, d, v);
											else {
												for (var N = T.from; N <= T.to && N < s.minOptimizationVal; N++) l(N, d, v);
												if (T.to >= s.minOptimizationVal)
													for (var V = T.from >= s.minOptimizationVal ? T.from : s.minOptimizationVal, O = T.to, k = s.charCodeToOptimizedIndex(V), I = s.charCodeToOptimizedIndex(O), q = k; q <= I; q++) d[q] = q
											}
										}
									});
									break;
								case "Group":
									c(w.value, d, v);
									break;
								default:
									throw Error("Non Exhaustive Match")
							}
							var C = w.quantifier !== void 0 && w.quantifier.atLeast === 0;
							if (w.type === "Group" && f(w) === !1 || w.type !== "Group" && C === !1) break
						}
						break;
					default:
						throw Error("non exhaustive match!")
				}
				return n.values(d)
			}
			r.firstCharOptimizedIndices = c;

			function l(m, d, v) {
				var x = s.charCodeToOptimizedIndex(m);
				d[x] = x, v === !0 && u(m, d)
			}

			function u(m, d) {
				var v = String.fromCharCode(m),
					x = v.toUpperCase();
				if (x !== v) {
					var _ = s.charCodeToOptimizedIndex(x.charCodeAt(0));
					d[_] = _
				} else {
					var y = v.toLowerCase();
					if (y !== v) {
						var _ = s.charCodeToOptimizedIndex(y.charCodeAt(0));
						d[_] = _
					}
				}
			}

			function h(m, d) {
				return n.find(m.value, function(v) {
					if (typeof v == "number") return n.contains(d, v);
					var x = v;
					return n.find(d, function(_) {
						return x.from <= _ && _ <= x.to
					}) !== void 0
				})
			}

			function f(m) {
				return m.quantifier && m.quantifier.atLeast === 0 ? !0 : m.value ? n.isArray(m.value) ? n.every(m.value, f) : f(m.value) : !1
			}
			var p = function(m) {
				e(d, m);

				function d(v) {
					var x = m.call(this) || this;
					return x.targetCharCodes = v, x.found = !1, x
				}
				return d.prototype.visitChildren = function(v) {
					if (this.found !== !0) {
						switch (v.type) {
							case "Lookahead":
								this.visitLookahead(v);
								return;
							case "NegativeLookahead":
								this.visitNegativeLookahead(v);
								return
						}
						m.prototype.visitChildren.call(this, v)
					}
				}, d.prototype.visitCharacter = function(v) {
					n.contains(this.targetCharCodes, v.value) && (this.found = !0)
				}, d.prototype.visitSet = function(v) {
					v.complement ? h(v, this.targetCharCodes) === void 0 && (this.found = !0) : h(v, this.targetCharCodes) !== void 0 && (this.found = !0)
				}, d
			}(t.BaseRegExpVisitor);

			function g(m, d) {
				if (d instanceof RegExp) {
					var v = i.getRegExpAst(d),
						x = new p(m);
					return x.visit(v), x.found
				} else return n.find(d, function(_) {
					return n.contains(m, _.charCodeAt(0))
				}) !== void 0
			}
			r.canMatchCharCode = g
		}),
		Nx = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var A = function(L, j) {
					return A = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(K, Q) {
						K.__proto__ = Q
					} || function(K, Q) {
						for (var se in Q) Object.prototype.hasOwnProperty.call(Q, se) && (K[se] = Q[se])
					}, A(L, j)
				};
				return function(L, j) {
					if (typeof j != "function" && j !== null) throw new TypeError("Class extends value " + String(j) + " is not a constructor or null");
					A(L, j);

					function K() {
						this.constructor = L
					}
					L.prototype = j === null ? Object.create(j) : (K.prototype = j.prototype, new K)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.charCodeToOptimizedIndex = r.minOptimizationVal = r.buildLineBreakIssueMessage = r.LineTerminatorOptimizedTester = r.isShortPattern = r.isCustomPattern = r.cloneEmptyGroups = r.performWarningRuntimeChecks = r.performRuntimeChecks = r.addStickyFlag = r.addStartOfInput = r.findUnreachablePatterns = r.findModesThatDoNotExist = r.findInvalidGroupType = r.findDuplicatePatterns = r.findUnsupportedFlags = r.findStartOfInputAnchor = r.findEmptyMatchRegExps = r.findEndOfInputAnchor = r.findInvalidPatterns = r.findMissingPatterns = r.validatePatterns = r.analyzeTokenTypes = r.enableSticky = r.disableSticky = r.SUPPORT_STICKY = r.MODES = r.DEFAULT_MODE = void 0;
			var t = em(),
				n = bh(),
				i = Ut(),
				s = CE(),
				o = tm(),
				a = "PATTERN";
			r.DEFAULT_MODE = "defaultMode", r.MODES = "modes", r.SUPPORT_STICKY = typeof new RegExp("(?:)")
				.sticky == "boolean";

			function c() {
				r.SUPPORT_STICKY = !1
			}
			r.disableSticky = c;

			function l() {
				r.SUPPORT_STICKY = !0
			}
			r.enableSticky = l;

			function u(A, L) {
				L = i.defaults(L, {
					useSticky: r.SUPPORT_STICKY,
					debug: !1,
					safeMode: !1,
					positionTracking: "full",
					lineTerminatorCharacters: ["\r", `
`],
					tracer: function(M, D) {
						return D()
					}
				});
				var j = L.tracer;
				j("initCharCodeToOptimizedIndexMap", function() {
					U()
				});
				var K;
				j("Reject Lexer.NA", function() {
					K = i.reject(A, function(M) {
						return M[a] === n.Lexer.NA
					})
				});
				var Q = !1,
					se;
				j("Transform Patterns", function() {
					Q = !1, se = i.map(K, function(M) {
						var D = M[a];
						if (i.isRegExp(D)) {
							var X = D.source;
							return X.length === 1 && X !== "^" && X !== "$" && X !== "." && !D.ignoreCase ? X : X.length === 2 && X[0] === "\\" && !i.contains(["d", "D", "s", "S", "t", "r", "n", "t", "0", "c", "b", "B", "f", "v", "w", "W"], X[1]) ? X[1] : L.useSticky ? O(D) : V(D)
						} else {
							if (i.isFunction(D)) return Q = !0, {
								exec: D
							};
							if (i.has(D, "exec")) return Q = !0, D;
							if (typeof D == "string") {
								if (D.length === 1) return D;
								var W = D.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"),
									te = new RegExp(W);
								return L.useSticky ? O(te) : V(te)
							} else throw Error("non exhaustive match")
						}
					})
				});
				var de, ue, xe, Ee, De;
				j("misc mapping", function() {
					de = i.map(K, function(M) {
						return M.tokenTypeIdx
					}), ue = i.map(K, function(M) {
						var D = M.GROUP;
						if (D !== n.Lexer.SKIPPED) {
							if (i.isString(D)) return D;
							if (i.isUndefined(D)) return !1;
							throw Error("non exhaustive match")
						}
					}), xe = i.map(K, function(M) {
						var D = M.LONGER_ALT;
						if (D) {
							var X = i.indexOf(K, D);
							return X
						}
					}), Ee = i.map(K, function(M) {
						return M.PUSH_MODE
					}), De = i.map(K, function(M) {
						return i.has(M, "POP_MODE")
					})
				});
				var ht;
				j("Line Terminator Handling", function() {
					var M = $(L.lineTerminatorCharacters);
					ht = i.map(K, function(D) {
						return !1
					}), L.positionTracking !== "onlyOffset" && (ht = i.map(K, function(D) {
						if (i.has(D, "LINE_BREAKS")) return D.LINE_BREAKS;
						if (J(D, M) === !1) return s.canMatchCharCode(M, D.PATTERN)
					}))
				});
				var ct, He, Ve, ot;
				j("Misc Mapping #2", function() {
					ct = i.map(K, B), He = i.map(se, Y), Ve = i.reduce(K, function(M, D) {
						var X = D.GROUP;
						return i.isString(X) && X !== n.Lexer.SKIPPED && (M[X] = []), M
					}, {}), ot = i.map(se, function(M, D) {
						return {
							pattern: se[D],
							longerAlt: xe[D],
							canLineTerminator: ht[D],
							isCustom: ct[D],
							short: He[D],
							group: ue[D],
							push: Ee[D],
							pop: De[D],
							tokenTypeIdx: de[D],
							tokenType: K[D]
						}
					})
				});
				var it = !0,
					E = [];
				return L.safeMode || j("First Char Optimization", function() {
					E = i.reduce(K, function(M, D, X) {
						if (typeof D.PATTERN == "string") {
							var W = D.PATTERN.charCodeAt(0),
								te = ie(W);
							ae(M, te, ot[X])
						} else if (i.isArray(D.START_CHARS_HINT)) {
							var ce;
							i.forEach(D.START_CHARS_HINT, function(ee) {
								var pe = typeof ee == "string" ? ee.charCodeAt(0) : ee,
									ve = ie(pe);
								ce !== ve && (ce = ve, ae(M, ve, ot[X]))
							})
						} else if (i.isRegExp(D.PATTERN))
							if (D.PATTERN.unicode) it = !1, L.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	Unable to analyze < " + D.PATTERN.toString() + ` > pattern.
`) + `	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`);
							else {
								var le = s.getOptimizedStartCodesIndices(D.PATTERN, L.ensureOptimizations);
								i.isEmpty(le) && (it = !1), i.forEach(le, function(ee) {
									ae(M, ee, ot[X])
								})
							}
						else L.ensureOptimizations && i.PRINT_ERROR("" + s.failedOptimizationPrefixMsg + ("	TokenType: <" + D.name + `> is using a custom token pattern without providing <start_chars_hint> parameter.
`) + `	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`), it = !1;
						return M
					}, [])
				}), j("ArrayPacking", function() {
					E = i.packArray(E)
				}), {
					emptyGroups: Ve,
					patternIdxToConfig: ot,
					charCodeToPatternIdxToConfig: E,
					hasCustom: Q,
					canBeOptimized: it
				}
			}
			r.analyzeTokenTypes = u;

			function h(A, L) {
				var j = [],
					K = p(A);
				j = j.concat(K.errors);
				var Q = g(K.valid),
					se = Q.valid;
				return j = j.concat(Q.errors), j = j.concat(f(se)), j = j.concat(C(se)), j = j.concat(S(se, L)), j = j.concat(b(se)), j
			}
			r.validatePatterns = h;

			function f(A) {
				var L = [],
					j = i.filter(A, function(K) {
						return i.isRegExp(K[a])
					});
				return L = L.concat(d(j)), L = L.concat(_(j)), L = L.concat(y(j)), L = L.concat(w(j)), L = L.concat(v(j)), L
			}

			function p(A) {
				var L = i.filter(A, function(Q) {
						return !i.has(Q, a)
					}),
					j = i.map(L, function(Q) {
						return {
							message: "Token Type: ->" + Q.name + "<- missing static 'PATTERN' property",
							type: n.LexerDefinitionErrorType.MISSING_PATTERN,
							tokenTypes: [Q]
						}
					}),
					K = i.difference(A, L);
				return {
					errors: j,
					valid: K
				}
			}
			r.findMissingPatterns = p;

			function g(A) {
				var L = i.filter(A, function(Q) {
						var se = Q[a];
						return !i.isRegExp(se) && !i.isFunction(se) && !i.has(se, "exec") && !i.isString(se)
					}),
					j = i.map(L, function(Q) {
						return {
							message: "Token Type: ->" + Q.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
							type: n.LexerDefinitionErrorType.INVALID_PATTERN,
							tokenTypes: [Q]
						}
					}),
					K = i.difference(A, L);
				return {
					errors: j,
					valid: K
				}
			}
			r.findInvalidPatterns = g;
			var m = /[^\\][\$]/;

			function d(A) {
				var L = function(Q) {
						e(se, Q);

						function se() {
							var de = Q !== null && Q.apply(this, arguments) || this;
							return de.found = !1, de
						}
						return se.prototype.visitEndAnchor = function(de) {
							this.found = !0
						}, se
					}(t.BaseRegExpVisitor),
					j = i.filter(A, function(Q) {
						var se = Q[a];
						try {
							var de = o.getRegExpAst(se),
								ue = new L;
							return ue.visit(de), ue.found
						} catch {
							return m.test(se.source)
						}
					}),
					K = i.map(j, function(Q) {
						return {
							message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + Q.name + `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
							type: n.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
							tokenTypes: [Q]
						}
					});
				return K
			}
			r.findEndOfInputAnchor = d;

			function v(A) {
				var L = i.filter(A, function(K) {
						var Q = K[a];
						return Q.test("")
					}),
					j = i.map(L, function(K) {
						return {
							message: "Token Type: ->" + K.name + "<- static 'PATTERN' must not match an empty string",
							type: n.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
							tokenTypes: [K]
						}
					});
				return j
			}
			r.findEmptyMatchRegExps = v;
			var x = /[^\\[][\^]|^\^/;

			function _(A) {
				var L = function(Q) {
						e(se, Q);

						function se() {
							var de = Q !== null && Q.apply(this, arguments) || this;
							return de.found = !1, de
						}
						return se.prototype.visitStartAnchor = function(de) {
							this.found = !0
						}, se
					}(t.BaseRegExpVisitor),
					j = i.filter(A, function(Q) {
						var se = Q[a];
						try {
							var de = o.getRegExpAst(se),
								ue = new L;
							return ue.visit(de), ue.found
						} catch {
							return x.test(se.source)
						}
					}),
					K = i.map(j, function(Q) {
						return {
							message: `Unexpected RegExp Anchor Error:
	Token Type: ->` + Q.name + `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
							type: n.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
							tokenTypes: [Q]
						}
					});
				return K
			}
			r.findStartOfInputAnchor = _;

			function y(A) {
				var L = i.filter(A, function(K) {
						var Q = K[a];
						return Q instanceof RegExp && (Q.multiline || Q.global)
					}),
					j = i.map(L, function(K) {
						return {
							message: "Token Type: ->" + K.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
							type: n.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
							tokenTypes: [K]
						}
					});
				return j
			}
			r.findUnsupportedFlags = y;

			function w(A) {
				var L = [],
					j = i.map(A, function(se) {
						return i.reduce(A, function(de, ue) {
							return se.PATTERN.source === ue.PATTERN.source && !i.contains(L, ue) && ue.PATTERN !== n.Lexer.NA && (L.push(ue), de.push(ue)), de
						}, [])
					});
				j = i.compact(j);
				var K = i.filter(j, function(se) {
						return se.length > 1
					}),
					Q = i.map(K, function(se) {
						var de = i.map(se, function(xe) {
								return xe.name
							}),
							ue = i.first(se)
							.PATTERN;
						return {
							message: "The same RegExp pattern ->" + ue + "<-" + ("has been used in all of the following Token Types: " + de.join(", ") + " <-"),
							type: n.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
							tokenTypes: se
						}
					});
				return Q
			}
			r.findDuplicatePatterns = w;

			function C(A) {
				var L = i.filter(A, function(K) {
						if (!i.has(K, "GROUP")) return !1;
						var Q = K.GROUP;
						return Q !== n.Lexer.SKIPPED && Q !== n.Lexer.NA && !i.isString(Q)
					}),
					j = i.map(L, function(K) {
						return {
							message: "Token Type: ->" + K.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
							type: n.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
							tokenTypes: [K]
						}
					});
				return j
			}
			r.findInvalidGroupType = C;

			function S(A, L) {
				var j = i.filter(A, function(Q) {
						return Q.PUSH_MODE !== void 0 && !i.contains(L, Q.PUSH_MODE)
					}),
					K = i.map(j, function(Q) {
						var se = "Token Type: ->" + Q.name + "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->" + Q.PUSH_MODE + "<-which does not exist";
						return {
							message: se,
							type: n.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
							tokenTypes: [Q]
						}
					});
				return K
			}
			r.findModesThatDoNotExist = S;

			function b(A) {
				var L = [],
					j = i.reduce(A, function(K, Q, se) {
						var de = Q.PATTERN;
						return de === n.Lexer.NA || (i.isString(de) ? K.push({
							str: de,
							idx: se,
							tokenType: Q
						}) : i.isRegExp(de) && N(de) && K.push({
							str: de.source,
							idx: se,
							tokenType: Q
						})), K
					}, []);
				return i.forEach(A, function(K, Q) {
					i.forEach(j, function(se) {
						var de = se.str,
							ue = se.idx,
							xe = se.tokenType;
						if (Q < ue && T(de, K.PATTERN)) {
							var Ee = "Token: ->" + xe.name + `<- can never be matched.
` + ("Because it appears AFTER the Token Type ->" + K.name + "<-") + `in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
							L.push({
								message: Ee,
								type: n.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
								tokenTypes: [K, xe]
							})
						}
					})
				}), L
			}
			r.findUnreachablePatterns = b;

			function T(A, L) {
				if (i.isRegExp(L)) {
					var j = L.exec(A);
					return j !== null && j.index === 0
				} else {
					if (i.isFunction(L)) return L(A, 0, [], {});
					if (i.has(L, "exec")) return L.exec(A, 0, [], {});
					if (typeof L == "string") return L === A;
					throw Error("non exhaustive match")
				}
			}

			function N(A) {
				var L = [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"];
				return i.find(L, function(j) {
					return A.source.indexOf(j) !== -1
				}) === void 0
			}

			function V(A) {
				var L = A.ignoreCase ? "i" : "";
				return new RegExp("^(?:" + A.source + ")", L)
			}
			r.addStartOfInput = V;

			function O(A) {
				var L = A.ignoreCase ? "iy" : "y";
				return new RegExp("" + A.source, L)
			}
			r.addStickyFlag = O;

			function k(A, L, j) {
				var K = [];
				return i.has(A, r.DEFAULT_MODE) || K.push({
					message: "A MultiMode Lexer cannot be initialized without a <" + r.DEFAULT_MODE + `> property in its definition
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
				}), i.has(A, r.MODES) || K.push({
					message: "A MultiMode Lexer cannot be initialized without a <" + r.MODES + `> property in its definition
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
				}), i.has(A, r.MODES) && i.has(A, r.DEFAULT_MODE) && !i.has(A.modes, A.defaultMode) && K.push({
					message: "A MultiMode Lexer cannot be initialized with a " + r.DEFAULT_MODE + ": <" + A.defaultMode + `>which does not exist
`,
					type: n.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
				}), i.has(A, r.MODES) && i.forEach(A.modes, function(Q, se) {
					i.forEach(Q, function(de, ue) {
						i.isUndefined(de) && K.push({
							message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + ("<" + se + "> at index: <" + ue + `>
`),
							type: n.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
						})
					})
				}), K
			}
			r.performRuntimeChecks = k;

			function I(A, L, j) {
				var K = [],
					Q = !1,
					se = i.compact(i.flatten(i.mapValues(A.modes, function(xe) {
						return xe
					}))),
					de = i.reject(se, function(xe) {
						return xe[a] === n.Lexer.NA
					}),
					ue = $(j);
				return L && i.forEach(de, function(xe) {
					var Ee = J(xe, ue);
					if (Ee !== !1) {
						var De = H(xe, Ee),
							ht = {
								message: De,
								type: Ee.issue,
								tokenType: xe
							};
						K.push(ht)
					} else i.has(xe, "LINE_BREAKS") ? xe.LINE_BREAKS === !0 && (Q = !0) : s.canMatchCharCode(ue, xe.PATTERN) && (Q = !0)
				}), L && !Q && K.push({
					message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS
	for details.`,
					type: n.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
				}), K
			}
			r.performWarningRuntimeChecks = I;

			function q(A) {
				var L = {},
					j = i.keys(A);
				return i.forEach(j, function(K) {
					var Q = A[K];
					if (i.isArray(Q)) L[K] = [];
					else throw Error("non exhaustive match")
				}), L
			}
			r.cloneEmptyGroups = q;

			function B(A) {
				var L = A.PATTERN;
				if (i.isRegExp(L)) return !1;
				if (i.isFunction(L) || i.has(L, "exec")) return !0;
				if (i.isString(L)) return !1;
				throw Error("non exhaustive match")
			}
			r.isCustomPattern = B;

			function Y(A) {
				return i.isString(A) && A.length === 1 ? A.charCodeAt(0) : !1
			}
			r.isShortPattern = Y, r.LineTerminatorOptimizedTester = {
				test: function(A) {
					for (var L = A.length, j = this.lastIndex; j < L; j++) {
						var K = A.charCodeAt(j);
						if (K === 10) return this.lastIndex = j + 1, !0;
						if (K === 13) return A.charCodeAt(j + 1) === 10 ? this.lastIndex = j + 2 : this.lastIndex = j + 1, !0
					}
					return !1
				},
				lastIndex: 0
			};

			function J(A, L) {
				if (i.has(A, "LINE_BREAKS")) return !1;
				if (i.isRegExp(A.PATTERN)) {
					try {
						s.canMatchCharCode(L, A.PATTERN)
					} catch (j) {
						return {
							issue: n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
							errMsg: j.message
						}
					}
					return !1
				} else {
					if (i.isString(A.PATTERN)) return !1;
					if (B(A)) return {
						issue: n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK
					};
					throw Error("non exhaustive match")
				}
			}

			function H(A, L) {
				if (L.issue === n.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) return `Warning: unable to identify line terminator usage in pattern.
` + ("	The problem is in the <" + A.name + `> Token Type
`) + ("	 Root cause: " + L.errMsg + `.
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
				if (L.issue === n.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
` + ("	The problem is in the <" + A.name + `> Token Type
`) + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
				throw Error("non exhaustive match")
			}
			r.buildLineBreakIssueMessage = H;

			function $(A) {
				var L = i.map(A, function(j) {
					return i.isString(j) && j.length > 0 ? j.charCodeAt(0) : j
				});
				return L
			}

			function ae(A, L, j) {
				A[L] === void 0 ? A[L] = [j] : A[L].push(j)
			}
			r.minOptimizationVal = 256;
			var oe = [];

			function ie(A) {
				return A < r.minOptimizationVal ? A : oe[A]
			}
			r.charCodeToOptimizedIndex = ie;

			function U() {
				if (i.isEmpty(oe)) {
					oe = new Array(65536);
					for (var A = 0; A < 65536; A++) oe[A] = A > 255 ? 255 + ~~(A / 255) : A
				}
			}
		}),
		tc = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.isTokenType = r.hasExtendingTokensTypesMapProperty = r.hasExtendingTokensTypesProperty = r.hasCategoriesProperty = r.hasShortKeyProperty = r.singleAssignCategoriesToksMap = r.assignCategoriesMapProp = r.assignCategoriesTokensProp = r.assignTokenDefaultProps = r.expandCategories = r.augmentTokenTypes = r.tokenIdxToClass = r.tokenShortNameIdx = r.tokenStructuredMatcherNoCategories = r.tokenStructuredMatcher = void 0;
			var e = Ut();

			function t(m, d) {
				var v = m.tokenTypeIdx;
				return v === d.tokenTypeIdx ? !0 : d.isParent === !0 && d.categoryMatchesMap[v] === !0
			}
			r.tokenStructuredMatcher = t;

			function n(m, d) {
				return m.tokenTypeIdx === d.tokenTypeIdx
			}
			r.tokenStructuredMatcherNoCategories = n, r.tokenShortNameIdx = 1, r.tokenIdxToClass = {};

			function i(m) {
				var d = s(m);
				o(d), c(d), a(d), e.forEach(d, function(v) {
					v.isParent = v.categoryMatches.length > 0
				})
			}
			r.augmentTokenTypes = i;

			function s(m) {
				for (var d = e.cloneArr(m), v = m, x = !0; x;) {
					v = e.compact(e.flatten(e.map(v, function(y) {
						return y.CATEGORIES
					})));
					var _ = e.difference(v, d);
					d = d.concat(_), e.isEmpty(_) ? x = !1 : v = _
				}
				return d
			}
			r.expandCategories = s;

			function o(m) {
				e.forEach(m, function(d) {
					u(d) || (r.tokenIdxToClass[r.tokenShortNameIdx] = d, d.tokenTypeIdx = r.tokenShortNameIdx++), h(d) && !e.isArray(d.CATEGORIES) && (d.CATEGORIES = [d.CATEGORIES]), h(d) || (d.CATEGORIES = []), f(d) || (d.categoryMatches = []), p(d) || (d.categoryMatchesMap = {})
				})
			}
			r.assignTokenDefaultProps = o;

			function a(m) {
				e.forEach(m, function(d) {
					d.categoryMatches = [], e.forEach(d.categoryMatchesMap, function(v, x) {
						d.categoryMatches.push(r.tokenIdxToClass[x].tokenTypeIdx)
					})
				})
			}
			r.assignCategoriesTokensProp = a;

			function c(m) {
				e.forEach(m, function(d) {
					l([], d)
				})
			}
			r.assignCategoriesMapProp = c;

			function l(m, d) {
				e.forEach(m, function(v) {
					d.categoryMatchesMap[v.tokenTypeIdx] = !0
				}), e.forEach(d.CATEGORIES, function(v) {
					var x = m.concat(d);
					e.contains(x, v) || l(x, v)
				})
			}
			r.singleAssignCategoriesToksMap = l;

			function u(m) {
				return e.has(m, "tokenTypeIdx")
			}
			r.hasShortKeyProperty = u;

			function h(m) {
				return e.has(m, "CATEGORIES")
			}
			r.hasCategoriesProperty = h;

			function f(m) {
				return e.has(m, "categoryMatches")
			}
			r.hasExtendingTokensTypesProperty = f;

			function p(m) {
				return e.has(m, "categoryMatchesMap")
			}
			r.hasExtendingTokensTypesMapProperty = p;

			function g(m) {
				return e.has(m, "tokenTypeIdx")
			}
			r.isTokenType = g
		}),
		Dx = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defaultLexerErrorProvider = void 0, r.defaultLexerErrorProvider = {
				buildUnableToPopLexerModeMessage: function(e) {
					return "Unable to pop Lexer Mode after encountering Token ->" + e.image + "<- The Mode Stack is empty"
				},
				buildUnexpectedCharactersMessage: function(e, t, n, i, s) {
					return "unexpected character: ->" + e.charAt(t) + "<- at offset: " + t + "," + (" skipped " + n + " characters.")
				}
			}
		}),
		bh = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.Lexer = r.LexerDefinitionErrorType = void 0;
			var e = Nx(),
				t = Ut(),
				n = tc(),
				i = Dx(),
				s = tm(),
				o;
			(function(l) {
				l[l.MISSING_PATTERN = 0] = "MISSING_PATTERN", l[l.INVALID_PATTERN = 1] = "INVALID_PATTERN", l[l.EOI_ANCHOR_FOUND = 2] = "EOI_ANCHOR_FOUND", l[l.UNSUPPORTED_FLAGS_FOUND = 3] = "UNSUPPORTED_FLAGS_FOUND", l[l.DUPLICATE_PATTERNS_FOUND = 4] = "DUPLICATE_PATTERNS_FOUND", l[l.INVALID_GROUP_TYPE_FOUND = 5] = "INVALID_GROUP_TYPE_FOUND", l[l.PUSH_MODE_DOES_NOT_EXIST = 6] = "PUSH_MODE_DOES_NOT_EXIST", l[l.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE", l[l.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY", l[l.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST", l[l.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED", l[l.SOI_ANCHOR_FOUND = 11] = "SOI_ANCHOR_FOUND", l[l.EMPTY_MATCH_PATTERN = 12] = "EMPTY_MATCH_PATTERN", l[l.NO_LINE_BREAKS_FLAGS = 13] = "NO_LINE_BREAKS_FLAGS", l[l.UNREACHABLE_PATTERN = 14] = "UNREACHABLE_PATTERN", l[l.IDENTIFY_TERMINATOR = 15] = "IDENTIFY_TERMINATOR", l[l.CUSTOM_LINE_BREAK = 16] = "CUSTOM_LINE_BREAK"
			})(o = r.LexerDefinitionErrorType || (r.LexerDefinitionErrorType = {}));
			var a = {
				deferDefinitionErrorsHandling: !1,
				positionTracking: "full",
				lineTerminatorsPattern: /\n|\r\n?/g,
				lineTerminatorCharacters: [`
`, "\r"],
				ensureOptimizations: !1,
				safeMode: !1,
				errorMessageProvider: i.defaultLexerErrorProvider,
				traceInitPerf: !1,
				skipValidations: !1
			};
			Object.freeze(a);
			var c = function() {
				function l(u, h) {
					var f = this;
					if (h === void 0 && (h = a), this.lexerDefinition = u, this.lexerDefinitionErrors = [], this.lexerDefinitionWarning = [], this.patternIdxToConfig = {}, this.charCodeToPatternIdxToConfig = {}, this.modes = [], this.emptyGroups = {}, this.config = void 0, this.trackStartLines = !0, this.trackEndLines = !0, this.hasCustom = !1, this.canModeBeOptimized = {}, typeof h == "boolean") throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
					this.config = t.merge(a, h);
					var p = this.config.traceInitPerf;
					p === !0 ? (this.traceInitMaxIdent = 1 / 0, this.traceInitPerf = !0) : typeof p == "number" && (this.traceInitMaxIdent = p, this.traceInitPerf = !0), this.traceInitIndent = -1, this.TRACE_INIT("Lexer Constructor", function() {
						var g, m = !0;
						f.TRACE_INIT("Lexer Config handling", function() {
							if (f.config.lineTerminatorsPattern === a.lineTerminatorsPattern) f.config.lineTerminatorsPattern = e.LineTerminatorOptimizedTester;
							else if (f.config.lineTerminatorCharacters === a.lineTerminatorCharacters) throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
							if (h.safeMode && h.ensureOptimizations) throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
							f.trackStartLines = /full|onlyStart/i.test(f.config.positionTracking), f.trackEndLines = /full/i.test(f.config.positionTracking), t.isArray(u) ? (g = {
								modes: {}
							}, g.modes[e.DEFAULT_MODE] = t.cloneArr(u), g[e.DEFAULT_MODE] = e.DEFAULT_MODE) : (m = !1, g = t.cloneObj(u))
						}), f.config.skipValidations === !1 && (f.TRACE_INIT("performRuntimeChecks", function() {
							f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.performRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
						}), f.TRACE_INIT("performWarningRuntimeChecks", function() {
							f.lexerDefinitionWarning = f.lexerDefinitionWarning.concat(e.performWarningRuntimeChecks(g, f.trackStartLines, f.config.lineTerminatorCharacters))
						})), g.modes = g.modes ? g.modes : {}, t.forEach(g.modes, function(_, y) {
							g.modes[y] = t.reject(_, function(w) {
								return t.isUndefined(w)
							})
						});
						var d = t.keys(g.modes);
						if (t.forEach(g.modes, function(_, y) {
							f.TRACE_INIT("Mode: <" + y + "> processing", function() {
								if (f.modes.push(y), f.config.skipValidations === !1 && f.TRACE_INIT("validatePatterns", function() {
									f.lexerDefinitionErrors = f.lexerDefinitionErrors.concat(e.validatePatterns(_, d))
								}), t.isEmpty(f.lexerDefinitionErrors)) {
									n.augmentTokenTypes(_);
									var w;
									f.TRACE_INIT("analyzeTokenTypes", function() {
										w = e.analyzeTokenTypes(_, {
											lineTerminatorCharacters: f.config.lineTerminatorCharacters,
											positionTracking: h.positionTracking,
											ensureOptimizations: h.ensureOptimizations,
											safeMode: h.safeMode,
											tracer: f.TRACE_INIT.bind(f)
										})
									}), f.patternIdxToConfig[y] = w.patternIdxToConfig, f.charCodeToPatternIdxToConfig[y] = w.charCodeToPatternIdxToConfig, f.emptyGroups = t.merge(f.emptyGroups, w.emptyGroups), f.hasCustom = w.hasCustom || f.hasCustom, f.canModeBeOptimized[y] = w.canBeOptimized
								}
							})
						}), f.defaultMode = g.defaultMode, !t.isEmpty(f.lexerDefinitionErrors) && !f.config.deferDefinitionErrorsHandling) {
							var v = t.map(f.lexerDefinitionErrors, function(_) {
									return _.message
								}),
								x = v.join(`-----------------------
`);
							throw new Error(`Errors detected in definition of Lexer:
` + x)
						}
						t.forEach(f.lexerDefinitionWarning, function(_) {
							t.PRINT_WARNING(_.message)
						}), f.TRACE_INIT("Choosing sub-methods implementations", function() {
							if (e.SUPPORT_STICKY ? (f.chopInput = t.IDENTITY, f.match = f.matchWithTest) : (f.updateLastIndex = t.NOOP, f.match = f.matchWithExec), m && (f.handleModes = t.NOOP), f.trackStartLines === !1 && (f.computeNewColumn = t.IDENTITY), f.trackEndLines === !1 && (f.updateTokenEndLineColumnLocation = t.NOOP), /full/i.test(f.config.positionTracking)) f.createTokenInstance = f.createFullToken;
							else if (/onlyStart/i.test(f.config.positionTracking)) f.createTokenInstance = f.createStartOnlyToken;
							else if (/onlyOffset/i.test(f.config.positionTracking)) f.createTokenInstance = f.createOffsetOnlyToken;
							else throw Error('Invalid <positionTracking> config option: "' + f.config.positionTracking + '"');
							f.hasCustom ? (f.addToken = f.addTokenUsingPush, f.handlePayload = f.handlePayloadWithCustom) : (f.addToken = f.addTokenUsingMemberAccess, f.handlePayload = f.handlePayloadNoCustom)
						}), f.TRACE_INIT("Failed Optimization Warnings", function() {
							var _ = t.reduce(f.canModeBeOptimized, function(y, w, C) {
								return w === !1 && y.push(C), y
							}, []);
							if (h.ensureOptimizations && !t.isEmpty(_)) throw Error("Lexer Modes: < " + _.join(", ") + ` > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`)
						}), f.TRACE_INIT("clearRegExpParserCache", function() {
							s.clearRegExpParserCache()
						}), f.TRACE_INIT("toFastProperties", function() {
							t.toFastProperties(f)
						})
					})
				}
				return l.prototype.tokenize = function(u, h) {
					if (h === void 0 && (h = this.defaultMode), !t.isEmpty(this.lexerDefinitionErrors)) {
						var f = t.map(this.lexerDefinitionErrors, function(m) {
								return m.message
							}),
							p = f.join(`-----------------------
`);
						throw new Error(`Unable to Tokenize because Errors detected in definition of Lexer:
` + p)
					}
					var g = this.tokenizeInternal(u, h);
					return g
				}, l.prototype.tokenizeInternal = function(u, h) {
					var f = this,
						p, g, m, d, v, x, _, y, w, C, S, b, T, N, V, O = u,
						k = O.length,
						I = 0,
						q = 0,
						B = this.hasCustom ? 0 : Math.floor(u.length / 10),
						Y = new Array(B),
						J = [],
						H = this.trackStartLines ? 1 : void 0,
						$ = this.trackStartLines ? 1 : void 0,
						ae = e.cloneEmptyGroups(this.emptyGroups),
						oe = this.trackStartLines,
						ie = this.config.lineTerminatorsPattern,
						U = 0,
						A = [],
						L = [],
						j = [],
						K = [];
					Object.freeze(K);
					var Q = void 0;

					function se() {
						return A
					}

					function de(ee) {
						var pe = e.charCodeToOptimizedIndex(ee),
							ve = L[pe];
						return ve === void 0 ? K : ve
					}
					var ue = function(ee) {
						if (j.length === 1 && ee.tokenType.PUSH_MODE === void 0) {
							var pe = f.config.errorMessageProvider.buildUnableToPopLexerModeMessage(ee);
							J.push({
								offset: ee.startOffset,
								line: ee.startLine !== void 0 ? ee.startLine : void 0,
								column: ee.startColumn !== void 0 ? ee.startColumn : void 0,
								length: ee.image.length,
								message: pe
							})
						} else {
							j.pop();
							var ve = t.last(j);
							A = f.patternIdxToConfig[ve], L = f.charCodeToPatternIdxToConfig[ve], U = A.length;
							var Se = f.canModeBeOptimized[ve] && f.config.safeMode === !1;
							L && Se ? Q = de : Q = se
						}
					};

					function xe(ee) {
						j.push(ee), L = this.charCodeToPatternIdxToConfig[ee], A = this.patternIdxToConfig[ee], U = A.length, U = A.length;
						var pe = this.canModeBeOptimized[ee] && this.config.safeMode === !1;
						L && pe ? Q = de : Q = se
					}
					xe.call(this, h);
					for (var Ee; I < k;) {
						v = null;
						var De = O.charCodeAt(I),
							ht = Q(De),
							ct = ht.length;
						for (p = 0; p < ct; p++) {
							Ee = ht[p];
							var He = Ee.pattern;
							x = null;
							var Ve = Ee.short;
							if (Ve !== !1 ? De === Ve && (v = He) : Ee.isCustom === !0 ? (V = He.exec(O, I, Y, ae), V !== null ? (v = V[0], V.payload !== void 0 && (x = V.payload)) : v = null) : (this.updateLastIndex(He, I), v = this.match(He, u, I)), v !== null) {
								if (d = Ee.longerAlt, d !== void 0) {
									var ot = A[d],
										it = ot.pattern;
									_ = null, ot.isCustom === !0 ? (V = it.exec(O, I, Y, ae), V !== null ? (m = V[0], V.payload !== void 0 && (_ = V.payload)) : m = null) : (this.updateLastIndex(it, I), m = this.match(it, u, I)), m && m.length > v.length && (v = m, x = _, Ee = ot)
								}
								break
							}
						}
						if (v !== null) {
							if (y = v.length, w = Ee.group, w !== void 0 && (C = Ee.tokenTypeIdx, S = this.createTokenInstance(v, I, C, Ee.tokenType, H, $, y), this.handlePayload(S, x), w === !1 ? q = this.addToken(Y, q, S) : ae[w].push(S)), u = this.chopInput(u, y), I = I + y, $ = this.computeNewColumn($, y), oe === !0 && Ee.canLineTerminator === !0) {
								var E = 0,
									M = void 0,
									D = void 0;
								ie.lastIndex = 0;
								do M = ie.test(v), M === !0 && (D = ie.lastIndex - 1, E++); while (M === !0);
								E !== 0 && (H = H + E, $ = y - D, this.updateTokenEndLineColumnLocation(S, w, D, E, H, $, y))
							}
							this.handleModes(Ee, ue, xe, S)
						} else {
							for (var X = I, W = H, te = $, ce = !1; !ce && I < k;)
								for (T = O.charCodeAt(I), u = this.chopInput(u, 1), I++, g = 0; g < U; g++) {
									var le = A[g],
										He = le.pattern,
										Ve = le.short;
									if (Ve !== !1 ? O.charCodeAt(I) === Ve && (ce = !0) : le.isCustom === !0 ? ce = He.exec(O, I, Y, ae) !== null : (this.updateLastIndex(He, I), ce = He.exec(u) !== null), ce === !0) break
								}
							b = I - X, N = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(O, X, b, W, te), J.push({
								offset: X,
								line: W,
								column: te,
								length: b,
								message: N
							})
						}
					}
					return this.hasCustom || (Y.length = q), {
						tokens: Y,
						groups: ae,
						errors: J
					}
				}, l.prototype.handleModes = function(u, h, f, p) {
					if (u.pop === !0) {
						var g = u.push;
						h(p), g !== void 0 && f.call(this, g)
					} else u.push !== void 0 && f.call(this, u.push)
				}, l.prototype.chopInput = function(u, h) {
					return u.substring(h)
				}, l.prototype.updateLastIndex = function(u, h) {
					u.lastIndex = h
				}, l.prototype.updateTokenEndLineColumnLocation = function(u, h, f, p, g, m, d) {
					var v, x;
					h !== void 0 && (v = f === d - 1, x = v ? -1 : 0, p === 1 && v === !0 || (u.endLine = g + x, u.endColumn = m - 1 + -x))
				}, l.prototype.computeNewColumn = function(u, h) {
					return u + h
				}, l.prototype.createTokenInstance = function() {
					for (var u = [], h = 0; h < arguments.length; h++) u[h] = arguments[h];
					return null
				}, l.prototype.createOffsetOnlyToken = function(u, h, f, p) {
					return {
						image: u,
						startOffset: h,
						tokenTypeIdx: f,
						tokenType: p
					}
				}, l.prototype.createStartOnlyToken = function(u, h, f, p, g, m) {
					return {
						image: u,
						startOffset: h,
						startLine: g,
						startColumn: m,
						tokenTypeIdx: f,
						tokenType: p
					}
				}, l.prototype.createFullToken = function(u, h, f, p, g, m, d) {
					return {
						image: u,
						startOffset: h,
						endOffset: h + d - 1,
						startLine: g,
						endLine: g,
						startColumn: m,
						endColumn: m + d - 1,
						tokenTypeIdx: f,
						tokenType: p
					}
				}, l.prototype.addToken = function(u, h, f) {
					return 666
				}, l.prototype.addTokenUsingPush = function(u, h, f) {
					return u.push(f), h
				}, l.prototype.addTokenUsingMemberAccess = function(u, h, f) {
					return u[h] = f, h++, h
				}, l.prototype.handlePayload = function(u, h) {}, l.prototype.handlePayloadNoCustom = function(u, h) {}, l.prototype.handlePayloadWithCustom = function(u, h) {
					h !== null && (u.payload = h)
				}, l.prototype.match = function(u, h, f) {
					return null
				}, l.prototype.matchWithTest = function(u, h, f) {
					var p = u.test(h);
					return p === !0 ? h.substring(f, u.lastIndex) : null
				}, l.prototype.matchWithExec = function(u, h) {
					var f = u.exec(h);
					return f !== null ? f[0] : f
				}, l.prototype.TRACE_INIT = function(u, h) {
					if (this.traceInitPerf === !0) {
						this.traceInitIndent++;
						var f = new Array(this.traceInitIndent + 1)
							.join("	");
						this.traceInitIndent < this.traceInitMaxIdent && console.log(f + "--> <" + u + ">");
						var p = t.timer(h),
							g = p.time,
							m = p.value,
							d = g > 10 ? console.warn : console.log;
						return this.traceInitIndent < this.traceInitMaxIdent && d(f + "<-- <" + u + "> time: " + g + "ms"), this.traceInitIndent--, m
					} else return h()
				}, l.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.", l.NA = /NOT_APPLICABLE/, l
			}();
			r.Lexer = c
		}),
		Po = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.tokenMatcher = r.createTokenInstance = r.EOF = r.createToken = r.hasTokenLabel = r.tokenName = r.tokenLabel = void 0;
			var e = Ut(),
				t = bh(),
				n = tc();

			function i(y) {
				return o(y) ? y.LABEL : y.name
			}
			r.tokenLabel = i;

			function s(y) {
				return y.name
			}
			r.tokenName = s;

			function o(y) {
				return e.isString(y.LABEL) && y.LABEL !== ""
			}
			r.hasTokenLabel = o;
			var a = "parent",
				c = "categories",
				l = "label",
				u = "group",
				h = "push_mode",
				f = "pop_mode",
				p = "longer_alt",
				g = "line_breaks",
				m = "start_chars_hint";

			function d(y) {
				return v(y)
			}
			r.createToken = d;

			function v(y) {
				var w = y.pattern,
					C = {};
				if (C.name = y.name, e.isUndefined(w) || (C.PATTERN = w), e.has(y, a)) throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
				return e.has(y, c) && (C.CATEGORIES = y[c]), n.augmentTokenTypes([C]), e.has(y, l) && (C.LABEL = y[l]), e.has(y, u) && (C.GROUP = y[u]), e.has(y, f) && (C.POP_MODE = y[f]), e.has(y, h) && (C.PUSH_MODE = y[h]), e.has(y, p) && (C.LONGER_ALT = y[p]), e.has(y, g) && (C.LINE_BREAKS = y[g]), e.has(y, m) && (C.START_CHARS_HINT = y[m]), C
			}
			r.EOF = d({
				name: "EOF",
				pattern: t.Lexer.NA
			}), n.augmentTokenTypes([r.EOF]);

			function x(y, w, C, S, b, T, N, V) {
				return {
					image: w,
					startOffset: C,
					endOffset: S,
					startLine: b,
					endLine: T,
					startColumn: N,
					endColumn: V,
					tokenTypeIdx: y.tokenTypeIdx,
					tokenType: y
				}
			}
			r.createTokenInstance = x;

			function _(y, w) {
				return n.tokenStructuredMatcher(y, w)
			}
			r.tokenMatcher = _
		}),
		Ai = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var v = function(x, _) {
					return v = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(y, w) {
						y.__proto__ = w
					} || function(y, w) {
						for (var C in w) Object.prototype.hasOwnProperty.call(w, C) && (y[C] = w[C])
					}, v(x, _)
				};
				return function(x, _) {
					if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
					v(x, _);

					function y() {
						this.constructor = x
					}
					x.prototype = _ === null ? Object.create(_) : (y.prototype = _.prototype, new y)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.serializeProduction = r.serializeGrammar = r.Terminal = r.Alternation = r.RepetitionWithSeparator = r.Repetition = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Option = r.Alternative = r.Rule = r.NonTerminal = r.AbstractProduction = void 0;
			var t = Ut(),
				n = Po(),
				i = function() {
					function v(x) {
						this._definition = x
					}
					return Object.defineProperty(v.prototype, "definition", {
						get: function() {
							return this._definition
						},
						set: function(x) {
							this._definition = x
						},
						enumerable: !1,
						configurable: !0
					}), v.prototype.accept = function(x) {
						x.visit(this), t.forEach(this.definition, function(_) {
							_.accept(x)
						})
					}, v
				}();
			r.AbstractProduction = i;
			var s = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, []) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return Object.defineProperty(x.prototype, "definition", {
					get: function() {
						return this.referencedRule !== void 0 ? this.referencedRule.definition : []
					},
					set: function(_) {},
					enumerable: !1,
					configurable: !0
				}), x.prototype.accept = function(_) {
					_.visit(this)
				}, x
			}(i);
			r.NonTerminal = s;
			var o = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.orgText = "", t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.Rule = o;
			var a = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.ignoreAmbiguities = !1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.Alternative = a;
			var c = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.Option = c;
			var l = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.RepetitionMandatory = l;
			var u = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.RepetitionMandatoryWithSeparator = u;
			var h = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.Repetition = h;
			var f = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return x
			}(i);
			r.RepetitionWithSeparator = f;
			var p = function(v) {
				e(x, v);

				function x(_) {
					var y = v.call(this, _.definition) || this;
					return y.idx = 1, y.ignoreAmbiguities = !1, y.hasPredicates = !1, t.assign(y, t.pick(_, function(w) {
						return w !== void 0
					})), y
				}
				return Object.defineProperty(x.prototype, "definition", {
					get: function() {
						return this._definition
					},
					set: function(_) {
						this._definition = _
					},
					enumerable: !1,
					configurable: !0
				}), x
			}(i);
			r.Alternation = p;
			var g = function() {
				function v(x) {
					this.idx = 1, t.assign(this, t.pick(x, function(_) {
						return _ !== void 0
					}))
				}
				return v.prototype.accept = function(x) {
					x.visit(this)
				}, v
			}();
			r.Terminal = g;

			function m(v) {
				return t.map(v, d)
			}
			r.serializeGrammar = m;

			function d(v) {
				function x(w) {
					return t.map(w, d)
				}
				if (v instanceof s) return {
					type: "NonTerminal",
					name: v.nonTerminalName,
					idx: v.idx
				};
				if (v instanceof a) return {
					type: "Alternative",
					definition: x(v.definition)
				};
				if (v instanceof c) return {
					type: "Option",
					idx: v.idx,
					definition: x(v.definition)
				};
				if (v instanceof l) return {
					type: "RepetitionMandatory",
					idx: v.idx,
					definition: x(v.definition)
				};
				if (v instanceof u) return {
					type: "RepetitionMandatoryWithSeparator",
					idx: v.idx,
					separator: d(new g({
						terminalType: v.separator
					})),
					definition: x(v.definition)
				};
				if (v instanceof f) return {
					type: "RepetitionWithSeparator",
					idx: v.idx,
					separator: d(new g({
						terminalType: v.separator
					})),
					definition: x(v.definition)
				};
				if (v instanceof h) return {
					type: "Repetition",
					idx: v.idx,
					definition: x(v.definition)
				};
				if (v instanceof p) return {
					type: "Alternation",
					idx: v.idx,
					definition: x(v.definition)
				};
				if (v instanceof g) {
					var _ = {
							type: "Terminal",
							name: v.terminalType.name,
							label: n.tokenLabel(v.terminalType),
							idx: v.idx
						},
						y = v.terminalType.PATTERN;
					return v.terminalType.PATTERN && (_.pattern = t.isRegExp(y) ? y.source : y), _
				} else {
					if (v instanceof o) return {
						type: "Rule",
						name: v.name,
						orgText: v.orgText,
						definition: x(v.definition)
					};
					throw Error("non exhaustive match")
				}
			}
			r.serializeProduction = d
		}),
		nm = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RestWalker = void 0;
			var e = Ut(),
				t = Ai(),
				n = function() {
					function s() {}
					return s.prototype.walk = function(o, a) {
						var c = this;
						a === void 0 && (a = []), e.forEach(o.definition, function(l, u) {
							var h = e.drop(o.definition, u + 1);
							if (l instanceof t.NonTerminal) c.walkProdRef(l, h, a);
							else if (l instanceof t.Terminal) c.walkTerminal(l, h, a);
							else if (l instanceof t.Alternative) c.walkFlat(l, h, a);
							else if (l instanceof t.Option) c.walkOption(l, h, a);
							else if (l instanceof t.RepetitionMandatory) c.walkAtLeastOne(l, h, a);
							else if (l instanceof t.RepetitionMandatoryWithSeparator) c.walkAtLeastOneSep(l, h, a);
							else if (l instanceof t.RepetitionWithSeparator) c.walkManySep(l, h, a);
							else if (l instanceof t.Repetition) c.walkMany(l, h, a);
							else if (l instanceof t.Alternation) c.walkOr(l, h, a);
							else throw Error("non exhaustive match")
						})
					}, s.prototype.walkTerminal = function(o, a, c) {}, s.prototype.walkProdRef = function(o, a, c) {}, s.prototype.walkFlat = function(o, a, c) {
						var l = a.concat(c);
						this.walk(o, l)
					}, s.prototype.walkOption = function(o, a, c) {
						var l = a.concat(c);
						this.walk(o, l)
					}, s.prototype.walkAtLeastOne = function(o, a, c) {
						var l = [new t.Option({
							definition: o.definition
						})].concat(a, c);
						this.walk(o, l)
					}, s.prototype.walkAtLeastOneSep = function(o, a, c) {
						var l = i(o, a, c);
						this.walk(o, l)
					}, s.prototype.walkMany = function(o, a, c) {
						var l = [new t.Option({
							definition: o.definition
						})].concat(a, c);
						this.walk(o, l)
					}, s.prototype.walkManySep = function(o, a, c) {
						var l = i(o, a, c);
						this.walk(o, l)
					}, s.prototype.walkOr = function(o, a, c) {
						var l = this,
							u = a.concat(c);
						e.forEach(o.definition, function(h) {
							var f = new t.Alternative({
								definition: [h]
							});
							l.walk(f, u)
						})
					}, s
				}();
			r.RestWalker = n;

			function i(s, o, a) {
				var c = [new t.Option({
						definition: [new t.Terminal({
							terminalType: s.separator
						})].concat(s.definition)
					})],
					l = c.concat(o, a);
				return l
			}
		}),
		nc = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GAstVisitor = void 0;
			var e = Ai(),
				t = function() {
					function n() {}
					return n.prototype.visit = function(i) {
						var s = i;
						switch (s.constructor) {
							case e.NonTerminal:
								return this.visitNonTerminal(s);
							case e.Alternative:
								return this.visitAlternative(s);
							case e.Option:
								return this.visitOption(s);
							case e.RepetitionMandatory:
								return this.visitRepetitionMandatory(s);
							case e.RepetitionMandatoryWithSeparator:
								return this.visitRepetitionMandatoryWithSeparator(s);
							case e.RepetitionWithSeparator:
								return this.visitRepetitionWithSeparator(s);
							case e.Repetition:
								return this.visitRepetition(s);
							case e.Alternation:
								return this.visitAlternation(s);
							case e.Terminal:
								return this.visitTerminal(s);
							case e.Rule:
								return this.visitRule(s);
							default:
								throw Error("non exhaustive match")
						}
					}, n.prototype.visitNonTerminal = function(i) {}, n.prototype.visitAlternative = function(i) {}, n.prototype.visitOption = function(i) {}, n.prototype.visitRepetition = function(i) {}, n.prototype.visitRepetitionMandatory = function(i) {}, n.prototype.visitRepetitionMandatoryWithSeparator = function(i) {}, n.prototype.visitRepetitionWithSeparator = function(i) {}, n.prototype.visitAlternation = function(i) {}, n.prototype.visitTerminal = function(i) {}, n.prototype.visitRule = function(i) {}, n
				}();
			r.GAstVisitor = t
		}),
		Mh = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var f = function(p, g) {
					return f = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(m, d) {
						m.__proto__ = d
					} || function(m, d) {
						for (var v in d) Object.prototype.hasOwnProperty.call(d, v) && (m[v] = d[v])
					}, f(p, g)
				};
				return function(p, g) {
					if (typeof g != "function" && g !== null) throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
					f(p, g);

					function m() {
						this.constructor = p
					}
					p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.collectMethods = r.DslMethodsCollectorVisitor = r.getProductionDslName = r.isBranchingProd = r.isOptionalProd = r.isSequenceProd = void 0;
			var t = Ut(),
				n = Ai(),
				i = nc();

			function s(f) {
				return f instanceof n.Alternative || f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionMandatory || f instanceof n.RepetitionMandatoryWithSeparator || f instanceof n.RepetitionWithSeparator || f instanceof n.Terminal || f instanceof n.Rule
			}
			r.isSequenceProd = s;

			function o(f, p) {
				p === void 0 && (p = []);
				var g = f instanceof n.Option || f instanceof n.Repetition || f instanceof n.RepetitionWithSeparator;
				return g ? !0 : f instanceof n.Alternation ? t.some(f.definition, function(m) {
					return o(m, p)
				}) : f instanceof n.NonTerminal && t.contains(p, f) ? !1 : f instanceof n.AbstractProduction ? (f instanceof n.NonTerminal && p.push(f), t.every(f.definition, function(m) {
					return o(m, p)
				})) : !1
			}
			r.isOptionalProd = o;

			function a(f) {
				return f instanceof n.Alternation
			}
			r.isBranchingProd = a;

			function c(f) {
				if (f instanceof n.NonTerminal) return "SUBRULE";
				if (f instanceof n.Option) return "OPTION";
				if (f instanceof n.Alternation) return "OR";
				if (f instanceof n.RepetitionMandatory) return "AT_LEAST_ONE";
				if (f instanceof n.RepetitionMandatoryWithSeparator) return "AT_LEAST_ONE_SEP";
				if (f instanceof n.RepetitionWithSeparator) return "MANY_SEP";
				if (f instanceof n.Repetition) return "MANY";
				if (f instanceof n.Terminal) return "CONSUME";
				throw Error("non exhaustive match")
			}
			r.getProductionDslName = c;
			var l = function(f) {
				e(p, f);

				function p() {
					var g = f !== null && f.apply(this, arguments) || this;
					return g.separator = "-", g.dslMethods = {
						option: [],
						alternation: [],
						repetition: [],
						repetitionWithSeparator: [],
						repetitionMandatory: [],
						repetitionMandatoryWithSeparator: []
					}, g
				}
				return p.prototype.reset = function() {
					this.dslMethods = {
						option: [],
						alternation: [],
						repetition: [],
						repetitionWithSeparator: [],
						repetitionMandatory: [],
						repetitionMandatoryWithSeparator: []
					}
				}, p.prototype.visitTerminal = function(g) {
					var m = g.terminalType.name + this.separator + "Terminal";
					t.has(this.dslMethods, m) || (this.dslMethods[m] = []), this.dslMethods[m].push(g)
				}, p.prototype.visitNonTerminal = function(g) {
					var m = g.nonTerminalName + this.separator + "Terminal";
					t.has(this.dslMethods, m) || (this.dslMethods[m] = []), this.dslMethods[m].push(g)
				}, p.prototype.visitOption = function(g) {
					this.dslMethods.option.push(g)
				}, p.prototype.visitRepetitionWithSeparator = function(g) {
					this.dslMethods.repetitionWithSeparator.push(g)
				}, p.prototype.visitRepetitionMandatory = function(g) {
					this.dslMethods.repetitionMandatory.push(g)
				}, p.prototype.visitRepetitionMandatoryWithSeparator = function(g) {
					this.dslMethods.repetitionMandatoryWithSeparator.push(g)
				}, p.prototype.visitRepetition = function(g) {
					this.dslMethods.repetition.push(g)
				}, p.prototype.visitAlternation = function(g) {
					this.dslMethods.alternation.push(g)
				}, p
			}(i.GAstVisitor);
			r.DslMethodsCollectorVisitor = l;
			var u = new l;

			function h(f) {
				u.reset(), f.accept(u);
				var p = u.dslMethods;
				return u.reset(), p
			}
			r.collectMethods = h
		}),
		Ox = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.firstForTerminal = r.firstForBranching = r.firstForSequence = r.first = void 0;
			var e = Ut(),
				t = Ai(),
				n = Mh();

			function i(c) {
				if (c instanceof t.NonTerminal) return i(c.referencedRule);
				if (c instanceof t.Terminal) return a(c);
				if (n.isSequenceProd(c)) return s(c);
				if (n.isBranchingProd(c)) return o(c);
				throw Error("non exhaustive match")
			}
			r.first = i;

			function s(c) {
				for (var l = [], u = c.definition, h = 0, f = u.length > h, p, g = !0; f && g;) p = u[h], g = n.isOptionalProd(p), l = l.concat(i(p)), h = h + 1, f = u.length > h;
				return e.uniq(l)
			}
			r.firstForSequence = s;

			function o(c) {
				var l = e.map(c.definition, function(u) {
					return i(u)
				});
				return e.uniq(e.flatten(l))
			}
			r.firstForBranching = o;

			function a(c) {
				return [c.terminalType]
			}
			r.firstForTerminal = a
		}),
		kx = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.IN = void 0, r.IN = "_~IN~_"
		}),
		AE = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var h = function(f, p) {
					return h = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(g, m) {
						g.__proto__ = m
					} || function(g, m) {
						for (var d in m) Object.prototype.hasOwnProperty.call(m, d) && (g[d] = m[d])
					}, h(f, p)
				};
				return function(f, p) {
					if (typeof p != "function" && p !== null) throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
					h(f, p);

					function g() {
						this.constructor = f
					}
					f.prototype = p === null ? Object.create(p) : (g.prototype = p.prototype, new g)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.buildInProdFollowPrefix = r.buildBetweenProdsFollowPrefix = r.computeAllProdsFollows = r.ResyncFollowsWalker = void 0;
			var t = nm(),
				n = Ox(),
				i = Ut(),
				s = kx(),
				o = Ai(),
				a = function(h) {
					e(f, h);

					function f(p) {
						var g = h.call(this) || this;
						return g.topProd = p, g.follows = {}, g
					}
					return f.prototype.startWalking = function() {
						return this.walk(this.topProd), this.follows
					}, f.prototype.walkTerminal = function(p, g, m) {}, f.prototype.walkProdRef = function(p, g, m) {
						var d = l(p.referencedRule, p.idx) + this.topProd.name,
							v = g.concat(m),
							x = new o.Alternative({
								definition: v
							}),
							_ = n.first(x);
						this.follows[d] = _
					}, f
				}(t.RestWalker);
			r.ResyncFollowsWalker = a;

			function c(h) {
				var f = {};
				return i.forEach(h, function(p) {
					var g = new a(p)
						.startWalking();
					i.assign(f, g)
				}), f
			}
			r.computeAllProdsFollows = c;

			function l(h, f) {
				return h.name + f + s.IN
			}
			r.buildBetweenProdsFollowPrefix = l;

			function u(h) {
				var f = h.terminalType.name;
				return f + h.idx + s.IN
			}
			r.buildInProdFollowPrefix = u
		}),
		wh = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defaultGrammarValidatorErrorProvider = r.defaultGrammarResolverErrorProvider = r.defaultParserErrorProvider = void 0;
			var e = Po(),
				t = Ut(),
				n = Ut(),
				i = Ai(),
				s = Mh();
			r.defaultParserErrorProvider = {
				buildMismatchTokenMessage: function(o) {
					var a = o.expected,
						c = o.actual,
						l = o.previous,
						u = o.ruleName,
						h = e.hasTokenLabel(a),
						f = h ? "--> " + e.tokenLabel(a) + " <--" : "token of type --> " + a.name + " <--",
						p = "Expecting " + f + " but found --> '" + c.image + "' <--";
					return p
				},
				buildNotAllInputParsedMessage: function(o) {
					var a = o.firstRedundant,
						c = o.ruleName;
					return "Redundant input, expecting EOF but found: " + a.image
				},
				buildNoViableAltMessage: function(o) {
					var a = o.expectedPathsPerAlt,
						c = o.actual,
						l = o.previous,
						u = o.customUserDescription,
						h = o.ruleName,
						f = "Expecting: ",
						p = n.first(c)
						.image,
						g = `
but found: '` + p + "'";
					if (u) return f + u + g;
					var m = n.reduce(a, function(_, y) {
							return _.concat(y)
						}, []),
						d = n.map(m, function(_) {
							return "[" + n.map(_, function(y) {
									return e.tokenLabel(y)
								})
								.join(", ") + "]"
						}),
						v = n.map(d, function(_, y) {
							return "  " + (y + 1) + ". " + _
						}),
						x = `one of these possible Token sequences:
` + v.join(`
`);
					return f + x + g
				},
				buildEarlyExitMessage: function(o) {
					var a = o.expectedIterationPaths,
						c = o.actual,
						l = o.customUserDescription,
						u = o.ruleName,
						h = "Expecting: ",
						f = n.first(c)
						.image,
						p = `
but found: '` + f + "'";
					if (l) return h + l + p;
					var g = n.map(a, function(d) {
							return "[" + n.map(d, function(v) {
									return e.tokenLabel(v)
								})
								.join(",") + "]"
						}),
						m = `expecting at least one iteration which starts with one of these possible Token sequences::
  ` + ("<" + g.join(" ,") + ">");
					return h + m + p
				}
			}, Object.freeze(r.defaultParserErrorProvider), r.defaultGrammarResolverErrorProvider = {
				buildRuleNotFoundError: function(o, a) {
					var c = "Invalid grammar, reference to a rule which is not defined: ->" + a.nonTerminalName + `<-
inside top level rule: ->` + o.name + "<-";
					return c
				}
			}, r.defaultGrammarValidatorErrorProvider = {
				buildDuplicateFoundError: function(o, a) {
					function c(d) {
						return d instanceof i.Terminal ? d.terminalType.name : d instanceof i.NonTerminal ? d.nonTerminalName : ""
					}
					var l = o.name,
						u = n.first(a),
						h = u.idx,
						f = s.getProductionDslName(u),
						p = c(u),
						g = h > 0,
						m = "->" + f + (g ? h : "") + "<- " + (p ? "with argument: ->" + p + "<-" : "") + `
                  appears more than once (` + a.length + " times) in the top level rule: ->" + l + `<-.
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES
                  `;
					return m = m.replace(/[ \t]+/g, " "), m = m.replace(/\s\s+/g, `
`), m
				},
				buildNamespaceConflictError: function(o) {
					var a = `Namespace conflict found in grammar.
` + ("The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <" + o.name + `>.
`) + `To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
					return a
				},
				buildAlternationPrefixAmbiguityError: function(o) {
					var a = n.map(o.prefixPath, function(u) {
							return e.tokenLabel(u)
						})
						.join(", "),
						c = o.alternation.idx === 0 ? "" : o.alternation.idx,
						l = "Ambiguous alternatives: <" + o.ambiguityIndices.join(" ,") + `> due to common lookahead prefix
` + ("in <OR" + c + "> inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`) + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
					return l
				},
				buildAlternationAmbiguityError: function(o) {
					var a = n.map(o.prefixPath, function(u) {
							return e.tokenLabel(u)
						})
						.join(", "),
						c = o.alternation.idx === 0 ? "" : o.alternation.idx,
						l = "Ambiguous Alternatives Detected: <" + o.ambiguityIndices.join(" ,") + "> in <OR" + c + ">" + (" inside <" + o.topLevelRule.name + `> Rule,
`) + ("<" + a + `> may appears as a prefix path in all these alternatives.
`);
					return l = l + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`, l
				},
				buildEmptyRepetitionError: function(o) {
					var a = s.getProductionDslName(o.repetition);
					o.repetition.idx !== 0 && (a += o.repetition.idx);
					var c = "The repetition <" + a + "> within Rule <" + o.topLevelRule.name + `> can never consume any tokens.
This could lead to an infinite loop.`;
					return c
				},
				buildTokenNameError: function(o) {
					return "deprecated"
				},
				buildEmptyAlternationError: function(o) {
					var a = "Ambiguous empty alternative: <" + (o.emptyChoiceIdx + 1) + ">" + (" in <OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
`) + "Only the last alternative may be an empty alternative.";
					return a
				},
				buildTooManyAlternativesError: function(o) {
					var a = `An Alternation cannot have more than 256 alternatives:
` + ("<OR" + o.alternation.idx + "> inside <" + o.topLevelRule.name + `> Rule.
 has ` + (o.alternation.definition.length + 1) + " alternatives.");
					return a
				},
				buildLeftRecursionError: function(o) {
					var a = o.topLevelRule.name,
						c = t.map(o.leftRecursionPath, function(h) {
							return h.name
						}),
						l = a + " --> " + c.concat([a])
						.join(" --> "),
						u = `Left Recursion found in grammar.
` + ("rule: <" + a + `> can be invoked from itself (directly or indirectly)
`) + (`without consuming any Tokens. The grammar path that causes this is:
 ` + l + `
`) + ` To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_Factoring.`;
					return u
				},
				buildInvalidRuleNameError: function(o) {
					return "deprecated"
				},
				buildDuplicateRuleNameError: function(o) {
					var a;
					o.topLevelRule instanceof i.Rule ? a = o.topLevelRule.name : a = o.topLevelRule;
					var c = "Duplicate definition, rule: ->" + a + "<- is already defined in the grammar: ->" + o.grammarName + "<-";
					return c
				}
			}
		}),
		IE = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var a = function(c, l) {
					return a = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(u, h) {
						u.__proto__ = h
					} || function(u, h) {
						for (var f in h) Object.prototype.hasOwnProperty.call(h, f) && (u[f] = h[f])
					}, a(c, l)
				};
				return function(c, l) {
					if (typeof l != "function" && l !== null) throw new TypeError("Class extends value " + String(l) + " is not a constructor or null");
					a(c, l);

					function u() {
						this.constructor = c
					}
					c.prototype = l === null ? Object.create(l) : (u.prototype = l.prototype, new u)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GastRefResolverVisitor = r.resolveGrammar = void 0;
			var t = qi(),
				n = Ut(),
				i = nc();

			function s(a, c) {
				var l = new o(a, c);
				return l.resolveRefs(), l.errors
			}
			r.resolveGrammar = s;
			var o = function(a) {
				e(c, a);

				function c(l, u) {
					var h = a.call(this) || this;
					return h.nameToTopRule = l, h.errMsgProvider = u, h.errors = [], h
				}
				return c.prototype.resolveRefs = function() {
					var l = this;
					n.forEach(n.values(this.nameToTopRule), function(u) {
						l.currTopLevel = u, u.accept(l)
					})
				}, c.prototype.visitNonTerminal = function(l) {
					var u = this.nameToTopRule[l.nonTerminalName];
					if (u) l.referencedRule = u;
					else {
						var h = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, l);
						this.errors.push({
							message: h,
							type: t.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
							ruleName: this.currTopLevel.name,
							unresolvedRefName: l.nonTerminalName
						})
					}
				}, c
			}(i.GAstVisitor);
			r.GastRefResolverVisitor = o
		}),
		Th = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var d = function(v, x) {
					return d = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(_, y) {
						_.__proto__ = y
					} || function(_, y) {
						for (var w in y) Object.prototype.hasOwnProperty.call(y, w) && (_[w] = y[w])
					}, d(v, x)
				};
				return function(v, x) {
					if (typeof x != "function" && x !== null) throw new TypeError("Class extends value " + String(x) + " is not a constructor or null");
					d(v, x);

					function _() {
						this.constructor = v
					}
					v.prototype = x === null ? Object.create(x) : (_.prototype = x.prototype, new _)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.nextPossibleTokensAfter = r.possiblePathsFrom = r.NextTerminalAfterAtLeastOneSepWalker = r.NextTerminalAfterAtLeastOneWalker = r.NextTerminalAfterManySepWalker = r.NextTerminalAfterManyWalker = r.AbstractNextTerminalAfterProductionWalker = r.NextAfterTokenWalker = r.AbstractNextPossibleTokensWalker = void 0;
			var t = nm(),
				n = Ut(),
				i = Ox(),
				s = Ai(),
				o = function(d) {
					e(v, d);

					function v(x, _) {
						var y = d.call(this) || this;
						return y.topProd = x, y.path = _, y.possibleTokTypes = [], y.nextProductionName = "", y.nextProductionOccurrence = 0, y.found = !1, y.isAtEndOfPath = !1, y
					}
					return v.prototype.startWalking = function() {
						if (this.found = !1, this.path.ruleStack[0] !== this.topProd.name) throw Error("The path does not start with the walker's top Rule!");
						return this.ruleStack = n.cloneArr(this.path.ruleStack)
							.reverse(), this.occurrenceStack = n.cloneArr(this.path.occurrenceStack)
							.reverse(), this.ruleStack.pop(), this.occurrenceStack.pop(), this.updateExpectedNext(), this.walk(this.topProd), this.possibleTokTypes
					}, v.prototype.walk = function(x, _) {
						_ === void 0 && (_ = []), this.found || d.prototype.walk.call(this, x, _)
					}, v.prototype.walkProdRef = function(x, _, y) {
						if (x.referencedRule.name === this.nextProductionName && x.idx === this.nextProductionOccurrence) {
							var w = _.concat(y);
							this.updateExpectedNext(), this.walk(x.referencedRule, w)
						}
					}, v.prototype.updateExpectedNext = function() {
						n.isEmpty(this.ruleStack) ? (this.nextProductionName = "", this.nextProductionOccurrence = 0, this.isAtEndOfPath = !0) : (this.nextProductionName = this.ruleStack.pop(), this.nextProductionOccurrence = this.occurrenceStack.pop())
					}, v
				}(t.RestWalker);
			r.AbstractNextPossibleTokensWalker = o;
			var a = function(d) {
				e(v, d);

				function v(x, _) {
					var y = d.call(this, x, _) || this;
					return y.path = _, y.nextTerminalName = "", y.nextTerminalOccurrence = 0, y.nextTerminalName = y.path.lastTok.name, y.nextTerminalOccurrence = y.path.lastTokOccurrence, y
				}
				return v.prototype.walkTerminal = function(x, _, y) {
					if (this.isAtEndOfPath && x.terminalType.name === this.nextTerminalName && x.idx === this.nextTerminalOccurrence && !this.found) {
						var w = _.concat(y),
							C = new s.Alternative({
								definition: w
							});
						this.possibleTokTypes = i.first(C), this.found = !0
					}
				}, v
			}(o);
			r.NextAfterTokenWalker = a;
			var c = function(d) {
				e(v, d);

				function v(x, _) {
					var y = d.call(this) || this;
					return y.topRule = x, y.occurrence = _, y.result = {
						token: void 0,
						occurrence: void 0,
						isEndOfRule: void 0
					}, y
				}
				return v.prototype.startWalking = function() {
					return this.walk(this.topRule), this.result
				}, v
			}(t.RestWalker);
			r.AbstractNextTerminalAfterProductionWalker = c;
			var l = function(d) {
				e(v, d);

				function v() {
					return d !== null && d.apply(this, arguments) || this
				}
				return v.prototype.walkMany = function(x, _, y) {
					if (x.idx === this.occurrence) {
						var w = n.first(_.concat(y));
						this.result.isEndOfRule = w === void 0, w instanceof s.Terminal && (this.result.token = w.terminalType, this.result.occurrence = w.idx)
					} else d.prototype.walkMany.call(this, x, _, y)
				}, v
			}(c);
			r.NextTerminalAfterManyWalker = l;
			var u = function(d) {
				e(v, d);

				function v() {
					return d !== null && d.apply(this, arguments) || this
				}
				return v.prototype.walkManySep = function(x, _, y) {
					if (x.idx === this.occurrence) {
						var w = n.first(_.concat(y));
						this.result.isEndOfRule = w === void 0, w instanceof s.Terminal && (this.result.token = w.terminalType, this.result.occurrence = w.idx)
					} else d.prototype.walkManySep.call(this, x, _, y)
				}, v
			}(c);
			r.NextTerminalAfterManySepWalker = u;
			var h = function(d) {
				e(v, d);

				function v() {
					return d !== null && d.apply(this, arguments) || this
				}
				return v.prototype.walkAtLeastOne = function(x, _, y) {
					if (x.idx === this.occurrence) {
						var w = n.first(_.concat(y));
						this.result.isEndOfRule = w === void 0, w instanceof s.Terminal && (this.result.token = w.terminalType, this.result.occurrence = w.idx)
					} else d.prototype.walkAtLeastOne.call(this, x, _, y)
				}, v
			}(c);
			r.NextTerminalAfterAtLeastOneWalker = h;
			var f = function(d) {
				e(v, d);

				function v() {
					return d !== null && d.apply(this, arguments) || this
				}
				return v.prototype.walkAtLeastOneSep = function(x, _, y) {
					if (x.idx === this.occurrence) {
						var w = n.first(_.concat(y));
						this.result.isEndOfRule = w === void 0, w instanceof s.Terminal && (this.result.token = w.terminalType, this.result.occurrence = w.idx)
					} else d.prototype.walkAtLeastOneSep.call(this, x, _, y)
				}, v
			}(c);
			r.NextTerminalAfterAtLeastOneSepWalker = f;

			function p(d, v, x) {
				x === void 0 && (x = []), x = n.cloneArr(x);
				var _ = [],
					y = 0;

				function w(T) {
					return T.concat(n.drop(d, y + 1))
				}

				function C(T) {
					var N = p(w(T), v, x);
					return _.concat(N)
				}
				for (; x.length < v && y < d.length;) {
					var S = d[y];
					if (S instanceof s.Alternative || S instanceof s.NonTerminal) return C(S.definition);
					if (S instanceof s.Option) _ = C(S.definition);
					else if (S instanceof s.RepetitionMandatory) {
						var b = S.definition.concat([new s.Repetition({
							definition: S.definition
						})]);
						return C(b)
					} else if (S instanceof s.RepetitionMandatoryWithSeparator) {
						var b = [new s.Alternative({
							definition: S.definition
						}), new s.Repetition({
							definition: [new s.Terminal({
								terminalType: S.separator
							})].concat(S.definition)
						})];
						return C(b)
					} else if (S instanceof s.RepetitionWithSeparator) {
						var b = S.definition.concat([new s.Repetition({
							definition: [new s.Terminal({
								terminalType: S.separator
							})].concat(S.definition)
						})]);
						_ = C(b)
					} else if (S instanceof s.Repetition) {
						var b = S.definition.concat([new s.Repetition({
							definition: S.definition
						})]);
						_ = C(b)
					} else {
						if (S instanceof s.Alternation) return n.forEach(S.definition, function(T) {
							n.isEmpty(T.definition) === !1 && (_ = C(T.definition))
						}), _;
						if (S instanceof s.Terminal) x.push(S.terminalType);
						else throw Error("non exhaustive match")
					}
					y++
				}
				return _.push({
					partialPath: x,
					suffixDef: n.drop(d, y)
				}), _
			}
			r.possiblePathsFrom = p;

			function g(d, v, x, _) {
				var y = "EXIT_NONE_TERMINAL",
					w = [y],
					C = "EXIT_ALTERNATIVE",
					S = !1,
					b = v.length,
					T = b - _ - 1,
					N = [],
					V = [];
				for (V.push({
					idx: -1,
					def: d,
					ruleStack: [],
					occurrenceStack: []
				}); !n.isEmpty(V);) {
					var O = V.pop();
					if (O === C) {
						S && n.last(V)
							.idx <= T && V.pop();
						continue
					}
					var k = O.def,
						I = O.idx,
						q = O.ruleStack,
						B = O.occurrenceStack;
					if (!n.isEmpty(k)) {
						var Y = k[0];
						if (Y === y) {
							var J = {
								idx: I,
								def: n.drop(k),
								ruleStack: n.dropRight(q),
								occurrenceStack: n.dropRight(B)
							};
							V.push(J)
						} else if (Y instanceof s.Terminal)
							if (I < b - 1) {
								var H = I + 1,
									$ = v[H];
								if (x($, Y.terminalType)) {
									var J = {
										idx: H,
										def: n.drop(k),
										ruleStack: q,
										occurrenceStack: B
									};
									V.push(J)
								}
							} else if (I === b - 1) N.push({
							nextTokenType: Y.terminalType,
							nextTokenOccurrence: Y.idx,
							ruleStack: q,
							occurrenceStack: B
						}), S = !0;
						else throw Error("non exhaustive match");
						else if (Y instanceof s.NonTerminal) {
							var ae = n.cloneArr(q);
							ae.push(Y.nonTerminalName);
							var oe = n.cloneArr(B);
							oe.push(Y.idx);
							var J = {
								idx: I,
								def: Y.definition.concat(w, n.drop(k)),
								ruleStack: ae,
								occurrenceStack: oe
							};
							V.push(J)
						} else if (Y instanceof s.Option) {
							var ie = {
								idx: I,
								def: n.drop(k),
								ruleStack: q,
								occurrenceStack: B
							};
							V.push(ie), V.push(C);
							var U = {
								idx: I,
								def: Y.definition.concat(n.drop(k)),
								ruleStack: q,
								occurrenceStack: B
							};
							V.push(U)
						} else if (Y instanceof s.RepetitionMandatory) {
							var A = new s.Repetition({
									definition: Y.definition,
									idx: Y.idx
								}),
								L = Y.definition.concat([A], n.drop(k)),
								J = {
									idx: I,
									def: L,
									ruleStack: q,
									occurrenceStack: B
								};
							V.push(J)
						} else if (Y instanceof s.RepetitionMandatoryWithSeparator) {
							var j = new s.Terminal({
									terminalType: Y.separator
								}),
								A = new s.Repetition({
									definition: [j].concat(Y.definition),
									idx: Y.idx
								}),
								L = Y.definition.concat([A], n.drop(k)),
								J = {
									idx: I,
									def: L,
									ruleStack: q,
									occurrenceStack: B
								};
							V.push(J)
						} else if (Y instanceof s.RepetitionWithSeparator) {
							var ie = {
								idx: I,
								def: n.drop(k),
								ruleStack: q,
								occurrenceStack: B
							};
							V.push(ie), V.push(C);
							var j = new s.Terminal({
									terminalType: Y.separator
								}),
								K = new s.Repetition({
									definition: [j].concat(Y.definition),
									idx: Y.idx
								}),
								L = Y.definition.concat([K], n.drop(k)),
								U = {
									idx: I,
									def: L,
									ruleStack: q,
									occurrenceStack: B
								};
							V.push(U)
						} else if (Y instanceof s.Repetition) {
							var ie = {
								idx: I,
								def: n.drop(k),
								ruleStack: q,
								occurrenceStack: B
							};
							V.push(ie), V.push(C);
							var K = new s.Repetition({
									definition: Y.definition,
									idx: Y.idx
								}),
								L = Y.definition.concat([K], n.drop(k)),
								U = {
									idx: I,
									def: L,
									ruleStack: q,
									occurrenceStack: B
								};
							V.push(U)
						} else if (Y instanceof s.Alternation)
							for (var Q = Y.definition.length - 1; Q >= 0; Q--) {
								var se = Y.definition[Q],
									de = {
										idx: I,
										def: se.definition.concat(n.drop(k)),
										ruleStack: q,
										occurrenceStack: B
									};
								V.push(de), V.push(C)
							} else if (Y instanceof s.Alternative) V.push({
								idx: I,
								def: Y.definition.concat(n.drop(k)),
								ruleStack: q,
								occurrenceStack: B
							});
							else if (Y instanceof s.Rule) V.push(m(Y, I, q, B));
						else throw Error("non exhaustive match")
					}
				}
				return N
			}
			r.nextPossibleTokensAfter = g;

			function m(d, v, x, _) {
				var y = n.cloneArr(x);
				y.push(d.name);
				var w = n.cloneArr(_);
				return w.push(1), {
					idx: v,
					def: d.definition,
					ruleStack: y,
					occurrenceStack: w
				}
			}
		}),
		Sh = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var T = function(N, V) {
					return T = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(O, k) {
						O.__proto__ = k
					} || function(O, k) {
						for (var I in k) Object.prototype.hasOwnProperty.call(k, I) && (O[I] = k[I])
					}, T(N, V)
				};
				return function(N, V) {
					if (typeof V != "function" && V !== null) throw new TypeError("Class extends value " + String(V) + " is not a constructor or null");
					T(N, V);

					function O() {
						this.constructor = N
					}
					N.prototype = V === null ? Object.create(V) : (O.prototype = V.prototype, new O)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.areTokenCategoriesNotUsed = r.isStrictPrefixOfPath = r.containsPath = r.getLookaheadPathsForOptionalProd = r.getLookaheadPathsForOr = r.lookAheadSequenceFromAlternatives = r.buildSingleAlternativeLookaheadFunction = r.buildAlternativesLookAheadFunc = r.buildLookaheadFuncForOptionalProd = r.buildLookaheadFuncForOr = r.getProdType = r.PROD_TYPE = void 0;
			var t = Ut(),
				n = Th(),
				i = nm(),
				s = tc(),
				o = Ai(),
				a = nc(),
				c;
			(function(T) {
				T[T.OPTION = 0] = "OPTION", T[T.REPETITION = 1] = "REPETITION", T[T.REPETITION_MANDATORY = 2] = "REPETITION_MANDATORY", T[T.REPETITION_MANDATORY_WITH_SEPARATOR = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR", T[T.REPETITION_WITH_SEPARATOR = 4] = "REPETITION_WITH_SEPARATOR", T[T.ALTERNATION = 5] = "ALTERNATION"
			})(c = r.PROD_TYPE || (r.PROD_TYPE = {}));

			function l(T) {
				if (T instanceof o.Option) return c.OPTION;
				if (T instanceof o.Repetition) return c.REPETITION;
				if (T instanceof o.RepetitionMandatory) return c.REPETITION_MANDATORY;
				if (T instanceof o.RepetitionMandatoryWithSeparator) return c.REPETITION_MANDATORY_WITH_SEPARATOR;
				if (T instanceof o.RepetitionWithSeparator) return c.REPETITION_WITH_SEPARATOR;
				if (T instanceof o.Alternation) return c.ALTERNATION;
				throw Error("non exhaustive match")
			}
			r.getProdType = l;

			function u(T, N, V, O, k, I) {
				var q = y(T, N, V),
					B = b(q) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
				return I(q, O, B, k)
			}
			r.buildLookaheadFuncForOr = u;

			function h(T, N, V, O, k, I) {
				var q = w(T, N, k, V),
					B = b(q) ? s.tokenStructuredMatcherNoCategories : s.tokenStructuredMatcher;
				return I(q[0], B, O)
			}
			r.buildLookaheadFuncForOptionalProd = h;

			function f(T, N, V, O) {
				var k = T.length,
					I = t.every(T, function(Y) {
						return t.every(Y, function(J) {
							return J.length === 1
						})
					});
				if (N) return function(Y) {
					for (var J = t.map(Y, function(K) {
						return K.GATE
					}), H = 0; H < k; H++) {
						var $ = T[H],
							ae = $.length,
							oe = J[H];
						if (oe !== void 0 && oe.call(this) === !1) continue;
						e: for (var ie = 0; ie < ae; ie++) {
							for (var U = $[ie], A = U.length, L = 0; L < A; L++) {
								var j = this.LA(L + 1);
								if (V(j, U[L]) === !1) continue e
							}
							return H
						}
					}
				};
				if (I && !O) {
					var q = t.map(T, function(Y) {
							return t.flatten(Y)
						}),
						B = t.reduce(q, function(Y, J, H) {
							return t.forEach(J, function($) {
								t.has(Y, $.tokenTypeIdx) || (Y[$.tokenTypeIdx] = H), t.forEach($.categoryMatches, function(ae) {
									t.has(Y, ae) || (Y[ae] = H)
								})
							}), Y
						}, []);
					return function() {
						var Y = this.LA(1);
						return B[Y.tokenTypeIdx]
					}
				} else return function() {
					for (var Y = 0; Y < k; Y++) {
						var J = T[Y],
							H = J.length;
						e: for (var $ = 0; $ < H; $++) {
							for (var ae = J[$], oe = ae.length, ie = 0; ie < oe; ie++) {
								var U = this.LA(ie + 1);
								if (V(U, ae[ie]) === !1) continue e
							}
							return Y
						}
					}
				}
			}
			r.buildAlternativesLookAheadFunc = f;

			function p(T, N, V) {
				var O = t.every(T, function(J) {
						return J.length === 1
					}),
					k = T.length;
				if (O && !V) {
					var I = t.flatten(T);
					if (I.length === 1 && t.isEmpty(I[0].categoryMatches)) {
						var q = I[0],
							B = q.tokenTypeIdx;
						return function() {
							return this.LA(1)
								.tokenTypeIdx === B
						}
					} else {
						var Y = t.reduce(I, function(J, H, $) {
							return J[H.tokenTypeIdx] = !0, t.forEach(H.categoryMatches, function(ae) {
								J[ae] = !0
							}), J
						}, []);
						return function() {
							var J = this.LA(1);
							return Y[J.tokenTypeIdx] === !0
						}
					}
				} else return function() {
					e: for (var J = 0; J < k; J++) {
						for (var H = T[J], $ = H.length, ae = 0; ae < $; ae++) {
							var oe = this.LA(ae + 1);
							if (N(oe, H[ae]) === !1) continue e
						}
						return !0
					}
					return !1
				}
			}
			r.buildSingleAlternativeLookaheadFunction = p;
			var g = function(T) {
					e(N, T);

					function N(V, O, k) {
						var I = T.call(this) || this;
						return I.topProd = V, I.targetOccurrence = O, I.targetProdType = k, I
					}
					return N.prototype.startWalking = function() {
						return this.walk(this.topProd), this.restDef
					}, N.prototype.checkIsTarget = function(V, O, k, I) {
						return V.idx === this.targetOccurrence && this.targetProdType === O ? (this.restDef = k.concat(I), !0) : !1
					}, N.prototype.walkOption = function(V, O, k) {
						this.checkIsTarget(V, c.OPTION, O, k) || T.prototype.walkOption.call(this, V, O, k)
					}, N.prototype.walkAtLeastOne = function(V, O, k) {
						this.checkIsTarget(V, c.REPETITION_MANDATORY, O, k) || T.prototype.walkOption.call(this, V, O, k)
					}, N.prototype.walkAtLeastOneSep = function(V, O, k) {
						this.checkIsTarget(V, c.REPETITION_MANDATORY_WITH_SEPARATOR, O, k) || T.prototype.walkOption.call(this, V, O, k)
					}, N.prototype.walkMany = function(V, O, k) {
						this.checkIsTarget(V, c.REPETITION, O, k) || T.prototype.walkOption.call(this, V, O, k)
					}, N.prototype.walkManySep = function(V, O, k) {
						this.checkIsTarget(V, c.REPETITION_WITH_SEPARATOR, O, k) || T.prototype.walkOption.call(this, V, O, k)
					}, N
				}(i.RestWalker),
				m = function(T) {
					e(N, T);

					function N(V, O, k) {
						var I = T.call(this) || this;
						return I.targetOccurrence = V, I.targetProdType = O, I.targetRef = k, I.result = [], I
					}
					return N.prototype.checkIsTarget = function(V, O) {
						V.idx === this.targetOccurrence && this.targetProdType === O && (this.targetRef === void 0 || V === this.targetRef) && (this.result = V.definition)
					}, N.prototype.visitOption = function(V) {
						this.checkIsTarget(V, c.OPTION)
					}, N.prototype.visitRepetition = function(V) {
						this.checkIsTarget(V, c.REPETITION)
					}, N.prototype.visitRepetitionMandatory = function(V) {
						this.checkIsTarget(V, c.REPETITION_MANDATORY)
					}, N.prototype.visitRepetitionMandatoryWithSeparator = function(V) {
						this.checkIsTarget(V, c.REPETITION_MANDATORY_WITH_SEPARATOR)
					}, N.prototype.visitRepetitionWithSeparator = function(V) {
						this.checkIsTarget(V, c.REPETITION_WITH_SEPARATOR)
					}, N.prototype.visitAlternation = function(V) {
						this.checkIsTarget(V, c.ALTERNATION)
					}, N
				}(a.GAstVisitor);

			function d(T) {
				for (var N = new Array(T), V = 0; V < T; V++) N[V] = [];
				return N
			}

			function v(T) {
				for (var N = [""], V = 0; V < T.length; V++) {
					for (var O = T[V], k = [], I = 0; I < N.length; I++) {
						var q = N[I];
						k.push(q + "_" + O.tokenTypeIdx);
						for (var B = 0; B < O.categoryMatches.length; B++) {
							var Y = "_" + O.categoryMatches[B];
							k.push(q + Y)
						}
					}
					N = k
				}
				return N
			}

			function x(T, N, V) {
				for (var O = 0; O < T.length; O++)
					if (O !== V)
						for (var k = T[O], I = 0; I < N.length; I++) {
							var q = N[I];
							if (k[q] === !0) return !1
						}
				return !0
			}

			function _(T, N) {
				for (var V = t.map(T, function(H) {
					return n.possiblePathsFrom([H], 1)
				}), O = d(V.length), k = t.map(V, function(H) {
					var $ = {};
					return t.forEach(H, function(ae) {
						var oe = v(ae.partialPath);
						t.forEach(oe, function(ie) {
							$[ie] = !0
						})
					}), $
				}), I = V, q = 1; q <= N; q++) {
					var B = I;
					I = d(B.length);
					for (var Y = function(H) {
						for (var $ = B[H], ae = 0; ae < $.length; ae++) {
							var oe = $[ae].partialPath,
								ie = $[ae].suffixDef,
								U = v(oe),
								A = x(k, U, H);
							if (A || t.isEmpty(ie) || oe.length === N) {
								var L = O[H];
								if (C(L, oe) === !1) {
									L.push(oe);
									for (var j = 0; j < U.length; j++) {
										var K = U[j];
										k[H][K] = !0
									}
								}
							} else {
								var Q = n.possiblePathsFrom(ie, q + 1, oe);
								I[H] = I[H].concat(Q), t.forEach(Q, function(se) {
									var de = v(se.partialPath);
									t.forEach(de, function(ue) {
										k[H][ue] = !0
									})
								})
							}
						}
					}, J = 0; J < B.length; J++) Y(J)
				}
				return O
			}
			r.lookAheadSequenceFromAlternatives = _;

			function y(T, N, V, O) {
				var k = new m(T, c.ALTERNATION, O);
				return N.accept(k), _(k.result, V)
			}
			r.getLookaheadPathsForOr = y;

			function w(T, N, V, O) {
				var k = new m(T, V);
				N.accept(k);
				var I = k.result,
					q = new g(N, T, V),
					B = q.startWalking(),
					Y = new o.Alternative({
						definition: I
					}),
					J = new o.Alternative({
						definition: B
					});
				return _([Y, J], O)
			}
			r.getLookaheadPathsForOptionalProd = w;

			function C(T, N) {
				e: for (var V = 0; V < T.length; V++) {
					var O = T[V];
					if (O.length === N.length) {
						for (var k = 0; k < O.length; k++) {
							var I = N[k],
								q = O[k],
								B = I === q || q.categoryMatchesMap[I.tokenTypeIdx] !== void 0;
							if (B === !1) continue e
						}
						return !0
					}
				}
				return !1
			}
			r.containsPath = C;

			function S(T, N) {
				return T.length < N.length && t.every(T, function(V, O) {
					var k = N[O];
					return V === k || k.categoryMatchesMap[V.tokenTypeIdx]
				})
			}
			r.isStrictPrefixOfPath = S;

			function b(T) {
				return t.every(T, function(N) {
					return t.every(N, function(V) {
						return t.every(V, function(O) {
							return t.isEmpty(O.categoryMatches)
						})
					})
				})
			}
			r.areTokenCategoriesNotUsed = b
		}),
		Fx = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var O = function(k, I) {
					return O = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(q, B) {
						q.__proto__ = B
					} || function(q, B) {
						for (var Y in B) Object.prototype.hasOwnProperty.call(B, Y) && (q[Y] = B[Y])
					}, O(k, I)
				};
				return function(k, I) {
					if (typeof I != "function" && I !== null) throw new TypeError("Class extends value " + String(I) + " is not a constructor or null");
					O(k, I);

					function q() {
						this.constructor = k
					}
					k.prototype = I === null ? Object.create(I) : (q.prototype = I.prototype, new q)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.checkPrefixAlternativesAmbiguities = r.validateSomeNonEmptyLookaheadPath = r.validateTooManyAlts = r.RepetionCollector = r.validateAmbiguousAlternationAlternatives = r.validateEmptyOrAlternative = r.getFirstNoneTerminal = r.validateNoLeftRecursion = r.validateRuleIsOverridden = r.validateRuleDoesNotAlreadyExist = r.OccurrenceValidationCollector = r.identifyProductionForDuplicates = r.validateGrammar = void 0;
			var t = Ut(),
				n = Ut(),
				i = qi(),
				s = Mh(),
				o = Sh(),
				a = Th(),
				c = Ai(),
				l = nc();

			function u(O, k, I, q, B) {
				var Y = t.map(O, function(A) {
						return h(A, q)
					}),
					J = t.map(O, function(A) {
						return v(A, A, q)
					}),
					H = [],
					$ = [],
					ae = [];
				n.every(J, n.isEmpty) && (H = n.map(O, function(A) {
					return y(A, q)
				}), $ = n.map(O, function(A) {
					return w(A, k, q)
				}), ae = b(O, k, q));
				var oe = V(O, I, q),
					ie = n.map(O, function(A) {
						return S(A, q)
					}),
					U = n.map(O, function(A) {
						return m(A, O, B, q)
					});
				return t.flatten(Y.concat(ae, J, H, $, oe, ie, U))
			}
			r.validateGrammar = u;

			function h(O, k) {
				var I = new g;
				O.accept(I);
				var q = I.allProductions,
					B = t.groupBy(q, f),
					Y = t.pick(B, function(H) {
						return H.length > 1
					}),
					J = t.map(t.values(Y), function(H) {
						var $ = t.first(H),
							ae = k.buildDuplicateFoundError(O, H),
							oe = s.getProductionDslName($),
							ie = {
								message: ae,
								type: i.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
								ruleName: O.name,
								dslName: oe,
								occurrence: $.idx
							},
							U = p($);
						return U && (ie.parameter = U), ie
					});
				return J
			}

			function f(O) {
				return s.getProductionDslName(O) + "_#_" + O.idx + "_#_" + p(O)
			}
			r.identifyProductionForDuplicates = f;

			function p(O) {
				return O instanceof c.Terminal ? O.terminalType.name : O instanceof c.NonTerminal ? O.nonTerminalName : ""
			}
			var g = function(O) {
				e(k, O);

				function k() {
					var I = O !== null && O.apply(this, arguments) || this;
					return I.allProductions = [], I
				}
				return k.prototype.visitNonTerminal = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitOption = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetitionWithSeparator = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetitionMandatory = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetitionMandatoryWithSeparator = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetition = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitAlternation = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitTerminal = function(I) {
					this.allProductions.push(I)
				}, k
			}(l.GAstVisitor);
			r.OccurrenceValidationCollector = g;

			function m(O, k, I, q) {
				var B = [],
					Y = n.reduce(k, function(H, $) {
						return $.name === O.name ? H + 1 : H
					}, 0);
				if (Y > 1) {
					var J = q.buildDuplicateRuleNameError({
						topLevelRule: O,
						grammarName: I
					});
					B.push({
						message: J,
						type: i.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
						ruleName: O.name
					})
				}
				return B
			}
			r.validateRuleDoesNotAlreadyExist = m;

			function d(O, k, I) {
				var q = [],
					B;
				return t.contains(k, O) || (B = "Invalid rule override, rule: ->" + O + "<- cannot be overridden in the grammar: ->" + I + "<-as it is not defined in any of the super grammars ", q.push({
					message: B,
					type: i.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
					ruleName: O
				})), q
			}
			r.validateRuleIsOverridden = d;

			function v(O, k, I, q) {
				q === void 0 && (q = []);
				var B = [],
					Y = x(k.definition);
				if (t.isEmpty(Y)) return [];
				var J = O.name,
					H = t.contains(Y, O);
				H && B.push({
					message: I.buildLeftRecursionError({
						topLevelRule: O,
						leftRecursionPath: q
					}),
					type: i.ParserDefinitionErrorType.LEFT_RECURSION,
					ruleName: J
				});
				var $ = t.difference(Y, q.concat([O])),
					ae = t.map($, function(oe) {
						var ie = t.cloneArr(q);
						return ie.push(oe), v(O, oe, I, ie)
					});
				return B.concat(t.flatten(ae))
			}
			r.validateNoLeftRecursion = v;

			function x(O) {
				var k = [];
				if (t.isEmpty(O)) return k;
				var I = t.first(O);
				if (I instanceof c.NonTerminal) k.push(I.referencedRule);
				else if (I instanceof c.Alternative || I instanceof c.Option || I instanceof c.RepetitionMandatory || I instanceof c.RepetitionMandatoryWithSeparator || I instanceof c.RepetitionWithSeparator || I instanceof c.Repetition) k = k.concat(x(I.definition));
				else if (I instanceof c.Alternation) k = t.flatten(t.map(I.definition, function(J) {
					return x(J.definition)
				}));
				else if (!(I instanceof c.Terminal)) throw Error("non exhaustive match");
				var q = s.isOptionalProd(I),
					B = O.length > 1;
				if (q && B) {
					var Y = t.drop(O);
					return k.concat(x(Y))
				} else return k
			}
			r.getFirstNoneTerminal = x;
			var _ = function(O) {
				e(k, O);

				function k() {
					var I = O !== null && O.apply(this, arguments) || this;
					return I.alternations = [], I
				}
				return k.prototype.visitAlternation = function(I) {
					this.alternations.push(I)
				}, k
			}(l.GAstVisitor);

			function y(O, k) {
				var I = new _;
				O.accept(I);
				var q = I.alternations,
					B = t.reduce(q, function(Y, J) {
						var H = t.dropRight(J.definition),
							$ = t.map(H, function(ae, oe) {
								var ie = a.nextPossibleTokensAfter([ae], [], null, 1);
								return t.isEmpty(ie) ? {
									message: k.buildEmptyAlternationError({
										topLevelRule: O,
										alternation: J,
										emptyChoiceIdx: oe
									}),
									type: i.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
									ruleName: O.name,
									occurrence: J.idx,
									alternative: oe + 1
								} : null
							});
						return Y.concat(t.compact($))
					}, []);
				return B
			}
			r.validateEmptyOrAlternative = y;

			function w(O, k, I) {
				var q = new _;
				O.accept(q);
				var B = q.alternations;
				B = n.reject(B, function(J) {
					return J.ignoreAmbiguities === !0
				});
				var Y = t.reduce(B, function(J, H) {
					var $ = H.idx,
						ae = H.maxLookahead || k,
						oe = o.getLookaheadPathsForOr($, O, ae, H),
						ie = T(oe, H, O, I),
						U = N(oe, H, O, I);
					return J.concat(ie, U)
				}, []);
				return Y
			}
			r.validateAmbiguousAlternationAlternatives = w;
			var C = function(O) {
				e(k, O);

				function k() {
					var I = O !== null && O.apply(this, arguments) || this;
					return I.allProductions = [], I
				}
				return k.prototype.visitRepetitionWithSeparator = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetitionMandatory = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetitionMandatoryWithSeparator = function(I) {
					this.allProductions.push(I)
				}, k.prototype.visitRepetition = function(I) {
					this.allProductions.push(I)
				}, k
			}(l.GAstVisitor);
			r.RepetionCollector = C;

			function S(O, k) {
				var I = new _;
				O.accept(I);
				var q = I.alternations,
					B = t.reduce(q, function(Y, J) {
						return J.definition.length > 255 && Y.push({
							message: k.buildTooManyAlternativesError({
								topLevelRule: O,
								alternation: J
							}),
							type: i.ParserDefinitionErrorType.TOO_MANY_ALTS,
							ruleName: O.name,
							occurrence: J.idx
						}), Y
					}, []);
				return B
			}
			r.validateTooManyAlts = S;

			function b(O, k, I) {
				var q = [];
				return n.forEach(O, function(B) {
					var Y = new C;
					B.accept(Y);
					var J = Y.allProductions;
					n.forEach(J, function(H) {
						var $ = o.getProdType(H),
							ae = H.maxLookahead || k,
							oe = H.idx,
							ie = o.getLookaheadPathsForOptionalProd(oe, B, $, ae),
							U = ie[0];
						if (n.isEmpty(n.flatten(U))) {
							var A = I.buildEmptyRepetitionError({
								topLevelRule: B,
								repetition: H
							});
							q.push({
								message: A,
								type: i.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
								ruleName: B.name
							})
						}
					})
				}), q
			}
			r.validateSomeNonEmptyLookaheadPath = b;

			function T(O, k, I, q) {
				var B = [],
					Y = n.reduce(O, function(H, $, ae) {
						return k.definition[ae].ignoreAmbiguities === !0 || n.forEach($, function(oe) {
							var ie = [ae];
							n.forEach(O, function(U, A) {
								ae !== A && o.containsPath(U, oe) && k.definition[A].ignoreAmbiguities !== !0 && ie.push(A)
							}), ie.length > 1 && !o.containsPath(B, oe) && (B.push(oe), H.push({
								alts: ie,
								path: oe
							}))
						}), H
					}, []),
					J = t.map(Y, function(H) {
						var $ = n.map(H.alts, function(oe) {
								return oe + 1
							}),
							ae = q.buildAlternationAmbiguityError({
								topLevelRule: I,
								alternation: k,
								ambiguityIndices: $,
								prefixPath: H.path
							});
						return {
							message: ae,
							type: i.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
							ruleName: I.name,
							occurrence: k.idx,
							alternatives: [H.alts]
						}
					});
				return J
			}

			function N(O, k, I, q) {
				var B = [],
					Y = n.reduce(O, function(J, H, $) {
						var ae = n.map(H, function(oe) {
							return {
								idx: $,
								path: oe
							}
						});
						return J.concat(ae)
					}, []);
				return n.forEach(Y, function(J) {
					var H = k.definition[J.idx];
					if (H.ignoreAmbiguities !== !0) {
						var $ = J.idx,
							ae = J.path,
							oe = n.findAll(Y, function(U) {
								return k.definition[U.idx].ignoreAmbiguities !== !0 && U.idx < $ && o.isStrictPrefixOfPath(U.path, ae)
							}),
							ie = n.map(oe, function(U) {
								var A = [U.idx + 1, $ + 1],
									L = k.idx === 0 ? "" : k.idx,
									j = q.buildAlternationPrefixAmbiguityError({
										topLevelRule: I,
										alternation: k,
										ambiguityIndices: A,
										prefixPath: U.path
									});
								return {
									message: j,
									type: i.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
									ruleName: I.name,
									occurrence: L,
									alternatives: A
								}
							});
						B = B.concat(ie)
					}
				}), B
			}
			r.checkPrefixAlternativesAmbiguities = N;

			function V(O, k, I) {
				var q = [],
					B = n.map(k, function(Y) {
						return Y.name
					});
				return n.forEach(O, function(Y) {
					var J = Y.name;
					if (n.contains(B, J)) {
						var H = I.buildNamespaceConflictError(Y);
						q.push({
							message: H,
							type: i.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
							ruleName: J
						})
					}
				}), q
			}
		}),
		RE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.validateGrammar = r.resolveGrammar = void 0;
			var e = Ut(),
				t = IE(),
				n = Fx(),
				i = wh();

			function s(a) {
				a = e.defaults(a, {
					errMsgProvider: i.defaultGrammarResolverErrorProvider
				});
				var c = {};
				return e.forEach(a.rules, function(l) {
					c[l.name] = l
				}), t.resolveGrammar(c, a.errMsgProvider)
			}
			r.resolveGrammar = s;

			function o(a) {
				return a = e.defaults(a, {
					errMsgProvider: i.defaultGrammarValidatorErrorProvider
				}), n.validateGrammar(a.rules, a.maxLookahead, a.tokenTypes, a.errMsgProvider, a.grammarName)
			}
			r.validateGrammar = o
		}),
		ic = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var g = function(m, d) {
					return g = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(v, x) {
						v.__proto__ = x
					} || function(v, x) {
						for (var _ in x) Object.prototype.hasOwnProperty.call(x, _) && (v[_] = x[_])
					}, g(m, d)
				};
				return function(m, d) {
					if (typeof d != "function" && d !== null) throw new TypeError("Class extends value " + String(d) + " is not a constructor or null");
					g(m, d);

					function v() {
						this.constructor = m
					}
					m.prototype = d === null ? Object.create(d) : (v.prototype = d.prototype, new v)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.EarlyExitException = r.NotAllInputParsedException = r.NoViableAltException = r.MismatchedTokenException = r.isRecognitionException = void 0;
			var t = Ut(),
				n = "MismatchedTokenException",
				i = "NoViableAltException",
				s = "EarlyExitException",
				o = "NotAllInputParsedException",
				a = [n, i, s, o];
			Object.freeze(a);

			function c(g) {
				return t.contains(a, g.name)
			}
			r.isRecognitionException = c;
			var l = function(g) {
					e(m, g);

					function m(d, v) {
						var x = this.constructor,
							_ = g.call(this, d) || this;
						return _.token = v, _.resyncedTokens = [], Object.setPrototypeOf(_, x.prototype), Error.captureStackTrace && Error.captureStackTrace(_, _.constructor), _
					}
					return m
				}(Error),
				u = function(g) {
					e(m, g);

					function m(d, v, x) {
						var _ = g.call(this, d, v) || this;
						return _.previousToken = x, _.name = n, _
					}
					return m
				}(l);
			r.MismatchedTokenException = u;
			var h = function(g) {
				e(m, g);

				function m(d, v, x) {
					var _ = g.call(this, d, v) || this;
					return _.previousToken = x, _.name = i, _
				}
				return m
			}(l);
			r.NoViableAltException = h;
			var f = function(g) {
				e(m, g);

				function m(d, v) {
					var x = g.call(this, d, v) || this;
					return x.name = o, x
				}
				return m
			}(l);
			r.NotAllInputParsedException = f;
			var p = function(g) {
				e(m, g);

				function m(d, v, x) {
					var _ = g.call(this, d, v) || this;
					return _.previousToken = x, _.name = s, _
				}
				return m
			}(l);
			r.EarlyExitException = p
		}),
		Ux = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.attemptInRepetitionRecovery = r.Recoverable = r.InRuleRecoveryException = r.IN_RULE_RECOVERY_EXCEPTION = r.EOF_FOLLOW_KEY = void 0;
			var e = Po(),
				t = Ut(),
				n = ic(),
				i = kx(),
				s = qi();
			r.EOF_FOLLOW_KEY = {}, r.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";

			function o(l) {
				this.name = r.IN_RULE_RECOVERY_EXCEPTION, this.message = l
			}
			r.InRuleRecoveryException = o, o.prototype = Error.prototype;
			var a = function() {
				function l() {}
				return l.prototype.initRecoverable = function(u) {
					this.firstAfterRepMap = {}, this.resyncFollows = {}, this.recoveryEnabled = t.has(u, "recoveryEnabled") ? u.recoveryEnabled : s.DEFAULT_PARSER_CONFIG.recoveryEnabled, this.recoveryEnabled && (this.attemptInRepetitionRecovery = c)
				}, l.prototype.getTokenToInsert = function(u) {
					var h = e.createTokenInstance(u, "", NaN, NaN, NaN, NaN, NaN, NaN);
					return h.isInsertedInRecovery = !0, h
				}, l.prototype.canTokenTypeBeInsertedInRecovery = function(u) {
					return !0
				}, l.prototype.tryInRepetitionRecovery = function(u, h, f, p) {
					for (var g = this, m = this.findReSyncTokenType(), d = this.exportLexerState(), v = [], x = !1, _ = this.LA(1), y = this.LA(1), w = function() {
						var C = g.LA(0),
							S = g.errorMessageProvider.buildMismatchTokenMessage({
								expected: p,
								actual: _,
								previous: C,
								ruleName: g.getCurrRuleFullName()
							}),
							b = new n.MismatchedTokenException(S, _, g.LA(0));
						b.resyncedTokens = t.dropRight(v), g.SAVE_ERROR(b)
					}; !x;)
						if (this.tokenMatcher(y, p)) {
							w();
							return
						} else if (f.call(this)) {
						w(), u.apply(this, h);
						return
					} else this.tokenMatcher(y, m) ? x = !0 : (y = this.SKIP_TOKEN(), this.addToResyncTokens(y, v));
					this.importLexerState(d)
				}, l.prototype.shouldInRepetitionRecoveryBeTried = function(u, h, f) {
					return !(f === !1 || u === void 0 || h === void 0 || this.tokenMatcher(this.LA(1), u) || this.isBackTracking() || this.canPerformInRuleRecovery(u, this.getFollowsForInRuleRecovery(u, h)))
				}, l.prototype.getFollowsForInRuleRecovery = function(u, h) {
					var f = this.getCurrentGrammarPath(u, h),
						p = this.getNextPossibleTokenTypes(f);
					return p
				}, l.prototype.tryInRuleRecovery = function(u, h) {
					if (this.canRecoverWithSingleTokenInsertion(u, h)) {
						var f = this.getTokenToInsert(u);
						return f
					}
					if (this.canRecoverWithSingleTokenDeletion(u)) {
						var p = this.SKIP_TOKEN();
						return this.consumeToken(), p
					}
					throw new o("sad sad panda")
				}, l.prototype.canPerformInRuleRecovery = function(u, h) {
					return this.canRecoverWithSingleTokenInsertion(u, h) || this.canRecoverWithSingleTokenDeletion(u)
				}, l.prototype.canRecoverWithSingleTokenInsertion = function(u, h) {
					var f = this;
					if (!this.canTokenTypeBeInsertedInRecovery(u) || t.isEmpty(h)) return !1;
					var p = this.LA(1),
						g = t.find(h, function(m) {
							return f.tokenMatcher(p, m)
						}) !== void 0;
					return g
				}, l.prototype.canRecoverWithSingleTokenDeletion = function(u) {
					var h = this.tokenMatcher(this.LA(2), u);
					return h
				}, l.prototype.isInCurrentRuleReSyncSet = function(u) {
					var h = this.getCurrFollowKey(),
						f = this.getFollowSetFromFollowKey(h);
					return t.contains(f, u)
				}, l.prototype.findReSyncTokenType = function() {
					for (var u = this.flattenFollowSet(), h = this.LA(1), f = 2;;) {
						var p = h.tokenType;
						if (t.contains(u, p)) return p;
						h = this.LA(f), f++
					}
				}, l.prototype.getCurrFollowKey = function() {
					if (this.RULE_STACK.length === 1) return r.EOF_FOLLOW_KEY;
					var u = this.getLastExplicitRuleShortName(),
						h = this.getLastExplicitRuleOccurrenceIndex(),
						f = this.getPreviousExplicitRuleShortName();
					return {
						ruleName: this.shortRuleNameToFullName(u),
						idxInCallingRule: h,
						inRule: this.shortRuleNameToFullName(f)
					}
				}, l.prototype.buildFullFollowKeyStack = function() {
					var u = this,
						h = this.RULE_STACK,
						f = this.RULE_OCCURRENCE_STACK;
					return t.map(h, function(p, g) {
						return g === 0 ? r.EOF_FOLLOW_KEY : {
							ruleName: u.shortRuleNameToFullName(p),
							idxInCallingRule: f[g],
							inRule: u.shortRuleNameToFullName(h[g - 1])
						}
					})
				}, l.prototype.flattenFollowSet = function() {
					var u = this,
						h = t.map(this.buildFullFollowKeyStack(), function(f) {
							return u.getFollowSetFromFollowKey(f)
						});
					return t.flatten(h)
				}, l.prototype.getFollowSetFromFollowKey = function(u) {
					if (u === r.EOF_FOLLOW_KEY) return [e.EOF];
					var h = u.ruleName + u.idxInCallingRule + i.IN + u.inRule;
					return this.resyncFollows[h]
				}, l.prototype.addToResyncTokens = function(u, h) {
					return this.tokenMatcher(u, e.EOF) || h.push(u), h
				}, l.prototype.reSyncTo = function(u) {
					for (var h = [], f = this.LA(1); this.tokenMatcher(f, u) === !1;) f = this.SKIP_TOKEN(), this.addToResyncTokens(f, h);
					return t.dropRight(h)
				}, l.prototype.attemptInRepetitionRecovery = function(u, h, f, p, g, m, d) {}, l.prototype.getCurrentGrammarPath = function(u, h) {
					var f = this.getHumanReadableRuleStack(),
						p = t.cloneArr(this.RULE_OCCURRENCE_STACK),
						g = {
							ruleStack: f,
							occurrenceStack: p,
							lastTok: u,
							lastTokOccurrence: h
						};
					return g
				}, l.prototype.getHumanReadableRuleStack = function() {
					var u = this;
					return t.map(this.RULE_STACK, function(h) {
						return u.shortRuleNameToFullName(h)
					})
				}, l
			}();
			r.Recoverable = a;

			function c(l, u, h, f, p, g, m) {
				var d = this.getKeyForAutomaticLookahead(f, p),
					v = this.firstAfterRepMap[d];
				if (v === void 0) {
					var x = this.getCurrRuleFullName(),
						_ = this.getGAstProductions()[x],
						y = new g(_, p);
					v = y.startWalking(), this.firstAfterRepMap[d] = v
				}
				var w = v.token,
					C = v.occurrence,
					S = v.isEndOfRule;
				this.RULE_STACK.length === 1 && S && w === void 0 && (w = e.EOF, C = 1), this.shouldInRepetitionRecoveryBeTried(w, C, m) && this.tryInRepetitionRecovery(l, u, h, w)
			}
			r.attemptInRepetitionRecovery = c
		}),
		im = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.getKeyForAutomaticLookahead = r.AT_LEAST_ONE_SEP_IDX = r.MANY_SEP_IDX = r.AT_LEAST_ONE_IDX = r.MANY_IDX = r.OPTION_IDX = r.OR_IDX = r.BITS_FOR_ALT_IDX = r.BITS_FOR_RULE_IDX = r.BITS_FOR_OCCURRENCE_IDX = r.BITS_FOR_METHOD_TYPE = void 0, r.BITS_FOR_METHOD_TYPE = 4, r.BITS_FOR_OCCURRENCE_IDX = 8, r.BITS_FOR_RULE_IDX = 12, r.BITS_FOR_ALT_IDX = 8, r.OR_IDX = 1 << r.BITS_FOR_OCCURRENCE_IDX, r.OPTION_IDX = 2 << r.BITS_FOR_OCCURRENCE_IDX, r.MANY_IDX = 3 << r.BITS_FOR_OCCURRENCE_IDX, r.AT_LEAST_ONE_IDX = 4 << r.BITS_FOR_OCCURRENCE_IDX, r.MANY_SEP_IDX = 5 << r.BITS_FOR_OCCURRENCE_IDX, r.AT_LEAST_ONE_SEP_IDX = 6 << r.BITS_FOR_OCCURRENCE_IDX;

			function e(n, i, s) {
				return s | i | n
			}
			r.getKeyForAutomaticLookahead = e;
			var t = 32 - r.BITS_FOR_ALT_IDX
		}),
		PE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.LooksAhead = void 0;
			var e = Sh(),
				t = Ut(),
				n = qi(),
				i = im(),
				s = Mh(),
				o = function() {
					function a() {}
					return a.prototype.initLooksAhead = function(c) {
						this.dynamicTokensEnabled = t.has(c, "dynamicTokensEnabled") ? c.dynamicTokensEnabled : n.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled, this.maxLookahead = t.has(c, "maxLookahead") ? c.maxLookahead : n.DEFAULT_PARSER_CONFIG.maxLookahead, this.lookAheadFuncsCache = t.isES2015MapSupported() ? new Map : [], t.isES2015MapSupported() ? (this.getLaFuncFromCache = this.getLaFuncFromMap, this.setLaFuncCache = this.setLaFuncCacheUsingMap) : (this.getLaFuncFromCache = this.getLaFuncFromObj, this.setLaFuncCache = this.setLaFuncUsingObj)
					}, a.prototype.preComputeLookaheadFunctions = function(c) {
						var l = this;
						t.forEach(c, function(u) {
							l.TRACE_INIT(u.name + " Rule Lookahead", function() {
								var h = s.collectMethods(u),
									f = h.alternation,
									p = h.repetition,
									g = h.option,
									m = h.repetitionMandatory,
									d = h.repetitionMandatoryWithSeparator,
									v = h.repetitionWithSeparator;
								t.forEach(f, function(x) {
									var _ = x.idx === 0 ? "" : x.idx;
									l.TRACE_INIT("" + s.getProductionDslName(x) + _, function() {
										var y = e.buildLookaheadFuncForOr(x.idx, u, x.maxLookahead || l.maxLookahead, x.hasPredicates, l.dynamicTokensEnabled, l.lookAheadBuilderForAlternatives),
											w = i.getKeyForAutomaticLookahead(l.fullRuleNameToShort[u.name], i.OR_IDX, x.idx);
										l.setLaFuncCache(w, y)
									})
								}), t.forEach(p, function(x) {
									l.computeLookaheadFunc(u, x.idx, i.MANY_IDX, e.PROD_TYPE.REPETITION, x.maxLookahead, s.getProductionDslName(x))
								}), t.forEach(g, function(x) {
									l.computeLookaheadFunc(u, x.idx, i.OPTION_IDX, e.PROD_TYPE.OPTION, x.maxLookahead, s.getProductionDslName(x))
								}), t.forEach(m, function(x) {
									l.computeLookaheadFunc(u, x.idx, i.AT_LEAST_ONE_IDX, e.PROD_TYPE.REPETITION_MANDATORY, x.maxLookahead, s.getProductionDslName(x))
								}), t.forEach(d, function(x) {
									l.computeLookaheadFunc(u, x.idx, i.AT_LEAST_ONE_SEP_IDX, e.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, x.maxLookahead, s.getProductionDslName(x))
								}), t.forEach(v, function(x) {
									l.computeLookaheadFunc(u, x.idx, i.MANY_SEP_IDX, e.PROD_TYPE.REPETITION_WITH_SEPARATOR, x.maxLookahead, s.getProductionDslName(x))
								})
							})
						})
					}, a.prototype.computeLookaheadFunc = function(c, l, u, h, f, p) {
						var g = this;
						this.TRACE_INIT("" + p + (l === 0 ? "" : l), function() {
							var m = e.buildLookaheadFuncForOptionalProd(l, c, f || g.maxLookahead, g.dynamicTokensEnabled, h, g.lookAheadBuilderForOptional),
								d = i.getKeyForAutomaticLookahead(g.fullRuleNameToShort[c.name], u, l);
							g.setLaFuncCache(d, m)
						})
					}, a.prototype.lookAheadBuilderForOptional = function(c, l, u) {
						return e.buildSingleAlternativeLookaheadFunction(c, l, u)
					}, a.prototype.lookAheadBuilderForAlternatives = function(c, l, u, h) {
						return e.buildAlternativesLookAheadFunc(c, l, u, h)
					}, a.prototype.getKeyForAutomaticLookahead = function(c, l) {
						var u = this.getLastExplicitRuleShortName();
						return i.getKeyForAutomaticLookahead(u, c, l)
					}, a.prototype.getLaFuncFromCache = function(c) {}, a.prototype.getLaFuncFromMap = function(c) {
						return this.lookAheadFuncsCache.get(c)
					}, a.prototype.getLaFuncFromObj = function(c) {
						return this.lookAheadFuncsCache[c]
					}, a.prototype.setLaFuncCache = function(c, l) {}, a.prototype.setLaFuncCacheUsingMap = function(c, l) {
						this.lookAheadFuncsCache.set(c, l)
					}, a.prototype.setLaFuncUsingObj = function(c, l) {
						this.lookAheadFuncsCache[c] = l
					}, a
				}();
			r.LooksAhead = o
		}),
		LE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.addNoneTerminalToCst = r.addTerminalToCst = r.setNodeLocationFull = r.setNodeLocationOnlyOffset = void 0;

			function e(s, o) {
				isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset, s.endOffset = o.endOffset) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset)
			}
			r.setNodeLocationOnlyOffset = e;

			function t(s, o) {
				isNaN(s.startOffset) === !0 ? (s.startOffset = o.startOffset, s.startColumn = o.startColumn, s.startLine = o.startLine, s.endOffset = o.endOffset, s.endColumn = o.endColumn, s.endLine = o.endLine) : s.endOffset < o.endOffset && (s.endOffset = o.endOffset, s.endColumn = o.endColumn, s.endLine = o.endLine)
			}
			r.setNodeLocationFull = t;

			function n(s, o, a) {
				s.children[a] === void 0 ? s.children[a] = [o] : s.children[a].push(o)
			}
			r.addTerminalToCst = n;

			function i(s, o, a) {
				s.children[o] === void 0 ? s.children[o] = [a] : s.children[o].push(a)
			}
			r.addNoneTerminalToCst = i
		}),
		Bx = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.defineNameProp = r.functionName = r.classNameFromInstance = void 0;
			var e = Ut();

			function t(o) {
				return i(o.constructor)
			}
			r.classNameFromInstance = t;
			var n = "name";

			function i(o) {
				var a = o.name;
				return a || "anonymous"
			}
			r.functionName = i;

			function s(o, a) {
				var c = Object.getOwnPropertyDescriptor(o, n);
				return e.isUndefined(c) || c.configurable ? (Object.defineProperty(o, n, {
					enumerable: !1,
					configurable: !0,
					writable: !1,
					value: a
				}), !0) : !1
			}
			r.defineNameProp = s
		}),
		NE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.validateRedundantMethods = r.validateMissingCstMethods = r.validateVisitor = r.CstVisitorDefinitionError = r.createBaseVisitorConstructorWithDefaults = r.createBaseSemanticVisitorConstructor = r.defaultVisit = void 0;
			var e = Ut(),
				t = Bx();

			function n(h, f) {
				for (var p = e.keys(h), g = p.length, m = 0; m < g; m++)
					for (var d = p[m], v = h[d], x = v.length, _ = 0; _ < x; _++) {
						var y = v[_];
						y.tokenTypeIdx === void 0 && this[y.name](y.children, f)
					}
			}
			r.defaultVisit = n;

			function i(h, f) {
				var p = function() {};
				t.defineNameProp(p, h + "BaseSemantics");
				var g = {
					visit: function(m, d) {
						if (e.isArray(m) && (m = m[0]), !e.isUndefined(m)) return this[m.name](m.children, d)
					},
					validateVisitor: function() {
						var m = a(this, f);
						if (!e.isEmpty(m)) {
							var d = e.map(m, function(v) {
								return v.msg
							});
							throw Error("Errors Detected in CST Visitor <" + t.functionName(this.constructor) + `>:
	` + ("" + d.join(`

`)
								.replace(/\n/g, `
	`)))
						}
					}
				};
				return p.prototype = g, p.prototype.constructor = p, p._RULE_NAMES = f, p
			}
			r.createBaseSemanticVisitorConstructor = i;

			function s(h, f, p) {
				var g = function() {};
				t.defineNameProp(g, h + "BaseSemanticsWithDefaults");
				var m = Object.create(p.prototype);
				return e.forEach(f, function(d) {
					m[d] = n
				}), g.prototype = m, g.prototype.constructor = g, g
			}
			r.createBaseVisitorConstructorWithDefaults = s;
			var o;
			(function(h) {
				h[h.REDUNDANT_METHOD = 0] = "REDUNDANT_METHOD", h[h.MISSING_METHOD = 1] = "MISSING_METHOD"
			})(o = r.CstVisitorDefinitionError || (r.CstVisitorDefinitionError = {}));

			function a(h, f) {
				var p = c(h, f),
					g = u(h, f);
				return p.concat(g)
			}
			r.validateVisitor = a;

			function c(h, f) {
				var p = e.map(f, function(g) {
					if (!e.isFunction(h[g])) return {
						msg: "Missing visitor method: <" + g + "> on " + t.functionName(h.constructor) + " CST Visitor.",
						type: o.MISSING_METHOD,
						methodName: g
					}
				});
				return e.compact(p)
			}
			r.validateMissingCstMethods = c;
			var l = ["constructor", "visit", "validateVisitor"];

			function u(h, f) {
				var p = [];
				for (var g in h) e.isFunction(h[g]) && !e.contains(l, g) && !e.contains(f, g) && p.push({
					msg: "Redundant visitor method: <" + g + "> on " + t.functionName(h.constructor) + ` CST Visitor
There is no Grammar Rule corresponding to this method's name.
`,
					type: o.REDUNDANT_METHOD,
					methodName: g
				});
				return p
			}
			r.validateRedundantMethods = u
		}),
		DE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.TreeBuilder = void 0;
			var e = LE(),
				t = Ut(),
				n = NE(),
				i = qi(),
				s = function() {
					function o() {}
					return o.prototype.initTreeBuilder = function(a) {
						if (this.CST_STACK = [], this.outputCst = a.outputCst, this.nodeLocationTracking = t.has(a, "nodeLocationTracking") ? a.nodeLocationTracking : i.DEFAULT_PARSER_CONFIG.nodeLocationTracking, !this.outputCst) this.cstInvocationStateUpdate = t.NOOP, this.cstFinallyStateUpdate = t.NOOP, this.cstPostTerminal = t.NOOP, this.cstPostNonTerminal = t.NOOP, this.cstPostRule = t.NOOP;
						else if (/full/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationFull, this.setNodeLocationFromNode = e.setNodeLocationFull, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery) : (this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = this.cstPostRuleFull, this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular);
						else if (/onlyOffset/i.test(this.nodeLocationTracking)) this.recoveryEnabled ? (this.setNodeLocationFromToken = e.setNodeLocationOnlyOffset, this.setNodeLocationFromNode = e.setNodeLocationOnlyOffset, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery) : (this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = this.cstPostRuleOnlyOffset, this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular);
						else if (/none/i.test(this.nodeLocationTracking)) this.setNodeLocationFromToken = t.NOOP, this.setNodeLocationFromNode = t.NOOP, this.cstPostRule = t.NOOP, this.setInitialNodeLocation = t.NOOP;
						else throw Error('Invalid <nodeLocationTracking> config option: "' + a.nodeLocationTracking + '"')
					}, o.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(a) {
						a.location = {
							startOffset: NaN,
							endOffset: NaN
						}
					}, o.prototype.setInitialNodeLocationOnlyOffsetRegular = function(a) {
						a.location = {
							startOffset: this.LA(1)
								.startOffset,
							endOffset: NaN
						}
					}, o.prototype.setInitialNodeLocationFullRecovery = function(a) {
						a.location = {
							startOffset: NaN,
							startLine: NaN,
							startColumn: NaN,
							endOffset: NaN,
							endLine: NaN,
							endColumn: NaN
						}
					}, o.prototype.setInitialNodeLocationFullRegular = function(a) {
						var c = this.LA(1);
						a.location = {
							startOffset: c.startOffset,
							startLine: c.startLine,
							startColumn: c.startColumn,
							endOffset: NaN,
							endLine: NaN,
							endColumn: NaN
						}
					}, o.prototype.cstInvocationStateUpdate = function(a, c) {
						var l = {
							name: a,
							children: {}
						};
						this.setInitialNodeLocation(l), this.CST_STACK.push(l)
					}, o.prototype.cstFinallyStateUpdate = function() {
						this.CST_STACK.pop()
					}, o.prototype.cstPostRuleFull = function(a) {
						var c = this.LA(0),
							l = a.location;
						l.startOffset <= c.startOffset ? (l.endOffset = c.endOffset, l.endLine = c.endLine, l.endColumn = c.endColumn) : (l.startOffset = NaN, l.startLine = NaN, l.startColumn = NaN)
					}, o.prototype.cstPostRuleOnlyOffset = function(a) {
						var c = this.LA(0),
							l = a.location;
						l.startOffset <= c.startOffset ? l.endOffset = c.endOffset : l.startOffset = NaN
					}, o.prototype.cstPostTerminal = function(a, c) {
						var l = this.CST_STACK[this.CST_STACK.length - 1];
						e.addTerminalToCst(l, c, a), this.setNodeLocationFromToken(l.location, c)
					}, o.prototype.cstPostNonTerminal = function(a, c) {
						var l = this.CST_STACK[this.CST_STACK.length - 1];
						e.addNoneTerminalToCst(l, c, a), this.setNodeLocationFromNode(l.location, a.location)
					}, o.prototype.getBaseCstVisitorConstructor = function() {
						if (t.isUndefined(this.baseCstVisitorConstructor)) {
							var a = n.createBaseSemanticVisitorConstructor(this.className, t.keys(this.gastProductionsCache));
							return this.baseCstVisitorConstructor = a, a
						}
						return this.baseCstVisitorConstructor
					}, o.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
						if (t.isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {
							var a = n.createBaseVisitorConstructorWithDefaults(this.className, t.keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
							return this.baseCstVisitorWithDefaultsConstructor = a, a
						}
						return this.baseCstVisitorWithDefaultsConstructor
					}, o.prototype.getLastExplicitRuleShortName = function() {
						var a = this.RULE_STACK;
						return a[a.length - 1]
					}, o.prototype.getPreviousExplicitRuleShortName = function() {
						var a = this.RULE_STACK;
						return a[a.length - 2]
					}, o.prototype.getLastExplicitRuleOccurrenceIndex = function() {
						var a = this.RULE_OCCURRENCE_STACK;
						return a[a.length - 1]
					}, o
				}();
			r.TreeBuilder = s
		}),
		OE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.LexerAdapter = void 0;
			var e = qi(),
				t = function() {
					function n() {}
					return n.prototype.initLexerAdapter = function() {
						this.tokVector = [], this.tokVectorLength = 0, this.currIdx = -1
					}, Object.defineProperty(n.prototype, "input", {
						get: function() {
							return this.tokVector
						},
						set: function(i) {
							if (this.selfAnalysisDone !== !0) throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
							this.reset(), this.tokVector = i, this.tokVectorLength = i.length
						},
						enumerable: !1,
						configurable: !0
					}), n.prototype.SKIP_TOKEN = function() {
						return this.currIdx <= this.tokVector.length - 2 ? (this.consumeToken(), this.LA(1)) : e.END_OF_FILE
					}, n.prototype.LA = function(i) {
						var s = this.currIdx + i;
						return s < 0 || this.tokVectorLength <= s ? e.END_OF_FILE : this.tokVector[s]
					}, n.prototype.consumeToken = function() {
						this.currIdx++
					}, n.prototype.exportLexerState = function() {
						return this.currIdx
					}, n.prototype.importLexerState = function(i) {
						this.currIdx = i
					}, n.prototype.resetLexerState = function() {
						this.currIdx = -1
					}, n.prototype.moveToTerminatedState = function() {
						this.currIdx = this.tokVector.length - 1
					}, n.prototype.getLexerPosition = function() {
						return this.exportLexerState()
					}, n
				}();
			r.LexerAdapter = t
		}),
		kE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RecognizerApi = void 0;
			var e = Ut(),
				t = ic(),
				n = qi(),
				i = wh(),
				s = Fx(),
				o = Ai(),
				a = function() {
					function c() {}
					return c.prototype.ACTION = function(l) {
						return l.call(this)
					}, c.prototype.consume = function(l, u, h) {
						return this.consumeInternal(u, l, h)
					}, c.prototype.subrule = function(l, u, h) {
						return this.subruleInternal(u, l, h)
					}, c.prototype.option = function(l, u) {
						return this.optionInternal(u, l)
					}, c.prototype.or = function(l, u) {
						return this.orInternal(u, l)
					}, c.prototype.many = function(l, u) {
						return this.manyInternal(l, u)
					}, c.prototype.atLeastOne = function(l, u) {
						return this.atLeastOneInternal(l, u)
					}, c.prototype.CONSUME = function(l, u) {
						return this.consumeInternal(l, 0, u)
					}, c.prototype.CONSUME1 = function(l, u) {
						return this.consumeInternal(l, 1, u)
					}, c.prototype.CONSUME2 = function(l, u) {
						return this.consumeInternal(l, 2, u)
					}, c.prototype.CONSUME3 = function(l, u) {
						return this.consumeInternal(l, 3, u)
					}, c.prototype.CONSUME4 = function(l, u) {
						return this.consumeInternal(l, 4, u)
					}, c.prototype.CONSUME5 = function(l, u) {
						return this.consumeInternal(l, 5, u)
					}, c.prototype.CONSUME6 = function(l, u) {
						return this.consumeInternal(l, 6, u)
					}, c.prototype.CONSUME7 = function(l, u) {
						return this.consumeInternal(l, 7, u)
					}, c.prototype.CONSUME8 = function(l, u) {
						return this.consumeInternal(l, 8, u)
					}, c.prototype.CONSUME9 = function(l, u) {
						return this.consumeInternal(l, 9, u)
					}, c.prototype.SUBRULE = function(l, u) {
						return this.subruleInternal(l, 0, u)
					}, c.prototype.SUBRULE1 = function(l, u) {
						return this.subruleInternal(l, 1, u)
					}, c.prototype.SUBRULE2 = function(l, u) {
						return this.subruleInternal(l, 2, u)
					}, c.prototype.SUBRULE3 = function(l, u) {
						return this.subruleInternal(l, 3, u)
					}, c.prototype.SUBRULE4 = function(l, u) {
						return this.subruleInternal(l, 4, u)
					}, c.prototype.SUBRULE5 = function(l, u) {
						return this.subruleInternal(l, 5, u)
					}, c.prototype.SUBRULE6 = function(l, u) {
						return this.subruleInternal(l, 6, u)
					}, c.prototype.SUBRULE7 = function(l, u) {
						return this.subruleInternal(l, 7, u)
					}, c.prototype.SUBRULE8 = function(l, u) {
						return this.subruleInternal(l, 8, u)
					}, c.prototype.SUBRULE9 = function(l, u) {
						return this.subruleInternal(l, 9, u)
					}, c.prototype.OPTION = function(l) {
						return this.optionInternal(l, 0)
					}, c.prototype.OPTION1 = function(l) {
						return this.optionInternal(l, 1)
					}, c.prototype.OPTION2 = function(l) {
						return this.optionInternal(l, 2)
					}, c.prototype.OPTION3 = function(l) {
						return this.optionInternal(l, 3)
					}, c.prototype.OPTION4 = function(l) {
						return this.optionInternal(l, 4)
					}, c.prototype.OPTION5 = function(l) {
						return this.optionInternal(l, 5)
					}, c.prototype.OPTION6 = function(l) {
						return this.optionInternal(l, 6)
					}, c.prototype.OPTION7 = function(l) {
						return this.optionInternal(l, 7)
					}, c.prototype.OPTION8 = function(l) {
						return this.optionInternal(l, 8)
					}, c.prototype.OPTION9 = function(l) {
						return this.optionInternal(l, 9)
					}, c.prototype.OR = function(l) {
						return this.orInternal(l, 0)
					}, c.prototype.OR1 = function(l) {
						return this.orInternal(l, 1)
					}, c.prototype.OR2 = function(l) {
						return this.orInternal(l, 2)
					}, c.prototype.OR3 = function(l) {
						return this.orInternal(l, 3)
					}, c.prototype.OR4 = function(l) {
						return this.orInternal(l, 4)
					}, c.prototype.OR5 = function(l) {
						return this.orInternal(l, 5)
					}, c.prototype.OR6 = function(l) {
						return this.orInternal(l, 6)
					}, c.prototype.OR7 = function(l) {
						return this.orInternal(l, 7)
					}, c.prototype.OR8 = function(l) {
						return this.orInternal(l, 8)
					}, c.prototype.OR9 = function(l) {
						return this.orInternal(l, 9)
					}, c.prototype.MANY = function(l) {
						this.manyInternal(0, l)
					}, c.prototype.MANY1 = function(l) {
						this.manyInternal(1, l)
					}, c.prototype.MANY2 = function(l) {
						this.manyInternal(2, l)
					}, c.prototype.MANY3 = function(l) {
						this.manyInternal(3, l)
					}, c.prototype.MANY4 = function(l) {
						this.manyInternal(4, l)
					}, c.prototype.MANY5 = function(l) {
						this.manyInternal(5, l)
					}, c.prototype.MANY6 = function(l) {
						this.manyInternal(6, l)
					}, c.prototype.MANY7 = function(l) {
						this.manyInternal(7, l)
					}, c.prototype.MANY8 = function(l) {
						this.manyInternal(8, l)
					}, c.prototype.MANY9 = function(l) {
						this.manyInternal(9, l)
					}, c.prototype.MANY_SEP = function(l) {
						this.manySepFirstInternal(0, l)
					}, c.prototype.MANY_SEP1 = function(l) {
						this.manySepFirstInternal(1, l)
					}, c.prototype.MANY_SEP2 = function(l) {
						this.manySepFirstInternal(2, l)
					}, c.prototype.MANY_SEP3 = function(l) {
						this.manySepFirstInternal(3, l)
					}, c.prototype.MANY_SEP4 = function(l) {
						this.manySepFirstInternal(4, l)
					}, c.prototype.MANY_SEP5 = function(l) {
						this.manySepFirstInternal(5, l)
					}, c.prototype.MANY_SEP6 = function(l) {
						this.manySepFirstInternal(6, l)
					}, c.prototype.MANY_SEP7 = function(l) {
						this.manySepFirstInternal(7, l)
					}, c.prototype.MANY_SEP8 = function(l) {
						this.manySepFirstInternal(8, l)
					}, c.prototype.MANY_SEP9 = function(l) {
						this.manySepFirstInternal(9, l)
					}, c.prototype.AT_LEAST_ONE = function(l) {
						this.atLeastOneInternal(0, l)
					}, c.prototype.AT_LEAST_ONE1 = function(l) {
						return this.atLeastOneInternal(1, l)
					}, c.prototype.AT_LEAST_ONE2 = function(l) {
						this.atLeastOneInternal(2, l)
					}, c.prototype.AT_LEAST_ONE3 = function(l) {
						this.atLeastOneInternal(3, l)
					}, c.prototype.AT_LEAST_ONE4 = function(l) {
						this.atLeastOneInternal(4, l)
					}, c.prototype.AT_LEAST_ONE5 = function(l) {
						this.atLeastOneInternal(5, l)
					}, c.prototype.AT_LEAST_ONE6 = function(l) {
						this.atLeastOneInternal(6, l)
					}, c.prototype.AT_LEAST_ONE7 = function(l) {
						this.atLeastOneInternal(7, l)
					}, c.prototype.AT_LEAST_ONE8 = function(l) {
						this.atLeastOneInternal(8, l)
					}, c.prototype.AT_LEAST_ONE9 = function(l) {
						this.atLeastOneInternal(9, l)
					}, c.prototype.AT_LEAST_ONE_SEP = function(l) {
						this.atLeastOneSepFirstInternal(0, l)
					}, c.prototype.AT_LEAST_ONE_SEP1 = function(l) {
						this.atLeastOneSepFirstInternal(1, l)
					}, c.prototype.AT_LEAST_ONE_SEP2 = function(l) {
						this.atLeastOneSepFirstInternal(2, l)
					}, c.prototype.AT_LEAST_ONE_SEP3 = function(l) {
						this.atLeastOneSepFirstInternal(3, l)
					}, c.prototype.AT_LEAST_ONE_SEP4 = function(l) {
						this.atLeastOneSepFirstInternal(4, l)
					}, c.prototype.AT_LEAST_ONE_SEP5 = function(l) {
						this.atLeastOneSepFirstInternal(5, l)
					}, c.prototype.AT_LEAST_ONE_SEP6 = function(l) {
						this.atLeastOneSepFirstInternal(6, l)
					}, c.prototype.AT_LEAST_ONE_SEP7 = function(l) {
						this.atLeastOneSepFirstInternal(7, l)
					}, c.prototype.AT_LEAST_ONE_SEP8 = function(l) {
						this.atLeastOneSepFirstInternal(8, l)
					}, c.prototype.AT_LEAST_ONE_SEP9 = function(l) {
						this.atLeastOneSepFirstInternal(9, l)
					}, c.prototype.RULE = function(l, u, h) {
						if (h === void 0 && (h = n.DEFAULT_RULE_CONFIG), e.contains(this.definedRulesNames, l)) {
							var f = i.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
									topLevelRule: l,
									grammarName: this.className
								}),
								p = {
									message: f,
									type: n.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
									ruleName: l
								};
							this.definitionErrors.push(p)
						}
						this.definedRulesNames.push(l);
						var g = this.defineRule(l, u, h);
						return this[l] = g, g
					}, c.prototype.OVERRIDE_RULE = function(l, u, h) {
						h === void 0 && (h = n.DEFAULT_RULE_CONFIG);
						var f = [];
						f = f.concat(s.validateRuleIsOverridden(l, this.definedRulesNames, this.className)), this.definitionErrors = this.definitionErrors.concat(f);
						var p = this.defineRule(l, u, h);
						return this[l] = p, p
					}, c.prototype.BACKTRACK = function(l, u) {
						return function() {
							this.isBackTrackingStack.push(1);
							var h = this.saveRecogState();
							try {
								return l.apply(this, u), !0
							} catch (f) {
								if (t.isRecognitionException(f)) return !1;
								throw f
							} finally {
								this.reloadRecogState(h), this.isBackTrackingStack.pop()
							}
						}
					}, c.prototype.getGAstProductions = function() {
						return this.gastProductionsCache
					}, c.prototype.getSerializedGastProductions = function() {
						return o.serializeGrammar(e.values(this.gastProductionsCache))
					}, c
				}();
			r.RecognizerApi = a
		}),
		FE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.RecognizerEngine = void 0;
			var e = Ut(),
				t = im(),
				n = ic(),
				i = Sh(),
				s = Th(),
				o = qi(),
				a = Ux(),
				c = Po(),
				l = tc(),
				u = Bx(),
				h = function() {
					function f() {}
					return f.prototype.initRecognizerEngine = function(p, g) {
						if (this.className = u.classNameFromInstance(this), this.shortRuleNameToFull = {}, this.fullRuleNameToShort = {}, this.ruleShortNameIdx = 256, this.tokenMatcher = l.tokenStructuredMatcherNoCategories, this.definedRulesNames = [], this.tokensMap = {}, this.isBackTrackingStack = [], this.RULE_STACK = [], this.RULE_OCCURRENCE_STACK = [], this.gastProductionsCache = {}, e.has(g, "serializedGrammar")) throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
						if (e.isArray(p)) {
							if (e.isEmpty(p)) throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
							if (typeof p[0].startOffset == "number") throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`)
						}
						if (e.isArray(p)) this.tokensMap = e.reduce(p, function(x, _) {
							return x[_.name] = _, x
						}, {});
						else if (e.has(p, "modes") && e.every(e.flatten(e.values(p.modes)), l.isTokenType)) {
							var m = e.flatten(e.values(p.modes)),
								d = e.uniq(m);
							this.tokensMap = e.reduce(d, function(x, _) {
								return x[_.name] = _, x
							}, {})
						} else if (e.isObject(p)) this.tokensMap = e.cloneObj(p);
						else throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
						this.tokensMap.EOF = c.EOF;
						var v = e.every(e.values(p), function(x) {
							return e.isEmpty(x.categoryMatches)
						});
						this.tokenMatcher = v ? l.tokenStructuredMatcherNoCategories : l.tokenStructuredMatcher, l.augmentTokenTypes(e.values(this.tokensMap))
					}, f.prototype.defineRule = function(p, g, m) {
						if (this.selfAnalysisDone) throw Error("Grammar rule <" + p + `> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
						var d = e.has(m, "resyncEnabled") ? m.resyncEnabled : o.DEFAULT_RULE_CONFIG.resyncEnabled,
							v = e.has(m, "recoveryValueFunc") ? m.recoveryValueFunc : o.DEFAULT_RULE_CONFIG.recoveryValueFunc,
							x = this.ruleShortNameIdx << t.BITS_FOR_METHOD_TYPE + t.BITS_FOR_OCCURRENCE_IDX;
						this.ruleShortNameIdx++, this.shortRuleNameToFull[x] = p, this.fullRuleNameToShort[p] = x;

						function _(C) {
							try {
								if (this.outputCst === !0) {
									g.apply(this, C);
									var S = this.CST_STACK[this.CST_STACK.length - 1];
									return this.cstPostRule(S), S
								} else return g.apply(this, C)
							} catch (b) {
								return this.invokeRuleCatch(b, d, v)
							} finally {
								this.ruleFinallyStateUpdate()
							}
						}
						var y = function(C, S) {
								return C === void 0 && (C = 0), this.ruleInvocationStateUpdate(x, p, C), _.call(this, S)
							},
							w = "ruleName";
						return y[w] = p, y.originalGrammarAction = g, y
					}, f.prototype.invokeRuleCatch = function(p, g, m) {
						var d = this.RULE_STACK.length === 1,
							v = g && !this.isBackTracking() && this.recoveryEnabled;
						if (n.isRecognitionException(p)) {
							var x = p;
							if (v) {
								var _ = this.findReSyncTokenType();
								if (this.isInCurrentRuleReSyncSet(_))
									if (x.resyncedTokens = this.reSyncTo(_), this.outputCst) {
										var y = this.CST_STACK[this.CST_STACK.length - 1];
										return y.recoveredNode = !0, y
									} else return m();
								else {
									if (this.outputCst) {
										var y = this.CST_STACK[this.CST_STACK.length - 1];
										y.recoveredNode = !0, x.partialCstResult = y
									}
									throw x
								}
							} else {
								if (d) return this.moveToTerminatedState(), m();
								throw x
							}
						} else throw p
					}, f.prototype.optionInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.OPTION_IDX, g);
						return this.optionInternalLogic(p, g, m)
					}, f.prototype.optionInternalLogic = function(p, g, m) {
						var d = this,
							v = this.getLaFuncFromCache(m),
							x, _;
						if (p.DEF !== void 0) {
							if (x = p.DEF, _ = p.GATE, _ !== void 0) {
								var y = v;
								v = function() {
									return _.call(d) && y.call(d)
								}
							}
						} else x = p;
						if (v.call(this) === !0) return x.call(this)
					}, f.prototype.atLeastOneInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_IDX, p);
						return this.atLeastOneInternalLogic(p, g, m)
					}, f.prototype.atLeastOneInternalLogic = function(p, g, m) {
						var d = this,
							v = this.getLaFuncFromCache(m),
							x, _;
						if (g.DEF !== void 0) {
							if (x = g.DEF, _ = g.GATE, _ !== void 0) {
								var y = v;
								v = function() {
									return _.call(d) && y.call(d)
								}
							}
						} else x = g;
						if (v.call(this) === !0)
							for (var w = this.doSingleRepetition(x); v.call(this) === !0 && w === !0;) w = this.doSingleRepetition(x);
						else throw this.raiseEarlyExitException(p, i.PROD_TYPE.REPETITION_MANDATORY, g.ERR_MSG);
						this.attemptInRepetitionRecovery(this.atLeastOneInternal, [p, g], v, t.AT_LEAST_ONE_IDX, p, s.NextTerminalAfterAtLeastOneWalker)
					}, f.prototype.atLeastOneSepFirstInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.AT_LEAST_ONE_SEP_IDX, p);
						this.atLeastOneSepFirstInternalLogic(p, g, m)
					}, f.prototype.atLeastOneSepFirstInternalLogic = function(p, g, m) {
						var d = this,
							v = g.DEF,
							x = g.SEP,
							_ = this.getLaFuncFromCache(m);
						if (_.call(this) === !0) {
							v.call(this);
							for (var y = function() {
								return d.tokenMatcher(d.LA(1), x)
							}; this.tokenMatcher(this.LA(1), x) === !0;) this.CONSUME(x), v.call(this);
							this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [p, x, y, v, s.NextTerminalAfterAtLeastOneSepWalker], y, t.AT_LEAST_ONE_SEP_IDX, p, s.NextTerminalAfterAtLeastOneSepWalker)
						} else throw this.raiseEarlyExitException(p, i.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, g.ERR_MSG)
					}, f.prototype.manyInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.MANY_IDX, p);
						return this.manyInternalLogic(p, g, m)
					}, f.prototype.manyInternalLogic = function(p, g, m) {
						var d = this,
							v = this.getLaFuncFromCache(m),
							x, _;
						if (g.DEF !== void 0) {
							if (x = g.DEF, _ = g.GATE, _ !== void 0) {
								var y = v;
								v = function() {
									return _.call(d) && y.call(d)
								}
							}
						} else x = g;
						for (var w = !0; v.call(this) === !0 && w === !0;) w = this.doSingleRepetition(x);
						this.attemptInRepetitionRecovery(this.manyInternal, [p, g], v, t.MANY_IDX, p, s.NextTerminalAfterManyWalker, w)
					}, f.prototype.manySepFirstInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.MANY_SEP_IDX, p);
						this.manySepFirstInternalLogic(p, g, m)
					}, f.prototype.manySepFirstInternalLogic = function(p, g, m) {
						var d = this,
							v = g.DEF,
							x = g.SEP,
							_ = this.getLaFuncFromCache(m);
						if (_.call(this) === !0) {
							v.call(this);
							for (var y = function() {
								return d.tokenMatcher(d.LA(1), x)
							}; this.tokenMatcher(this.LA(1), x) === !0;) this.CONSUME(x), v.call(this);
							this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [p, x, y, v, s.NextTerminalAfterManySepWalker], y, t.MANY_SEP_IDX, p, s.NextTerminalAfterManySepWalker)
						}
					}, f.prototype.repetitionSepSecondInternal = function(p, g, m, d, v) {
						for (; m();) this.CONSUME(g), d.call(this);
						this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [p, g, m, d, v], m, t.AT_LEAST_ONE_SEP_IDX, p, v)
					}, f.prototype.doSingleRepetition = function(p) {
						var g = this.getLexerPosition();
						p.call(this);
						var m = this.getLexerPosition();
						return m > g
					}, f.prototype.orInternal = function(p, g) {
						var m = this.getKeyForAutomaticLookahead(t.OR_IDX, g),
							d = e.isArray(p) ? p : p.DEF,
							v = this.getLaFuncFromCache(m),
							x = v.call(this, d);
						if (x !== void 0) {
							var _ = d[x];
							return _.ALT.call(this)
						}
						this.raiseNoAltException(g, p.ERR_MSG)
					}, f.prototype.ruleFinallyStateUpdate = function() {
						if (this.RULE_STACK.pop(), this.RULE_OCCURRENCE_STACK.pop(), this.cstFinallyStateUpdate(), this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1) {
							var p = this.LA(1),
								g = this.errorMessageProvider.buildNotAllInputParsedMessage({
									firstRedundant: p,
									ruleName: this.getCurrRuleFullName()
								});
							this.SAVE_ERROR(new n.NotAllInputParsedException(g, p))
						}
					}, f.prototype.subruleInternal = function(p, g, m) {
						var d;
						try {
							var v = m !== void 0 ? m.ARGS : void 0;
							return d = p.call(this, g, v), this.cstPostNonTerminal(d, m !== void 0 && m.LABEL !== void 0 ? m.LABEL : p.ruleName), d
						} catch (x) {
							this.subruleInternalError(x, m, p.ruleName)
						}
					}, f.prototype.subruleInternalError = function(p, g, m) {
						throw n.isRecognitionException(p) && p.partialCstResult !== void 0 && (this.cstPostNonTerminal(p.partialCstResult, g !== void 0 && g.LABEL !== void 0 ? g.LABEL : m), delete p.partialCstResult), p
					}, f.prototype.consumeInternal = function(p, g, m) {
						var d;
						try {
							var v = this.LA(1);
							this.tokenMatcher(v, p) === !0 ? (this.consumeToken(), d = v) : this.consumeInternalError(p, v, m)
						} catch (x) {
							d = this.consumeInternalRecovery(p, g, x)
						}
						return this.cstPostTerminal(m !== void 0 && m.LABEL !== void 0 ? m.LABEL : p.name, d), d
					}, f.prototype.consumeInternalError = function(p, g, m) {
						var d, v = this.LA(0);
						throw m !== void 0 && m.ERR_MSG ? d = m.ERR_MSG : d = this.errorMessageProvider.buildMismatchTokenMessage({
							expected: p,
							actual: g,
							previous: v,
							ruleName: this.getCurrRuleFullName()
						}), this.SAVE_ERROR(new n.MismatchedTokenException(d, g, v))
					}, f.prototype.consumeInternalRecovery = function(p, g, m) {
						if (this.recoveryEnabled && m.name === "MismatchedTokenException" && !this.isBackTracking()) {
							var d = this.getFollowsForInRuleRecovery(p, g);
							try {
								return this.tryInRuleRecovery(p, d)
							} catch (v) {
								throw v.name === a.IN_RULE_RECOVERY_EXCEPTION ? m : v
							}
						} else throw m
					}, f.prototype.saveRecogState = function() {
						var p = this.errors,
							g = e.cloneArr(this.RULE_STACK);
						return {
							errors: p,
							lexerState: this.exportLexerState(),
							RULE_STACK: g,
							CST_STACK: this.CST_STACK
						}
					}, f.prototype.reloadRecogState = function(p) {
						this.errors = p.errors, this.importLexerState(p.lexerState), this.RULE_STACK = p.RULE_STACK
					}, f.prototype.ruleInvocationStateUpdate = function(p, g, m) {
						this.RULE_OCCURRENCE_STACK.push(m), this.RULE_STACK.push(p), this.cstInvocationStateUpdate(g, p)
					}, f.prototype.isBackTracking = function() {
						return this.isBackTrackingStack.length !== 0
					}, f.prototype.getCurrRuleFullName = function() {
						var p = this.getLastExplicitRuleShortName();
						return this.shortRuleNameToFull[p]
					}, f.prototype.shortRuleNameToFullName = function(p) {
						return this.shortRuleNameToFull[p]
					}, f.prototype.isAtEndOfInput = function() {
						return this.tokenMatcher(this.LA(1), c.EOF)
					}, f.prototype.reset = function() {
						this.resetLexerState(), this.isBackTrackingStack = [], this.errors = [], this.RULE_STACK = [], this.CST_STACK = [], this.RULE_OCCURRENCE_STACK = []
					}, f
				}();
			r.RecognizerEngine = h
		}),
		UE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.ErrorHandler = void 0;
			var e = ic(),
				t = Ut(),
				n = Sh(),
				i = qi(),
				s = function() {
					function o() {}
					return o.prototype.initErrorHandler = function(a) {
						this._errors = [], this.errorMessageProvider = t.has(a, "errorMessageProvider") ? a.errorMessageProvider : i.DEFAULT_PARSER_CONFIG.errorMessageProvider
					}, o.prototype.SAVE_ERROR = function(a) {
						if (e.isRecognitionException(a)) return a.context = {
							ruleStack: this.getHumanReadableRuleStack(),
							ruleOccurrenceStack: t.cloneArr(this.RULE_OCCURRENCE_STACK)
						}, this._errors.push(a), a;
						throw Error("Trying to save an Error which is not a RecognitionException")
					}, Object.defineProperty(o.prototype, "errors", {
						get: function() {
							return t.cloneArr(this._errors)
						},
						set: function(a) {
							this._errors = a
						},
						enumerable: !1,
						configurable: !0
					}), o.prototype.raiseEarlyExitException = function(a, c, l) {
						for (var u = this.getCurrRuleFullName(), h = this.getGAstProductions()[u], f = n.getLookaheadPathsForOptionalProd(a, h, c, this.maxLookahead), p = f[0], g = [], m = 1; m <= this.maxLookahead; m++) g.push(this.LA(m));
						var d = this.errorMessageProvider.buildEarlyExitMessage({
							expectedIterationPaths: p,
							actual: g,
							previous: this.LA(0),
							customUserDescription: l,
							ruleName: u
						});
						throw this.SAVE_ERROR(new e.EarlyExitException(d, this.LA(1), this.LA(0)))
					}, o.prototype.raiseNoAltException = function(a, c) {
						for (var l = this.getCurrRuleFullName(), u = this.getGAstProductions()[l], h = n.getLookaheadPathsForOr(a, u, this.maxLookahead), f = [], p = 1; p <= this.maxLookahead; p++) f.push(this.LA(p));
						var g = this.LA(0),
							m = this.errorMessageProvider.buildNoViableAltMessage({
								expectedPathsPerAlt: h,
								actual: f,
								previous: g,
								customUserDescription: c,
								ruleName: this.getCurrRuleFullName()
							});
						throw this.SAVE_ERROR(new e.NoViableAltException(m, this.LA(1), g))
					}, o
				}();
			r.ErrorHandler = s
		}),
		BE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.ContentAssist = void 0;
			var e = Th(),
				t = Ut(),
				n = function() {
					function i() {}
					return i.prototype.initContentAssist = function() {}, i.prototype.computeContentAssist = function(s, o) {
						var a = this.gastProductionsCache[s];
						if (t.isUndefined(a)) throw Error("Rule ->" + s + "<- does not exist in this grammar.");
						return e.nextPossibleTokensAfter([a], o, this.tokenMatcher, this.maxLookahead)
					}, i.prototype.getNextPossibleTokenTypes = function(s) {
						var o = t.first(s.ruleStack),
							a = this.getGAstProductions(),
							c = a[o],
							l = new e.NextAfterTokenWalker(c, s)
							.startWalking();
						return l
					}, i
				}();
			r.ContentAssist = n
		}),
		GE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.GastRecorder = void 0;
			var e = Ut(),
				t = Ai(),
				n = bh(),
				i = tc(),
				s = Po(),
				o = qi(),
				a = im(),
				c = {
					description: "This Object indicates the Parser is during Recording Phase"
				};
			Object.freeze(c);
			var l = !0,
				u = Math.pow(2, a.BITS_FOR_OCCURRENCE_IDX) - 1,
				h = s.createToken({
					name: "RECORDING_PHASE_TOKEN",
					pattern: n.Lexer.NA
				});
			i.augmentTokenTypes([h]);
			var f = s.createTokenInstance(h, `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`, -1, -1, -1, -1, -1, -1);
			Object.freeze(f);
			var p = {
					name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
					children: {}
				},
				g = function() {
					function _() {}
					return _.prototype.initGastRecorder = function(y) {
						this.recordingProdStack = [], this.RECORDING_PHASE = !1
					}, _.prototype.enableRecording = function() {
						var y = this;
						this.RECORDING_PHASE = !0, this.TRACE_INIT("Enable Recording", function() {
							for (var w = function(S) {
								var b = S > 0 ? S : "";
								y["CONSUME" + b] = function(T, N) {
									return this.consumeInternalRecord(T, S, N)
								}, y["SUBRULE" + b] = function(T, N) {
									return this.subruleInternalRecord(T, S, N)
								}, y["OPTION" + b] = function(T) {
									return this.optionInternalRecord(T, S)
								}, y["OR" + b] = function(T) {
									return this.orInternalRecord(T, S)
								}, y["MANY" + b] = function(T) {
									this.manyInternalRecord(S, T)
								}, y["MANY_SEP" + b] = function(T) {
									this.manySepFirstInternalRecord(S, T)
								}, y["AT_LEAST_ONE" + b] = function(T) {
									this.atLeastOneInternalRecord(S, T)
								}, y["AT_LEAST_ONE_SEP" + b] = function(T) {
									this.atLeastOneSepFirstInternalRecord(S, T)
								}
							}, C = 0; C < 10; C++) w(C);
							y.consume = function(S, b, T) {
								return this.consumeInternalRecord(b, S, T)
							}, y.subrule = function(S, b, T) {
								return this.subruleInternalRecord(b, S, T)
							}, y.option = function(S, b) {
								return this.optionInternalRecord(b, S)
							}, y.or = function(S, b) {
								return this.orInternalRecord(b, S)
							}, y.many = function(S, b) {
								this.manyInternalRecord(S, b)
							}, y.atLeastOne = function(S, b) {
								this.atLeastOneInternalRecord(S, b)
							}, y.ACTION = y.ACTION_RECORD, y.BACKTRACK = y.BACKTRACK_RECORD, y.LA = y.LA_RECORD
						})
					}, _.prototype.disableRecording = function() {
						var y = this;
						this.RECORDING_PHASE = !1, this.TRACE_INIT("Deleting Recording methods", function() {
							for (var w = 0; w < 10; w++) {
								var C = w > 0 ? w : "";
								delete y["CONSUME" + C], delete y["SUBRULE" + C], delete y["OPTION" + C], delete y["OR" + C], delete y["MANY" + C], delete y["MANY_SEP" + C], delete y["AT_LEAST_ONE" + C], delete y["AT_LEAST_ONE_SEP" + C]
							}
							delete y.consume, delete y.subrule, delete y.option, delete y.or, delete y.many, delete y.atLeastOne, delete y.ACTION, delete y.BACKTRACK, delete y.LA
						})
					}, _.prototype.ACTION_RECORD = function(y) {}, _.prototype.BACKTRACK_RECORD = function(y, w) {
						return function() {
							return !0
						}
					}, _.prototype.LA_RECORD = function(y) {
						return o.END_OF_FILE
					}, _.prototype.topLevelRuleRecord = function(y, w) {
						try {
							var C = new t.Rule({
								definition: [],
								name: y
							});
							return C.name = y, this.recordingProdStack.push(C), w.call(this), this.recordingProdStack.pop(), C
						} catch (S) {
							if (S.KNOWN_RECORDER_ERROR !== !0) try {
								S.message = S.message + `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`
							} catch {
								throw S
							}
							throw S
						}
					}, _.prototype.optionInternalRecord = function(y, w) {
						return m.call(this, t.Option, y, w)
					}, _.prototype.atLeastOneInternalRecord = function(y, w) {
						m.call(this, t.RepetitionMandatory, w, y)
					}, _.prototype.atLeastOneSepFirstInternalRecord = function(y, w) {
						m.call(this, t.RepetitionMandatoryWithSeparator, w, y, l)
					}, _.prototype.manyInternalRecord = function(y, w) {
						m.call(this, t.Repetition, w, y)
					}, _.prototype.manySepFirstInternalRecord = function(y, w) {
						m.call(this, t.RepetitionWithSeparator, w, y, l)
					}, _.prototype.orInternalRecord = function(y, w) {
						return d.call(this, y, w)
					}, _.prototype.subruleInternalRecord = function(y, w, C) {
						if (x(w), !y || e.has(y, "ruleName") === !1) {
							var S = new Error("<SUBRULE" + v(w) + "> argument is invalid" + (" expecting a Parser method reference but got: <" + JSON.stringify(y) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
							throw S.KNOWN_RECORDER_ERROR = !0, S
						}
						var b = e.peek(this.recordingProdStack),
							T = y.ruleName,
							N = new t.NonTerminal({
								idx: w,
								nonTerminalName: T,
								referencedRule: void 0
							});
						return b.definition.push(N), this.outputCst ? p : c
					}, _.prototype.consumeInternalRecord = function(y, w, C) {
						if (x(w), !i.hasShortKeyProperty(y)) {
							var S = new Error("<CONSUME" + v(w) + "> argument is invalid" + (" expecting a TokenType reference but got: <" + JSON.stringify(y) + ">") + (`
 inside top level rule: <` + this.recordingProdStack[0].name + ">"));
							throw S.KNOWN_RECORDER_ERROR = !0, S
						}
						var b = e.peek(this.recordingProdStack),
							T = new t.Terminal({
								idx: w,
								terminalType: y
							});
						return b.definition.push(T), f
					}, _
				}();
			r.GastRecorder = g;

			function m(_, y, w, C) {
				C === void 0 && (C = !1), x(w);
				var S = e.peek(this.recordingProdStack),
					b = e.isFunction(y) ? y : y.DEF,
					T = new _({
						definition: [],
						idx: w
					});
				return C && (T.separator = y.SEP), e.has(y, "MAX_LOOKAHEAD") && (T.maxLookahead = y.MAX_LOOKAHEAD), this.recordingProdStack.push(T), b.call(this), S.definition.push(T), this.recordingProdStack.pop(), c
			}

			function d(_, y) {
				var w = this;
				x(y);
				var C = e.peek(this.recordingProdStack),
					S = e.isArray(_) === !1,
					b = S === !1 ? _ : _.DEF,
					T = new t.Alternation({
						definition: [],
						idx: y,
						ignoreAmbiguities: S && _.IGNORE_AMBIGUITIES === !0
					});
				e.has(_, "MAX_LOOKAHEAD") && (T.maxLookahead = _.MAX_LOOKAHEAD);
				var N = e.some(b, function(V) {
					return e.isFunction(V.GATE)
				});
				return T.hasPredicates = N, C.definition.push(T), e.forEach(b, function(V) {
					var O = new t.Alternative({
						definition: []
					});
					T.definition.push(O), e.has(V, "IGNORE_AMBIGUITIES") ? O.ignoreAmbiguities = V.IGNORE_AMBIGUITIES : e.has(V, "GATE") && (O.ignoreAmbiguities = !0), w.recordingProdStack.push(O), V.ALT.call(w), w.recordingProdStack.pop()
				}), c
			}

			function v(_) {
				return _ === 0 ? "" : "" + _
			}

			function x(_) {
				if (_ < 0 || _ > u) {
					var y = new Error("Invalid DSL Method idx value: <" + _ + `>
	` + ("Idx value must be a none negative value smaller than " + (u + 1)));
					throw y.KNOWN_RECORDER_ERROR = !0, y
				}
			}
		}),
		VE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.PerformanceTracer = void 0;
			var e = Ut(),
				t = qi(),
				n = function() {
					function i() {}
					return i.prototype.initPerformanceTracer = function(s) {
						if (e.has(s, "traceInitPerf")) {
							var o = s.traceInitPerf,
								a = typeof o == "number";
							this.traceInitMaxIdent = a ? o : 1 / 0, this.traceInitPerf = a ? o > 0 : o
						} else this.traceInitMaxIdent = 0, this.traceInitPerf = t.DEFAULT_PARSER_CONFIG.traceInitPerf;
						this.traceInitIndent = -1
					}, i.prototype.TRACE_INIT = function(s, o) {
						if (this.traceInitPerf === !0) {
							this.traceInitIndent++;
							var a = new Array(this.traceInitIndent + 1)
								.join("	");
							this.traceInitIndent < this.traceInitMaxIdent && console.log(a + "--> <" + s + ">");
							var c = e.timer(o),
								l = c.time,
								u = c.value,
								h = l > 10 ? console.warn : console.log;
							return this.traceInitIndent < this.traceInitMaxIdent && h(a + "<-- <" + s + "> time: " + l + "ms"), this.traceInitIndent--, u
						} else return o()
					}, i
				}();
			r.PerformanceTracer = n
		}),
		zE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.applyMixins = void 0;

			function e(t, n) {
				n.forEach(function(i) {
					var s = i.prototype;
					Object.getOwnPropertyNames(s)
						.forEach(function(o) {
							if (o !== "constructor") {
								var a = Object.getOwnPropertyDescriptor(s, o);
								a && (a.get || a.set) ? Object.defineProperty(t.prototype, o, a) : t.prototype[o] = i.prototype[o]
							}
						})
				})
			}
			r.applyMixins = e
		}),
		qi = gt(r => {
			"use strict";
			var e = r && r.__extends || function() {
				var S = function(b, T) {
					return S = Object.setPrototypeOf || {
						__proto__: []
					}
					instanceof Array && function(N, V) {
						N.__proto__ = V
					} || function(N, V) {
						for (var O in V) Object.prototype.hasOwnProperty.call(V, O) && (N[O] = V[O])
					}, S(b, T)
				};
				return function(b, T) {
					if (typeof T != "function" && T !== null) throw new TypeError("Class extends value " + String(T) + " is not a constructor or null");
					S(b, T);

					function N() {
						this.constructor = b
					}
					b.prototype = T === null ? Object.create(T) : (N.prototype = T.prototype, new N)
				}
			}();
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.EmbeddedActionsParser = r.CstParser = r.Parser = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.DEFAULT_RULE_CONFIG = r.DEFAULT_PARSER_CONFIG = r.END_OF_FILE = void 0;
			var t = Ut(),
				n = AE(),
				i = Po(),
				s = wh(),
				o = RE(),
				a = Ux(),
				c = PE(),
				l = DE(),
				u = OE(),
				h = kE(),
				f = FE(),
				p = UE(),
				g = BE(),
				m = GE(),
				d = VE(),
				v = zE();
			r.END_OF_FILE = i.createTokenInstance(i.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN), Object.freeze(r.END_OF_FILE), r.DEFAULT_PARSER_CONFIG = Object.freeze({
				recoveryEnabled: !1,
				maxLookahead: 3,
				dynamicTokensEnabled: !1,
				outputCst: !0,
				errorMessageProvider: s.defaultParserErrorProvider,
				nodeLocationTracking: "none",
				traceInitPerf: !1,
				skipValidations: !1
			}), r.DEFAULT_RULE_CONFIG = Object.freeze({
				recoveryValueFunc: function() {},
				resyncEnabled: !0
			});
			var x;
			(function(S) {
				S[S.INVALID_RULE_NAME = 0] = "INVALID_RULE_NAME", S[S.DUPLICATE_RULE_NAME = 1] = "DUPLICATE_RULE_NAME", S[S.INVALID_RULE_OVERRIDE = 2] = "INVALID_RULE_OVERRIDE", S[S.DUPLICATE_PRODUCTIONS = 3] = "DUPLICATE_PRODUCTIONS", S[S.UNRESOLVED_SUBRULE_REF = 4] = "UNRESOLVED_SUBRULE_REF", S[S.LEFT_RECURSION = 5] = "LEFT_RECURSION", S[S.NONE_LAST_EMPTY_ALT = 6] = "NONE_LAST_EMPTY_ALT", S[S.AMBIGUOUS_ALTS = 7] = "AMBIGUOUS_ALTS", S[S.CONFLICT_TOKENS_RULES_NAMESPACE = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE", S[S.INVALID_TOKEN_NAME = 9] = "INVALID_TOKEN_NAME", S[S.NO_NON_EMPTY_LOOKAHEAD = 10] = "NO_NON_EMPTY_LOOKAHEAD", S[S.AMBIGUOUS_PREFIX_ALTS = 11] = "AMBIGUOUS_PREFIX_ALTS", S[S.TOO_MANY_ALTS = 12] = "TOO_MANY_ALTS"
			})(x = r.ParserDefinitionErrorType || (r.ParserDefinitionErrorType = {}));

			function _(S) {
				return S === void 0 && (S = void 0),
					function() {
						return S
					}
			}
			r.EMPTY_ALT = _;
			var y = function() {
				function S(b, T) {
					this.definitionErrors = [], this.selfAnalysisDone = !1;
					var N = this;
					if (N.initErrorHandler(T), N.initLexerAdapter(), N.initLooksAhead(T), N.initRecognizerEngine(b, T), N.initRecoverable(T), N.initTreeBuilder(T), N.initContentAssist(), N.initGastRecorder(T), N.initPerformanceTracer(T), t.has(T, "ignoredIssues")) throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
					this.skipValidations = t.has(T, "skipValidations") ? T.skipValidations : r.DEFAULT_PARSER_CONFIG.skipValidations
				}
				return S.performSelfAnalysis = function(b) {
					throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.")
				}, S.prototype.performSelfAnalysis = function() {
					var b = this;
					this.TRACE_INIT("performSelfAnalysis", function() {
						var T;
						b.selfAnalysisDone = !0;
						var N = b.className;
						b.TRACE_INIT("toFastProps", function() {
							t.toFastProperties(b)
						}), b.TRACE_INIT("Grammar Recording", function() {
							try {
								b.enableRecording(), t.forEach(b.definedRulesNames, function(O) {
									var k = b[O],
										I = k.originalGrammarAction,
										q = void 0;
									b.TRACE_INIT(O + " Rule", function() {
										q = b.topLevelRuleRecord(O, I)
									}), b.gastProductionsCache[O] = q
								})
							} finally {
								b.disableRecording()
							}
						});
						var V = [];
						if (b.TRACE_INIT("Grammar Resolving", function() {
							V = o.resolveGrammar({
								rules: t.values(b.gastProductionsCache)
							}), b.definitionErrors = b.definitionErrors.concat(V)
						}), b.TRACE_INIT("Grammar Validations", function() {
							if (t.isEmpty(V) && b.skipValidations === !1) {
								var O = o.validateGrammar({
									rules: t.values(b.gastProductionsCache),
									maxLookahead: b.maxLookahead,
									tokenTypes: t.values(b.tokensMap),
									errMsgProvider: s.defaultGrammarValidatorErrorProvider,
									grammarName: N
								});
								b.definitionErrors = b.definitionErrors.concat(O)
							}
						}), t.isEmpty(b.definitionErrors) && (b.recoveryEnabled && b.TRACE_INIT("computeAllProdsFollows", function() {
							var O = n.computeAllProdsFollows(t.values(b.gastProductionsCache));
							b.resyncFollows = O
						}), b.TRACE_INIT("ComputeLookaheadFunctions", function() {
							b.preComputeLookaheadFunctions(t.values(b.gastProductionsCache))
						})), !S.DEFER_DEFINITION_ERRORS_HANDLING && !t.isEmpty(b.definitionErrors)) throw T = t.map(b.definitionErrors, function(O) {
							return O.message
						}), new Error(`Parser Definition Errors detected:
 ` + T.join(`
-------------------------------
`))
					})
				}, S.DEFER_DEFINITION_ERRORS_HANDLING = !1, S
			}();
			r.Parser = y, v.applyMixins(y, [a.Recoverable, c.LooksAhead, l.TreeBuilder, u.LexerAdapter, f.RecognizerEngine, h.RecognizerApi, p.ErrorHandler, g.ContentAssist, m.GastRecorder, d.PerformanceTracer]);
			var w = function(S) {
				e(b, S);

				function b(T, N) {
					N === void 0 && (N = r.DEFAULT_PARSER_CONFIG);
					var V = this,
						O = t.cloneObj(N);
					return O.outputCst = !0, V = S.call(this, T, O) || this, V
				}
				return b
			}(y);
			r.CstParser = w;
			var C = function(S) {
				e(b, S);

				function b(T, N) {
					N === void 0 && (N = r.DEFAULT_PARSER_CONFIG);
					var V = this,
						O = t.cloneObj(N);
					return O.outputCst = !1, V = S.call(this, T, O) || this, V
				}
				return b
			}(y);
			r.EmbeddedActionsParser = C
		}),
		HE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.createSyntaxDiagramsCode = void 0;
			var e = Lx();

			function t(n, i) {
				var s = i === void 0 ? {} : i,
					o = s.resourceBase,
					a = o === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/" : o,
					c = s.css,
					l = c === void 0 ? "https://unpkg.com/chevrotain@" + e.VERSION + "/diagrams/diagrams.css" : c,
					u = `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>

`,
					h = `
<link rel='stylesheet' href='` + l + `'>
`,
					f = `
<script src='` + a + `vendor/railroad-diagrams.js'><\/script>
<script src='` + a + `src/diagrams_builder.js'><\/script>
<script src='` + a + `src/diagrams_behavior.js'><\/script>
<script src='` + a + `src/main.js'><\/script>
`,
					p = `
<div id="diagrams" align="center"></div>
`,
					g = `
<script>
    window.serializedGrammar = ` + JSON.stringify(n, null, "  ") + `;
<\/script>
`,
					m = `
<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
<\/script>
`;
				return u + h + f + p + g + m
			}
			r.createSyntaxDiagramsCode = t
		}),
		WE = gt(r => {
			"use strict";
			Object.defineProperty(r, "__esModule", {
				value: !0
			}), r.Parser = r.createSyntaxDiagramsCode = r.clearCache = r.GAstVisitor = r.serializeProduction = r.serializeGrammar = r.Terminal = r.Rule = r.RepetitionWithSeparator = r.RepetitionMandatoryWithSeparator = r.RepetitionMandatory = r.Repetition = r.Option = r.NonTerminal = r.Alternative = r.Alternation = r.defaultLexerErrorProvider = r.NoViableAltException = r.NotAllInputParsedException = r.MismatchedTokenException = r.isRecognitionException = r.EarlyExitException = r.defaultParserErrorProvider = r.tokenName = r.tokenMatcher = r.tokenLabel = r.EOF = r.createTokenInstance = r.createToken = r.LexerDefinitionErrorType = r.Lexer = r.EMPTY_ALT = r.ParserDefinitionErrorType = r.EmbeddedActionsParser = r.CstParser = r.VERSION = void 0;
			var e = Lx();
			Object.defineProperty(r, "VERSION", {
				enumerable: !0,
				get: function() {
					return e.VERSION
				}
			});
			var t = qi();
			Object.defineProperty(r, "CstParser", {
				enumerable: !0,
				get: function() {
					return t.CstParser
				}
			}), Object.defineProperty(r, "EmbeddedActionsParser", {
				enumerable: !0,
				get: function() {
					return t.EmbeddedActionsParser
				}
			}), Object.defineProperty(r, "ParserDefinitionErrorType", {
				enumerable: !0,
				get: function() {
					return t.ParserDefinitionErrorType
				}
			}), Object.defineProperty(r, "EMPTY_ALT", {
				enumerable: !0,
				get: function() {
					return t.EMPTY_ALT
				}
			});
			var n = bh();
			Object.defineProperty(r, "Lexer", {
				enumerable: !0,
				get: function() {
					return n.Lexer
				}
			}), Object.defineProperty(r, "LexerDefinitionErrorType", {
				enumerable: !0,
				get: function() {
					return n.LexerDefinitionErrorType
				}
			});
			var i = Po();
			Object.defineProperty(r, "createToken", {
				enumerable: !0,
				get: function() {
					return i.createToken
				}
			}), Object.defineProperty(r, "createTokenInstance", {
				enumerable: !0,
				get: function() {
					return i.createTokenInstance
				}
			}), Object.defineProperty(r, "EOF", {
				enumerable: !0,
				get: function() {
					return i.EOF
				}
			}), Object.defineProperty(r, "tokenLabel", {
				enumerable: !0,
				get: function() {
					return i.tokenLabel
				}
			}), Object.defineProperty(r, "tokenMatcher", {
				enumerable: !0,
				get: function() {
					return i.tokenMatcher
				}
			}), Object.defineProperty(r, "tokenName", {
				enumerable: !0,
				get: function() {
					return i.tokenName
				}
			});
			var s = wh();
			Object.defineProperty(r, "defaultParserErrorProvider", {
				enumerable: !0,
				get: function() {
					return s.defaultParserErrorProvider
				}
			});
			var o = ic();
			Object.defineProperty(r, "EarlyExitException", {
				enumerable: !0,
				get: function() {
					return o.EarlyExitException
				}
			}), Object.defineProperty(r, "isRecognitionException", {
				enumerable: !0,
				get: function() {
					return o.isRecognitionException
				}
			}), Object.defineProperty(r, "MismatchedTokenException", {
				enumerable: !0,
				get: function() {
					return o.MismatchedTokenException
				}
			}), Object.defineProperty(r, "NotAllInputParsedException", {
				enumerable: !0,
				get: function() {
					return o.NotAllInputParsedException
				}
			}), Object.defineProperty(r, "NoViableAltException", {
				enumerable: !0,
				get: function() {
					return o.NoViableAltException
				}
			});
			var a = Dx();
			Object.defineProperty(r, "defaultLexerErrorProvider", {
				enumerable: !0,
				get: function() {
					return a.defaultLexerErrorProvider
				}
			});
			var c = Ai();
			Object.defineProperty(r, "Alternation", {
				enumerable: !0,
				get: function() {
					return c.Alternation
				}
			}), Object.defineProperty(r, "Alternative", {
				enumerable: !0,
				get: function() {
					return c.Alternative
				}
			}), Object.defineProperty(r, "NonTerminal", {
				enumerable: !0,
				get: function() {
					return c.NonTerminal
				}
			}), Object.defineProperty(r, "Option", {
				enumerable: !0,
				get: function() {
					return c.Option
				}
			}), Object.defineProperty(r, "Repetition", {
				enumerable: !0,
				get: function() {
					return c.Repetition
				}
			}), Object.defineProperty(r, "RepetitionMandatory", {
				enumerable: !0,
				get: function() {
					return c.RepetitionMandatory
				}
			}), Object.defineProperty(r, "RepetitionMandatoryWithSeparator", {
				enumerable: !0,
				get: function() {
					return c.RepetitionMandatoryWithSeparator
				}
			}), Object.defineProperty(r, "RepetitionWithSeparator", {
				enumerable: !0,
				get: function() {
					return c.RepetitionWithSeparator
				}
			}), Object.defineProperty(r, "Rule", {
				enumerable: !0,
				get: function() {
					return c.Rule
				}
			}), Object.defineProperty(r, "Terminal", {
				enumerable: !0,
				get: function() {
					return c.Terminal
				}
			});
			var l = Ai();
			Object.defineProperty(r, "serializeGrammar", {
				enumerable: !0,
				get: function() {
					return l.serializeGrammar
				}
			}), Object.defineProperty(r, "serializeProduction", {
				enumerable: !0,
				get: function() {
					return l.serializeProduction
				}
			});
			var u = nc();
			Object.defineProperty(r, "GAstVisitor", {
				enumerable: !0,
				get: function() {
					return u.GAstVisitor
				}
			});

			function h() {
				console.warn(`The clearCache function was 'soft' removed from the Chevrotain API.
	 It performs no action other than printing this message.
	 Please avoid using it as it will be completely removed in the future`)
			}
			r.clearCache = h;
			var f = HE();
			Object.defineProperty(r, "createSyntaxDiagramsCode", {
				enumerable: !0,
				get: function() {
					return f.createSyntaxDiagramsCode
				}
			});
			var p = function() {
				function g() {
					throw new Error(`The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.
See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0`)
				}
				return g
			}();
			r.Parser = p
		}),
		Lo = WE();
	var Eh = class extends ei {
			constructor(e) {
				if (super(e), typeof Lo > "u") throw Error("THREE.VRMLLoader: External library chevrotain.min.js required.")
			}
			load(e, t, n, i) {
				let s = this,
					o = s.path === "" ? fi.extractUrlBase(e) : s.path,
					a = new ar(s.manager);
				a.setPath(s.path), a.setRequestHeader(s.requestHeader), a.setWithCredentials(s.withCredentials), a.load(e, function(c) {
					try {
						t(s.parse(c, o))
					} catch (l) {
						i ? i(l) : console.error(l), s.manager.itemError(e)
					}
				}, n, i)
			}
			parse(e, t) {
				let n = {};

				function i(E) {
					let M = s(),
						D = new rm(M.tokens),
						X = new sm(M.tokenVocabulary),
						W = o(X.getBaseCstVisitorConstructor()),
						te = D.lex(E);
					X.input = te.tokens;
					let ce = X.vrml();
					if (X.errors.length > 0) throw console.error(X.errors), Error("THREE.VRMLLoader: Parsing errors detected.");
					return W.visit(ce)
				}

				function s() {
					let E = Lo.createToken,
						M = E({
							name: "RouteIdentifier",
							pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*[\.][^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/
						}),
						D = E({
							name: "Identifier",
							pattern: /[^\x30-\x39\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d][^\0-\x20\x22\x27\x23\x2b\x2c\x2d\x2e\x5b\x5d\x5c\x7b\x7d]*/,
							longer_alt: M
						}),
						X = ["Anchor", "Billboard", "Collision", "Group", "Transform", "Inline", "LOD", "Switch", "AudioClip", "DirectionalLight", "PointLight", "Script", "Shape", "Sound", "SpotLight", "WorldInfo", "CylinderSensor", "PlaneSensor", "ProximitySensor", "SphereSensor", "TimeSensor", "TouchSensor", "VisibilitySensor", "Box", "Cone", "Cylinder", "ElevationGrid", "Extrusion", "IndexedFaceSet", "IndexedLineSet", "PointSet", "Sphere", "Color", "Coordinate", "Normal", "TextureCoordinate", "Appearance", "FontStyle", "ImageTexture", "Material", "MovieTexture", "PixelTexture", "TextureTransform", "ColorInterpolator", "CoordinateInterpolator", "NormalInterpolator", "OrientationInterpolator", "PositionInterpolator", "ScalarInterpolator", "Background", "Fog", "NavigationInfo", "Viewpoint", "Text"],
						W = E({
							name: "Version",
							pattern: /#VRML.*/,
							longer_alt: D
						}),
						te = E({
							name: "NodeName",
							pattern: new RegExp(X.join("|")),
							longer_alt: D
						}),
						ce = E({
							name: "DEF",
							pattern: /DEF/,
							longer_alt: D
						}),
						le = E({
							name: "USE",
							pattern: /USE/,
							longer_alt: D
						}),
						ee = E({
							name: "ROUTE",
							pattern: /ROUTE/,
							longer_alt: D
						}),
						pe = E({
							name: "TO",
							pattern: /TO/,
							longer_alt: D
						}),
						ve = E({
							name: "StringLiteral",
							pattern: /"(?:[^\\"\n\r]|\\[bfnrtv"\\/]|\\u[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F])*"/
						}),
						Se = E({
							name: "HexLiteral",
							pattern: /0[xX][0-9a-fA-F]+/
						}),
						Re = E({
							name: "NumberLiteral",
							pattern: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?/
						}),
						We = E({
							name: "TrueLiteral",
							pattern: /TRUE/
						}),
						Ye = E({
							name: "FalseLiteral",
							pattern: /FALSE/
						}),
						re = E({
							name: "NullLiteral",
							pattern: /NULL/
						}),
						Ce = E({
							name: "LSquare",
							pattern: /\[/
						}),
						Te = E({
							name: "RSquare",
							pattern: /]/
						}),
						ge = E({
							name: "LCurly",
							pattern: /{/
						}),
						we = E({
							name: "RCurly",
							pattern: /}/
						}),
						Oe = E({
							name: "Comment",
							pattern: /#.*/,
							group: Lo.Lexer.SKIPPED
						}),
						vt = [E({
							name: "WhiteSpace",
							pattern: /[ ,\s]/,
							group: Lo.Lexer.SKIPPED
						}), te, ce, le, ee, pe, We, Ye, re, W, D, M, ve, Se, Re, Ce, Te, ge, we, Oe],
						Wt = {};
					for (let Ze = 0, Fe = vt.length; Ze < Fe; Ze++) {
						let Ie = vt[Ze];
						Wt[Ie.name] = Ie
					}
					return {
						tokens: vt,
						tokenVocabulary: Wt
					}
				}

				function o(E) {
					class M extends E {
						constructor() {
							super(), this.validateVisitor()
						}
						vrml(W) {
							let te = {
								version: this.visit(W.version),
								nodes: [],
								routes: []
							};
							for (let ce = 0, le = W.node.length; ce < le; ce++) {
								let ee = W.node[ce];
								te.nodes.push(this.visit(ee))
							}
							if (W.route)
								for (let ce = 0, le = W.route.length; ce < le; ce++) {
									let ee = W.route[ce];
									te.routes.push(this.visit(ee))
								}
							return te
						}
						version(W) {
							return W.Version[0].image
						}
						node(W) {
							let te = {
								name: W.NodeName[0].image,
								fields: []
							};
							if (W.field)
								for (let ce = 0, le = W.field.length; ce < le; ce++) {
									let ee = W.field[ce];
									te.fields.push(this.visit(ee))
								}
							return W.def && (te.DEF = this.visit(W.def[0])), te
						}
						field(W) {
							let te = {
									name: W.Identifier[0].image,
									type: null,
									values: null
								},
								ce;
							return W.singleFieldValue && (ce = this.visit(W.singleFieldValue[0])), W.multiFieldValue && (ce = this.visit(W.multiFieldValue[0])), te.type = ce.type, te.values = ce.values, te
						}
						def(W) {
							return (W.Identifier || W.NodeName)[0].image
						}
						use(W) {
							return {
								USE: (W.Identifier || W.NodeName)[0].image
							}
						}
						singleFieldValue(W) {
							return D(this, W)
						}
						multiFieldValue(W) {
							return D(this, W)
						}
						route(W) {
							return {
								FROM: W.RouteIdentifier[0].image,
								TO: W.RouteIdentifier[1].image
							}
						}
					}

					function D(X, W) {
						let te = {
							type: null,
							values: []
						};
						if (W.node) {
							te.type = "node";
							for (let ce = 0, le = W.node.length; ce < le; ce++) {
								let ee = W.node[ce];
								te.values.push(X.visit(ee))
							}
						}
						if (W.use) {
							te.type = "use";
							for (let ce = 0, le = W.use.length; ce < le; ce++) {
								let ee = W.use[ce];
								te.values.push(X.visit(ee))
							}
						}
						if (W.StringLiteral) {
							te.type = "string";
							for (let ce = 0, le = W.StringLiteral.length; ce < le; ce++) {
								let ee = W.StringLiteral[ce];
								te.values.push(ee.image.replace(/'|"/g, ""))
							}
						}
						if (W.NumberLiteral) {
							te.type = "number";
							for (let ce = 0, le = W.NumberLiteral.length; ce < le; ce++) {
								let ee = W.NumberLiteral[ce];
								te.values.push(parseFloat(ee.image))
							}
						}
						if (W.HexLiteral) {
							te.type = "hex";
							for (let ce = 0, le = W.HexLiteral.length; ce < le; ce++) {
								let ee = W.HexLiteral[ce];
								te.values.push(ee.image)
							}
						}
						if (W.TrueLiteral) {
							te.type = "boolean";
							for (let ce = 0, le = W.TrueLiteral.length; ce < le; ce++) W.TrueLiteral[ce].image === "TRUE" && te.values.push(!0)
						}
						if (W.FalseLiteral) {
							te.type = "boolean";
							for (let ce = 0, le = W.FalseLiteral.length; ce < le; ce++) W.FalseLiteral[ce].image === "FALSE" && te.values.push(!1)
						}
						return W.NullLiteral && (te.type = "null", W.NullLiteral.forEach(function() {
							te.values.push(null)
						})), te
					}
					return new M
				}

				function a(E) {
					let M = E.nodes,
						D = new wr;
					for (let X = 0, W = M.length; X < W; X++) {
						let te = M[X];
						c(te)
					}
					for (let X = 0, W = M.length; X < W; X++) {
						let te = M[X],
							ce = l(te);
						ce instanceof yt && D.add(ce), te.name === "WorldInfo" && (D.userData.worldInfo = ce)
					}
					return D
				}

				function c(E) {
					E.DEF && (n[E.DEF] = E);
					let M = E.fields;
					for (let D = 0, X = M.length; D < X; D++) {
						let W = M[D];
						if (W.type === "node") {
							let te = W.values;
							for (let ce = 0, le = te.length; ce < le; ce++) c(te[ce])
						}
					}
				}

				function l(E) {
					return E.USE ? B(E.USE) : (E.build !== void 0 || (E.build = u(E)), E.build)
				}

				function u(E) {
					let M = E.name,
						D;
					switch (M) {
						case "Anchor":
						case "Group":
						case "Transform":
						case "Collision":
							D = h(E);
							break;
						case "Background":
							D = f(E);
							break;
						case "Shape":
							D = p(E);
							break;
						case "Appearance":
							D = g(E);
							break;
						case "Material":
							D = m(E);
							break;
						case "ImageTexture":
							D = _(E);
							break;
						case "PixelTexture":
							D = x(E);
							break;
						case "TextureTransform":
							D = y(E);
							break;
						case "IndexedFaceSet":
							D = S(E);
							break;
						case "IndexedLineSet":
							D = b(E);
							break;
						case "PointSet":
							D = T(E);
							break;
						case "Box":
							D = N(E);
							break;
						case "Cone":
							D = V(E);
							break;
						case "Cylinder":
							D = O(E);
							break;
						case "Sphere":
							D = k(E);
							break;
						case "ElevationGrid":
							D = I(E);
							break;
						case "Extrusion":
							D = q(E);
							break;
						case "Color":
						case "Coordinate":
						case "Normal":
						case "TextureCoordinate":
							D = w(E);
							break;
						case "WorldInfo":
							D = C(E);
							break;
						case "Billboard":
						case "Inline":
						case "LOD":
						case "Switch":
						case "AudioClip":
						case "DirectionalLight":
						case "PointLight":
						case "Script":
						case "Sound":
						case "SpotLight":
						case "CylinderSensor":
						case "PlaneSensor":
						case "ProximitySensor":
						case "SphereSensor":
						case "TimeSensor":
						case "TouchSensor":
						case "VisibilitySensor":
						case "Text":
						case "FontStyle":
						case "MovieTexture":
						case "ColorInterpolator":
						case "CoordinateInterpolator":
						case "NormalInterpolator":
						case "OrientationInterpolator":
						case "PositionInterpolator":
						case "ScalarInterpolator":
						case "Fog":
						case "NavigationInfo":
						case "Viewpoint":
							break;
						default:
							console.warn("THREE.VRMLLoader: Unknown node:", M);
							break
					}
					return D !== void 0 && E.DEF !== void 0 && D.hasOwnProperty("name") === !0 && (D.name = E.DEF), D
				}

				function h(E) {
					let M = new _n,
						D = E.fields;
					for (let X = 0, W = D.length; X < W; X++) {
						let te = D[X],
							ce = te.name,
							le = te.values;
						switch (ce) {
							case "bboxCenter":
								break;
							case "bboxSize":
								break;
							case "center":
								break;
							case "children":
								Y(le, M);
								break;
							case "description":
								break;
							case "collide":
								break;
							case "parameter":
								break;
							case "rotation":
								let ee = new ne(le[0], le[1], le[2]),
									pe = le[3];
								M.quaternion.setFromAxisAngle(ee, pe);
								break;
							case "scale":
								M.scale.set(le[0], le[1], le[2]);
								break;
							case "scaleOrientation":
								break;
							case "translation":
								M.position.set(le[0], le[1], le[2]);
								break;
							case "proxy":
								break;
							case "url":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ce);
								break
						}
					}
					return M
				}

				function f(E) {
					let M = new _n,
						D, X, W, te, ce = E.fields;
					for (let ee = 0, pe = ce.length; ee < pe; ee++) {
						let ve = ce[ee],
							Se = ve.name,
							Re = ve.values;
						switch (Se) {
							case "groundAngle":
								D = Re;
								break;
							case "groundColor":
								X = Re;
								break;
							case "backUrl":
								break;
							case "bottomUrl":
								break;
							case "frontUrl":
								break;
							case "leftUrl":
								break;
							case "rightUrl":
								break;
							case "topUrl":
								break;
							case "skyAngle":
								W = Re;
								break;
							case "skyColor":
								te = Re;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Se);
								break
						}
					}
					let le = 1e4;
					if (te) {
						let ee = new Os(le, 32, 16),
							pe = new Oi({
								fog: !1,
								side: Rn,
								depthWrite: !1,
								depthTest: !1
							});
						te.length > 3 ? (He(ee, le, W, ct(te), !0), pe.vertexColors = !0) : pe.color.setRGB(te[0], te[1], te[2]);
						let ve = new zt(ee, pe);
						M.add(ve)
					}
					if (X && X.length > 0) {
						let ee = new Os(le, 32, 16, 0, 2 * Math.PI, .5 * Math.PI, 1.5 * Math.PI),
							pe = new Oi({
								fog: !1,
								side: Rn,
								vertexColors: !0,
								depthWrite: !1,
								depthTest: !1
							});
						He(ee, le, D, ct(X), !1);
						let ve = new zt(ee, pe);
						M.add(ve)
					}
					return M.renderOrder = -1 / 0, M
				}

				function p(E) {
					let M = E.fields,
						D = new Oi({
							color: 0
						}),
						X;
					for (let te = 0, ce = M.length; te < ce; te++) {
						let le = M[te],
							ee = le.name,
							pe = le.values;
						switch (ee) {
							case "appearance":
								pe[0] !== null && (D = l(pe[0]));
								break;
							case "geometry":
								pe[0] !== null && (X = l(pe[0]));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ee);
								break
						}
					}
					let W;
					if (X && X.attributes.position) {
						let te = X._type;
						if (te === "points") {
							let ce = new Il({
								color: 16777215
							});
							X.attributes.color !== void 0 ? ce.vertexColors = !0 : D.isMeshPhongMaterial && ce.color.copy(D.emissive), W = new vu(X, ce)
						} else if (te === "line") {
							let ce = new Si({
								color: 16777215
							});
							X.attributes.color !== void 0 ? ce.vertexColors = !0 : D.isMeshPhongMaterial && ce.color.copy(D.emissive), W = new Ns(X, ce)
						} else X._solid !== void 0 && (D.side = X._solid ? _r : Bn), X.attributes.color !== void 0 && (D.vertexColors = !0), W = new zt(X, D)
					} else W = new yt, W.visible = !1;
					return W
				}

				function g(E) {
					let M = new an,
						D, X = E.fields;
					for (let W = 0, te = X.length; W < te; W++) {
						let ce = X[W],
							le = ce.name,
							ee = ce.values;
						switch (le) {
							case "material":
								if (ee[0] !== null) {
									let ve = l(ee[0]);
									ve.diffuseColor && M.color.copy(ve.diffuseColor), ve.emissiveColor && M.emissive.copy(ve.emissiveColor), ve.shininess && (M.shininess = ve.shininess), ve.specularColor && M.specular.copy(ve.specularColor), ve.transparency && (M.opacity = 1 - ve.transparency), ve.transparency > 0 && (M.transparent = !0)
								} else M = new Oi({
									color: 0
								});
								break;
							case "texture":
								let pe = ee[0];
								pe !== null && (pe.name === "ImageTexture" || pe.name === "PixelTexture") && (M.map = l(pe));
								break;
							case "textureTransform":
								ee[0] !== null && (D = l(ee[0]));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", le);
								break
						}
					}
					if (M.map) {
						if (M.map.__type) {
							switch (M.map.__type) {
								case fr.INTENSITY_ALPHA:
									M.opacity = 1;
									break;
								case fr.RGB:
									M.color.set(16777215);
									break;
								case fr.RGBA:
									M.color.set(16777215), M.opacity = 1;
									break;
								default:
							}
							delete M.map.__type
						}
						D && (M.map.center.copy(D.center), M.map.rotation = D.rotation, M.map.repeat.copy(D.scale), M.map.offset.copy(D.translation))
					}
					return M
				}

				function m(E) {
					let M = {},
						D = E.fields;
					for (let X = 0, W = D.length; X < W; X++) {
						let te = D[X],
							ce = te.name,
							le = te.values;
						switch (ce) {
							case "ambientIntensity":
								break;
							case "diffuseColor":
								M.diffuseColor = new Xe(le[0], le[1], le[2]);
								break;
							case "emissiveColor":
								M.emissiveColor = new Xe(le[0], le[1], le[2]);
								break;
							case "shininess":
								M.shininess = le[0];
								break;
							case "specularColor":
								M.emissiveColor = new Xe(le[0], le[1], le[2]);
								break;
							case "transparency":
								M.transparency = le[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ce);
								break
						}
					}
					return M
				}

				function d(E, M, D) {
					let X;
					switch (M) {
						case fr.INTENSITY:
							X = parseInt(E), D.r = X, D.g = X, D.b = X, D.a = 1;
							break;
						case fr.INTENSITY_ALPHA:
							X = parseInt("0x" + E.substring(2, 4)), D.r = X, D.g = X, D.b = X, D.a = parseInt("0x" + E.substring(4, 6));
							break;
						case fr.RGB:
							D.r = parseInt("0x" + E.substring(2, 4)), D.g = parseInt("0x" + E.substring(4, 6)), D.b = parseInt("0x" + E.substring(6, 8)), D.a = 1;
							break;
						case fr.RGBA:
							D.r = parseInt("0x" + E.substring(2, 4)), D.g = parseInt("0x" + E.substring(4, 6)), D.b = parseInt("0x" + E.substring(6, 8)), D.a = parseInt("0x" + E.substring(8, 10));
							break;
						default:
					}
				}

				function v(E) {
					let M;
					switch (E) {
						case 1:
							M = fr.INTENSITY;
							break;
						case 2:
							M = fr.INTENSITY_ALPHA;
							break;
						case 3:
							M = fr.RGB;
							break;
						case 4:
							M = fr.RGBA;
							break;
						default:
					}
					return M
				}

				function x(E) {
					let M, D = en,
						X = en,
						W = E.fields;
					for (let te = 0, ce = W.length; te < ce; te++) {
						let le = W[te],
							ee = le.name,
							pe = le.values;
						switch (ee) {
							case "image":
								let ve = pe[0],
									Se = pe[1],
									Re = pe[2],
									We = v(Re),
									Ye = new Uint8Array(4 * ve * Se),
									re = {
										r: 0,
										g: 0,
										b: 0,
										a: 0
									};
								for (let Ce = 3, Te = 0, ge = pe.length; Ce < ge; Ce++, Te++) {
									d(pe[Ce], We, re);
									let we = Te * 4;
									Ye[we + 0] = re.r, Ye[we + 1] = re.g, Ye[we + 2] = re.b, Ye[we + 3] = re.a
								}
								M = new xa(Ye, ve, Se), M.needsUpdate = !0, M.__type = We;
								break;
							case "repeatS":
								pe[0] === !1 && (D = Xt);
								break;
							case "repeatT":
								pe[0] === !1 && (X = Xt);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ee);
								break
						}
					}
					return M && (M.wrapS = D, M.wrapT = X), M
				}

				function _(E) {
					let M, D = en,
						X = en,
						W = E.fields;
					for (let te = 0, ce = W.length; te < ce; te++) {
						let le = W[te],
							ee = le.name,
							pe = le.values;
						switch (ee) {
							case "url":
								let ve = pe[0];
								ve && (M = Ve.load(ve));
								break;
							case "repeatS":
								pe[0] === !1 && (D = Xt);
								break;
							case "repeatT":
								pe[0] === !1 && (X = Xt);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ee);
								break
						}
					}
					return M && (M.wrapS = D, M.wrapT = X), M
				}

				function y(E) {
					let M = {
							center: new st,
							rotation: new st,
							scale: new st,
							translation: new st
						},
						D = E.fields;
					for (let X = 0, W = D.length; X < W; X++) {
						let te = D[X],
							ce = te.name,
							le = te.values;
						switch (ce) {
							case "center":
								M.center.set(le[0], le[1]);
								break;
							case "rotation":
								M.rotation = le[0];
								break;
							case "scale":
								M.scale.set(le[0], le[1]);
								break;
							case "translation":
								M.translation.set(le[0], le[1]);
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ce);
								break
						}
					}
					return M
				}

				function w(E) {
					return E.fields[0].values
				}

				function C(E) {
					let M = {},
						D = E.fields;
					for (let X = 0, W = D.length; X < W; X++) {
						let te = D[X],
							ce = te.name,
							le = te.values;
						switch (ce) {
							case "title":
								M.title = le[0];
								break;
							case "info":
								M.info = le;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ce);
								break
						}
					}
					return M
				}

				function S(E) {
					let M, D, X, W, te = !0,
						ce = !0,
						le = 0,
						ee, pe, ve, Se, Re = !0,
						We = !0,
						Ye = E.fields;
					for (let $e = 0, vt = Ye.length; $e < vt; $e++) {
						let Wt = Ye[$e],
							Ze = Wt.name,
							Fe = Wt.values;
						switch (Ze) {
							case "color":
								let Ie = Fe[0];
								Ie !== null && (M = l(Ie));
								break;
							case "coord":
								let Ue = Fe[0];
								Ue !== null && (D = l(Ue));
								break;
							case "normal":
								let je = Fe[0];
								je !== null && (X = l(je));
								break;
							case "texCoord":
								let Ke = Fe[0];
								Ke !== null && (W = l(Ke));
								break;
							case "ccw":
								te = Fe[0];
								break;
							case "colorIndex":
								ee = Fe;
								break;
							case "colorPerVertex":
								Re = Fe[0];
								break;
							case "convex":
								break;
							case "coordIndex":
								pe = Fe;
								break;
							case "creaseAngle":
								le = Fe[0];
								break;
							case "normalIndex":
								ve = Fe;
								break;
							case "normalPerVertex":
								We = Fe[0];
								break;
							case "solid":
								ce = Fe[0];
								break;
							case "texCoordIndex":
								Se = Fe;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Ze);
								break
						}
					}
					if (pe === void 0) return console.warn("THREE.VRMLLoader: Missing coordIndex."), new bt;
					let re = J(pe, te),
						Ce, Te, ge;
					if (M)
						if (Re === !0)
							if (ee && ee.length > 0) {
								let $e = J(ee, te);
								Ce = Q(re, $e, M, 3)
							} else Ce = ue(re, new ze(M, 3));
					else if (ee && ee.length > 0) {
						let $e = $(M, ee),
							vt = H($e, pe);
						Ce = se(re, vt)
					} else {
						let $e = H(M, pe);
						Ce = se(re, $e)
					}
					if (X)
						if (We === !0)
							if (ve && ve.length > 0) {
								let $e = J(ve, te);
								Te = Q(re, $e, X, 3)
							} else Te = ue(re, new ze(X, 3));
					else if (ve && ve.length > 0) {
						let $e = $(X, ve),
							vt = H($e, pe);
						Te = se(re, vt)
					} else {
						let $e = H(X, pe);
						Te = se(re, $e)
					} else Te = De(re, D, le);
					if (W)
						if (Se && Se.length > 0) {
							let $e = J(Se, te);
							ge = Q(re, $e, W, 2)
						} else ge = ue(re, new ze(W, 2));
					let we = new bt,
						Oe = ue(re, new ze(D, 3));
					return we.setAttribute("position", Oe), we.setAttribute("normal", Te), Ce && we.setAttribute("color", Ce), ge && we.setAttribute("uv", ge), we._solid = ce, we._type = "mesh", we
				}

				function b(E) {
					let M, D, X, W, te = !0,
						ce = E.fields;
					for (let Se = 0, Re = ce.length; Se < Re; Se++) {
						let We = ce[Se],
							Ye = We.name,
							re = We.values;
						switch (Ye) {
							case "color":
								let Ce = re[0];
								Ce !== null && (M = l(Ce));
								break;
							case "coord":
								let Te = re[0];
								Te !== null && (D = l(Te));
								break;
							case "colorIndex":
								X = re;
								break;
							case "colorPerVertex":
								te = re[0];
								break;
							case "coordIndex":
								W = re;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Ye);
								break
						}
					}
					let le, ee = ae(W);
					if (M)
						if (te === !0)
							if (X.length > 0) {
								let Se = ae(X);
								le = Q(ee, Se, M, 3)
							} else le = ue(ee, new ze(M, 3));
					else if (X.length > 0) {
						let Se = $(M, X),
							Re = oe(Se, W);
						le = de(ee, Re)
					} else {
						let Se = oe(M, W);
						le = de(ee, Se)
					}
					let pe = new bt,
						ve = ue(ee, new ze(D, 3));
					return pe.setAttribute("position", ve), le && pe.setAttribute("color", le), pe._type = "line", pe
				}

				function T(E) {
					let M, D, X = E.fields;
					for (let te = 0, ce = X.length; te < ce; te++) {
						let le = X[te],
							ee = le.name,
							pe = le.values;
						switch (ee) {
							case "color":
								let ve = pe[0];
								ve !== null && (M = l(ve));
								break;
							case "coord":
								let Se = pe[0];
								Se !== null && (D = l(Se));
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ee);
								break
						}
					}
					let W = new bt;
					return W.setAttribute("position", new ze(D, 3)), M && W.setAttribute("color", new ze(M, 3)), W._type = "points", W
				}

				function N(E) {
					let M = new ne(2, 2, 2),
						D = E.fields;
					for (let W = 0, te = D.length; W < te; W++) {
						let ce = D[W],
							le = ce.name,
							ee = ce.values;
						switch (le) {
							case "size":
								M.x = ee[0], M.y = ee[1], M.z = ee[2];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", le);
								break
						}
					}
					return new Jr(M.x, M.y, M.z)
				}

				function V(E) {
					let M = 1,
						D = 2,
						X = !1,
						W = E.fields;
					for (let ce = 0, le = W.length; ce < le; ce++) {
						let ee = W[ce],
							pe = ee.name,
							ve = ee.values;
						switch (pe) {
							case "bottom":
								X = !ve[0];
								break;
							case "bottomRadius":
								M = ve[0];
								break;
							case "height":
								D = ve[0];
								break;
							case "side":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", pe);
								break
						}
					}
					return new ya(M, D, 16, 1, X)
				}

				function O(E) {
					let M = 1,
						D = 2,
						X = E.fields;
					for (let te = 0, ce = X.length; te < ce; te++) {
						let le = X[te],
							ee = le.name,
							pe = le.values;
						switch (ee) {
							case "bottom":
								break;
							case "radius":
								M = pe[0];
								break;
							case "height":
								D = pe[0];
								break;
							case "side":
								break;
							case "top":
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", ee);
								break
						}
					}
					return new So(M, M, D, 16, 1)
				}

				function k(E) {
					let M = 1,
						D = E.fields;
					for (let W = 0, te = D.length; W < te; W++) {
						let ce = D[W],
							le = ce.name,
							ee = ce.values;
						switch (le) {
							case "radius":
								M = ee[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", le);
								break
						}
					}
					return new Os(M, 16, 16)
				}

				function I(E) {
					let M, D, X, W, te = !0,
						ce = !0,
						le = !0,
						ee = !0,
						pe = 0,
						ve = 2,
						Se = 2,
						Re = 1,
						We = 1,
						Ye = E.fields;
					for (let Fe = 0, Ie = Ye.length; Fe < Ie; Fe++) {
						let Ue = Ye[Fe],
							je = Ue.name,
							Ke = Ue.values;
						switch (je) {
							case "color":
								let jt = Ke[0];
								jt !== null && (M = l(jt));
								break;
							case "normal":
								let Ii = Ke[0];
								Ii !== null && (D = l(Ii));
								break;
							case "texCoord":
								let Ri = Ke[0];
								Ri !== null && (X = l(Ri));
								break;
							case "height":
								W = Ke;
								break;
							case "ccw":
								ee = Ke[0];
								break;
							case "colorPerVertex":
								te = Ke[0];
								break;
							case "creaseAngle":
								pe = Ke[0];
								break;
							case "normalPerVertex":
								ce = Ke[0];
								break;
							case "solid":
								le = Ke[0];
								break;
							case "xDimension":
								ve = Ke[0];
								break;
							case "xSpacing":
								Re = Ke[0];
								break;
							case "zDimension":
								Se = Ke[0];
								break;
							case "zSpacing":
								We = Ke[0];
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", je);
								break
						}
					}
					let re = [],
						Ce = [],
						Te = [],
						ge = [];
					for (let Fe = 0; Fe < Se; Fe++)
						for (let Ie = 0; Ie < ve; Ie++) {
							let Ue = Fe * ve + Ie,
								je = Re * Fe,
								Ke = W[Ue],
								jt = We * Ie;
							if (re.push(je, Ke, jt), M && te === !0) {
								let Ii = M[Ue * 3 + 0],
									Ri = M[Ue * 3 + 1],
									Z = M[Ue * 3 + 2];
								Te.push(Ii, Ri, Z)
							}
							if (D && ce === !0) {
								let Ii = D[Ue * 3 + 0],
									Ri = D[Ue * 3 + 1],
									Z = D[Ue * 3 + 2];
								Ce.push(Ii, Ri, Z)
							}
							if (X) {
								let Ii = X[Ue * 2 + 0],
									Ri = X[Ue * 2 + 1];
								ge.push(Ii, Ri)
							} else ge.push(Fe / (ve - 1), Ie / (Se - 1))
						}
					let we = [];
					for (let Fe = 0; Fe < ve - 1; Fe++)
						for (let Ie = 0; Ie < Se - 1; Ie++) {
							let Ue = Fe + Ie * ve,
								je = Fe + (Ie + 1) * ve,
								Ke = Fe + 1 + (Ie + 1) * ve,
								jt = Fe + 1 + Ie * ve;
							ee === !0 ? (we.push(Ue, Ke, je), we.push(Ke, Ue, jt)) : (we.push(Ue, je, Ke), we.push(Ke, jt, Ue))
						}
					let Oe = ue(we, new ze(re, 3)),
						$e = ue(we, new ze(ge, 2)),
						vt, Wt;
					if (M)
						if (te === !1) {
							for (let Fe = 0; Fe < ve - 1; Fe++)
								for (let Ie = 0; Ie < Se - 1; Ie++) {
									let Ue = Fe + Ie * (ve - 1),
										je = M[Ue * 3 + 0],
										Ke = M[Ue * 3 + 1],
										jt = M[Ue * 3 + 2];
									Te.push(je, Ke, jt), Te.push(je, Ke, jt), Te.push(je, Ke, jt), Te.push(je, Ke, jt), Te.push(je, Ke, jt), Te.push(je, Ke, jt)
								}
							vt = new ze(Te, 3)
						} else vt = ue(we, new ze(Te, 3));
					if (D)
						if (ce === !1) {
							for (let Fe = 0; Fe < ve - 1; Fe++)
								for (let Ie = 0; Ie < Se - 1; Ie++) {
									let Ue = Fe + Ie * (ve - 1),
										je = D[Ue * 3 + 0],
										Ke = D[Ue * 3 + 1],
										jt = D[Ue * 3 + 2];
									Ce.push(je, Ke, jt), Ce.push(je, Ke, jt), Ce.push(je, Ke, jt), Ce.push(je, Ke, jt), Ce.push(je, Ke, jt), Ce.push(je, Ke, jt)
								}
							Wt = new ze(Ce, 3)
						} else Wt = ue(we, new ze(Ce, 3));
					else Wt = De(we, re, pe);
					let Ze = new bt;
					return Ze.setAttribute("position", Oe), Ze.setAttribute("normal", Wt), Ze.setAttribute("uv", $e), vt && Ze.setAttribute("color", vt), Ze._solid = le, Ze._type = "mesh", Ze
				}

				function q(E) {
					let M = [1, 1, 1, -1, -1, -1, -1, 1, 1, 1],
						D = [0, 0, 0, 0, 1, 0],
						X, W, te = !0,
						ce = !0,
						le = 0,
						ee = !0,
						pe = !0,
						ve = E.fields;
					for (let Ze = 0, Fe = ve.length; Ze < Fe; Ze++) {
						let Ie = ve[Ze],
							Ue = Ie.name,
							je = Ie.values;
						switch (Ue) {
							case "beginCap":
								te = je[0];
								break;
							case "ccw":
								ce = je[0];
								break;
							case "convex":
								break;
							case "creaseAngle":
								le = je[0];
								break;
							case "crossSection":
								M = je;
								break;
							case "endCap":
								ee = je[0];
								break;
							case "orientation":
								W = je;
								break;
							case "scale":
								X = je;
								break;
							case "solid":
								pe = je[0];
								break;
							case "spine":
								D = je;
								break;
							default:
								console.warn("THREE.VRMLLoader: Unknown field:", Ue);
								break
						}
					}
					let Se = M[0] === M[M.length - 2] && M[1] === M[M.length - 1],
						Re = [],
						We = new ne,
						Ye = new ne,
						re = new ne,
						Ce = new ne,
						Te = new mn;
					for (let Ze = 0, Fe = 0, Ie = 0, Ue = D.length; Ze < Ue; Ze += 3, Fe += 2, Ie += 4) {
						We.fromArray(D, Ze), Ye.x = X ? X[Fe + 0] : 1, Ye.y = 1, Ye.z = X ? X[Fe + 1] : 1, re.x = W ? W[Ie + 0] : 0, re.y = W ? W[Ie + 1] : 0, re.z = W ? W[Ie + 2] : 1;
						let je = W ? W[Ie + 3] : 0;
						for (let Ke = 0, jt = M.length; Ke < jt; Ke += 2) Ce.x = M[Ke + 0], Ce.y = 0, Ce.z = M[Ke + 1], Ce.multiply(Ye), Te.setFromAxisAngle(re, je), Ce.applyQuaternion(Te), Ce.add(We), Re.push(Ce.x, Ce.y, Ce.z)
					}
					let ge = [],
						we = D.length / 3,
						Oe = M.length / 2;
					for (let Ze = 0; Ze < we - 1; Ze++)
						for (let Fe = 0; Fe < Oe - 1; Fe++) {
							let Ie = Fe + Ze * Oe,
								Ue = Fe + 1 + Ze * Oe,
								je = Fe + (Ze + 1) * Oe,
								Ke = Fe + 1 + (Ze + 1) * Oe;
							Fe === Oe - 2 && Se === !0 && (Ue = Ze * Oe, Ke = (Ze + 1) * Oe), ce === !0 ? (ge.push(Ie, Ue, je), ge.push(je, Ue, Ke)) : (ge.push(Ie, je, Ue), ge.push(je, Ke, Ue))
						}
					if (te === !0 || ee === !0) {
						let Ze = [];
						for (let Ue = 0, je = M.length; Ue < je; Ue += 2) Ze.push(new st(M[Ue], M[Ue + 1]));
						let Fe = _a.triangulateShape(Ze, []),
							Ie = [];
						for (let Ue = 0, je = Fe.length; Ue < je; Ue++) {
							let Ke = Fe[Ue];
							Ie.push(Ke[0], Ke[1], Ke[2])
						}
						if (te === !0)
							for (let Ue = 0, je = Ie.length; Ue < je; Ue += 3) ce === !0 ? ge.push(Ie[Ue + 0], Ie[Ue + 1], Ie[Ue + 2]) : ge.push(Ie[Ue + 0], Ie[Ue + 2], Ie[Ue + 1]);
						if (ee === !0) {
							let Ue = Oe * (we - 1);
							for (let je = 0, Ke = Ie.length; je < Ke; je += 3) ce === !0 ? ge.push(Ue + Ie[je + 0], Ue + Ie[je + 2], Ue + Ie[je + 1]) : ge.push(Ue + Ie[je + 0], Ue + Ie[je + 1], Ue + Ie[je + 2])
						}
					}
					let $e = ue(ge, new ze(Re, 3)),
						vt = De(ge, Re, le),
						Wt = new bt;
					return Wt.setAttribute("position", $e), Wt.setAttribute("normal", vt), Wt._solid = pe, Wt._type = "mesh", Wt
				}

				function B(E) {
					let M = n[E],
						D = l(M);
					return D.isObject3D || D.isMaterial ? D.clone() : D
				}

				function Y(E, M) {
					for (let D = 0, X = E.length; D < X; D++) {
						let W = l(E[D]);
						W instanceof yt && M.add(W)
					}
				}

				function J(E, M) {
					let D = [],
						X = 0;
					for (let W = 0, te = E.length; W < te; W++) {
						let ce = E[X],
							le = E[W + (M ? 1 : 2)],
							ee = E[W + (M ? 2 : 1)];
						D.push(ce, le, ee), (E[W + 3] === -1 || W + 3 >= te) && (W += 3, X = W + 1)
					}
					return D
				}

				function H(E, M) {
					let D = [],
						X = 0;
					for (let W = 0, te = M.length; W < te; W++) {
						let ce = X * 3,
							le = E[ce],
							ee = E[ce + 1],
							pe = E[ce + 2];
						D.push(le, ee, pe), (M[W + 3] === -1 || W + 3 >= te) && (W += 3, X++)
					}
					return D
				}

				function $(E, M) {
					let D = [];
					for (let X = 0, W = M.length; X < W; X++) {
						let ce = M[X] * 3,
							le = E[ce],
							ee = E[ce + 1],
							pe = E[ce + 2];
						D.push(le, ee, pe)
					}
					return D
				}

				function ae(E) {
					let M = [];
					for (let D = 0, X = E.length; D < X; D++) {
						let W = E[D],
							te = E[D + 1];
						M.push(W, te), (E[D + 2] === -1 || D + 2 >= X) && (D += 2)
					}
					return M
				}

				function oe(E, M) {
					let D = [],
						X = 0;
					for (let W = 0, te = M.length; W < te; W++) {
						let ce = X * 3,
							le = E[ce],
							ee = E[ce + 1],
							pe = E[ce + 2];
						D.push(le, ee, pe), (M[W + 2] === -1 || W + 2 >= te) && (W += 2, X++)
					}
					return D
				}
				let ie = new ne,
					U = new ne,
					A = new ne,
					L = new st,
					j = new st,
					K = new st;

				function Q(E, M, D, X) {
					let W = [];
					for (let te = 0, ce = E.length; te < ce; te += 3) {
						let le = M[te],
							ee = M[te + 1],
							pe = M[te + 2];
						X === 2 ? (L.fromArray(D, le * X), j.fromArray(D, ee * X), K.fromArray(D, pe * X), W.push(L.x, L.y), W.push(j.x, j.y), W.push(K.x, K.y)) : (ie.fromArray(D, le * X), U.fromArray(D, ee * X), A.fromArray(D, pe * X), W.push(ie.x, ie.y, ie.z), W.push(U.x, U.y, U.z), W.push(A.x, A.y, A.z))
					}
					return new ze(W, X)
				}

				function se(E, M) {
					let D = [];
					for (let X = 0, W = 0, te = E.length; X < te; X += 3, W++) ie.fromArray(M, W * 3), D.push(ie.x, ie.y, ie.z), D.push(ie.x, ie.y, ie.z), D.push(ie.x, ie.y, ie.z);
					return new ze(D, 3)
				}

				function de(E, M) {
					let D = [];
					for (let X = 0, W = 0, te = E.length; X < te; X += 2, W++) ie.fromArray(M, W * 3), D.push(ie.x, ie.y, ie.z), D.push(ie.x, ie.y, ie.z);
					return new ze(D, 3)
				}

				function ue(E, M) {
					let D = M.array,
						X = M.itemSize,
						W = new D.constructor(E.length * X),
						te = 0,
						ce = 0;
					for (let le = 0, ee = E.length; le < ee; le++) {
						te = E[le] * X;
						for (let pe = 0; pe < X; pe++) W[ce++] = D[te++]
					}
					return new ze(W, X)
				}
				let xe = new ne,
					Ee = new ne;

				function De(E, M, D) {
					let X = [],
						W = {};
					for (let ce = 0, le = E.length; ce < le; ce += 3) {
						let ee = E[ce],
							pe = E[ce + 1],
							ve = E[ce + 2],
							Se = new om(ee, pe, ve);
						ie.fromArray(M, ee * 3), U.fromArray(M, pe * 3), A.fromArray(M, ve * 3), Ee.subVectors(A, U), xe.subVectors(ie, U), Ee.cross(xe), Ee.normalize(), Se.normal.copy(Ee), W[ee] === void 0 && (W[ee] = []), W[pe] === void 0 && (W[pe] = []), W[ve] === void 0 && (W[ve] = []), W[ee].push(Se.normal), W[pe].push(Se.normal), W[ve].push(Se.normal), X.push(Se)
					}
					let te = [];
					for (let ce = 0, le = X.length; ce < le; ce++) {
						let ee = X[ce],
							pe = ht(W[ee.a], ee.normal, D),
							ve = ht(W[ee.b], ee.normal, D),
							Se = ht(W[ee.c], ee.normal, D);
						ie.fromArray(M, ee.a * 3), U.fromArray(M, ee.b * 3), A.fromArray(M, ee.c * 3), te.push(pe.x, pe.y, pe.z), te.push(ve.x, ve.y, ve.z), te.push(Se.x, Se.y, Se.z)
					}
					return new ze(te, 3)
				}

				function ht(E, M, D) {
					let X = new ne;
					if (D === 0) X.copy(M);
					else
						for (let W = 0, te = E.length; W < te; W++) E[W].angleTo(M) < D && X.add(E[W]);
					return X.normalize()
				}

				function ct(E) {
					let M = [];
					for (let D = 0, X = E.length; D < X; D += 3) M.push(new Xe(E[D], E[D + 1], E[D + 2]));
					return M
				}

				function He(E, M, D, X, W) {
					let te = [],
						ce = W === !0 ? 0 : Math.PI;
					for (let Re = 0, We = X.length; Re < We; Re++) {
						let Ye = Re === 0 ? 0 : D[Re - 1];
						Ye = W === !0 ? Ye : ce - Ye;
						let re = new ne;
						re.setFromSphericalCoords(M, Ye, 0), te.push(re)
					}
					let le = E.index,
						ee = E.attributes.position,
						pe = new Gn(new Float32Array(E.attributes.position.count * 3), 3),
						ve = new ne,
						Se = new Xe;
					for (let Re = 0; Re < le.count; Re++) {
						let We = le.getX(Re);
						ve.fromBufferAttribute(ee, We);
						let Ye, re, Ce = 1;
						for (let we = 1; we < te.length; we++) {
							Ye = we - 1, re = we;
							let Oe = te[Ye],
								$e = te[re];
							if (W === !0) {
								if (ve.y <= Oe.y && ve.y > $e.y) {
									Ce = Math.abs(Oe.y - ve.y) / Math.abs(Oe.y - $e.y);
									break
								}
							} else if (ve.y >= Oe.y && ve.y < $e.y) {
								Ce = Math.abs(Oe.y - ve.y) / Math.abs(Oe.y - $e.y);
								break
							}
						}
						let Te = X[Ye],
							ge = X[re];
						Se.copy(Te)
							.lerp(ge, Ce), pe.setXYZ(We, Se.r, Se.g, Se.b)
					}
					E.setAttribute("color", pe)
				}
				let Ve = new Fi(this.manager);
				if (Ve.setPath(this.resourcePath || t)
					.setCrossOrigin(this.crossOrigin), e.indexOf("#VRML V2.0") === -1) throw Error("THREE.VRMLLexer: Version of VRML asset not supported.");
				let ot = i(e);
				return a(ot)
			}
		},
		rm = class {
			constructor(e) {
				this.lexer = new Lo.Lexer(e)
			}
			lex(e) {
				let t = this.lexer.tokenize(e);
				if (t.errors.length > 0) throw console.error(t.errors), Error("THREE.VRMLLexer: Lexing errors detected.");
				return t
			}
		},
		jE = Lo.CstParser,
		sm = class extends jE {
			constructor(e) {
				super(e);
				let t = this,
					n = e.Version,
					i = e.LCurly,
					s = e.RCurly,
					o = e.LSquare,
					a = e.RSquare,
					c = e.Identifier,
					l = e.RouteIdentifier,
					u = e.StringLiteral,
					h = e.HexLiteral,
					f = e.NumberLiteral,
					p = e.TrueLiteral,
					g = e.FalseLiteral,
					m = e.NullLiteral,
					d = e.DEF,
					v = e.USE,
					x = e.ROUTE,
					_ = e.TO,
					y = e.NodeName;
				t.RULE("vrml", function() {
					t.SUBRULE(t.version), t.AT_LEAST_ONE(function() {
						t.SUBRULE(t.node)
					}), t.MANY(function() {
						t.SUBRULE(t.route)
					})
				}), t.RULE("version", function() {
					t.CONSUME(n)
				}), t.RULE("node", function() {
					t.OPTION(function() {
						t.SUBRULE(t.def)
					}), t.CONSUME(y), t.CONSUME(i), t.MANY(function() {
						t.SUBRULE(t.field)
					}), t.CONSUME(s)
				}), t.RULE("field", function() {
					t.CONSUME(c), t.OR2([{
						ALT: function() {
							t.SUBRULE(t.singleFieldValue)
						}
					}, {
						ALT: function() {
							t.SUBRULE(t.multiFieldValue)
						}
					}])
				}), t.RULE("def", function() {
					t.CONSUME(d), t.OR([{
						ALT: function() {
							t.CONSUME(c)
						}
					}, {
						ALT: function() {
							t.CONSUME(y)
						}
					}])
				}), t.RULE("use", function() {
					t.CONSUME(v), t.OR([{
						ALT: function() {
							t.CONSUME(c)
						}
					}, {
						ALT: function() {
							t.CONSUME(y)
						}
					}])
				}), t.RULE("singleFieldValue", function() {
					t.AT_LEAST_ONE(function() {
						t.OR([{
							ALT: function() {
								t.SUBRULE(t.node)
							}
						}, {
							ALT: function() {
								t.SUBRULE(t.use)
							}
						}, {
							ALT: function() {
								t.CONSUME(u)
							}
						}, {
							ALT: function() {
								t.CONSUME(h)
							}
						}, {
							ALT: function() {
								t.CONSUME(f)
							}
						}, {
							ALT: function() {
								t.CONSUME(p)
							}
						}, {
							ALT: function() {
								t.CONSUME(g)
							}
						}, {
							ALT: function() {
								t.CONSUME(m)
							}
						}])
					})
				}), t.RULE("multiFieldValue", function() {
					t.CONSUME(o), t.MANY(function() {
						t.OR([{
							ALT: function() {
								t.SUBRULE(t.node)
							}
						}, {
							ALT: function() {
								t.SUBRULE(t.use)
							}
						}, {
							ALT: function() {
								t.CONSUME(u)
							}
						}, {
							ALT: function() {
								t.CONSUME(h)
							}
						}, {
							ALT: function() {
								t.CONSUME(f)
							}
						}, {
							ALT: function() {
								t.CONSUME(m)
							}
						}])
					}), t.CONSUME(a)
				}), t.RULE("route", function() {
					t.CONSUME(x), t.CONSUME(l), t.CONSUME(_), t.CONSUME2(l)
				}), this.performSelfAnalysis()
			}
		},
		om = class {
			constructor(e, t, n) {
				this.a = e, this.b = t, this.c = n, this.normal = new ne
			}
		},
		fr = {
			INTENSITY: 1,
			INTENSITY_ALPHA: 2,
			RGB: 3,
			RGBA: 4
		};
	var Ch = class extends ei {
		constructor(e) {
			super(e), this.availableExtensions = []
		}
		load(e, t, n, i) {
			let s = this,
				o = new ar(s.manager);
			o.setPath(s.path), o.setResponseType("arraybuffer"), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
				try {
					t(s.parse(a))
				} catch (c) {
					i ? i(c) : console.error(c), s.manager.itemError(e)
				}
			}, n, i)
		}
		parse(e) {
			let t = this,
				n = new Fi(this.manager);

			function i(U) {
				let A = null,
					L = null,
					j, K, Q = [],
					se = [],
					de, ue = {},
					xe = {},
					Ee = {};
				try {
					A = qp(new Uint8Array(U))
				} catch (He) {
					if (He instanceof ReferenceError) return console.error("THREE.3MFLoader: fflate missing and file is compressed."), null
				}
				for (L in A) L.match(/\_rels\/.rels$/) ? j = L : L.match(/3D\/_rels\/.*\.model\.rels$/) ? K = L : L.match(/^3D\/.*\.model$/) ? Q.push(L) : L.match(/^3D\/Textures?\/.*/) && se.push(L);
				let De = A[j],
					ht = fi.decodeText(De),
					ct = s(ht);
				if (K) {
					let He = A[K],
						Ve = fi.decodeText(He);
					de = s(Ve)
				}
				for (let He = 0; He < Q.length; He++) {
					let Ve = Q[He],
						ot = A[Ve],
						it = fi.decodeText(ot),
						E = new DOMParser()
						.parseFromString(it, "application/xml");
					E.documentElement.nodeName.toLowerCase() !== "model" && console.error("THREE.3MFLoader: Error loading 3MF - no 3MF document found: ", Ve);
					let M = E.querySelector("model"),
						D = {};
					for (let W = 0; W < M.attributes.length; W++) {
						let te = M.attributes[W];
						te.name.match(/^xmlns:(.+)$/) && (D[te.value] = RegExp.$1)
					}
					let X = y(M);
					X.xml = M, 0 < Object.keys(D)
						.length && (X.extensions = D), ue[Ve] = X
				}
				for (let He = 0; He < se.length; He++) {
					let Ve = se[He];
					Ee[Ve] = A[Ve].buffer
				}
				return {
					rels: ct,
					modelRels: de,
					model: ue,
					printTicket: xe,
					texture: Ee
				}
			}

			function s(U) {
				let A = [],
					j = new DOMParser()
					.parseFromString(U, "application/xml")
					.querySelectorAll("Relationship");
				for (let K = 0; K < j.length; K++) {
					let Q = j[K],
						se = {
							target: Q.getAttribute("Target"),
							id: Q.getAttribute("Id"),
							type: Q.getAttribute("Type")
						};
					A.push(se)
				}
				return A
			}

			function o(U) {
				let A = {};
				for (let L = 0; L < U.length; L++) {
					let j = U[L],
						K = j.getAttribute("name");
					0 <= ["Title", "Designer", "Description", "Copyright", "LicenseTerms", "Rating", "CreationDate", "ModificationDate"].indexOf(K) && (A[K] = j.textContent)
				}
				return A
			}

			function a(U) {
				let A = {
						id: U.getAttribute("id"),
						basematerials: []
					},
					L = U.querySelectorAll("base");
				for (let j = 0; j < L.length; j++) {
					let K = L[j],
						Q = f(K);
					Q.index = j, A.basematerials.push(Q)
				}
				return A
			}

			function c(U) {
				return {
					id: U.getAttribute("id"),
					path: U.getAttribute("path"),
					contenttype: U.getAttribute("contenttype"),
					tilestyleu: U.getAttribute("tilestyleu"),
					tilestylev: U.getAttribute("tilestylev"),
					filter: U.getAttribute("filter")
				}
			}

			function l(U) {
				let A = {
						id: U.getAttribute("id"),
						texid: U.getAttribute("texid"),
						displaypropertiesid: U.getAttribute("displaypropertiesid")
					},
					L = U.querySelectorAll("tex2coord"),
					j = [];
				for (let K = 0; K < L.length; K++) {
					let Q = L[K],
						se = Q.getAttribute("u"),
						de = Q.getAttribute("v");
					j.push(parseFloat(se), parseFloat(de))
				}
				return A.uvs = new Float32Array(j), A
			}

			function u(U) {
				let A = {
						id: U.getAttribute("id"),
						displaypropertiesid: U.getAttribute("displaypropertiesid")
					},
					L = U.querySelectorAll("color"),
					j = [],
					K = new Xe;
				for (let Q = 0; Q < L.length; Q++) {
					let de = L[Q].getAttribute("color");
					K.setStyle(de.substring(0, 7)), K.convertSRGBToLinear(), j.push(K.r, K.g, K.b)
				}
				return A.colors = new Float32Array(j), A
			}

			function h(U) {
				let A = {
						id: U.getAttribute("id")
					},
					L = U.querySelectorAll("pbmetallic"),
					j = [];
				for (let K = 0; K < L.length; K++) {
					let Q = L[K];
					j.push({
						name: Q.getAttribute("name"),
						metallicness: parseFloat(Q.getAttribute("metallicness")),
						roughness: parseFloat(Q.getAttribute("roughness"))
					})
				}
				return A.data = j, A
			}

			function f(U) {
				let A = {};
				return A.name = U.getAttribute("name"), A.displaycolor = U.getAttribute("displaycolor"), A.displaypropertiesid = U.getAttribute("displaypropertiesid"), A
			}

			function p(U) {
				let A = {},
					L = [],
					j = U.querySelectorAll("vertices vertex");
				for (let de = 0; de < j.length; de++) {
					let ue = j[de],
						xe = ue.getAttribute("x"),
						Ee = ue.getAttribute("y"),
						De = ue.getAttribute("z");
					L.push(parseFloat(xe), parseFloat(Ee), parseFloat(De))
				}
				A.vertices = new Float32Array(L);
				let K = [],
					Q = [],
					se = U.querySelectorAll("triangles triangle");
				for (let de = 0; de < se.length; de++) {
					let ue = se[de],
						xe = ue.getAttribute("v1"),
						Ee = ue.getAttribute("v2"),
						De = ue.getAttribute("v3"),
						ht = ue.getAttribute("p1"),
						ct = ue.getAttribute("p2"),
						He = ue.getAttribute("p3"),
						Ve = ue.getAttribute("pid"),
						ot = {};
					ot.v1 = parseInt(xe, 10), ot.v2 = parseInt(Ee, 10), ot.v3 = parseInt(De, 10), Q.push(ot.v1, ot.v2, ot.v3), ht && (ot.p1 = parseInt(ht, 10)), ct && (ot.p2 = parseInt(ct, 10)), He && (ot.p3 = parseInt(He, 10)), Ve && (ot.pid = Ve), 0 < Object.keys(ot)
						.length && K.push(ot)
				}
				return A.triangleProperties = K, A.triangles = new Uint32Array(Q), A
			}

			function g(U) {
				let A = [],
					L = U.querySelectorAll("component");
				for (let j = 0; j < L.length; j++) {
					let K = L[j],
						Q = m(K);
					A.push(Q)
				}
				return A
			}

			function m(U) {
				let A = {};
				A.objectId = U.getAttribute("objectid");
				let L = U.getAttribute("transform");
				return L && (A.transform = d(L)), A
			}

			function d(U) {
				let A = [];
				U.split(" ")
					.forEach(function(j) {
						A.push(parseFloat(j))
					});
				let L = new ke;
				return L.set(A[0], A[3], A[6], A[9], A[1], A[4], A[7], A[10], A[2], A[5], A[8], A[11], 0, 0, 0, 1), L
			}

			function v(U) {
				let A = {
						type: U.getAttribute("type")
					},
					L = U.getAttribute("id");
				L && (A.id = L);
				let j = U.getAttribute("pid");
				j && (A.pid = j);
				let K = U.getAttribute("pindex");
				K && (A.pindex = K);
				let Q = U.getAttribute("thumbnail");
				Q && (A.thumbnail = Q);
				let se = U.getAttribute("partnumber");
				se && (A.partnumber = se);
				let de = U.getAttribute("name");
				de && (A.name = de);
				let ue = U.querySelector("mesh");
				ue && (A.mesh = p(ue));
				let xe = U.querySelector("components");
				return xe && (A.components = g(xe)), A
			}

			function x(U) {
				let A = {};
				A.basematerials = {};
				let L = U.querySelectorAll("basematerials");
				for (let ue = 0; ue < L.length; ue++) {
					let xe = L[ue],
						Ee = a(xe);
					A.basematerials[Ee.id] = Ee
				}
				A.texture2d = {};
				let j = U.querySelectorAll("texture2d");
				for (let ue = 0; ue < j.length; ue++) {
					let xe = j[ue],
						Ee = c(xe);
					A.texture2d[Ee.id] = Ee
				}
				A.colorgroup = {};
				let K = U.querySelectorAll("colorgroup");
				for (let ue = 0; ue < K.length; ue++) {
					let xe = K[ue],
						Ee = u(xe);
					A.colorgroup[Ee.id] = Ee
				}
				A.pbmetallicdisplayproperties = {};
				let Q = U.querySelectorAll("pbmetallicdisplayproperties");
				for (let ue = 0; ue < Q.length; ue++) {
					let xe = Q[ue],
						Ee = h(xe);
					A.pbmetallicdisplayproperties[Ee.id] = Ee
				}
				A.texture2dgroup = {};
				let se = U.querySelectorAll("texture2dgroup");
				for (let ue = 0; ue < se.length; ue++) {
					let xe = se[ue],
						Ee = l(xe);
					A.texture2dgroup[Ee.id] = Ee
				}
				A.object = {};
				let de = U.querySelectorAll("object");
				for (let ue = 0; ue < de.length; ue++) {
					let xe = de[ue],
						Ee = v(xe);
					A.object[Ee.id] = Ee
				}
				return A
			}

			function _(U) {
				let A = [],
					L = U.querySelectorAll("item");
				for (let j = 0; j < L.length; j++) {
					let K = L[j],
						Q = {
							objectId: K.getAttribute("objectid")
						},
						se = K.getAttribute("transform");
					se && (Q.transform = d(se)), A.push(Q)
				}
				return A
			}

			function y(U) {
				let A = {
						unit: U.getAttribute("unit") || "millimeter"
					},
					L = U.querySelectorAll("metadata");
				L && (A.metadata = o(L));
				let j = U.querySelector("resources");
				j && (A.resources = x(j));
				let K = U.querySelector("build");
				return K && (A.build = _(K)), A
			}

			function w(U, A, L, j) {
				let K = U.texid,
					se = L.resources.texture2d[K];
				if (se) {
					let de = j[se.path],
						ue = se.contenttype,
						xe = new Blob([de], {
							type: ue
						}),
						Ee = URL.createObjectURL(xe),
						De = n.load(Ee, function() {
							URL.revokeObjectURL(Ee)
						});
					switch (De.encoding = Pt, se.tilestyleu) {
						case "wrap":
							De.wrapS = en;
							break;
						case "mirror":
							De.wrapS = fa;
							break;
						case "none":
						case "clamp":
							De.wrapS = Xt;
							break;
						default:
							De.wrapS = en
					}
					switch (se.tilestylev) {
						case "wrap":
							De.wrapT = en;
							break;
						case "mirror":
							De.wrapT = fa;
							break;
						case "none":
						case "clamp":
							De.wrapT = Xt;
							break;
						default:
							De.wrapT = en
					}
					switch (se.filter) {
						case "auto":
							De.magFilter = pn, De.minFilter = Er;
							break;
						case "linear":
							De.magFilter = pn, De.minFilter = pn;
							break;
						case "nearest":
							De.magFilter = yn, De.minFilter = yn;
							break;
						default:
							De.magFilter = pn, De.minFilter = Er
					}
					return De
				} else return null
			}

			function C(U, A, L, j, K, Q, se) {
				let de = se.pindex,
					ue = {};
				for (let De = 0, ht = A.length; De < ht; De++) {
					let ct = A[De],
						He = ct.p1 !== void 0 ? ct.p1 : de;
					ue[He] === void 0 && (ue[He] = []), ue[He].push(ct)
				}
				let xe = Object.keys(ue),
					Ee = [];
				for (let De = 0, ht = xe.length; De < ht; De++) {
					let ct = xe[De],
						He = ue[ct],
						Ve = U.basematerials[ct],
						ot = q(Ve, j, K, Q, se, B),
						it = new bt,
						E = [],
						M = L.vertices;
					for (let X = 0, W = He.length; X < W; X++) {
						let te = He[X];
						E.push(M[te.v1 * 3 + 0]), E.push(M[te.v1 * 3 + 1]), E.push(M[te.v1 * 3 + 2]), E.push(M[te.v2 * 3 + 0]), E.push(M[te.v2 * 3 + 1]), E.push(M[te.v2 * 3 + 2]), E.push(M[te.v3 * 3 + 0]), E.push(M[te.v3 * 3 + 1]), E.push(M[te.v3 * 3 + 2])
					}
					it.setAttribute("position", new ze(E, 3));
					let D = new zt(it, ot);
					Ee.push(D)
				}
				return Ee
			}

			function S(U, A, L, j, K, Q, se) {
				let de = new bt,
					ue = [],
					xe = [],
					Ee = L.vertices,
					De = U.uvs;
				for (let Ve = 0, ot = A.length; Ve < ot; Ve++) {
					let it = A[Ve];
					ue.push(Ee[it.v1 * 3 + 0]), ue.push(Ee[it.v1 * 3 + 1]), ue.push(Ee[it.v1 * 3 + 2]), ue.push(Ee[it.v2 * 3 + 0]), ue.push(Ee[it.v2 * 3 + 1]), ue.push(Ee[it.v2 * 3 + 2]), ue.push(Ee[it.v3 * 3 + 0]), ue.push(Ee[it.v3 * 3 + 1]), ue.push(Ee[it.v3 * 3 + 2]), xe.push(De[it.p1 * 2 + 0]), xe.push(De[it.p1 * 2 + 1]), xe.push(De[it.p2 * 2 + 0]), xe.push(De[it.p2 * 2 + 1]), xe.push(De[it.p3 * 2 + 0]), xe.push(De[it.p3 * 2 + 1])
				}
				de.setAttribute("position", new ze(ue, 3)), de.setAttribute("uv", new ze(xe, 2));
				let ht = q(U, j, K, Q, se, w),
					ct = new an({
						map: ht,
						flatShading: !0
					});
				return new zt(de, ct)
			}

			function b(U, A, L, j) {
				let K = new bt,
					Q = [],
					se = [],
					de = L.vertices,
					ue = U.colors;
				for (let De = 0, ht = A.length; De < ht; De++) {
					let ct = A[De],
						He = ct.v1,
						Ve = ct.v2,
						ot = ct.v3;
					Q.push(de[He * 3 + 0]), Q.push(de[He * 3 + 1]), Q.push(de[He * 3 + 2]), Q.push(de[Ve * 3 + 0]), Q.push(de[Ve * 3 + 1]), Q.push(de[Ve * 3 + 2]), Q.push(de[ot * 3 + 0]), Q.push(de[ot * 3 + 1]), Q.push(de[ot * 3 + 2]);
					let it = ct.p1 !== void 0 ? ct.p1 : j.pindex,
						E = ct.p2 !== void 0 ? ct.p2 : it,
						M = ct.p3 !== void 0 ? ct.p3 : it;
					se.push(ue[it * 3 + 0]), se.push(ue[it * 3 + 1]), se.push(ue[it * 3 + 2]), se.push(ue[E * 3 + 0]), se.push(ue[E * 3 + 1]), se.push(ue[E * 3 + 2]), se.push(ue[M * 3 + 0]), se.push(ue[M * 3 + 1]), se.push(ue[M * 3 + 2])
				}
				K.setAttribute("position", new ze(Q, 3)), K.setAttribute("color", new ze(se, 3));
				let xe = new an({
					vertexColors: !0,
					flatShading: !0
				});
				return new zt(K, xe)
			}

			function T(U) {
				let A = new bt;
				A.setIndex(new Gn(U.triangles, 1)), A.setAttribute("position", new Gn(U.vertices, 3));
				let L = new an({
					color: 16777215,
					flatShading: !0
				});
				return new zt(A, L)
			}

			function N(U, A, L, j, K, Q) {
				let se = Object.keys(U),
					de = [];
				for (let ue = 0, xe = se.length; ue < xe; ue++) {
					let Ee = se[ue],
						De = U[Ee];
					switch (V(Ee, j)) {
						case "material":
							let ct = j.resources.basematerials[Ee],
								He = C(ct, De, A, L, j, K, Q);
							for (let it = 0, E = He.length; it < E; it++) de.push(He[it]);
							break;
						case "texture":
							let Ve = j.resources.texture2dgroup[Ee];
							de.push(S(Ve, De, A, L, j, K, Q));
							break;
						case "vertexColors":
							let ot = j.resources.colorgroup[Ee];
							de.push(b(ot, De, A, Q));
							break;
						case "default":
							de.push(T(A));
							break;
						default:
							console.error("THREE.3MFLoader: Unsupported resource type.")
					}
				}
				if (Q.name)
					for (let ue = 0; ue < de.length; ue++) de[ue].name = Q.name;
				return de
			}

			function V(U, A) {
				return A.resources.texture2dgroup[U] !== void 0 ? "texture" : A.resources.basematerials[U] !== void 0 ? "material" : A.resources.colorgroup[U] !== void 0 ? "vertexColors" : U === "default" ? "default" : void 0
			}

			function O(U, A) {
				let L = {},
					j = U.triangleProperties,
					K = A.pid;
				for (let Q = 0, se = j.length; Q < se; Q++) {
					let de = j[Q],
						ue = de.pid !== void 0 ? de.pid : K;
					ue === void 0 && (ue = "default"), L[ue] === void 0 && (L[ue] = []), L[ue].push(de)
				}
				return L
			}

			function k(U, A, L, j, K) {
				let Q = new _n,
					se = O(U, K),
					de = N(se, U, A, L, j, K);
				for (let ue = 0, xe = de.length; ue < xe; ue++) Q.add(de[ue]);
				return Q
			}

			function I(U, A, L) {
				if (!U) return;
				let j = [],
					K = Object.keys(U);
				for (let Q = 0; Q < K.length; Q++) {
					let se = K[Q];
					for (let de = 0; de < t.availableExtensions.length; de++) {
						let ue = t.availableExtensions[de];
						ue.ns === se && j.push(ue)
					}
				}
				for (let Q = 0; Q < j.length; Q++) {
					let se = j[Q];
					se.apply(L, U[se.ns], A)
				}
			}

			function q(U, A, L, j, K, Q) {
				return U.build !== void 0 || (U.build = Q(U, A, L, j, K)), U.build
			}

			function B(U, A, L) {
				let j, K = U.displaypropertiesid,
					Q = L.resources.pbmetallicdisplayproperties;
				if (K !== null && Q[K] !== void 0) {
					let xe = Q[K].data[U.index];
					j = new ks({
						flatShading: !0,
						roughness: xe.roughness,
						metalness: xe.metallicness
					})
				} else j = new an({
					flatShading: !0
				});
				j.name = U.name;
				let se = U.displaycolor,
					de = se.substring(0, 7);
				return j.color.setStyle(de), j.color.convertSRGBToLinear(), se.length === 9 && (j.opacity = parseInt(se.charAt(7) + se.charAt(8), 16) / 255), j
			}

			function Y(U, A, L, j) {
				let K = new _n;
				for (let Q = 0; Q < U.length; Q++) {
					let se = U[Q],
						de = A[se.objectId];
					de === void 0 && (J(se.objectId, A, L, j), de = A[se.objectId]);
					let ue = de.clone(),
						xe = se.transform;
					xe && ue.applyMatrix4(xe), K.add(ue)
				}
				return K
			}

			function J(U, A, L, j) {
				let K = L.resources.object[U];
				if (K.mesh) {
					let Q = K.mesh,
						se = L.extensions,
						de = L.xml;
					I(se, Q, de), A[K.id] = q(Q, A, L, j, K, k)
				} else {
					let Q = K.components;
					A[K.id] = q(Q, A, L, j, K, Y)
				}
				K.name && (A[K.id].name = K.name)
			}

			function H(U) {
				let A = U.model,
					L = U.modelRels,
					j = {},
					K = Object.keys(A),
					Q = {};
				if (L)
					for (let se = 0, de = L.length; se < de; se++) {
						let ue = L[se],
							xe = ue.target.substring(1);
						U.texture[xe] && (Q[ue.target] = U.texture[xe])
					}
				for (let se = 0; se < K.length; se++) {
					let de = K[se],
						ue = A[de],
						xe = Object.keys(ue.resources.object);
					for (let Ee = 0; Ee < xe.length; Ee++) {
						let De = xe[Ee];
						J(De, j, ue, Q)
					}
				}
				return j
			}

			function $(U) {
				for (let A = 0; A < U.length; A++) {
					let L = U[A];
					if (L.target.split(".")
						.pop()
						.toLowerCase() === "model") return L
				}
			}

			function ae(U, A) {
				let L = new _n,
					j = $(A.rels),
					K = A.model[j.target.substring(1)].build;
				for (let Q = 0; Q < K.length; Q++) {
					let se = K[Q],
						de = U[se.objectId].clone(),
						ue = se.transform;
					ue && de.applyMatrix4(ue), L.add(de)
				}
				return L
			}
			let oe = i(e),
				ie = H(oe);
			return ae(ie, oe)
		}
		addExtension(e) {
			this.availableExtensions.push(e)
		}
	};
	var ja = class extends Ht {
			constructor() {
				super()
			}
			CreateLoader(e) {
				return null
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				return !0
			}
			ClearContent() {
				this.loader = null, this.materialIdToIndex = null, this.objectUrlToFileName = null
			}
			ResetContent() {
				this.loader = null, this.materialIdToIndex = new Map, this.objectUrlToFileName = new Map
			}
			ImportContent(e, t) {
				this.LoadModel(e, t)
			}
			LoadModel(e, t) {
				let n = !1,
					i = new Dl(() => {
						n = !0
					}),
					s = uo(e);
				i.setURLModifier(a => {
					if (a === s) return a;
					let c = Sn(a);
					if (cr(a)
						.length > 0) {
						let u = this.callbacks.getFileBuffer(a);
						if (u !== null) {
							let h = uo(u);
							return this.objectUrlToFileName.set(h, c), h
						}
					}
					return a
				});
				let o = this.CreateLoader(i);
				if (o === null) {
					t();
					return
				}
				o.load(s, a => {
					Iv(() => n ? (this.OnThreeObjectsLoaded(a, t), !1) : !0)
				}, () => {}, a => {
					this.SetError(a), t()
				})
			}
			OnThreeObjectsLoaded(e, t) {
				function n(a) {
					let c = new kt()
						.CreateIdentity();
					return a.updateMatrix(), a.matrix !== void 0 && a.matrix !== null && c.Set(a.matrix.elements), new Jt(c)
				}

				function i(a, c, l, u) {
					let h = new Dn;
					l.name !== void 0 && h.SetName(l.name), h.SetTransformation(n(l)), u.AddChildNode(h);
					for (let f of l.children) i(a, c, f, h);
					if (l.isMesh && a.IsMeshVisible(l)) {
						l.children.length === 0 && h.SetType(zn.MeshNode);
						let f = a.ConvertThreeMesh(l),
							p = c.AddMesh(f);
						h.AddMeshIndex(p)
					}
				}
				let s = this.GetMainObject(e),
					o = this.model.GetRootNode();
				o.SetTransformation(n(s));
				for (let a of s.children) i(this, this.model, a, o);
				t()
			}
			ConvertThreeMesh(e) {
				let t = null;
				if (Array.isArray(e.material)) {
					if (t = es(e.geometry, null), e.geometry.attributes.color === void 0 || e.geometry.attributes.color === null) {
						let n = [];
						for (let i = 0; i < e.material.length; i++) {
							let s = e.material[i],
								o = this.FindOrCreateMaterial(s);
							n.push(o)
						}
						for (let i = 0; i < e.geometry.groups.length; i++) {
							let s = e.geometry.groups[i],
								o = null;
							s.count === 1 / 0 ? o = t.TriangleCount() : o = s.start / 3 + s.count / 3;
							for (let a = s.start / 3; a < o; a++) t.GetTriangle(a)
								.SetMaterial(n[s.materialIndex])
						}
					}
				} else {
					let n = this.FindOrCreateMaterial(e.material);
					t = es(e.geometry, n)
				}
				return e.name !== void 0 && e.name !== null && t.SetName(e.name), t
			}
			FindOrCreateMaterial(e) {
				if (this.materialIdToIndex.has(e.id)) return this.materialIdToIndex.get(e.id);
				let t = this.ConvertThreeMaterial(e),
					n = this.model.AddMaterial(t);
				return this.materialIdToIndex.set(e.id, n), n
			}
			ConvertThreeMaterial(e) {
				function t(i, s) {
					function o(a) {
						if (a.data !== void 0 && a.data !== null) {
							let c = new ImageData(a.width, a.height),
								l = a.width * a.height * 4;
							for (let u = 0; u < l; u++) c.data[u] = a.data[u];
							return wo.getDataURL(c)
						} else return wo.getDataURL(a)
					}
					if (i == null || i.image === void 0 || i.image === null) return null;
					try {
						let a = o(i.image),
							c = hl(a),
							l = new Li,
							u = null;
						return s.has(i.image.src) ? u = s.get(i.image.src) : i.name !== void 0 && i.name !== null ? u = i.name + "." + Vo(c.mimeType) : u = "Embedded_" + i.id.toString() + "." + Vo(c.mimeType), l.name = u, l.mimeType = c.mimeType, l.buffer = c.buffer, l.rotation = i.rotation, l.offset.x = i.offset.x, l.offset.y = i.offset.y, l.scale.x = i.repeat.x, l.scale.y = i.repeat.y, l
					} catch {
						return null
					}
				}
				let n = new An;
				return n.name = e.name, n.color = Pu(e.color), n.opacity = e.opacity, n.transparent = e.transparent, n.alphaTest = e.alphaTest, e.type === "MeshPhongMaterial" && (n.specular = Pu(e.specular), n.shininess = e.shininess / 100), n.diffuseMap = t(e.map, this.objectUrlToFileName), n.normalMap = t(e.normalMap, this.objectUrlToFileName), n.bumpMap = t(e.bumpMap, this.objectUrlToFileName), n
			}
		},
		Ah = class extends ja {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "fbx"
			}
			GetUpDirection() {
				return lt.Y
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new Ys(e)), new vh(e)
			}
			GetMainObject(e) {
				return e
			}
		},
		Ih = class extends ja {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "dae"
			}
			GetUpDirection() {
				return lt.Y
			}
			CreateLoader(e) {
				return e.addHandler(/\.tga$/i, new Ys(e)), new _h(e)
			}
			GetMainObject(e) {
				return e.scene
			}
		},
		Rh = class extends ja {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "wrl"
			}
			GetUpDirection() {
				return lt.Y
			}
			CreateLoader(e) {
				return new Eh(e)
			}
			GetMainObject(e) {
				return e
			}
			IsMeshVisible(e) {
				let t = !0;
				if (Array.isArray(e.material)) {
					for (let n = 0; n < e.material.length; n++)
						if (e.material[n].side === Rn) {
							t = !1;
							break
						}
				} else t = e.material.side !== Rn;
				return t
			}
		},
		Ph = class extends ja {
			constructor() {
				super()
			}
			CanImportExtension(e) {
				return e === "3mf"
			}
			GetUpDirection() {
				return lt.Z
			}
			CreateLoader(e) {
				return new Ch(e)
			}
			GetMainObject(e) {
				return e
			}
		};
	var ln = Uint8Array,
		xi = Uint16Array,
		Lh = Uint32Array,
		Nh = new ln([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
		Dh = new ln([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
		hm = new ln([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
		qx = function(r, e) {
			for (var t = new xi(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
			for (var i = new Lh(t[30]), n = 1; n < 30; ++n)
				for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
			return [t, i]
		},
		Xx = qx(Nh, 2),
		Yx = Xx[0],
		fm = Xx[1];
	Yx[28] = 258, fm[258] = 28;
	var Zx = qx(Dh, 0),
		qE = Zx[0],
		Gx = Zx[1],
		dm = new xi(32768);
	for (Bt = 0; Bt < 32768; ++Bt) as = (Bt & 43690) >>> 1 | (Bt & 21845) << 1, as = (as & 52428) >>> 2 | (as & 13107) << 2, as = (as & 61680) >>> 4 | (as & 3855) << 4, dm[Bt] = ((as & 65280) >>> 8 | (as & 255) << 8) >>> 1;
	var as, Bt, Pr = function(r, e, t) {
			for (var n = r.length, i = 0, s = new xi(e); i < n; ++i) r[i] && ++s[r[i] - 1];
			var o = new xi(e);
			for (i = 0; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
			var a;
			if (t) {
				a = new xi(1 << e);
				var c = 15 - e;
				for (i = 0; i < n; ++i)
					if (r[i])
						for (var l = i << 4 | r[i], u = e - r[i], h = o[r[i] - 1]++ << u, f = h | (1 << u) - 1; h <= f; ++h) a[dm[h] >>> c] = l
			} else
				for (a = new xi(n), i = 0; i < n; ++i) r[i] && (a[i] = dm[o[r[i] - 1]++] >>> 15 - r[i]);
			return a
		},
		$s = new ln(288);
	for (Bt = 0; Bt < 144; ++Bt) $s[Bt] = 8;
	var Bt;
	for (Bt = 144; Bt < 256; ++Bt) $s[Bt] = 9;
	var Bt;
	for (Bt = 256; Bt < 280; ++Bt) $s[Bt] = 7;
	var Bt;
	for (Bt = 280; Bt < 288; ++Bt) $s[Bt] = 8;
	var Bt, oc = new ln(32);
	for (Bt = 0; Bt < 32; ++Bt) oc[Bt] = 5;
	var Bt, XE = Pr($s, 9, 0),
		YE = Pr($s, 9, 1),
		ZE = Pr(oc, 5, 0),
		KE = Pr(oc, 5, 1),
		am = function(r) {
			for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
			return e
		},
		dr = function(r, e, t) {
			var n = e / 8 | 0;
			return (r[n] | r[n + 1] << 8) >> (e & 7) & t
		},
		lm = function(r, e) {
			var t = e / 8 | 0;
			return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
		},
		xm = function(r) {
			return (r + 7) / 8 | 0
		},
		ac = function(r, e, t) {
			(e == null || e < 0) && (e = 0), (t == null || t > r.length) && (t = r.length);
			var n = new(r.BYTES_PER_ELEMENT == 2 ? xi : r.BYTES_PER_ELEMENT == 4 ? Lh : ln)(t - e);
			return n.set(r.subarray(e, t)), n
		};
	var JE = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
		vi = function(r, e, t) {
			var n = new Error(e || JE[r]);
			if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, vi), !t) throw n;
			return n
		},
		$E = function(r, e, t) {
			var n = r.length;
			if (!n || t && t.f && !t.l) return e || new ln(0);
			var i = !e || t,
				s = !t || t.i;
			t || (t = {}), e || (e = new ln(n * 3));
			var o = function(L) {
					var j = e.length;
					if (L > j) {
						var K = new ln(Math.max(j * 2, L));
						K.set(e), e = K
					}
				},
				a = t.f || 0,
				c = t.p || 0,
				l = t.b || 0,
				u = t.l,
				h = t.d,
				f = t.m,
				p = t.n,
				g = n * 8;
			do {
				if (!u) {
					a = dr(r, c, 1);
					var m = dr(r, c + 1, 3);
					if (c += 3, m)
						if (m == 1) u = YE, h = KE, f = 9, p = 5;
						else if (m == 2) {
						var _ = dr(r, c, 31) + 257,
							y = dr(r, c + 10, 15) + 4,
							w = _ + dr(r, c + 5, 31) + 1;
						c += 14;
						for (var C = new ln(w), S = new ln(19), b = 0; b < y; ++b) S[hm[b]] = dr(r, c + b * 3, 7);
						c += y * 3;
						for (var T = am(S), N = (1 << T) - 1, V = Pr(S, T, 1), b = 0; b < w;) {
							var O = V[dr(r, c, N)];
							c += O & 15;
							var d = O >>> 4;
							if (d < 16) C[b++] = d;
							else {
								var k = 0,
									I = 0;
								for (d == 16 ? (I = 3 + dr(r, c, 3), c += 2, k = C[b - 1]) : d == 17 ? (I = 3 + dr(r, c, 7), c += 3) : d == 18 && (I = 11 + dr(r, c, 127), c += 7); I--;) C[b++] = k
							}
						}
						var q = C.subarray(0, _),
							B = C.subarray(_);
						f = am(q), p = am(B), u = Pr(q, f, 1), h = Pr(B, p, 1)
					} else vi(1);
					else {
						var d = xm(c) + 4,
							v = r[d - 4] | r[d - 3] << 8,
							x = d + v;
						if (x > n) {
							s && vi(0);
							break
						}
						i && o(l + v), e.set(r.subarray(d, x), l), t.b = l += v, t.p = c = x * 8, t.f = a;
						continue
					}
					if (c > g) {
						s && vi(0);
						break
					}
				}
				i && o(l + 131072);
				for (var Y = (1 << f) - 1, J = (1 << p) - 1, H = c;; H = c) {
					var k = u[lm(r, c) & Y],
						$ = k >>> 4;
					if (c += k & 15, c > g) {
						s && vi(0);
						break
					}
					if (k || vi(2), $ < 256) e[l++] = $;
					else if ($ == 256) {
						H = c, u = null;
						break
					} else {
						var ae = $ - 254;
						if ($ > 264) {
							var b = $ - 257,
								oe = Nh[b];
							ae = dr(r, c, (1 << oe) - 1) + Yx[b], c += oe
						}
						var ie = h[lm(r, c) & J],
							U = ie >>> 4;
						ie || vi(3), c += ie & 15;
						var B = qE[U];
						if (U > 3) {
							var oe = Dh[U];
							B += lm(r, c) & (1 << oe) - 1, c += oe
						}
						if (c > g) {
							s && vi(0);
							break
						}
						i && o(l + 131072);
						for (var A = l + ae; l < A; l += 4) e[l] = e[l - B], e[l + 1] = e[l + 1 - B], e[l + 2] = e[l + 2 - B], e[l + 3] = e[l + 3 - B];
						l = A
					}
				}
				t.l = u, t.p = H, t.b = l, t.f = a, u && (a = 1, t.m = f, t.d = h, t.n = p)
			} while (!a);
			return l == e.length ? e : ac(e, 0, l)
		},
		ls = function(r, e, t) {
			t <<= e & 7;
			var n = e / 8 | 0;
			r[n] |= t, r[n + 1] |= t >>> 8
		},
		rc = function(r, e, t) {
			t <<= e & 7;
			var n = e / 8 | 0;
			r[n] |= t, r[n + 1] |= t >>> 8, r[n + 2] |= t >>> 16
		},
		cm = function(r, e) {
			for (var t = [], n = 0; n < r.length; ++n) r[n] && t.push({
				s: n,
				f: r[n]
			});
			var i = t.length,
				s = t.slice();
			if (!i) return [ym, 0];
			if (i == 1) {
				var o = new ln(t[0].s + 1);
				return o[t[0].s] = 1, [o, 1]
			}
			t.sort(function(w, C) {
				return w.f - C.f
			}), t.push({
				s: -1,
				f: 25001
			});
			var a = t[0],
				c = t[1],
				l = 0,
				u = 1,
				h = 2;
			for (t[0] = {
				s: -1,
				f: a.f + c.f,
				l: a,
				r: c
			}; u != i - 1;) a = t[t[l].f < t[h].f ? l++ : h++], c = t[l != u && t[l].f < t[h].f ? l++ : h++], t[u++] = {
				s: -1,
				f: a.f + c.f,
				l: a,
				r: c
			};
			for (var f = s[0].s, n = 1; n < i; ++n) s[n].s > f && (f = s[n].s);
			var p = new xi(f + 1),
				g = pm(t[u - 1], p, 0);
			if (g > e) {
				var n = 0,
					m = 0,
					d = g - e,
					v = 1 << d;
				for (s.sort(function(C, S) {
					return p[S.s] - p[C.s] || C.f - S.f
				}); n < i; ++n) {
					var x = s[n].s;
					if (p[x] > e) m += v - (1 << g - p[x]), p[x] = e;
					else break
				}
				for (m >>>= d; m > 0;) {
					var _ = s[n].s;
					p[_] < e ? m -= 1 << e - p[_]++ - 1 : ++n
				}
				for (; n >= 0 && m; --n) {
					var y = s[n].s;
					p[y] == e && (--p[y], ++m)
				}
				g = e
			}
			return [new ln(p), g]
		},
		pm = function(r, e, t) {
			return r.s == -1 ? Math.max(pm(r.l, e, t + 1), pm(r.r, e, t + 1)) : e[r.s] = t
		},
		Vx = function(r) {
			for (var e = r.length; e && !r[--e];);
			for (var t = new xi(++e), n = 0, i = r[0], s = 1, o = function(c) {
				t[n++] = c
			}, a = 1; a <= e; ++a)
				if (r[a] == i && a != e) ++s;
				else {
					if (!i && s > 2) {
						for (; s > 138; s -= 138) o(32754);
						s > 2 && (o(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0)
					} else if (s > 3) {
						for (o(i), --s; s > 6; s -= 6) o(8304);
						s > 2 && (o(s - 3 << 5 | 8208), s = 0)
					}
					for (; s--;) o(i);
					s = 1, i = r[a]
				} return [t.subarray(0, n), e]
		},
		sc = function(r, e) {
			for (var t = 0, n = 0; n < e.length; ++n) t += r[n] * e[n];
			return t
		},
		mm = function(r, e, t) {
			var n = t.length,
				i = xm(e + 2);
			r[i] = n & 255, r[i + 1] = n >>> 8, r[i + 2] = r[i] ^ 255, r[i + 3] = r[i + 1] ^ 255;
			for (var s = 0; s < n; ++s) r[i + s + 4] = t[s];
			return (i + 4 + n) * 8
		},
		zx = function(r, e, t, n, i, s, o, a, c, l, u) {
			ls(e, u++, t), ++i[256];
			for (var h = cm(i, 15), f = h[0], p = h[1], g = cm(s, 15), m = g[0], d = g[1], v = Vx(f), x = v[0], _ = v[1], y = Vx(m), w = y[0], C = y[1], S = new xi(19), b = 0; b < x.length; ++b) S[x[b] & 31]++;
			for (var b = 0; b < w.length; ++b) S[w[b] & 31]++;
			for (var T = cm(S, 7), N = T[0], V = T[1], O = 19; O > 4 && !N[hm[O - 1]]; --O);
			var k = l + 5 << 3,
				I = sc(i, $s) + sc(s, oc) + o,
				q = sc(i, f) + sc(s, m) + o + 14 + 3 * O + sc(S, N) + (2 * S[16] + 3 * S[17] + 7 * S[18]);
			if (k <= I && k <= q) return mm(e, u, r.subarray(c, c + l));
			var B, Y, J, H;
			if (ls(e, u, 1 + (q < I)), u += 2, q < I) {
				B = Pr(f, p, 0), Y = f, J = Pr(m, d, 0), H = m;
				var $ = Pr(N, V, 0);
				ls(e, u, _ - 257), ls(e, u + 5, C - 1), ls(e, u + 10, O - 4), u += 14;
				for (var b = 0; b < O; ++b) ls(e, u + 3 * b, N[hm[b]]);
				u += 3 * O;
				for (var ae = [x, w], oe = 0; oe < 2; ++oe)
					for (var ie = ae[oe], b = 0; b < ie.length; ++b) {
						var U = ie[b] & 31;
						ls(e, u, $[U]), u += N[U], U > 15 && (ls(e, u, ie[b] >>> 5 & 127), u += ie[b] >>> 12)
					}
			} else B = XE, Y = $s, J = ZE, H = oc;
			for (var b = 0; b < a; ++b)
				if (n[b] > 255) {
					var U = n[b] >>> 18 & 31;
					rc(e, u, B[U + 257]), u += Y[U + 257], U > 7 && (ls(e, u, n[b] >>> 23 & 31), u += Nh[U]);
					var A = n[b] & 31;
					rc(e, u, J[A]), u += H[A], A > 3 && (rc(e, u, n[b] >>> 5 & 8191), u += Dh[A])
				} else rc(e, u, B[n[b]]), u += Y[n[b]];
			return rc(e, u, B[256]), u + Y[256]
		},
		QE = new Lh([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]),
		ym = new ln(0),
		e1 = function(r, e, t, n, i, s) {
			var o = r.length,
				a = new ln(n + o + 5 * (1 + Math.ceil(o / 7e3)) + i),
				c = a.subarray(n, a.length - i),
				l = 0;
			if (!e || o < 8)
				for (var u = 0; u <= o; u += 65535) {
					var h = u + 65535;
					h >= o && (c[l >> 3] = s), l = mm(c, l + 1, r.subarray(u, h))
				} else {
					for (var f = QE[e - 1], p = f >>> 13, g = f & 8191, m = (1 << t) - 1, d = new xi(32768), v = new xi(m + 1), x = Math.ceil(t / 3), _ = 2 * x, y = function(Ee) {
						return (r[Ee] ^ r[Ee + 1] << x ^ r[Ee + 2] << _) & m
					}, w = new Lh(25e3), C = new xi(288), S = new xi(32), b = 0, T = 0, u = 0, N = 0, V = 0, O = 0; u < o; ++u) {
						var k = y(u),
							I = u & 32767,
							q = v[k];
						if (d[I] = q, v[k] = I, V <= u) {
							var B = o - u;
							if ((b > 7e3 || N > 24576) && B > 423) {
								l = zx(r, c, 0, w, C, S, T, N, O, u - O, l), N = b = T = 0, O = u;
								for (var Y = 0; Y < 286; ++Y) C[Y] = 0;
								for (var Y = 0; Y < 30; ++Y) S[Y] = 0
							}
							var J = 2,
								H = 0,
								$ = g,
								ae = I - q & 32767;
							if (B > 2 && k == y(u - ae))
								for (var oe = Math.min(p, B) - 1, ie = Math.min(32767, u), U = Math.min(258, B); ae <= ie && --$ && I != q;) {
									if (r[u + J] == r[u + J - ae]) {
										for (var A = 0; A < U && r[u + A] == r[u + A - ae]; ++A);
										if (A > J) {
											if (J = A, H = ae, A > oe) break;
											for (var L = Math.min(ae, A - 2), j = 0, Y = 0; Y < L; ++Y) {
												var K = u - ae + Y + 32768 & 32767,
													Q = d[K],
													se = K - Q + 32768 & 32767;
												se > j && (j = se, q = K)
											}
										}
									}
									I = q, q = d[I], ae += I - q + 32768 & 32767
								}
							if (H) {
								w[N++] = 268435456 | fm[J] << 18 | Gx[H];
								var de = fm[J] & 31,
									ue = Gx[H] & 31;
								T += Nh[de] + Dh[ue], ++C[257 + de], ++S[ue], V = u + J, ++b
							} else w[N++] = r[u], ++C[r[u]]
						}
					}
					l = zx(r, c, s, w, C, S, T, N, O, u - O, l), !s && l & 7 && (l = mm(c, l + 1, ym))
				}
			return ac(a, 0, n + xm(l) + i)
		},
		t1 = function() {
			for (var r = new Int32Array(256), e = 0; e < 256; ++e) {
				for (var t = e, n = 9; --n;) t = (t & 1 && -306674912) ^ t >>> 1;
				r[e] = t
			}
			return r
		}(),
		n1 = function() {
			var r = -1;
			return {
				p: function(e) {
					for (var t = r, n = 0; n < e.length; ++n) t = t1[t & 255 ^ e[n]] ^ t >>> 8;
					r = t
				},
				d: function() {
					return ~r
				}
			}
		};
	var i1 = function(r, e, t, n, i) {
			return e1(r, e.level == null ? 6 : e.level, e.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 12 + e.mem, t, n, !i)
		},
		Kx = function(r, e) {
			var t = {};
			for (var n in r) t[n] = r[n];
			for (var n in e) t[n] = e[n];
			return t
		};
	var Rr = function(r, e) {
			return r[e] | r[e + 1] << 8
		},
		pr = function(r, e) {
			return (r[e] | r[e + 1] << 8 | r[e + 2] << 16 | r[e + 3] << 24) >>> 0
		},
		um = function(r, e) {
			return pr(r, e) + pr(r, e + 4) * 4294967296
		},
		Hn = function(r, e, t) {
			for (; t; ++e) r[e] = t, t >>>= 8
		};

	function r1(r, e) {
		return i1(r, e || {}, 0, 0)
	}

	function s1(r, e) {
		return $E(r, e)
	}
	var Jx = function(r, e, t, n) {
			for (var i in r) {
				var s = r[i],
					o = e + i,
					a = n;
				Array.isArray(s) && (a = Kx(n, s[1]), s = s[0]), s instanceof ln ? t[o] = [s, a] : (t[o += "/"] = [new ln(0), a], Jx(s, o, t, n))
			}
		},
		Hx = typeof TextEncoder < "u" && new TextEncoder,
		gm = typeof TextDecoder < "u" && new TextDecoder,
		o1 = 0;
	try {
		gm.decode(ym, {
			stream: !0
		}), o1 = 1
	} catch {}
	var a1 = function(r) {
		for (var e = "", t = 0;;) {
			var n = r[t++],
				i = (n > 127) + (n > 223) + (n > 239);
			if (t + i > r.length) return [e, ac(r, t - 1)];
			i ? i == 3 ? (n = ((n & 15) << 18 | (r[t++] & 63) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) - 65536, e += String.fromCharCode(55296 | n >> 10, 56320 | n & 1023)) : i & 1 ? e += String.fromCharCode((n & 31) << 6 | r[t++] & 63) : e += String.fromCharCode((n & 15) << 12 | (r[t++] & 63) << 6 | r[t++] & 63) : e += String.fromCharCode(n)
		}
	};

	function Wx(r, e) {
		if (e) {
			for (var t = new ln(r.length), n = 0; n < r.length; ++n) t[n] = r.charCodeAt(n);
			return t
		}
		if (Hx) return Hx.encode(r);
		for (var i = r.length, s = new ln(r.length + (r.length >> 1)), o = 0, a = function(u) {
			s[o++] = u
		}, n = 0; n < i; ++n) {
			if (o + 5 > s.length) {
				var c = new ln(o + 8 + (i - n << 1));
				c.set(s), s = c
			}
			var l = r.charCodeAt(n);
			l < 128 || e ? a(l) : l < 2048 ? (a(192 | l >> 6), a(128 | l & 63)) : l > 55295 && l < 57344 ? (l = 65536 + (l & 1023 << 10) | r.charCodeAt(++n) & 1023, a(240 | l >> 18), a(128 | l >> 12 & 63), a(128 | l >> 6 & 63), a(128 | l & 63)) : (a(224 | l >> 12), a(128 | l >> 6 & 63), a(128 | l & 63))
		}
		return ac(s, 0, o)
	}

	function l1(r, e) {
		if (e) {
			for (var t = "", n = 0; n < r.length; n += 16384) t += String.fromCharCode.apply(null, r.subarray(n, n + 16384));
			return t
		} else {
			if (gm) return gm.decode(r);
			var i = a1(r),
				s = i[0],
				o = i[1];
			return o.length && vi(8), s
		}
	}
	var c1 = function(r, e) {
			return e + 30 + Rr(r, e + 26) + Rr(r, e + 28)
		},
		u1 = function(r, e, t) {
			var n = Rr(r, e + 28),
				i = l1(r.subarray(e + 46, e + 46 + n), !(Rr(r, e + 8) & 2048)),
				s = e + 46 + n,
				o = pr(r, e + 20),
				a = t && o == 4294967295 ? h1(r, s) : [o, pr(r, e + 24), pr(r, e + 42)],
				c = a[0],
				l = a[1],
				u = a[2];
			return [Rr(r, e + 10), c, l, i, s + Rr(r, e + 30) + Rr(r, e + 32), u]
		},
		h1 = function(r, e) {
			for (; Rr(r, e) != 1; e += 4 + Rr(r, e + 2));
			return [um(r, e + 12), um(r, e + 4), um(r, e + 20)]
		},
		vm = function(r) {
			var e = 0;
			if (r)
				for (var t in r) {
					var n = r[t].length;
					n > 65535 && vi(9), e += n + 4
				}
			return e
		},
		jx = function(r, e, t, n, i, s, o, a) {
			var c = n.length,
				l = t.extra,
				u = a && a.length,
				h = vm(l);
			Hn(r, e, o != null ? 33639248 : 67324752), e += 4, o != null && (r[e++] = 20, r[e++] = t.os), r[e] = 20, e += 2, r[e++] = t.flag << 1 | (s < 0 && 8), r[e++] = i && 8, r[e++] = t.compression & 255, r[e++] = t.compression >> 8;
			var f = new Date(t.mtime == null ? Date.now() : t.mtime),
				p = f.getFullYear() - 1980;
			if ((p < 0 || p > 119) && vi(10), Hn(r, e, p << 25 | f.getMonth() + 1 << 21 | f.getDate() << 16 | f.getHours() << 11 | f.getMinutes() << 5 | f.getSeconds() >>> 1), e += 4, s != -1 && (Hn(r, e, t.crc), Hn(r, e + 4, s < 0 ? -s - 2 : s), Hn(r, e + 8, t.size)), Hn(r, e + 12, c), Hn(r, e + 14, h), e += 16, o != null && (Hn(r, e, u), Hn(r, e + 6, t.attrs), Hn(r, e + 10, o), e += 14), r.set(n, e), e += c, h)
				for (var g in l) {
					var m = l[g],
						d = m.length;
					Hn(r, e, +g), Hn(r, e + 2, d), r.set(m, e + 4), e += 4 + d
				}
			return u && (r.set(a, e), e += u), e
		},
		f1 = function(r, e, t, n, i) {
			Hn(r, e, 101010256), Hn(r, e + 8, t), Hn(r, e + 10, t), Hn(r, e + 12, n), Hn(r, e + 16, i)
		};

	function $x(r, e) {
		e || (e = {});
		var t = {},
			n = [];
		Jx(r, "", t, e);
		var i = 0,
			s = 0;
		for (var o in t) {
			var a = t[o],
				c = a[0],
				l = a[1],
				u = l.level == 0 ? 0 : 8,
				h = Wx(o),
				f = h.length,
				p = l.comment,
				g = p && Wx(p),
				m = g && g.length,
				d = vm(l.extra);
			f > 65535 && vi(11);
			var v = u ? r1(c, l) : c,
				x = v.length,
				_ = n1();
			_.p(c), n.push(Kx(l, {
				size: c.length,
				crc: _.d(),
				c: v,
				f: h,
				m: g,
				u: f != o.length || g && p.length != m,
				o: i,
				compression: u
			})), i += 30 + f + d + x, s += 76 + 2 * (f + d) + (m || 0) + x
		}
		for (var y = new ln(s + 22), w = i, C = s - i, S = 0; S < n.length; ++S) {
			var h = n[S];
			jx(y, h.o, h, h.f, h.u, h.c.length);
			var b = 30 + h.f.length + vm(h.extra);
			y.set(h.c, h.o + b), jx(y, i, h, h.f, h.u, h.c.length, h.o, h.m), i += 16 + b + (h.m ? h.m.length : 0)
		}
		return f1(y, i, n.length, C, w), y
	}

	function Oh(r, e) {
		for (var t = {}, n = r.length - 22; pr(r, n) != 101010256; --n)(!n || r.length - n > 65558) && vi(13);
		var i = Rr(r, n + 8);
		if (!i) return {};
		var s = pr(r, n + 16),
			o = s == 4294967295 || i == 65535;
		if (o) {
			var a = pr(r, n - 12);
			o = pr(r, a) == 101075792, o && (i = pr(r, a + 32), s = pr(r, a + 48))
		}
		for (var c = e && e.filter, l = 0; l < i; ++l) {
			var u = u1(r, s, o),
				h = u[0],
				f = u[1],
				p = u[2],
				g = u[3],
				m = u[4],
				d = u[5],
				v = c1(r, d);
			s = m, (!c || c({
				name: g,
				size: f,
				originalSize: p,
				compression: h
			})) && (h ? h == 8 ? t[g] = s1(r.subarray(v, v + f), new ln(p)) : vi(14, "unknown compression type " + h) : t[g] = ac(r, v, v + f))
		}
		return t
	}
	var bm = {
			Success: 0,
			NoDocumentXml: 1
		},
		Mm = class {
			constructor(e, t) {
				this.name = e, this.type = t, this.shapeName = null, this.isVisible = !1, this.color = null, this.fileName = null, this.fileContent = null, this.inLinkCount = 0, this.properties = null
			}
			IsConvertible() {
				return !(this.fileName === null || this.fileContent === null || !this.isVisible || this.inLinkCount > 0)
			}
		},
		wm = class {
			constructor() {
				this.files = null, this.properties = null, this.objectNames = [], this.objectData = new Map
			}
			Init(e) {
				let t = new Uint8Array(e);
				return this.files = Oh(t), this.LoadDocumentXml() ? (this.LoadGuiDocumentXml(), bm.Success) : bm.NoDocumentXml
			}
			GetObjectListToConvert() {
				let e = [];
				for (let t of this.objectNames) {
					let n = this.objectData.get(t);
					!n.IsConvertible() || e.push(n)
				}
				return e
			}
			IsSupportedType(e) {
				return !(!e.startsWith("Part::") && !e.startsWith("PartDesign::") || e.indexOf("Part2D") !== -1)
			}
			HasFile(e) {
				return e in this.files
			}
			LoadDocumentXml() {
				let e = this.GetXMLContent("Document.xml");
				if (e === null) return !1;
				this.properties = new On("Properties");
				let t = e.getElementsByTagName("Document");
				for (let s of t)
					for (let o of s.childNodes) o.tagName === "Properties" && this.GetPropertiesFromElement(o, this.properties);
				let n = e.getElementsByTagName("Objects");
				for (let s of n) {
					let o = s.getElementsByTagName("Object");
					for (let a of o) {
						let c = a.getAttribute("name"),
							l = a.getAttribute("type");
						if (!this.IsSupportedType(l)) continue;
						let u = new Mm(c, l);
						this.objectNames.push(c), this.objectData.set(c, u)
					}
				}
				let i = e.getElementsByTagName("ObjectData");
				for (let s of i) {
					let o = s.getElementsByTagName("Object");
					for (let a of o) {
						let c = a.getAttribute("name");
						if (!this.objectData.has(c)) continue;
						let l = this.objectData.get(c);
						l.properties = new On("Properties");
						for (let f of a.childNodes) f.tagName === "Properties" && this.GetPropertiesFromElement(f, l.properties);
						let u = a.getElementsByTagName("Property");
						for (let f of u) {
							let p = f.getAttribute("name");
							if (p === "Label") l.shapeName = this.GetFirstChildValue(f, "String", "value");
							else if (p === "Visibility") {
								let g = this.GetFirstChildValue(f, "Bool", "value");
								l.isVisible = g === "true"
							} else if (p === "Visible") {
								let g = this.GetFirstChildValue(f, "Bool", "value");
								l.isVisible = g === "true"
							} else if (p === "Shape") {
								let g = this.GetFirstChildValue(f, "Part", "file");
								if (!this.HasFile(g)) continue;
								let m = cr(g);
								if (m !== "brp" && m !== "brep") continue;
								l.fileName = g, l.fileContent = this.files[g]
							}
						}
						let h = a.getElementsByTagName("Link");
						for (let f of h) {
							let p = f.getAttribute("value");
							if (this.objectData.has(p)) {
								let g = this.objectData.get(p);
								g.inLinkCount += 1
							}
						}
					}
				}
				return !0
			}
			LoadGuiDocumentXml() {
				let e = this.GetXMLContent("GuiDocument.xml");
				if (e === null) return !1;
				let t = e.getElementsByTagName("ViewProvider");
				for (let n of t) {
					let i = n.getAttribute("name");
					if (!this.objectData.has(i)) continue;
					let s = this.objectData.get(i),
						o = n.getElementsByTagName("Property");
					for (let a of o) {
						let c = a.getAttribute("name");
						if (c === "Visibility") {
							let l = this.GetFirstChildValue(a, "Bool", "value");
							s.isVisible = l === "true"
						} else if (c === "ShapeColor") {
							let l = this.GetFirstChildValue(a, "PropertyColor", "value"),
								u = parseInt(l, 10);
							s.color = new Qn(u >> 24 & 255, u >> 16 & 255, u >> 8 & 255, 255)
						}
					}
				}
				return !0
			}
			GetPropertiesFromElement(e, t) {
				let n = e.getElementsByTagName("Property");
				for (let i of n) {
					let s = i.getAttribute("name"),
						o = i.getAttribute("type"),
						a = null;
					if (o === "App::PropertyBool") {
						let c = this.GetFirstChildValue(i, "String", "bool");
						c !== null && c.length > 0 && (a = new mt(ut.Boolean, s, c === "true"))
					} else if (o === "App::PropertyInteger") {
						let c = this.GetFirstChildValue(i, "Integer", "value");
						c !== null && c.length > 0 && (a = new mt(ut.Integer, s, parseInt(c)))
					} else if (o === "App::PropertyString") {
						let c = this.GetFirstChildValue(i, "String", "value");
						c !== null && c.length > 0 && (a = new mt(ut.Text, s, c))
					} else if (o === "App::PropertyUUID") {
						let c = this.GetFirstChildValue(i, "Uuid", "value");
						c !== null && c.length > 0 && (a = new mt(ut.Text, s, c))
					} else if (o === "App::PropertyFloat" || o === "App::PropertyLength" || o === "App::PropertyDistance" || o === "App::PropertyArea" || o === "App::PropertyVolume") {
						let c = this.GetFirstChildValue(i, "Float", "value");
						c !== null && c.length > 0 && (a = new mt(ut.Number, s, parseFloat(c)))
					}
					a !== null && t.AddProperty(a)
				}
			}
			GetXMLContent(e) {
				if (!this.HasFile(e)) return null;
				let t = new DOMParser,
					n = fn(this.files[e]);
				return t.parseFromString(n, "text/xml")
			}
			GetFirstChildValue(e, t, n) {
				let i = e.getElementsByTagName(t);
				return i.length === 0 ? null : i[0].getAttribute(n)
			}
		},
		kh = class extends Ht {
			constructor() {
				super(), this.worker = null, this.document = null
			}
			CanImportExtension(e) {
				return e === "fcstd"
			}
			GetUpDirection() {
				return lt.Z
			}
			ClearContent() {
				this.worker !== null && (this.worker.terminate(), this.worker = null), this.document = null
			}
			ResetContent() {
				this.worker = null, this.document = new wm
			}
			ImportContent(e, t) {
				if (this.document.Init(e) === bm.NoDocumentXml) {
					this.SetError("No Document.xml found."), t();
					return
				}
				this.document.properties !== null && this.document.properties.PropertyCount() > 0 && this.model.AddPropertyGroup(this.document.properties);
				let i = this.document.GetObjectListToConvert();
				if (i.length === 0) {
					this.SetError("No importable object found."), t();
					return
				}
				this.ConvertObjects(i, t)
			}
			ConvertObjects(e, t) {
				let n = ll("loaders/occt-import-js-worker.js");
				this.worker = new Worker(n);
				let i = 0,
					s = new Bi(this.model),
					o = c => {
						if (c !== null) {
							let l = e[i];
							this.OnFileConverted(l, c, s)
						}
						if (i += 1, i === e.length) t();
						else {
							let l = e[i];
							this.worker.postMessage({
								format: "brep",
								buffer: l.fileContent
							})
						}
					};
				this.worker.addEventListener("message", c => {
					o(c.data)
				}), this.worker.addEventListener("error", c => {
					o(null)
				});
				let a = e[i];
				this.worker.postMessage({
					format: "brep",
					buffer: a.fileContent
				})
			}
			OnFileConverted(e, t, n) {
				if (!t.success || t.meshes.length === 0) return;
				let i = new Dn;
				i.SetType(zn.GroupNode), e.shapeName !== null && i.SetName(e.shapeName);
				let s = 1;
				for (let a of t.meshes) {
					let c = null;
					e.color !== null && (c = n.GetMaterialIndex(e.color.r, e.color.g, e.color.b, e.color.a));
					let l = es(a, c);
					if (e.shapeName !== null) {
						let h = s.toString()
							.padStart(3, "0");
						l.SetName(e.shapeName + " " + h)
					}
					e.properties !== null && e.properties.PropertyCount() > 0 && l.AddPropertyGroup(e.properties);
					let u = this.model.AddMesh(l);
					i.AddMeshIndex(u), s += 1
				}
				this.model.GetRootNode()
					.AddChildNode(i)
			}
		};
	var No = class {
			constructor() {
				this.defaultColor = new nt(200, 200, 200)
			}
		},
		Xi = {
			NoImportableFile: 1,
			FailedToLoadFile: 2,
			ImportFailed: 3,
			UnknownError: 4
		},
		qa = class {
			constructor(e) {
				this.code = e, this.mainFile = null, this.message = null
			}
		},
		Tm = class {
			constructor() {
				this.model = null, this.mainFile = null, this.upVector = null, this.usedFiles = null, this.missingFiles = null
			}
		},
		Sm = class {
			constructor(e) {
				this.getBufferCallback = e, this.fileBuffers = new Map
			}
			GetFileBuffer(e) {
				let t = Sn(e);
				if (this.fileBuffers.has(t)) return this.fileBuffers.get(t);
				let n = this.getBufferCallback(t);
				return this.fileBuffers.set(t, n), n
			}
		},
		Fh = class {
			constructor() {
				this.importers = [new eh, new rh, new th, new nh, new Yu, new Zu, new $u, new sh, new Xu, new Ku, new ih, new kh, new Ah, new Ih, new Rh, new Ph], this.fileList = new Ul, this.model = null, this.usedFiles = [], this.missingFiles = []
			}
			AddImporter(e) {
				this.importers.push(e)
			}
			ImportFiles(e, t, n) {
				n.onLoadStart(), this.LoadFiles(e, {
					onReady: () => {
						n.onImportStart(), Ao(() => {
							this.DecompressArchives(this.fileList, () => {
								this.ImportLoadedFiles(t, n)
							})
						})
					},
					onFileListProgress: n.onFileListProgress,
					onFileLoadProgress: n.onFileLoadProgress
				})
			}
			LoadFiles(e, t) {
				let n = new Ul;
				n.FillFromInputFiles(e);
				let i = !1;
				if (this.HasImportableFile(n)) i = !0;
				else {
					let s = !1;
					for (let o = 0; o < this.missingFiles.length; o++) {
						let a = this.missingFiles[o];
						n.ContainsFileByPath(a) && (s = !0)
					}
					s ? (this.fileList.ExtendFromFileList(n), i = !1) : i = !0
				}
				i && (this.fileList = n), this.fileList.GetContent({
					onReady: t.onReady,
					onFileListProgress: t.onFileListProgress,
					onFileLoadProgress: t.onFileLoadProgress
				})
			}
			ImportLoadedFiles(e, t) {
				let n = this.GetImportableFiles(this.fileList);
				if (n.length === 0) {
					t.onImportError(new qa(Xi.NoImportableFile));
					return
				}
				if (n.length === 1 || !t.onSelectMainFile) {
					let i = n[0];
					this.ImportLoadedMainFile(i, e, t)
				} else {
					let i = n.map(s => s.file.name);
					t.onSelectMainFile(i, s => {
						if (s === null) {
							t.onImportError(new qa(Xi.NoImportableFile));
							return
						}
						Ao(() => {
							let o = n[s];
							this.ImportLoadedMainFile(o, e, t)
						})
					})
				}
			}
			ImportLoadedMainFile(e, t, n) {
				if (e === null || e.file === null || e.file.content === null) {
					let o = new qa(Xi.FailedToLoadFile);
					e !== null && e.file !== null && (o.mainFile = e.file.name), n.onImportError(o);
					return
				}
				this.model = null, this.usedFiles = [], this.missingFiles = [], this.usedFiles.push(e.file.name);
				let i = e.importer,
					s = new Sm(o => {
						let a = null,
							c = this.fileList.FindFileByPath(o);
						return c === null || c.content === null ? (this.missingFiles.push(o), a = null) : (this.usedFiles.push(o), a = c.content), a
					});
				i.Import(e.file.name, e.file.extension, e.file.content, {
					getDefaultMaterialColor: () => t.defaultColor,
					getFileBuffer: o => s.GetFileBuffer(o),
					onSuccess: () => {
						this.model = i.GetModel();
						let o = new Tm;
						o.mainFile = e.file.name, o.model = this.model, o.usedFiles = this.usedFiles, o.missingFiles = this.missingFiles, o.upVector = i.GetUpDirection(), n.onImportSuccess(o)
					},
					onError: () => {
						let o = new qa(Xi.ImportFailed);
						o.mainFile = e.file.name, o.message = i.GetErrorMessage(), n.onImportError(o)
					},
					onComplete: () => {
						i.Clear()
					}
				})
			}
			DecompressArchives(e, t) {
				let n = e.GetFiles(),
					i = [];
				for (let s of n) s.extension === "zip" && i.push(s);
				if (i.length === 0) {
					t();
					return
				}
				for (let s = 0; s < i.length; s++) {
					let o = i[s],
						a = new Uint8Array(o.content),
						c = Oh(a);
					for (let l in c)
						if (Object.prototype.hasOwnProperty.call(c, l)) {
							let u = new Fl(l, lr.Decompressed, null);
							u.SetContent(c[l].buffer), e.AddFile(u)
						}
				}
				t()
			}
			GetFileList() {
				return this.fileList
			}
			HasImportableFile(e) {
				return this.GetImportableFiles(e)
					.length > 0
			}
			GetImportableFiles(e) {
				function t(s, o) {
					for (let a = 0; a < o.length; a++) {
						let c = o[a];
						if (c.CanImportExtension(s.extension)) return c
					}
					return null
				}
				let n = [],
					i = e.GetFiles();
				for (let s = 0; s < i.length; s++) {
					let o = i[s],
						a = t(o, this.importers);
					a !== null && n.push({
						file: o,
						importer: a
					})
				}
				return n
			}
		};
	var Xa = class {
		constructor() {
			this.skipNextEvent = !1, this.eventListener = null
		}
		SetEventListener(e) {
			this.eventListener = e, window.onhashchange = this.OnChange.bind(this)
		}
		SkipNextEventHandler() {
			this.skipNextEvent = !0
		}
		HasHash() {
			return this.GetHash()
				.length > 0
		}
		ClearHash() {
			this.SetHash("")
		}
		GetModelFilesFromHash() {
			return zs(this.GetHash())
				.GetModelUrls()
		}
		SetModelFilesToHash(e) {
			let t = Fu(e);
			this.SetHash(t)
		}
		GetCameraFromHash() {
			return zs(this.GetHash())
				.GetCamera()
		}
		GetCameraModeFromHash() {
			return zs(this.GetHash())
				.GetCameraMode()
		}
		GetBackgroundFromHash() {
			return zs(this.GetHash())
				.GetBackgroundColor()
		}
		GetEnvironmentSettingsFromHash() {
			return zs(this.GetHash())
				.GetEnvironmentSettings()
		}
		GetDefaultColorFromHash() {
			return zs(this.GetHash())
				.GetDefaultColor()
		}
		GetEdgeSettingsFromHash() {
			return zs(this.GetHash())
				.GetEdgeSettings()
		}
		GetHash() {
			return window.location.hash.substring(1)
		}
		SetHash(e) {
			window.location.hash = e
		}
		OnChange() {
			if (this.skipNextEvent) {
				this.skipNextEvent = !1;
				return
			}
			this.eventListener()
		}
	};
	var Uh = class {
			constructor() {
				this.forceMediumpForMaterials = !1
			}
		},
		Bh = class {
			constructor() {
				this.defaultMaterial = null, this.objectUrls = []
			}
		},
		Em = class {
			constructor(e) {
				this.callbacks = e, this.texturesNeeded = 0, this.texturesLoaded = 0, this.threeObject = null
			}
			OnTextureNeeded() {
				this.texturesNeeded += 1
			}
			OnTextureLoaded() {
				this.texturesLoaded += 1, this.callbacks.onTextureLoaded(), this.Finish()
			}
			OnModelLoaded(e) {
				this.threeObject = e, this.Finish()
			}
			Finish() {
				this.threeObject !== null && this.texturesNeeded === this.texturesLoaded && this.callbacks.onModelLoaded(this.threeObject)
			}
		},
		Cm = class {
			constructor(e, t) {
				this.meshInstances = [], this.AddNode(e, t)
			}
			AddNode(e, t) {
				let n = e.GetTransformation()
					.GetMatrix(),
					i = new ke()
					.fromArray(n.Get());
				t.applyMatrix4(i);
				for (let s of e.GetChildNodes()) {
					let o = new yt;
					t.add(o), this.AddNode(s, o)
				}
				for (let s of e.GetMeshIndices()) this.meshInstances.push({
					node: e,
					threeNode: t,
					meshIndex: s
				})
			}
			GetMeshInstances() {
				return this.meshInstances
			}
		};

	function Qx(r, e, t, n) {
		function i(f, p, g, m, d, v) {
			function x(T, N) {
				N.wrapS = en, N.wrapT = en, N.rotation = T.rotation, N.offset.x = T.offset.x, N.offset.y = T.offset.y, N.repeat.x = T.scale.x, N.repeat.y = T.scale.y
			}

			function _(T, N, V, O, k) {
				if (V === null || !V.IsValid()) return;
				let I = new Fi;
				T.OnTextureNeeded();
				let q = null;
				V.mimeType !== null ? q = rg(V.buffer, V.mimeType) : q = uo(V.buffer), O.objectUrls.push(q), I.load(q, B => {
					x(V, B), N.needsUpdate = !0, k(B), T.OnTextureLoaded()
				}, null, B => {
					T.OnTextureLoaded()
				})
			}
			let y = p.GetMaterial(g),
				w = Ui(y.color);
			y.vertexColors && w.setRGB(1, 1, 1);
			let C = {
				color: w,
				vertexColors: y.vertexColors,
				opacity: y.opacity,
				transparent: y.transparent,
				alphaTest: y.alphaTest,
				side: Bn
			};
			d.forceMediumpForMaterials && (C.precision = "mediump");
			let S = null;
			if (m === wn.Phong) {
				if (S = new an(C), y.type === on.Phong) {
					let T = Ui(y.specular);
					Yt(y.shininess, 0) && T.setRGB(0, 0, 0), S.specular = T, S.shininess = y.shininess * 100, _(f, S, y.specularMap, v, N => {
						S.specularMap = N
					})
				}
			} else m === wn.Physical && (S = new ks(C), y.type === on.Physical && (S.metalness = y.metalness, S.roughness = y.roughness, _(f, S, y.metalnessMap, v, T => {
				S.metalness = 1, S.roughness = 1, S.metalnessMap = T, S.roughnessMap = T
			})));
			let b = Ui(y.emissive);
			return S.emissive = b, _(f, S, y.diffuseMap, v, T => {
				y.multiplyDiffuseMap || S.color.setRGB(1, 1, 1), S.map = T
			}), _(f, S, y.bumpMap, v, T => {
				S.bumpMap = T
			}), _(f, S, y.normalMap, v, T => {
				S.normalMap = T
			}), _(f, S, y.emissiveMap, v, T => {
				S.emissiveMap = T
			}), y.isDefault && (v.defaultMaterial = S), S
		}

		function s(f, p, g) {
			let m = f.GetMesh(p.meshIndex),
				d = m.TriangleCount(),
				v = [];
			for (let I = 0; I < d; I++) v.push(I);
			v.sort((I, q) => {
				let B = m.GetTriangle(I),
					Y = m.GetTriangle(q);
				return B.mat - Y.mat
			});
			let x = new bt,
				_ = [],
				y = [],
				w = new Map,
				C = [],
				S = [],
				b = [],
				T = [],
				N = [];
			N.push({
				start: 0,
				end: -1
			});
			let V = m.VertexColorCount() > 0,
				O = m.TextureUVCount() > 0;
			for (let I = 0; I < v.length; I++) {
				let q = v[I],
					B = m.GetTriangle(q),
					Y = m.GetVertex(B.v0),
					J = m.GetVertex(B.v1),
					H = m.GetVertex(B.v2);
				if (C.push(Y.x, Y.y, Y.z, J.x, J.y, J.z, H.x, H.y, H.z), B.HasVertexColors()) {
					let U = Ui(m.GetVertexColor(B.c0)),
						A = Ui(m.GetVertexColor(B.c1)),
						L = Ui(m.GetVertexColor(B.c2));
					S.push(U.r, U.g, U.b, A.r, A.g, A.b, L.r, L.g, L.b)
				} else V && S.push(0, 0, 0, 0, 0, 0, 0, 0, 0);
				let $ = m.GetNormal(B.n0),
					ae = m.GetNormal(B.n1),
					oe = m.GetNormal(B.n2);
				if (b.push($.x, $.y, $.z, ae.x, ae.y, ae.z, oe.x, oe.y, oe.z), B.HasTextureUVs()) {
					let U = m.GetTextureUV(B.u0),
						A = m.GetTextureUV(B.u1),
						L = m.GetTextureUV(B.u2);
					T.push(U.x, U.y, A.x, A.y, L.x, L.y)
				} else O && T.push(0, 0, 0, 0, 0, 0);
				let ie = B.mat;
				w.has(ie) || (w.set(ie, _.length), _.push(g[ie]), y.push(ie), I > 0 && (N[N.length - 1].end = I - 1, N.push({
					start: N[N.length - 1].end + 1,
					end: -1
				})))
			}
			N[N.length - 1].end = d - 1, x.setAttribute("position", new ze(C, 3)), S.length !== 0 && x.setAttribute("color", new ze(S, 3)), x.setAttribute("normal", new ze(b, 3)), T.length !== 0 && x.setAttribute("uv", new ze(T, 2));
			for (let I = 0; I < N.length; I++) {
				let q = N[I];
				x.addGroup(q.start * 3, (q.end - q.start + 1) * 3, I)
			}
			let k = new zt(x, _);
			return k.name = m.GetName(), k.userData = {
				originalMeshId: p,
				originalMaterials: y,
				threeMaterials: null
			}, k
		}

		function o(f, p, g, m) {
			let d = p.GetMesh(g.meshIndex);
			if (Aa(d) === Hs.TriangleMesh) {
				let x = s(p, g, m);
				f.add(x)
			}
		}

		function a(f, p, g, m) {
			let d = p.GetRootNode(),
				x = new Cm(d, f)
				.GetMeshInstances();
			Av(x.length, 100, {
				runTask: (_, y, w) => {
					for (let C = _; C <= y; C++) {
						let S = x[C],
							b = S.node,
							T = S.threeNode,
							N = new ts(b.GetId(), S.meshIndex);
						o(T, p, N, g)
					}
					w()
				},
				onReady: () => {
					m.OnModelLoaded(f)
				}
			})
		}
		let c = new Em(n),
			l = yv(r),
			u = [];
		for (let f = 0; f < r.MaterialCount(); f++) {
			let p = i(c, r, f, l, e, t);
			u.push(p)
		}
		let h = new yt;
		a(h, r, u, c)
	}
	var Gh = class {
		constructor() {
			this.importer = new Fh, this.inProgress = !1, this.defaultMaterial = null, this.objectUrls = null, this.hasHighpDriverIssue = xv()
		}
		InProgress() {
			return this.inProgress
		}
		LoadModel(e, t, n) {
			this.inProgress || (this.inProgress = !0, this.RevokeObjectUrls(), this.importer.ImportFiles(e, t, {
				onLoadStart: () => {
					n.onLoadStart()
				},
				onFileListProgress: (i, s) => {
					n.onFileListProgress(i, s)
				},
				onFileLoadProgress: (i, s) => {
					n.onFileLoadProgress(i, s)
				},
				onImportStart: () => {
					n.onImportStart()
				},
				onSelectMainFile: (i, s) => {
					n.onSelectMainFile ? n.onSelectMainFile(i, s) : s(0)
				},
				onImportSuccess: i => {
					n.onVisualizationStart();
					let s = new Uh;
					s.forceMediumpForMaterials = this.hasHighpDriverIssue;
					let o = new Bh;
					Qx(i.model, s, o, {
						onTextureLoaded: () => {
							n.onTextureLoaded()
						},
						onModelLoaded: a => {
							if (this.defaultMaterial = o.defaultMaterial, this.objectUrls = o.objectUrls, i.upVector === lt.X) {
								let c = new mn()
									.setFromAxisAngle(new ne(0, 0, 1), Math.PI / 2);
								a.quaternion.multiply(c)
							} else if (i.upVector === lt.Z) {
								let c = new mn()
									.setFromAxisAngle(new ne(1, 0, 0), -Math.PI / 2);
								a.quaternion.multiply(c)
							}
							n.onModelFinished(i, a), this.inProgress = !1
						}
					})
				},
				onImportError: i => {
					n.onLoadError(i), this.inProgress = !1
				}
			}))
		}
		GetImporter() {
			return this.importer
		}
		GetDefaultMaterial() {
			return this.defaultMaterial
		}
		ReplaceDefaultMaterialColor(e) {
			this.defaultMaterial !== null && !this.defaultMaterial.vertexColors && (this.defaultMaterial.color = Ui(e))
		}
		RevokeObjectUrls() {
			if (this.objectUrls !== null) {
				for (let e of this.objectUrls) sg(e);
				this.objectUrls = null
			}
		}
	};
	var lc = null;

	function Am() {
		lc !== null && (lc.Close(), lc = null)
	}

	function d1() {
		lc = null
	}

	function p1(r) {
		Am(), lc = r
	}
	var cc = class {
			constructor() {
				this.modalDiv = ui("ov_modal"), this.modalDiv.addEventListener("mousemove", e => {
					e.stopPropagation()
				}), this.overlayDiv = null, this.resizeHandler = null, this.positionCalculator = null, this.closeHandler = null, this.isOpen = !1, this.closeable = !0
			}
			GetContentDiv() {
				return this.modalDiv
			}
			SetCloseable(e) {
				this.closeable = e
			}
			SetPositionCalculator(e) {
				this.positionCalculator = e
			}
			SetCloseHandler(e) {
				this.closeHandler = e
			}
			Open() {
				this.isOpen || (p1(this), this.overlayDiv = _e(document.body, "ov_modal_overlay"), document.body.appendChild(this.modalDiv), this.resizeHandler = this.Resize.bind(this), window.addEventListener("resize", this.resizeHandler), this.closeable && (this.overlayDiv.addEventListener("click", e => {
					e.preventDefault(), this.Close()
				}), this.overlayDiv.addEventListener("mousemove", e => {
					e.stopPropagation()
				}), this.overlayDiv.addEventListener("contextmenu", e => {
					e.preventDefault(), this.Close()
				})), this.isOpen = !0, this.Resize())
			}
			Close() {
				!this.isOpen || (d1(), window.removeEventListener("resize", this.resizeHandler), this.closeHandler !== null && this.closeHandler(), this.modalDiv.remove(), this.overlayDiv.remove(), this.overlayDiv = null, this.resizeHandler = null, this.isOpen = !1)
			}
			Resize() {
				let e = window.innerWidth,
					t = window.innerHeight,
					n = (e - this.modalDiv.offsetWidth) / 2,
					i = (t - this.modalDiv.offsetHeight) / 3;
				if (this.positionCalculator !== null) {
					let s = this.positionCalculator();
					n = s.x, i = s.y
				}
				this.modalDiv.style.left = n + "px", this.modalDiv.style.top = i + "px"
			}
		},
		Ya = class extends cc {
			constructor() {
				super(), this.SetCloseable(!1), this.textDiv = null
			}
			Init(e) {
				let t = this.GetContentDiv();
				t.classList.add("ov_progress"), _e(t, "ov_progress_img", '<svg><use href="assets/images/3dviewer_net_logo.svg#logo"></use></svg>'), this.textDiv = _e(t, "ov_progress_text"), this.SetText(e)
			}
			SetText(e) {
				this.textDiv.innerHTML = e
			}
		},
		yi = class extends cc {
			constructor() {
				super()
			}
			Init(e, t) {
				function n(c, l) {
					let u = _e(l, "ov_button ov_dialog_button", c.name);
					c.subClass && u.classList.add(c.subClass), u.addEventListener("click", () => {
						c.onClick()
					})
				}
				let i = this.GetContentDiv();
				i.classList.add("ov_dialog"), _e(i, "ov_dialog_title", e);
				let s = _e(i, "ov_dialog_content"),
					o = _e(i, "ov_dialog_buttons"),
					a = _e(o, "ov_dialog_buttons_inner");
				for (let c = 0; c < t.length; c++) n(t[c], a);
				return s
			}
		},
		uc = class extends cc {
			constructor() {
				super()
			}
			Init(e) {
				let t = this.GetContentDiv();
				return t.classList.add("ov_popup"), this.SetPositionCalculator(e), t
			}
		},
		Vh = class extends uc {
			constructor() {
				super(), this.listDiv = null
			}
			Init(e) {
				let t = super.Init(e);
				return this.listDiv = _e(t, "ov_popup_list ov_thin_scrollbar"), t
			}
			AddListItem(e, t) {
				let n = _e(this.listDiv, "ov_popup_list_item");
				if (e.icon && Xn(n, e.icon, "left_inline"), e.color) {
					let i = _e(n, "ov_popup_list_item_icon"),
						s = Cc(e.color);
					i.appendChild(s)
				}
				_e(n, "ov_popup_list_item_name", e.name), n.addEventListener("click", t.onClick), Cf() && t.onHoverStart && t.onHoverStop && (n.addEventListener("mouseover", () => {
					t.onHoverStart()
				}), n.addEventListener("mouseout", () => {
					t.onHoverStop()
				}))
			}
		};

	function cs(r, e, t) {
		let n = new yi,
			i = n.Init(r, [{
				name: "OK",
				onClick() {
					n.Close()
				}
			}]);
		return _e(i, "ov_dialog_message", e), t !== null && _e(i, "ov_dialog_submessage", t), n.Open(), n
	}

	function Za(r, e) {
		if (r.length === 0) return null;
		let t = new Vh;
		t.Init(() => e.calculatePosition(t.GetContentDiv()));
		for (let n = 0; n < r.length; n++) {
			let i = r[n];
			t.AddListItem(i, {
				onHoverStart: function() {
					e.onHoverStart && e.onHoverStart(n)
				},
				onHoverStop: function() {
					e.onHoverStop && e.onHoverStop(n)
				},
				onClick: function() {
					t.Close(), e.onClick(n)
				}
			})
		}
		return t.Open(), t
	}

	function ey(r, e) {
		let t = r.getBoundingClientRect();
		return {
			x: t.left - e.offsetWidth,
			y: t.top
		}
	}

	function zh(r, e) {
		let t = r.getBoundingClientRect();
		return {
			x: t.left + r.offsetWidth,
			y: t.top + r.offsetHeight - e.offsetHeight
		}
	}

	function ty(r, e) {
		let t = window.innerWidth,
			n = window.innerHeight,
			i = r.x,
			s = r.y,
			o = i + e.offsetWidth,
			a = s + e.offsetHeight;
		return o > t && (i = i - (o - t)), a > n && (s = s - (a - n)), {
			x: i,
			y: s
		}
	}
	var Ka = class {
		constructor() {
			this.modelLoader = new Gh, this.modalDialog = null
		}
		LoadModel(e, t, n) {
			if (this.modelLoader.InProgress()) return;
			let i = null;
			this.modelLoader.LoadModel(e, t, {
				onLoadStart: () => {
					this.CloseDialogIfOpen(), n.onStart(), i = new Ya, i.Init("Loading Model"), i.Open()
				},
				onFileListProgress: (s, o) => {},
				onFileLoadProgress: (s, o) => {},
				onSelectMainFile: (s, o) => {
					i.Close(), this.modalDialog = this.ShowFileSelectorDialog(s, a => {
						i.Open(), o(a)
					})
				},
				onImportStart: () => {
					i.SetText("\u52a0\u8f7d\u4e2d")
				},
				onVisualizationStart: () => {
					i.SetText("Visualizing Model")
				},
				onModelFinished: (s, o) => {
					i.Close(), n.onFinish(s, o)
				},
				onTextureLoaded: () => {
					n.onRender()
				},
				onLoadError: s => {
					i.Close(), n.onError(s), this.modalDialog = this.ShowErrorDialog(s)
				}
			})
		}
		GetModelLoader() {
			return this.modelLoader
		}
		GetImporter() {
			return this.modelLoader.GetImporter()
		}
		ShowErrorDialog(e) {
			return e.code === Xi.NoImportableFile ? cs("Something went wrong", "No importable file found.", null) : e.code === Xi.FailedToLoadFile ? cs("Something went wrong", "Failed to load file for import.", "The remote server refused to fulfill the request. Check if the url is correct, and make sure that CORS requests are allowed on the remote server.") : e.code === Xi.ImportFailed ? cs("Something went wrong", "Failed to import model.", e.message) : cs("Something went wrong", "Unknown error.", null)
		}
		ShowFileSelectorDialog(e, t) {
			let n = new yi,
				i = n.Init("Select Model", [{
					name: "Cancel",
					subClass: "outline",
					onClick() {
						n.Close()
					}
				}]);
			n.SetCloseHandler(() => {
				t(null)
			}), _e(i, "ov_dialog_message", "Multiple importable models found. Select the model you would like to import from the list below.");
			let o = _e(i, "ov_dialog_section"),
				a = _e(o, "ov_dialog_import_file_list ov_thin_scrollbar");
			for (let c = 0; c < e.length; c++) {
				let l = e[c],
					u = _e(a, "ov_dialog_file_link");
				Xn(u, "meshes", "ov_file_link_img"), _e(u, "ov_dialog_file_link_text", l), u.addEventListener("click", () => {
					n.SetCloseHandler(null), n.Close(), t(c)
				})
			}
			return n.Open(), n
		}
		CloseDialogIfOpen() {
			this.modalDialog !== null && (this.modalDialog.Close(), this.modalDialog = null)
		}
	};
	var Hh = class {
		constructor(e) {
			this.parameters = e, this.viewer = new Ea, this.hashHandler = new Xa, this.modelLoaderUI = new Ka
		}
		Load() {
			let e = Zt(this.parameters.viewerDiv, "canvas");
			if (this.viewer.Init(e), this.Resize(), this.hashHandler.HasHash()) {
				let t = this.hashHandler.GetModelFilesFromHash();
				if (t === null) return;
				Uu(t);
				let n = "fishermans_bastion",
					i = !1,
					s = this.hashHandler.GetEnvironmentSettingsFromHash();
				s !== null && (n = s.environmentMapName, i = s.backgroundIsEnvMap);
				let o = "assets/envmaps/" + n + "/",
					a = [o + "posx.jpg", o + "negx.jpg", o + "posy.jpg", o + "negy.jpg", o + "posz.jpg", o + "negz.jpg"];
				this.viewer.SetEnvironmentMapSettings(a, i);
				let c = this.hashHandler.GetCameraModeFromHash();
				c !== null && this.viewer.SetCameraMode(c);
				let l = this.hashHandler.GetBackgroundFromHash();
				l !== null && this.viewer.SetBackgroundColor(l);
				let u = this.hashHandler.GetEdgeSettingsFromHash();
				u !== null && this.viewer.SetEdgeSettings(u.showEdges, u.edgeColor, u.edgeThreshold);
				let h = new No,
					f = this.hashHandler.GetDefaultColorFromHash();
				f !== null && (h.defaultColor = f);
				let p = Vu(t);
				this.modelLoaderUI.LoadModel(p, h, {
					onStart: () => {},
					onFinish: (d, v) => {
						this.OnModelFinished(v)
					},
					onRender: () => {
						this.viewer.Render()
					},
					onError: d => {}
				});
				let g = Fu(t),
					m = this.parameters.websiteLinkDiv.getAttribute("href") + "#" + g;
				this.parameters.websiteLinkDiv.setAttribute("href", m)
			}
			window.addEventListener("resize", () => {
				this.Resize()
			})
		}
		Resize() {
			let e = window.innerWidth,
				t = window.innerHeight;
			this.viewer.Resize(e, t)
		}
		OnModelFinished(e) {
			this.viewer.SetMainObject(e);
			let t = this.viewer.GetBoundingSphere(i => !0);
			this.viewer.AdjustClippingPlanesToSphere(t);
			let n = this.hashHandler.GetCameraFromHash();
			n !== null ? this.viewer.SetCamera(n) : (this.viewer.SetUpVector(lt.Y, !1), this.viewer.FitSphereToWindow(t, !1))
		}
	};
	var Ja = class {
			constructor(e) {
				this.parentDiv = e, this.panelDiv = _e(e), At(this.panelDiv, !1), this.visible = !1
			}
			GetName() {
				return null
			}
			GetIcon() {
				return null
			}
			IsVisible() {
				return this.visible
			}
			Show(e) {
				this.visible !== e && (this.visible = e, At(this.panelDiv, this.visible))
			}
			Resize() {}
			Clear() {}
		},
		$a = class {
			constructor(e) {
				this.parentDiv = e, this.menuDiv = _e(e, "ov_panel_set_menu"), this.contentDiv = _e(e, "ov_panel_set_content ov_thin_scrollbar"), this.panels = [], this.panelButtons = [], this.panelsVisible = !0, this.panelsPrevWidth = null, this.callbacks = null
			}
			Init(e) {
				this.callbacks = e
			}
			GetContentDiv() {
				return this.contentDiv
			}
			AddPanel(e) {
				this.panels.push(e);
				let t = Xn(this.menuDiv, e.GetIcon(), "ov_panel_set_menu_button");
				t.setAttribute("alt", e.GetName()), t.setAttribute("title", e.GetName()), this.panelButtons.push(t), t.addEventListener("click", () => {
					e === this.GetVisiblePanel() ? this.ShowPanels(!1) : (this.ShowPanels(!0), this.ShowPanel(e))
				})
			}
			IsPanelsVisible() {
				return this.panelsVisible
			}
			ShowPanels(e) {
				if (!!this.IsParentVisible() && this.panelsVisible !== e) {
					if (this.panelsVisible = e, this.panelsVisible) At(this.contentDiv, !0), Bo(this.parentDiv, this.menuDiv.offsetWidth + this.panelsPrevWidth);
					else {
						for (let t of this.panelButtons) t.classList.remove("selected");
						for (let t of this.panels) t.Show(!1);
						this.panelsPrevWidth = this.contentDiv.offsetWidth, Bo(this.parentDiv, this.menuDiv.offsetWidth), At(this.contentDiv, !1)
					}
					this.callbacks.onShowHidePanels(this.panelsVisible), this.callbacks.onResizeRequested()
				}
			}
			ShowPanel(e) {
				if (e === this.GetVisiblePanel()) return;
				let t = this.GetPanelButton(e);
				for (let n of this.panelButtons) n !== t && n.classList.remove("selected");
				t.classList.add("selected");
				for (let n of this.panels) n !== e && n.Show(!1);
				e.Show(!0), e.Resize()
			}
			GetVisiblePanel() {
				if (!this.panelsVisible) return null;
				for (let e of this.panels)
					if (e.IsVisible()) return e;
				return null
			}
			SetPanelIcon(e, t) {
				let n = this.GetPanelButton(e);
				Ur(n, t)
			}
			GetPanelButton(e) {
				let t = this.panels.indexOf(e);
				return this.panelButtons[t]
			}
			Resize() {
				let e = this.parentDiv.offsetHeight;
				if (ci(this.menuDiv, e), ci(this.contentDiv, e), this.panelsVisible)
					for (let t of this.panels) t.IsVisible() && t.Resize()
			}
			IsParentVisible() {
				return Mc(this.parentDiv)
			}
			Clear() {
				for (let e of this.panels) e.Clear()
			}
		};

	function ny(r) {
		r.scrollIntoView({
			behavior: "smooth",
			block: "nearest"
		})
	}
	var us = class {
			constructor(e) {
				this.imagePath = e, this.mainElement = fl(this.imagePath, "ov_tree_item_button"), this.mainElement.setAttribute("src", this.imagePath)
			}
			SetImage(e) {
				this.imagePath = e, Ur(this.mainElement, this.imagePath)
			}
			OnClick(e) {
				this.mainElement.addEventListener("click", t => {
					t.stopPropagation(), e(t)
				})
			}
			GetDomElement() {
				return this.mainElement
			}
		},
		Wh = class {
			constructor(e, t) {
				if (this.name = e, this.parent = null, this.mainElement = ui("ov_tree_item"), this.mainElement.setAttribute("title", this.name), this.nameElement = _e(this.mainElement, "ov_tree_item_name", this.name), Ia(t)) {
					let n = fl(t, "ov_tree_item_icon");
					ao(n, this.nameElement)
				}
			}
			OnClick(e) {
				this.mainElement.classList.add("clickable"), this.mainElement.style.cursor = "pointer", this.mainElement.addEventListener("click", e)
			}
			SetParent(e) {
				this.parent = e
			}
			AddDomElements(e) {
				e.appendChild(this.mainElement)
			}
		},
		Qs = class extends Wh {
			constructor(e, t) {
				super(e, t), this.selected = !1
			}
			SetSelected(e) {
				if (this.selected = e, this.selected) {
					this.mainElement.classList.add("selected");
					let t = this.parent;
					if (t === null) ny(this.mainElement);
					else
						for (; t !== null;) t.ShowChildren(!0), ny(this.mainElement), t = t.parent
				} else this.mainElement.classList.remove("selected")
			}
		},
		Qa = class extends Qs {
			constructor(e, t) {
				super(e, t), this.buttonsDiv = ui("ov_tree_item_button_container"), ao(this.buttonsDiv, this.nameElement)
			}
			AppendButton(e) {
				this.buttonsDiv.appendChild(e.GetDomElement())
			}
		},
		eo = class extends Wh {
			constructor(e, t) {
				super(e, t), this.children = [], this.isVisible = !0, this.isChildrenVisible = !1, this.childrenDiv = null, this.openButtonIcon = "arrow_down", this.closeButtonIcon = "arrow_right", this.openCloseButton = fl(this.openButtonIcon, "ov_tree_item_icon"), ao(this.openCloseButton, this.nameElement)
			}
			AddChild(e) {
				this.CreateChildrenDiv(), this.children.push(e), e.SetParent(this), e.AddDomElements(this.childrenDiv)
			}
			ExpandAll(e) {
				for (let t of this.children) t instanceof eo && (t.ShowChildren(e), t.ExpandAll(e))
			}
			Show(e) {
				this.isVisible = e, this.childrenDiv !== null && (this.isVisible ? (At(this.mainElement, !0), this.childrenDiv.classList.add("ov_tree_view_children")) : (At(this.mainElement, !1), this.childrenDiv.classList.remove("ov_tree_view_children")))
			}
			ShowChildren(e) {
				this.isChildrenVisible = e, this.childrenDiv !== null && (e ? (Ur(this.openCloseButton, this.openButtonIcon), At(this.childrenDiv, !0)) : (Ur(this.openCloseButton, this.closeButtonIcon), At(this.childrenDiv, !1)))
			}
			CreateChildrenDiv() {
				return this.childrenDiv === null && (this.childrenDiv = ui("ov_tree_view_children"), tg(this.childrenDiv, this.mainElement), this.Show(this.isVisible), this.ShowChildren(this.isChildrenVisible), this.OnClick(e => {
					this.isChildrenVisible = !this.isChildrenVisible, this.ShowChildren(this.isChildrenVisible)
				})), this.childrenDiv
			}
		},
		jh = class extends eo {
			constructor(e, t) {
				super(e, t), this.buttonsDiv = ui("ov_tree_item_button_container"), ao(this.buttonsDiv, this.nameElement)
			}
			AppendButton(e) {
				this.buttonsDiv.appendChild(e.GetDomElement())
			}
		},
		qh = class {
			constructor(e) {
				this.mainDiv = _e(e, "ov_tree_view"), this.children = []
			}
			AddClass(e) {
				this.mainDiv.classList.add(e)
			}
			AddChild(e) {
				e.AddDomElements(this.mainDiv), this.children.push(e)
			}
			Clear() {
				li(this.mainDiv), this.children = []
			}
		};
	var el = class {
			constructor(e) {
				this.parentDiv = e, this.callbacks = null, this.popup = null, this.button = _e(this.parentDiv, "ov_panel_button"), this.buttonText = _e(this.button, "ov_panel_button_text"), Xn(this.button, "arrow_right", "ov_panel_button_icon"), this.button.addEventListener("click", () => {
					this.OnButtonClick()
				})
			}
			Init(e) {
				this.callbacks = e
			}
			OnButtonClick() {}
			Clear() {
				this.popup !== null && (this.popup.Close(), this.popup = null)
			}
		},
		to = class extends Ja {
			constructor(e) {
				super(e), this.callbacks = null, this.titleDiv = _e(this.panelDiv, "ov_navigator_tree_title"), this.treeDiv = _e(this.panelDiv, "ov_navigator_tree_panel ov_thin_scrollbar"), this.treeView = new qh(this.treeDiv);
				let t = this.GetName();
				this.titleDiv.innerHTML = t, this.titleDiv.setAttribute("title", t)
			}
			Clear() {
				this.treeView.Clear()
			}
			GetName() {
				return null
			}
			Init(e) {
				this.callbacks = e
			}
			Fill(e) {}
		};
	var Xh = class extends to {
		constructor(e) {
			super(e)
		}
		GetName() {
			return "Files"
		}
		GetIcon() {
			return "files"
		}
		Resize() {
			let e = Fr(this.titleDiv),
				t = this.parentDiv.offsetHeight;
			ci(this.treeDiv, t - e)
		}
		Clear() {
			super.Clear()
		}
		Fill(e) {
			super.Fill(e);
			let t = e.usedFiles,
				n = e.missingFiles;
			if (n.length > 0) {
				let i = new eo("Missing Files", null);
				i.ShowChildren(!0), this.treeView.AddChild(i);
				for (let o = 0; o < n.length; o++) {
					let a = n[o],
						c = new Qa(a),
						l = new us("open");
					l.OnClick(() => {
						this.callbacks.onFileBrowseButtonClicked()
					}), c.AppendButton(l), i.AddChild(c)
				}
				let s = new eo("Available Files", null);
				s.ShowChildren(!0), this.treeView.AddChild(s);
				for (let o = 0; o < t.length; o++) {
					let a = t[o],
						c = new Qs(a);
					s.AddChild(c)
				}
			} else
				for (let i = 0; i < t.length; i++) {
					let s = t[i],
						o = new Qs(s);
					this.treeView.AddChild(o)
				}
		}
	};
	var _i = {
			No: 0,
			Parents: 1,
			Children: 2,
			All: 3
		},
		Yh = class extends Qs {
			constructor(e, t, n) {
				super(e), this.OnClick(() => {
					n.onSelected(t)
				})
			}
		},
		Do = class extends Qa {
			constructor(e, t, n, i) {
				super(e, t), this.meshInstanceId = n, this.visible = !0, this.fitToWindowButton = new us("fit"), this.fitToWindowButton.OnClick(() => {
					i.onFitToWindow(this.meshInstanceId)
				}), this.AppendButton(this.fitToWindowButton), this.showHideButton = new us("visible"), this.showHideButton.OnClick(() => {
					i.onShowHide(this.meshInstanceId)
				}), this.AppendButton(this.showHideButton), this.OnClick(() => {
					i.onSelected(this.meshInstanceId)
				})
			}
			GetMeshInstanceId() {
				return this.meshInstanceId
			}
			IsVisible() {
				return this.visible
			}
			SetVisible(e, t) {
				if (this.visible !== e && (this.visible = e, this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"), t === _i.Parents && this.parent instanceof mr)) {
					let n = this.parent.CalculateIsVisible();
					this.parent.SetVisible(n, _i.Parents)
				}
			}
		},
		mr = class extends jh {
			constructor(e, t, n) {
				super(e, null), this.nodeId = t, this.callbacks = n, this.visible = !0, this.fitToWindowButton = new us("fit"), this.fitToWindowButton.OnClick(() => {
					this.callbacks.onFitToWindow(t)
				}), this.AppendButton(this.fitToWindowButton), this.showHideButton = new us("visible"), this.showHideButton.OnClick(() => {
					this.callbacks.onShowHide(t)
				}), this.AppendButton(this.showHideButton)
			}
			GetNodeId() {
				return this.nodeId
			}
			IsVisible() {
				return this.visible
			}
			CalculateIsVisible() {
				let e = !1;
				for (let t of this.children)
					if ((t instanceof mr || t instanceof Do) && t.IsVisible()) {
						e = !0;
						break
					} return e
			}
			SetVisible(e, t) {
				if (this.visible !== e) {
					if (this.visible = e, this.visible ? this.showHideButton.SetImage("visible") : this.showHideButton.SetImage("hidden"), Ia(this.callbacks.onVisibilityChanged) && this.callbacks.onVisibilityChanged(this.visible), t === _i.Children || t === _i.All)
						for (let n of this.children)(n instanceof mr || n instanceof Do) && n.SetVisible(this.visible, _i.Children);
					if ((t === _i.Parents || t === _i.All) && this.parent instanceof mr) {
						let n = this.parent.CalculateIsVisible();
						this.parent.SetVisible(n, _i.Parents)
					}
				}
			}
			EnumerateMeshItems(e) {
				for (let t of this.children) t instanceof mr ? t.EnumerateMeshItems(e) : t instanceof Do && e(t)
			}
		};
	var Im = class extends el {
			constructor(e) {
				super(e), this.meshInfoArray = null
			}
			Update(e) {
				if (this.meshInfoArray = e, this.meshInfoArray === null) return;
				let t = "Meshes (" + this.meshInfoArray.length + ")";
				this.buttonText.innerHTML = t
			}
			OnButtonClick() {
				if (this.meshInfoArray === null) return;
				let e = [];
				for (let t = 0; t < this.meshInfoArray.length; t++) {
					let n = this.meshInfoArray[t];
					e.push({
						name: Tc(n.name)
					})
				}
				e.length !== 0 && (this.popup = Za(e, {
					calculatePosition: t => zh(this.button, t),
					onHoverStart: t => {
						let n = this.meshInfoArray[t];
						this.callbacks.onMeshHover(n.meshId)
					},
					onHoverStop: t => {
						this.callbacks.onMeshHover(null)
					},
					onClick: t => {
						let n = this.meshInfoArray[t];
						this.callbacks.onMeshSelected(n.meshId)
					}
				}))
			}
		},
		Zh = class extends to {
			constructor(e) {
				super(e), this.callbacks = null, this.materialIndexToItem = new Map, this.popupDiv = _e(this.panelDiv, "ov_navigator_info_panel"), this.meshesButton = new Im(this.popupDiv)
			}
			GetName() {
				return "Materials"
			}
			GetIcon() {
				return "materials"
			}
			Resize() {
				let e = Fr(this.titleDiv),
					t = Fr(this.popupDiv),
					n = this.parentDiv.offsetHeight;
				ci(this.treeDiv, n - e - t)
			}
			Clear() {
				super.Clear(), this.meshesButton.Clear(), this.materialIndexToItem = new Map
			}
			Init(e) {
				super.Init(e), this.meshesButton.Init({
					onMeshHover: t => {
						this.callbacks.onMeshTemporarySelected(t)
					},
					onMeshSelected: t => {
						this.callbacks.onMeshSelected(t)
					}
				})
			}
			Fill(e) {
				super.Fill(e);
				let t = e.model;
				for (let n = 0; n < t.MaterialCount(); n++) {
					let i = t.GetMaterial(n),
						s = Sc(i.name),
						o = new Yh(s, n, {
							onSelected: a => {
								this.callbacks.onMaterialSelected(a)
							}
						});
					this.materialIndexToItem.set(n, o), this.treeView.AddChild(o)
				}
			}
			GetMaterialItem(e) {
				return this.materialIndexToItem.get(e)
			}
			SelectMaterialItem(e, t) {
				this.GetMaterialItem(e)
					.SetSelected(t)
			}
			UpdateMeshList(e) {
				this.meshesButton.Update(e)
			}
		};
	var ni = {
			Simple: 0,
			FlatList: 1,
			TreeView: 2
		},
		Rm = class extends el {
			constructor(e) {
				super(e), this.materialInfoArray = null
			}
			Update(e) {
				if (this.materialInfoArray = e, this.materialInfoArray === null) return;
				let t = "Materials (" + this.materialInfoArray.length + ")";
				this.buttonText.innerHTML = t
			}
			OnButtonClick() {
				if (this.materialInfoArray === null) return;
				let e = [];
				for (let t = 0; t < this.materialInfoArray.length; t++) {
					let n = this.materialInfoArray[t];
					e.push({
						name: Sc(n.name),
						color: n.color
					})
				}
				e.length !== 0 && (this.popup = Za(e, {
					calculatePosition: t => zh(this.button, t),
					onClick: t => {
						let n = this.materialInfoArray[t];
						this.callbacks.onMaterialSelected(n.index)
					}
				}))
			}
		},
		Kh = class extends to {
			constructor(e) {
				super(e), this.callbacks = null, this.nodeIdToItem = new Map, this.meshInstanceIdToItem = new Map, this.rootItem = null, this.mode = ni.Simple, this.buttons = null, this.treeView.AddClass("tight"), this.titleButtonsDiv = _e(this.titleDiv, "ov_navigator_tree_title_buttons"), this.buttonsDiv = ui("ov_navigator_buttons"), ao(this.buttonsDiv, this.treeDiv), this.popupDiv = _e(this.panelDiv, "ov_navigator_info_panel"), this.materialsButton = new Rm(this.popupDiv)
			}
			GetName() {
				return "Meshes"
			}
			GetIcon() {
				return "meshes"
			}
			Resize() {
				let e = Fr(this.titleDiv),
					t = 0;
				Mc(this.buttonsDiv) && (t = Fr(this.buttonsDiv));
				let n = Fr(this.popupDiv),
					i = this.parentDiv.offsetHeight;
				ci(this.treeDiv, i - e - t - n)
			}
			Clear() {
				this.ClearMeshTree(), li(this.titleButtonsDiv), li(this.buttonsDiv), this.buttons = null
			}
			ClearMeshTree() {
				super.Clear(), this.materialsButton.Clear(), this.nodeIdToItem = new Map, this.meshInstanceIdToItem = new Map, this.rootItem = null
			}
			Init(e) {
				super.Init(e), this.materialsButton.Init({
					onMeshHover: t => {
						this.callbacks.onMeshTemporarySelected(t)
					},
					onMeshSelected: t => {
						this.callbacks.onMeshSelected(t)
					},
					onMaterialSelected: t => {
						this.callbacks.onMaterialSelected(t)
					}
				})
			}
			Fill(e) {
				super.Fill(e);
				let t = e.model.GetRootNode(),
					n = !1;
				for (let i of t.GetChildNodes())
					if (i.GetType() === zn.GroupNode) {
						n = !0;
						break
					} this.mode === ni.Simple ? n && (this.mode = ni.FlatList) : (this.mode === ni.FlatList || this.mode === ni.TreeView) && (n || (this.mode = ni.Simple)), this.FillButtons(e), this.mode === ni.Simple ? (At(this.buttonsDiv, !1), this.titleDiv.classList.add("withbuttons"), this.titleDiv.classList.remove("nomargin")) : (At(this.buttonsDiv, !0), this.titleDiv.classList.remove("withbuttons"), this.titleDiv.classList.add("nomargin")), this.FillMeshTree(e.model), this.Resize()
			}
			FillButtons(e) {
				function t(s, o, a, c) {
					o.div = _e(s, "ov_navigator_button"), o.div.setAttribute("alt", o.name), o.div.setAttribute("title", o.name), a && o.div.classList.add(a), o.iconDiv = Xn(o.div, o.icon), o.div.addEventListener("click", () => {
						c()
					})
				}

				function n(s, o) {
					let a = o === ni.TreeView;
					a ? (s.flatList.iconDiv.classList.remove("selected"), s.treeView.iconDiv.classList.add("selected")) : (s.flatList.iconDiv.classList.add("selected"), s.treeView.iconDiv.classList.remove("selected")), At(s.separator, a), At(s.expandAll.div, a), At(s.collapseAll.div, a)
				}

				function i(s, o) {
					let a = [];
					s.EnumerateMeshItems(c => (c.IsVisible() || a.push(c.GetMeshInstanceId()), !0)), s.ClearMeshTree(), s.FillMeshTree(o.model);
					for (let c of a) s.GetMeshItem(c)
						.SetVisible(!1, _i.Parents);
					n(s.buttons, s.mode), s.callbacks.onViewTypeChanged()
				}
				this.buttons = {
					flatList: {
						name: "Flat list",
						icon: "flat_list",
						div: null,
						iconDiv: null
					},
					treeView: {
						name: "Tree view",
						icon: "tree_view",
						div: null,
						iconDiv: null
					},
					separator: null,
					expandAll: {
						name: "Expand all",
						icon: "expand",
						div: null,
						iconDiv: null
					},
					collapseAll: {
						name: "Collapse all",
						icon: "collapse",
						div: null,
						iconDiv: null
					},
					showHideMeshes: {
						name: "Show/hide meshes",
						icon: "visible",
						div: null,
						iconDiv: null
					},
					fitToWindow: {
						name: "Fit meshes to window",
						icon: "fit",
						div: null,
						iconDiv: null
					}
				}, this.mode === ni.Simple ? (t(this.titleButtonsDiv, this.buttons.showHideMeshes, "right", () => {
					let s = this.rootItem.GetNodeId();
					this.callbacks.onNodeShowHide(s)
				}), t(this.titleButtonsDiv, this.buttons.fitToWindow, "right", () => {
					let s = this.rootItem.GetNodeId();
					this.callbacks.onNodeFitToWindow(s)
				})) : (t(this.buttonsDiv, this.buttons.flatList, null, () => {
					this.mode !== ni.FlatList && (this.mode = ni.FlatList, i(this, e))
				}), t(this.buttonsDiv, this.buttons.treeView, null, () => {
					this.mode !== ni.TreeView && (this.mode = ni.TreeView, i(this, e))
				}), this.buttons.separator = _e(this.buttonsDiv, "ov_navigator_buttons_separator"), t(this.buttonsDiv, this.buttons.expandAll, null, () => {
					this.rootItem.ExpandAll(!0)
				}), t(this.buttonsDiv, this.buttons.collapseAll, null, () => {
					this.rootItem.ExpandAll(!1)
				}), t(this.buttonsDiv, this.buttons.showHideMeshes, "right", () => {
					let s = this.rootItem.GetNodeId();
					this.callbacks.onNodeShowHide(s)
				}), t(this.buttonsDiv, this.buttons.fitToWindow, "right", () => {
					let s = this.rootItem.GetNodeId();
					this.callbacks.onNodeFitToWindow(s)
				}), n(this.buttons, this.mode))
			}
			FillMeshTree(e) {
				function t(a, c, l, u, h, f) {
					let p = c.GetMesh(u),
						g = Tc(p.GetName()),
						m = new ts(l.GetId(), u),
						d = f === ni.TreeView ? "tree_mesh" : null,
						v = new Do(g, d, m, {
							onShowHide: x => {
								a.callbacks.onMeshShowHide(x)
							},
							onFitToWindow: x => {
								a.callbacks.onMeshFitToWindow(x)
							},
							onSelected: x => {
								a.callbacks.onMeshSelected(x)
							}
						});
					a.meshInstanceIdToItem.set(m.GetKey(), v), h.AddChild(v)
				}

				function n(a, c) {
					let l = ag(c.GetName()),
						u = c.GetId(),
						h = new mr(l, u, {
							onShowHide: f => {
								a.callbacks.onNodeShowHide(f)
							},
							onFitToWindow: f => {
								a.callbacks.onNodeFitToWindow(f)
							}
						});
					return a.nodeIdToItem.set(u, h), h
				}

				function i(a, c) {
					let l = c.GetId(),
						u = new mr(null, l, {
							onVisibilityChanged: h => {
								h ? Ur(a.buttons.showHideMeshes.iconDiv, "visible") : Ur(a.buttons.showHideMeshes.iconDiv, "hidden")
							}
						});
					return u.Show(!1), u.ShowChildren(!0), a.treeView.AddChild(u), a.nodeIdToItem.set(l, u), u
				}

				function s(a, c, l, u, h) {
					let f = [];
					for (let p of l.GetChildNodes())
						if (h === ni.TreeView)
							if (p.GetType() === zn.GroupNode) {
								let g = n(a, p);
								u.AddChild(g), s(a, c, p, g, h)
							} else p.GetType() === zn.MeshNode && f.push(p);
					else s(a, c, p, u, h);
					for (let p of f) s(a, c, p, u, h);
					for (let p of l.GetMeshIndices()) t(a, c, l, p, u, h)
				}
				let o = e.GetRootNode();
				this.rootItem = i(this, o), s(this, e, o, this.rootItem, this.mode)
			}
			UpdateMaterialList(e) {
				this.materialsButton.Update(e)
			}
			GetNodeItem(e) {
				return this.nodeIdToItem.get(e)
			}
			MeshItemCount() {
				return this.meshInstanceIdToItem.size
			}
			GetMeshItem(e) {
				return this.meshInstanceIdToItem.get(e.GetKey())
			}
			EnumerateNodeItems(e) {
				for (let t of this.nodeIdToItem.values())
					if (!e(t)) break
			}
			EnumerateMeshItems(e) {
				for (let t of this.meshInstanceIdToItem.values())
					if (!e(t)) break
			}
			IsMeshVisible(e) {
				return this.GetMeshItem(e)
					.IsVisible()
			}
			HasHiddenMesh() {
				let e = !1;
				return this.EnumerateMeshItems(t => t.IsVisible() ? !0 : (e = !0, !1)), e
			}
			ShowAllMeshes(e) {
				this.EnumerateNodeItems(t => (t.SetVisible(e, _i.No), !0)), this.EnumerateMeshItems(t => (t.SetVisible(e, _i.No), !0))
			}
			ToggleNodeVisibility(e) {
				let t = this.GetNodeItem(e);
				t.SetVisible(!t.IsVisible(), _i.All)
			}
			ToggleMeshVisibility(e) {
				let t = this.GetMeshItem(e);
				t.SetVisible(!t.IsVisible(), _i.Parents)
			}
			IsMeshIsolated(e) {
				let t = !0;
				return this.EnumerateMeshItems(n => !n.GetMeshInstanceId()
					.IsEqual(e) && n.IsVisible() ? (t = !1, !1) : !0), t
			}
			IsolateMesh(e) {
				this.ShowAllMeshes(!1), this.ToggleMeshVisibility(e)
			}
		};
	var Wn = {
			Material: 1,
			Mesh: 2
		},
		no = class {
			constructor(e, t) {
				this.type = e, this.materialIndex = null, this.meshInstanceId = null, this.type === Wn.Material ? this.materialIndex = t : this.type === Wn.Mesh && (this.meshInstanceId = t)
			}
			IsEqual(e) {
				if (this.type !== e.type) return !1;
				if (this.type === Wn.Material) return this.materialIndex === e.materialIndex;
				if (this.type === Wn.Mesh) return this.meshInstanceId.IsEqual(e.meshInstanceId)
			}
		},
		Jh = class {
			constructor(e, t) {
				this.mainDiv = e, this.splitterDiv = t, this.panelSet = new $a(e), this.callbacks = null, this.selection = null, this.tempSelectedMeshId = null, this.filesPanel = new Xh(this.panelSet.GetContentDiv()), this.materialsPanel = new Zh(this.panelSet.GetContentDiv()), this.meshesPanel = new Kh(this.panelSet.GetContentDiv()), this.panelSet.AddPanel(this.filesPanel), this.panelSet.AddPanel(this.materialsPanel), this.panelSet.AddPanel(this.meshesPanel), this.panelSet.ShowPanel(this.meshesPanel)
			}
			ShowPanels(e) {
				this.panelSet.ShowPanels(e)
			}
			Init(e) {
				this.callbacks = e, this.panelSet.Init({
					onResizeRequested: () => {
						At(this.splitterDiv, this.panelSet.IsPanelsVisible()), this.callbacks.onResizeRequested()
					},
					onShowHidePanels: t => {
						this.callbacks.onShowHidePanels(t)
					}
				}), this.filesPanel.Init({
					onFileBrowseButtonClicked: () => {
						this.callbacks.openFileBrowserDialog()
					}
				}), this.materialsPanel.Init({
					onMaterialSelected: t => {
						this.SetSelection(new no(Wn.Material, t))
					},
					onMeshTemporarySelected: t => {
						this.tempSelectedMeshId = t, this.callbacks.onMeshSelectionChanged()
					},
					onMeshSelected: t => {
						this.SetSelection(new no(Wn.Mesh, t))
					}
				}), this.meshesPanel.Init({
					onMeshSelected: t => {
						this.SetSelection(new no(Wn.Mesh, t))
					},
					onMeshShowHide: t => {
						this.ToggleMeshVisibility(t)
					},
					onMeshFitToWindow: t => {
						this.FitMeshToWindow(t)
					},
					onNodeShowHide: t => {
						this.ToggleNodeVisibility(t)
					},
					onNodeFitToWindow: t => {
						this.FitNodeToWindow(t)
					},
					onMaterialSelected: t => {
						this.SetSelection(new no(Wn.Material, t))
					},
					onViewTypeChanged: () => {
						this.SetSelection(null)
					}
				}), Ac(this.splitterDiv, this.mainDiv, !1, () => {
					this.callbacks.onResizeRequested()
				})
			}
			GetWidth() {
				let e = Go(this.mainDiv),
					t = 0;
				return this.panelSet.IsPanelsVisible() && (t = this.splitterDiv.offsetWidth), e + t
			}
			Resize(e) {
				gs(this.mainDiv, e), ci(this.splitterDiv, e), this.panelSet.Resize()
			}
			FillTree(e) {
				this.filesPanel.Fill(e), e.missingFiles.length === 0 ? this.panelSet.SetPanelIcon(this.filesPanel, "files") : this.panelSet.SetPanelIcon(this.filesPanel, "missing_files"), this.materialsPanel.Fill(e), this.meshesPanel.Fill(e), this.OnSelectionChanged()
			}
			MeshItemCount() {
				return this.meshesPanel.MeshItemCount()
			}
			IsMeshVisible(e) {
				return this.meshesPanel.IsMeshVisible(e)
			}
			HasHiddenMesh() {
				return this.meshesPanel.HasHiddenMesh()
			}
			ShowAllMeshes(e) {
				this.meshesPanel.ShowAllMeshes(e), this.callbacks.onMeshVisibilityChanged()
			}
			ToggleNodeVisibility(e) {
				this.meshesPanel.ToggleNodeVisibility(e), this.callbacks.onMeshVisibilityChanged()
			}
			ToggleMeshVisibility(e) {
				this.meshesPanel.ToggleMeshVisibility(e), this.callbacks.onMeshVisibilityChanged()
			}
			IsMeshIsolated(e) {
				return this.meshesPanel.IsMeshIsolated(e)
			}
			IsolateMesh(e) {
				this.meshesPanel.IsolateMesh(e), this.callbacks.onMeshVisibilityChanged()
			}
			GetSelectedMeshId() {
				return this.tempSelectedMeshId !== null ? this.tempSelectedMeshId : this.selection === null || this.selection.type !== Wn.Mesh ? null : this.selection.meshInstanceId
			}
			SetSelection(e) {
				function t(s, o, a) {
					o.type === Wn.Material ? (a && s.panelSet.IsPanelsVisible() && s.panelSet.ShowPanel(s.materialsPanel), s.materialsPanel.SelectMaterialItem(o.materialIndex, a)) : o.type === Wn.Mesh && (a && s.panelSet.IsPanelsVisible() && s.panelSet.ShowPanel(s.meshesPanel), s.meshesPanel.GetMeshItem(o.meshInstanceId)
						.SetSelected(a))
				}

				function n(s, o) {
					s.selection = o, s.OnSelectionChanged()
				}
				let i = this.selection;
				i !== null && t(this, i, !1), n(this, e), this.tempSelectedMeshId = null, this.selection !== null && (i !== null && i.IsEqual(this.selection) ? (t(this, this.selection, !1), n(this, null)) : t(this, this.selection, !0)), this.callbacks.onMeshSelectionChanged()
			}
			OnSelectionChanged() {
				this.selection === null ? this.callbacks.onSelectionCleared() : this.selection.type === Wn.Material ? this.callbacks.onMaterialSelected(this.selection.materialIndex) : this.selection.type === Wn.Mesh && this.callbacks.onMeshSelected(this.selection.meshInstanceId), this.UpdatePanels()
			}
			UpdatePanels() {
				let e = null,
					t = null;
				this.selection !== null && (this.selection.type === Wn.Material ? e = this.selection.materialIndex : this.selection.type === Wn.Mesh && (t = this.selection.meshInstanceId));
				let n = this.callbacks.getMeshesForMaterial(e);
				this.materialsPanel.UpdateMeshList(n);
				let i = this.callbacks.getMaterialsForMesh(t);
				this.meshesPanel.UpdateMaterialList(i)
			}
			FitNodeToWindow(e) {
				let t = new Set;
				this.meshesPanel.GetNodeItem(e)
					.EnumerateMeshItems(i => {
						t.add(i.GetMeshInstanceId())
					}), this.callbacks.fitMeshesToWindow(t)
			}
			FitMeshToWindow(e) {
				this.callbacks.fitMeshToWindow(e)
			}
			Clear() {
				this.panelSet.Clear(), this.selection = null
			}
		};

	function Lr(r, e) {
		let t = new Date,
			n = 365;
		t.setTime(t.getTime() + n * 24 * 60 * 60 * 1e3), document.cookie = r + "=" + e + "; expires=" + t.toUTCString() + ";"
	}

	function Nr(r, e) {
		let n = decodeURIComponent(document.cookie)
			.split(";");
		for (let i = 0; i < n.length; i++) {
			let s = n[i].trim();
			if (s.startsWith(r + "=")) return s.substring(r.length + 1)
		}
		return e
	}

	function Oo(r, e) {
		let t = Nr(r, null);
		return t === null ? e : t === "true"
	}

	function ko(r, e) {
		Lr(r, e ? "true" : "false")
	}

	function tl(r, e) {
		let t = Nr(r, null);
		return t === null ? e : parseInt(t, 10)
	}

	function nl(r, e) {
		Lr(r, e.toString())
	}

	function Pm(r, e) {
		let t = Nr(r, null);
		return t === null ? e : Tn.StringToRGBColor(t)
	}

	function iy(r, e) {
		let t = Nr(r, null);
		return t === null ? e : Tn.StringToRGBAColor(t)
	}

	function Lm(r, e) {
		Lr(r, Tn.RGBColorToString(e))
	}

	function ry(r, e) {
		Lr(r, Tn.RGBAColorToString(e))
	}
	var ii = {
			Light: 1,
			Dark: 2
		},
		il = class {
			constructor() {
				this.environmentMapName = "fishermans_bastion", this.backgroundIsEnvMap = !1, this.backgroundColor = new Qn(255, 255, 255, 255), this.defaultColor = new nt(200, 200, 200), this.showEdges = !1, this.edgeColor = new nt(0, 0, 0), this.edgeThreshold = 1, this.themeId = ii.Light
			}
			LoadFromCookies() {
				this.environmentMapName = Nr("ov_environment_map", "fishermans_bastion"), this.backgroundIsEnvMap = Oo("ov_background_is_envmap", !1), this.backgroundColor = iy("ov_background_color", new Qn(255, 255, 255, 255)), this.defaultColor = Pm("ov_default_color", new nt(200, 200, 200)), this.showEdges = Oo("ov_show_edges", !1), this.edgeColor = Pm("ov_edge_color", new nt(0, 0, 0)), this.edgeThreshold = tl("ov_edge_threshold", 1), this.themeId = tl("ov_theme_id", ii.Light)
			}
			SaveToCookies() {
				Lr("ov_environment_map", this.environmentMapName), ko("ov_background_is_envmap", this.backgroundIsEnvMap), ry("ov_background_color", this.backgroundColor), Lm("ov_default_color", this.defaultColor), ko("ov_show_edges", this.showEdges), Lm("ov_edge_color", this.edgeColor), nl("ov_edge_threshold", this.edgeThreshold), nl("ov_theme_id", this.themeId)
			}
		};

	function m1(r, e, t) {
		let n = Mi(r, e),
			i = Mi(e, t),
			s = Mi(r, t),
			o = (n + i + s) / 2,
			a = o * (o - n) * (o - i) * (o - s);
		return a < 0 ? 0 : Math.sqrt(a)
	}

	function g1(r, e, t) {
		return Pf(r, Br(e, t)) / 6
	}

	function Nm(r) {
		if (r instanceof js) {
			let e = 0;
			return r.EnumerateMeshInstances(t => {
				e += Nm(t)
			}), e
		} else {
			let e = 0;
			return r.EnumerateTriangleVertices((t, n, i) => {
				e += g1(t, n, i)
			}), e
		}
	}

	function sy(r) {
		let e = 0;
		return r.EnumerateTriangleVertices((t, n, i) => {
			e += m1(t, n, i)
		}), e
	}
	var rl = class extends Ja {
		constructor(e) {
			super(e), this.callbacks = null, this.titleDiv = null, this.HasTitle() && (this.titleDiv = _e(this.panelDiv, "ov_sidebar_title"), _e(this.titleDiv, "ov_sidebar_title_text", this.GetName()), this.titleDiv.setAttribute("title", this.GetName())), this.contentDiv = _e(this.panelDiv, "ov_sidebar_content ov_thin_scrollbar")
		}
		GetName() {
			return null
		}
		HasTitle() {
			return !0
		}
		Clear() {
			li(this.contentDiv)
		}
		Init(e) {
			this.callbacks = e
		}
	};
	var $h = class extends rl {
		constructor(e) {
			super(e)
		}
		GetName() {
			return "细节"
		}
		GetIcon() {
			return "details"
		}
		AddObject3DProperties(e) {
			this.Clear();
			let t = _e(this.contentDiv, "ov_property_table"),
				n = up(e),
				i = Un(n.max, n.min);
			if (this.AddProperty(t, new mt(ut.Integer, "Vertices", e.VertexCount())), this.AddProperty(t, new mt(ut.Integer, "Triangles", e.TriangleCount())), this.AddProperty(t, new mt(ut.Number, "Size X", i.x)), this.AddProperty(t, new mt(ut.Number, "Size Y", i.y)), this.AddProperty(t, new mt(ut.Number, "Size Z", i.z)), this.AddCalculatedProperty(t, "Volume", () => {
				if (!hp(e)) return null;
				let s = Nm(e);
				return new mt(ut.Number, null, s)
			}), this.AddCalculatedProperty(t, "Surface", () => {
				let s = sy(e);
				return new mt(ut.Number, null, s)
			}), e.PropertyGroupCount() > 0) {
				let s = _e(this.contentDiv, "ov_property_table ov_property_table_custom");
				for (let o = 0; o < e.PropertyGroupCount(); o++) {
					let a = e.GetPropertyGroup(o);
					this.AddPropertyGroup(s, a);
					for (let c = 0; c < a.PropertyCount(); c++) {
						let l = a.GetProperty(c);
						this.AddPropertyInGroup(s, l)
					}
				}
			}
			this.Resize()
		}
		AddMaterialProperties(e) {
			function t(s, o, a, c) {
				if (c === null || c.name === null) return;
				let l = Sn(c.name);
				s.AddProperty(o, new mt(ut.Text, a, l))
			}
			this.Clear();
			let n = _e(this.contentDiv, "ov_property_table"),
				i = null;
			e.type === on.Phong ? i = "Phong" : e.type === on.Physical && (i = "Physical"), this.AddProperty(n, new mt(ut.Text, "Source", e.isDefault ? "Default" : "Model")), this.AddProperty(n, new mt(ut.Text, "Type", i)), e.vertexColors ? this.AddProperty(n, new mt(ut.Text, "Color", "Vertex colors")) : (this.AddProperty(n, new mt(ut.Color, "Color", e.color)), e.type === on.Phong && (this.AddProperty(n, new mt(ut.Color, "Ambient", e.ambient)), this.AddProperty(n, new mt(ut.Color, "Specular", e.specular)))), e.type === on.Physical && (this.AddProperty(n, new mt(ut.Percent, "Metalness", e.metalness)), this.AddProperty(n, new mt(ut.Percent, "Roughness", e.roughness))), this.AddProperty(n, new mt(ut.Percent, "Opacity", e.opacity)), t(this, n, "Diffuse Map", e.diffuseMap), t(this, n, "Bump Map", e.bumpMap), t(this, n, "Normal Map", e.normalMap), t(this, n, "Emissive Map", e.emissiveMap), e.type === on.Phong ? t(this, n, "Specular Map", e.specularMap) : e.type === on.Physical && t(this, n, "Metallic Map", e.metalnessMap), this.Resize()
		}
		AddPropertyGroup(e, t) {
			_e(e, "ov_property_table_row group", t.name)
				.setAttribute("title", t.name)
		}
		AddProperty(e, t) {
			let n = _e(e, "ov_property_table_row"),
				i = _e(n, "ov_property_table_cell ov_property_table_name", t.name + ":"),
				s = _e(n, "ov_property_table_cell ov_property_table_value");
			return i.setAttribute("title", t.name), this.DisplayPropertyValue(t, s), n
		}
		AddPropertyInGroup(e, t) {
			this.AddProperty(e, t)
				.classList.add("ingroup")
		}
		AddCalculatedProperty(e, t, n) {
			let i = _e(e, "ov_property_table_row"),
				s = _e(i, "ov_property_table_cell ov_property_table_name", t + ":"),
				o = _e(i, "ov_property_table_cell ov_property_table_value");
			s.setAttribute("title", t), _e(o, "ov_property_table_button", "Calculate...")
				.addEventListener("click", () => {
					li(o), o.innerHTML = "Please wait...", Ao(() => {
						let c = n();
						c === null ? o.innerHTML = "-" : this.DisplayPropertyValue(c, o)
					})
				})
		}
		DisplayPropertyValue(e, t) {
			li(t);
			let n = null,
				i = null;
			if (e.type === ut.Text) Ev(e.value) ? (n = '<a target="_blank" href="' + e.value + '">' + e.value + "</a>", i = e.value) : n = Hl(e);
			else if (e.type === ut.Color) {
				let s = "#" + Pi(e.value),
					o = Cc(e.value);
				t.appendChild(o), Zt(t, "span", null, s)
			} else n = Hl(e);
			n !== null && (t.innerHTML = n, t.setAttribute("title", i !== null ? i : n))
		}
	};

	function Dm(r, e, t, n, i) {
		let s = Pickr.create({
			el: r,
			theme: "monolith",
			position: "left-start",
			swatches: n,
			comparison: !1,
			default: t,
			components: {
				preview: !1,
				opacity: e,
				hue: !0,
				interaction: {
					hex: !1,
					rgba: !1,
					hsla: !1,
					hsva: !1,
					cmyk: !1,
					input: !0,
					clear: !1,
					save: !1
				}
			}
		});
		return s.on("change", (o, a, c) => {
			let l = o.toRGBA();
			i(parseInt(l[0], 10), parseInt(l[1], 10), parseInt(l[2], 10), Cn(l[3]))
		}), s
	}
	var Qh = class extends uc {
			constructor() {
				super()
			}
			ShowPopup(e, t, n, i) {
				let s = super.Init(() => ey(e, s)),
					o = [{
						element: null,
						name: "fishermans_bastion"
					}, {
						element: null,
						name: "citadella"
					}, {
						element: null,
						name: "maskonaive"
					}, {
						element: null,
						name: "teide"
					}, {
						element: null,
						name: "ice_river"
					}, {
						element: null,
						name: "park"
					}];
				if (t === wn.Phong) {
					o.unshift({
						element: null,
						name: "noimage"
					});
					for (let a of o) {
						a.element = Zt(s, "img", "ov_environment_map_preview"), a.element.setAttribute("src", "assets/envmaps/" + a.name + ".jpg");
						let c = !1;
						n.backgroundIsEnvMap ? c = a.name === n.environmentMapName : c = a.name === "noimage", c && a.element.classList.add("selected"), a.element.addEventListener("click", () => {
							for (let l of o) l.element.classList.remove("selected");
							a.element.classList.add("selected"), a.name === "noimage" ? (n.backgroundIsEnvMap = !1, n.environmentMapName = "fishermans_bastion") : (n.backgroundIsEnvMap = !0, n.environmentMapName = a.name), i.onEnvironmentMapChanged()
						})
					}
				} else if (t === wn.Physical) {
					if (i.getCameraMode() === Nn.Perspective) {
						let c = _e(s, "ov_environment_map_checkbox"),
							l = Ic(c, "use_as_background", "Use as background image", n.backgroundIsEnvMap, () => {
								n.backgroundIsEnvMap = l.checked, i.onEnvironmentMapChanged()
							})
					}
					for (let c of o) c.element = Zt(s, "img", "ov_environment_map_preview"), c.element.setAttribute("src", "assets/envmaps/" + c.name + ".jpg"), c.name === n.environmentMapName && c.element.classList.add("selected"), c.element.addEventListener("click", () => {
						for (let l of o) l.element.classList.remove("selected");
						c.element.classList.add("selected"), n.environmentMapName = c.name, i.onEnvironmentMapChanged()
					})
				}
				s.classList.add("sidebar"), this.Open()
			}
			Update() {}
		},
		hc = class {
			constructor(e, t, n) {
				this.parentDiv = e, this.contentDiv = _e(this.parentDiv, "ov_sidebar_settings_section"), _e(this.contentDiv, "ov_sidebar_title", t), this.settings = n, this.callbacks = null
			}
			Init(e) {
				this.callbacks = e
			}
			Update() {}
			UpdateVisibility() {}
			Clear() {}
		},
		Om = class extends hc {
			constructor(e, t) {
				super(e, "Model Display", t), this.backgroundColorPicker = null, this.environmentMapPhongDiv = null, this.environmentMapPhongInput = null, this.environmentMapPbrDiv = null, this.environmentMapPbrInput = null, this.environmentMapPopup = null, this.edgeDisplayToggle = null, this.edgeColorPicker = null, this.thresholdSlider = null, this.thresholdSliderValue = null, this.edgeSettingsDiv = null
			}
			Init(e) {
				super.Init(e);
				let t = _e(this.contentDiv, "ov_sidebar_parameter"),
					n = _e(t, "ov_color_picker");
				_e(t, null, "Background Color");
				let i = ["#ffffffff", "#e3e3e3ff", "#c9c9c9ff", "#898989ff", "#5f5f5fff", "#494949ff", "#383838ff", "#0f0f0fff"],
					s = "#" + Sf(this.settings.backgroundColor);
				this.backgroundColorPicker = Dm(n, !0, s, i, (f, p, g, m) => {
					this.settings.backgroundColor = new Qn(f, p, g, m), this.callbacks.onBackgroundColorChanged()
				}), this.environmentMapPhongDiv = _e(this.contentDiv, "ov_sidebar_parameter"), this.environmentMapPhongInput = _e(this.environmentMapPhongDiv, "ov_sidebar_image_picker"), _e(this.environmentMapPhongDiv, null, "Background Image"), this.environmentMapPhongInput.addEventListener("click", () => {
					this.environmentMapPopup = new Qh, this.environmentMapPopup.ShowPopup(this.environmentMapPhongInput, wn.Phong, this.settings, {
						getCameraMode: () => this.callbacks.getCameraMode(),
						onEnvironmentMapChanged: () => {
							this.UpdateEnvironmentMap(), this.callbacks.onEnvironmentMapChanged()
						}
					})
				}), this.environmentMapPbrDiv = _e(this.contentDiv, "ov_sidebar_parameter"), this.environmentMapPbrInput = _e(this.environmentMapPbrDiv, "ov_sidebar_image_picker"), _e(this.environmentMapPbrDiv, null, "Environment"), this.environmentMapPbrInput.addEventListener("click", () => {
					this.environmentMapPopup = new Qh, this.environmentMapPopup.ShowPopup(this.environmentMapPbrInput, wn.Physical, this.settings, {
						getCameraMode: () => this.callbacks.getCameraMode(),
						onEnvironmentMapChanged: () => {
							this.UpdateEnvironmentMap(), this.callbacks.onEnvironmentMapChanged()
						}
					})
				}), this.UpdateEnvironmentMap();
				let o = _e(this.contentDiv, "ov_sidebar_parameter");
				this.edgeDisplayToggle = Rf(o, "ov_sidebar_parameter_toggle"), _e(o, "ov_sidebar_parameter_text", "Show Edges"), this.edgeSettingsDiv = _e(this.contentDiv, "ov_sidebar_settings_padded"), this.edgeDisplayToggle.OnChange(() => {
					At(this.edgeSettingsDiv, this.edgeDisplayToggle.GetStatus()), this.settings.showEdges = this.edgeDisplayToggle.GetStatus(), this.callbacks.onShowEdgesChange()
				});
				let a = _e(this.edgeSettingsDiv, "ov_sidebar_settings_row"),
					c = ["#ffffff", "#e3e3e3", "#c9c9c9", "#898989", "#5f5f5f", "#494949", "#383838", "#0f0f0f"],
					l = _e(a, "ov_color_picker"),
					u = "#" + Pi(this.settings.edgeColor);
				this.edgeColorPicker = Dm(l, !1, u, c, (f, p, g, m) => {
					this.settings.edgeColor = new nt(f, p, g), this.callbacks.onEdgeColorChange()
				}), _e(a, null, "Edge Color");
				let h = _e(this.edgeSettingsDiv, "ov_sidebar_settings_row large");
				this.thresholdSlider = mg(h, 0, 90), this.thresholdSlider.setAttribute("title", "Edge Angle Threshold"), this.thresholdSliderValue = Zt(h, "span", "ov_slider_label"), this.thresholdSlider.addEventListener("input", () => {
					this.thresholdSliderValue.innerHTML = this.thresholdSlider.value
				}), this.thresholdSlider.addEventListener("change", () => {
					this.settings.edgeThreshold = this.thresholdSlider.value, this.callbacks.onEdgeThresholdChange()
				}), this.thresholdSlider.value = this.settings.edgeThreshold, this.thresholdSliderValue.innerHTML = this.settings.edgeThreshold, this.edgeDisplayToggle.SetStatus(this.settings.showEdges), At(this.edgeSettingsDiv, this.settings.showEdges)
			}
			UpdateEnvironmentMap() {
				function e(t, n) {
					t.style.backgroundImage = "url('assets/envmaps/" + n + ".jpg')"
				}
				this.environmentMapPhongDiv !== null && (this.settings.backgroundIsEnvMap ? (e(this.environmentMapPhongInput, this.settings.environmentMapName), this.environmentMapPhongInput.classList.remove("ov_environment_map_preview_no_color")) : (this.environmentMapPhongInput.style.backgroundImage = null, this.environmentMapPhongInput.classList.add("ov_environment_map_preview_no_color"))), this.environmentMapPbrDiv !== null && e(this.environmentMapPbrInput, this.settings.environmentMapName)
			}
			Update() {
				this.backgroundColorPicker !== null && this.backgroundColorPicker.setColor("#" + Sf(this.settings.backgroundColor)), (this.environmentMapPbrInput !== null || this.environmentMapPhongDiv !== null) && this.UpdateEnvironmentMap(), this.edgeDisplayToggle !== null && (this.edgeDisplayToggle.SetStatus(this.settings.showEdges), At(this.edgeSettingsDiv, this.settings.showEdges), this.edgeColorPicker.setColor("#" + Pi(this.settings.edgeColor)), this.thresholdSlider.value = this.settings.edgeThreshold, this.thresholdSliderValue.innerHTML = this.settings.edgeThreshold)
			}
			UpdateVisibility() {
				let e = this.callbacks.getShadingType() === wn.Physical;
				if (this.environmentMapPhongDiv !== null) {
					let t = this.callbacks.getCameraMode() === Nn.Perspective;
					At(this.environmentMapPhongDiv, !e && t)
				}
				this.environmentMapPbrDiv !== null && At(this.environmentMapPbrDiv, e)
			}
			Clear() {
				this.environmentMapPopup !== null && (this.environmentMapPopup.Close(), this.environmentMapPopup = null), this.backgroundColorPicker !== null && this.backgroundColorPicker.hide(), this.edgeColorPicker !== null && this.edgeColorPicker.hide()
			}
		},
		km = class extends hc {
			constructor(e, t) {
				super(e, "Import Settings", t), this.defaultColorPicker = null
			}
			Init(e) {
				super.Init(e);
				let t = _e(this.contentDiv, "ov_sidebar_parameter"),
					n = _e(t, "ov_color_picker");
				_e(t, null, "Default Color");
				let i = ["#ffffff", "#e3e3e3", "#cc3333", "#fac832", "#4caf50", "#3393bd", "#9b27b0", "#fda4b8"],
					s = "#" + Pi(this.settings.defaultColor);
				this.defaultColorPicker = Dm(n, !1, s, i, (o, a, c, l) => {
					this.settings.defaultColor = new nt(o, a, c), this.callbacks.onDefaultColorChanged()
				})
			}
			Update() {
				this.defaultColorPicker !== null && this.defaultColorPicker.setColor("#" + Pi(this.settings.defaultColor))
			}
			UpdateVisibility() {
				if (this.contentDiv !== null) {
					let e = this.callbacks.hasDefaultMaterial();
					At(this.contentDiv, e)
				}
			}
			Clear() {
				this.defaultColorPicker !== null && this.defaultColorPicker.hide()
			}
		},
		Fm = class extends hc {
			constructor(e, t) {
				super(e, "Appearance", t), this.darkModeToggle = null
			}
			Init(e) {
				super.Init(e);
				let t = _e(this.contentDiv, "ov_sidebar_parameter");
				this.darkModeToggle = Rf(t, "ov_sidebar_parameter_toggle"), this.darkModeToggle.OnChange(() => {
					this.settings.themeId = this.darkModeToggle.GetStatus() ? ii.Dark : ii.Light, this.callbacks.onThemeChanged()
				}), _e(t, null, "Dark Mode");
				let n = this.settings.themeId === ii.Dark;
				this.darkModeToggle.SetStatus(n)
			}
			Update() {
				if (this.darkModeToggle !== null) {
					let e = this.settings.themeId === ii.Dark;
					this.darkModeToggle.SetStatus(e)
				}
			}
			UpdateVisibility() {}
		},
		ef = class extends rl {
			constructor(e, t) {
				super(e), this.settings = t, this.sectionsDiv = _e(this.contentDiv, "ov_sidebar_settings_sections ov_thin_scrollbar"), this.modelDisplaySection = new Om(this.sectionsDiv, this.settings), this.importParametersSection = new km(this.sectionsDiv, this.settings), this.appearanceSection = new Fm(this.sectionsDiv, this.settings), this.resetToDefaultsButton = _e(this.contentDiv, "ov_button ov_panel_button outline", "Reset to Default"), this.resetToDefaultsButton.addEventListener("click", () => {
					this.ResetToDefaults()
				})
			}
			GetName() {
				return "Settings"
			}
			HasTitle() {
				return !1
			}
			GetIcon() {
				return "settings"
			}
			Clear() {
				this.modelDisplaySection.Clear(), this.importParametersSection.Clear(), this.appearanceSection.Clear()
			}
			Init(e) {
				super.Init(e), this.modelDisplaySection.Init({
					getShadingType: () => this.callbacks.getShadingType(),
					getCameraMode: () => this.callbacks.getCameraMode(),
					onEnvironmentMapChanged: () => {
						this.callbacks.onEnvironmentMapChanged()
					},
					onBackgroundColorChanged: () => {
						this.callbacks.onBackgroundColorChanged()
					},
					onShowEdgesChange: () => {
						this.callbacks.onEdgeDisplayChanged()
					},
					onEdgeColorChange: () => {
						this.callbacks.onEdgeDisplayChanged()
					},
					onEdgeThresholdChange: () => {
						this.callbacks.onEdgeDisplayChanged()
					}
				}), this.importParametersSection.Init({
					hasDefaultMaterial: () => this.callbacks.hasDefaultMaterial(),
					onDefaultColorChanged: () => {
						this.callbacks.onDefaultColorChanged()
					}
				}), this.appearanceSection.Init({
					onThemeChanged: () => {
						this.settings.themeId === ii.Light ? (this.settings.backgroundColor = new Qn(255, 255, 255, 255), this.settings.defaultColor = new nt(200, 200, 200)) : this.settings.themeId === ii.Dark && (this.settings.backgroundColor = new Qn(42, 43, 46, 255), this.settings.defaultColor = new nt(200, 200, 200)), this.modelDisplaySection.Update(), this.importParametersSection.Update(), e.onThemeChanged()
					}
				})
			}
			UpdateControlsVisibility() {
				this.modelDisplaySection.UpdateVisibility(), this.importParametersSection.UpdateVisibility(), this.Resize()
			}
			ResetToDefaults() {
				let e = new il;
				this.settings.environmentMapName = e.environmentMapName, this.settings.backgroundIsEnvMap = e.backgroundIsEnvMap, this.settings.backgroundColor = e.backgroundColor, this.settings.defaultColor = e.defaultColor, this.settings.showEdges = e.showEdges, this.settings.edgeColor = e.edgeColor, this.settings.edgeThreshold = e.edgeThreshold, this.settings.themeId = e.themeId, this.modelDisplaySection.Update(), this.importParametersSection.Update(), this.appearanceSection.Update(), this.callbacks.onEnvironmentMapChanged(), this.callbacks.onThemeChanged()
			}
			Resize() {
				let e = this.resetToDefaultsButton.offsetHeight,
					t = this.parentDiv.offsetHeight;
				gs(this.sectionsDiv, t - e)
			}
		};
	var tf = class {
		constructor(e, t, n) {
			this.mainDiv = e, this.splitterDiv = t, this.panelSet = new $a(e), this.detailsPanel = new $h(this.panelSet.GetContentDiv()), this.settingsPanel = new ef(this.panelSet.GetContentDiv(), n), this.panelSet.AddPanel(this.detailsPanel), this.panelSet.AddPanel(this.settingsPanel), this.panelSet.ShowPanel(this.detailsPanel)
		}
		IsPanelsle() {
			return this.panelSet.IsPanelsVisible()
		}
		ShowPanels(e) {
			this.panelSet.ShowPanels(e)
		}
		Init(e) {
			this.callbacks = e, this.panelSet.Init({
				onResizeRequested: () => {
					At(this.splitterDiv, this.panelSet.IsPanelsVisible()), this.callbacks.onResizeRequested()
				},
				onShowHidePanels: t => {
					this.callbacks.onShowHidePanels(t)
				}
			}), this.settingsPanel.Init({
				getShadingType: () => this.callbacks.getShadingType(),
				getCameraMode: () => this.callbacks.getCameraMode(),
				hasDefaultMaterial: () => this.callbacks.hasDefaultMaterial(),
				onEnvironmentMapChanged: () => {
					this.callbacks.onEnvironmentMapChanged()
				},
				onBackgroundColorChanged: () => {
					this.callbacks.onBackgroundColorChanged()
				},
				onDefaultColorChanged: () => {
					this.callbacks.onDefaultColorChanged()
				},
				onEdgeDisplayChanged: () => {
					this.callbacks.onEdgeDisplayChanged()
				},
				onThemeChanged: () => {
					this.callbacks.onThemeChanged()
				}
			}), Ac(this.splitterDiv, this.mainDiv, !0, () => {
				this.callbacks.onResizeRequested()
			})
		}
		UpdateControlsVisibility() {
			this.settingsPanel.UpdateControlsVisibility()
		}
		Resize(e) {
			gs(this.mainDiv, e), ci(this.splitterDiv, e), this.panelSet.Resize()
		}
		GetWidth() {
			let e = Go(this.mainDiv),
				t = 0;
			return this.panelSet.IsPanelsVisible() && (t = this.splitterDiv.offsetWidth), e + t
		}
		DecreaseWidth(e) {
			let t = this.mainDiv.offsetWidth;
			Bo(this.mainDiv, t - e)
		}
		Clear() {
			this.panelSet.Clear()
		}
		AddObject3DProperties(e) {
			this.detailsPanel.AddObject3DProperties(e)
		}
		AddMaterialProperties(e) {
			this.detailsPanel.AddMaterialProperties(e)
		}
	};
	var nf = class {
		constructor() {
			this.css = {
				"--ov_foreground_color": {},
				"--ov_background_color": {},
				"--ov_disabled_foreground_color": {},
				"--ov_button_color": {},
				"--ov_button_hover_color": {},
				"--ov_button_text_color": {},
				"--ov_outline_button_color": {},
				"--ov_outline_button_hover_color": {},
				"--ov_outline_button_text_color": {},
				"--ov_icon_color": {},
				"--ov_light_icon_color": {},
				"--ov_selected_icon_color": {},
				"--ov_disabled_icon_color": {},
				"--ov_hover_color": {},
				"--ov_hover_text_color": {},
				"--ov_logo_text_color": {},
				"--ov_logo_border_color": {},
				"--ov_toolbar_background_color": {},
				"--ov_toolbar_selected_color": {},
				"--ov_toolbar_separator_color": {},
				"--ov_treeview_selected_color": {},
				"--ov_dialog_foreground_color": {},
				"--ov_dialog_background_color": {},
				"--ov_border_color": {},
				"--ov_shadow": {}
			};
			let e = document.querySelector(":root"),
				t = window.getComputedStyle(e);
			for (let n in this.css) Object.prototype.hasOwnProperty.call(this.css, n) && (this.css[n].light = t.getPropertyValue(n), this.css[n].dark = t.getPropertyValue(n + "_dark"))
		}
		SwitchTheme(e) {
			let t = null;
			if (e === ii.Light) t = "light";
			else if (e === ii.Dark) t = "dark";
			else return;
			let n = document.querySelector(":root");
			for (let i in this.css)
				if (Object.prototype.hasOwnProperty.call(this.css, i)) {
					let s = this.css[i][t];
					s !== void 0 && n.style.setProperty(i, s)
				}
		}
	};
	var rf = class {
			constructor(e, t, n) {
				this.image = e, this.imageTitle = t, this.selected = !1, this.buttonDiv = ui("ov_toolbar_button"), this.buttonImg = Xn(this.buttonDiv, this.image), n !== null && this.buttonDiv.addEventListener("click", n), this.buttonDiv.setAttribute("alt", this.imageTitle), Ec(this.buttonDiv, this.imageTitle)
			}
			AddDomElements(e) {
				e.appendChild(this.buttonDiv)
			}
			AddClass(e) {
				this.buttonDiv.classList.add(e)
			}
			RemoveClass(e) {
				this.buttonDiv.classList.remove(e)
			}
			AddImageClass(e) {
				this.buttonImg.classList.add(e)
			}
			RemoveImageClass(e) {
				this.buttonImg.classList.remove(e)
			}
			IsSelected() {
				return this.selected
			}
			SetSelected(e) {
				this.selected = e, this.selected ? this.buttonDiv.classList.add("selected") : this.buttonDiv.classList.remove("selected")
			}
		},
		sf = class {
			constructor(e) {
				this.mainDiv = _e(e, "ov_toolbar")
			}
			AddImageButton(e, t, n) {
				let i = new rf(e, t, n);
				return i.AddDomElements(this.mainDiv), i
			}
			AddImagePushButton(e, t, n, i) {
				let s = new rf(e, t, () => {
					s.SetSelected(!s.IsSelected()), i(s.IsSelected())
				});
				return s.AddDomElements(this.mainDiv), s.SetSelected(n), s
			}
			AddImageRadioButton(e, t, n) {
				let i = [];
				for (let s = 0; s < e.length; s++) {
					let o = e[s],
						a = this.AddImageButton(o.image, o.title, () => {
							for (let c = 0; c < i.length; c++) {
								let l = i[c];
								c === s ? l.SetSelected(!0) : l.SetSelected(!1)
							}
							n(s)
						});
					t === s && a.SetSelected(!0), i.push(a)
				}
				return i
			}
			AddSeparator() {
				return _e(this.mainDiv, "ov_toolbar_separator")
			}
		};
	var Um = class {
			constructor() {
				this.indices = [], this.vertices = [], this.colors = [], this.normals = [], this.uvs = [], this.material = null
			}
			GetBounds() {
				let e = [1 / 0, 1 / 0, 1 / 0],
					t = [-1 / 0, -1 / 0, -1 / 0];
				for (let n = 0; n < this.vertices.length / 3; n++)
					for (let i = 0; i < 3; i++) e[i] = Math.min(e[i], this.vertices[n * 3 + i]), t[i] = Math.max(t[i], this.vertices[n * 3 + i]);
				return {
					min: e,
					max: t
				}
			}
			GetByteLength(e, t) {
				let n = this.indices.length,
					i = this.vertices.length + this.colors.length + this.normals.length + this.uvs.length;
				return n * e + i * t
			}
		},
		Bm = class {
			constructor() {
				this.primitives = []
			}
			PrimitiveCount() {
				return this.primitives.length
			}
			GetPrimitive(e) {
				return this.primitives[e]
			}
			GetByteLength(e, t) {
				let n = 0;
				for (let i = 0; i < this.primitives.length; i++) n += this.primitives[i].GetByteLength(e, t);
				return n
			}
		};

	function of (r) {
		function e(a, c, l, u) {
			function h(m, d, v) {
				return d !== null ? m.GetVertexColor(d) : v ? new nt(0, 0, 0) : null
			}

			function f(m, d, v) {
				return d !== null ? m.GetTextureUV(d) : v ? new Rt(0, 0) : null
			}

			function p(m, d, v) {
				let x = m.VertexColorCount() > 0,
					_ = m.TextureUVCount() > 0,
					y = m.GetVertex(d.vertex),
					w = m.GetNormal(d.normal),
					C = v.vertices.length / 3;
				v.indices.push(C), v.vertices.push(y.x, y.y, y.z);
				let S = h(m, d.color, x);
				S !== null && v.colors.push(S.r / 255, S.g / 255, S.b / 255), v.normals.push(w.x, w.y, w.z);
				let b = f(m, d.uv, _);
				return b !== null && v.uvs.push(b.x, b.y), {
					index: C,
					color: S,
					normal: w,
					uv: b
				}
			}

			function g(m, d, v) {
				function x(w, C, S) {
					if (S === null && C === null) return !0;
					let b = h(w, C, !0);
					return co(S, b)
				}

				function _(w, C, S) {
					let b = w.GetNormal(C);
					return Ji(S, b)
				}

				function y(w, C, S) {
					if (S === null && C === null) return !0;
					let b = f(w, C, !0);
					return so(S, b)
				}
				for (let w = 0; w < d.length; w++) {
					let C = d[w],
						S = x(m, v.color, C.color),
						b = _(m, v.normal, C.normal),
						T = y(m, v.uv, C.uv);
					if (S && b && T) return C
				}
				return null
			}
			if (u.has(c.vertex)) {
				let m = u.get(c.vertex),
					d = g(a, m, c);
				if (d !== null) l.indices.push(d.index);
				else {
					let v = p(a, c, l);
					m.push(v)
				}
			} else {
				let m = p(a, c, l);
				u.set(c.vertex, [m])
			}
		}
		let t = new Bm,
			n = r.TriangleCount();
		if (n === 0) return null;
		let i = [];
		for (let a = 0; a < n; a++) i.push(a);
		i.sort((a, c) => {
			let l = r.GetTriangle(a),
				u = r.GetTriangle(c);
			return l.mat - u.mat
		});
		let s = null,
			o = null;
		for (let a = 0; a < i.length; a++) {
			let c = i[a],
				l = r.GetTriangle(c);
			(s === null || s.material !== l.mat) && (s = new Um, s.material = l.mat, o = new Map, t.primitives.push(s));
			let u = {
					vertex: l.v0,
					color: l.c0,
					normal: l.n0,
					uv: l.u0
				},
				h = {
					vertex: l.v1,
					color: l.c1,
					normal: l.n1,
					uv: l.u1
				},
				f = {
					vertex: l.v2,
					color: l.c2,
					normal: l.n2,
					uv: l.u2
				};
			e(r, u, s, o), e(r, h, s, o), e(r, f, s, o)
		}
		return t
	}
	var sn = class {
			constructor(e) {
				this.name = e, this.content = null
			}
			GetName() {
				return this.name
			}
			SetName(e) {
				this.name = e
			}
			GetTextContent() {
				return fn(this.content)
			}
			GetBufferContent() {
				return this.content
			}
			SetTextContent(e) {
				let t = wc(e);
				this.content = t
			}
			SetBufferContent(e) {
				this.content = e
			}
		},
		$n = class {
			constructor() {}
			CanExport(e, t) {
				return !1
			}
			Export(e, t, n) {
				let i = [];
				this.ExportContent(e, t, i, () => {
					n(i)
				})
			}
			ExportContent(e, t, n, i) {}
			GetExportedMaterialName(e) {
				return this.GetExportedName(e, "Material")
			}
			GetExportedMeshName(e) {
				return this.GetExportedName(e, "Mesh")
			}
			GetExportedName(e, t) {
				return e.length === 0 ? t : e
			}
		};
	var af = class extends $n {
		constructor() {
			super(), this.rhino = null
		}
		CanExport(e, t) {
			return e === Dt.Binary && t === "3dm"
		}
		ExportContent(e, t, n, i) {
			this.rhino === null ? ds("loaders/rhino3dm.min.js")
				.then(() => {
					rhino3dm()
						.then(s => {
							this.rhino = s, this.ExportRhinoContent(e, n, i)
						})
				})
				.catch(() => {
					i()
				}) : this.ExportRhinoContent(e, n, i)
		}
		ExportRhinoContent(e, t, n) {
			function i(l) {
				return {
					r: l.r,
					g: l.g,
					b: l.b,
					a: 255
				}
			}
			let s = new sn("model.3dm");
			t.push(s);
			let o = new this.rhino.File3dm;
			e.EnumerateTransformedMeshes(l => {
				let u = of (l);
				for (let h = 0; h < u.PrimitiveCount(); h++) {
					let f = u.GetPrimitive(h),
						p = {
							data: {
								attributes: {
									position: {
										itemSize: 3,
										type: "Float32Array",
										array: f.vertices
									},
									normal: {
										itemSize: 3,
										type: "Float32Array",
										array: f.normals
									}
								},
								index: {
									type: "Uint16Array",
									array: f.indices
								}
							}
						},
						g = e.GetMaterial(f.material),
						m = new this.rhino.Material;
					m.name = this.GetExportedMaterialName(g.name), g.type === on.Phong && (m.ambientColor = i(g.ambient), m.specularColor = i(g.specular)), m.diffuseColor = i(g.color), m.transparency = 1 - g.opacity;
					let d = o.materials()
						.count();
					o.materials()
						.add(m);
					let v = new this.rhino.Mesh.createFromThreejsJSON(p),
						x = new this.rhino.ObjectAttributes;
					x.name = this.GetExportedMeshName(l.GetName()), x.materialSource = this.rhino.ObjectMaterialSource.MaterialFromObject, x.materialIndex = d, o.objects()
						.add(v, x)
				}
			});
			let a = new this.rhino.File3dmWriteOptions;
			a.version = 6;
			let c = o.toByteArray(a);
			s.SetBufferContent(c), n()
		}
	};

	function v1() {
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, e => {
			let t = Math.random() * 16 | 0;
			return (e === "x" ? t : t & 3 | 8)
				.toString(16)
		})
	}
	var lf = class extends $n {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === Dt.Text && t === "bim"
		}
		ExportContent(e, t, n, i) {
			let s = {
				schema_version: "1.0.0",
				meshes: [],
				elements: [],
				info: {}
			};
			this.ExportProperties(e.GetModel(), s.info);
			let o = 0;
			e.EnumerateTransformedMeshes(c => {
				let l = {
					mesh_id: o,
					coordinates: [],
					indices: []
				};
				c.EnumerateVertices(g => {
					l.coordinates.push(g.x, g.y, g.z)
				}), c.EnumerateTriangleVertexIndices((g, m, d) => {
					l.indices.push(g, m, d)
				});
				let u = {
						mesh_id: o,
						type: "Other",
						color: {
							r: 200,
							g: 200,
							b: 200,
							a: 255
						},
						vector: {
							x: 0,
							y: 0,
							z: 0
						},
						rotation: {
							qx: 0,
							qy: 0,
							qz: 0,
							qw: 1
						},
						guid: v1(),
						info: {}
					},
					h = null,
					f = !0,
					p = [];
				for (let g = 0; g < c.TriangleCount(); g++) {
					let m = c.GetTriangle(g),
						d = e.GetMaterial(m.mat),
						v = {
							r: d.color.r,
							g: d.color.g,
							b: d.color.b,
							a: Cn(d.opacity)
						};
					p.push(v.r, v.g, v.b, v.a), f && (h === null ? h = v : (h.r !== v.r || h.g !== v.g || h.b !== v.b || h.a !== v.a) && (f = !1, h = null))
				}
				f ? u.color = h : u.face_colors = p, u.info.Name = c.GetName(), this.ExportProperties(c, u.info), s.meshes.push(l), s.elements.push(u), o += 1
			});
			let a = new sn("model.bim");
			a.SetTextContent(JSON.stringify(s, null, 4)), n.push(a), i()
		}
		ExportProperties(e, t) {
			for (let n = 0; n < e.PropertyGroupCount(); n++) {
				let i = e.GetPropertyGroup(n);
				for (let s = 0; s < i.PropertyCount(); s++) {
					let o = i.GetProperty(s);
					t[o.name] = Hl(o)
				}
			}
		}
	};
	var hs = class {
		constructor(e, t) {
			this.arrayBuffer = new ArrayBuffer(e), this.dataView = new DataView(this.arrayBuffer), this.isLittleEndian = t, this.position = 0
		}
		GetPosition() {
			return this.position
		}
		SetPosition(e) {
			this.position = e
		}
		End() {
			return this.position >= this.arrayBuffer.byteLength
		}
		GetBuffer() {
			return this.arrayBuffer
		}
		WriteArrayBuffer(e) {
			let t = new Uint8Array(e);
			new Uint8Array(this.arrayBuffer)
				.set(t, this.position), this.position += e.byteLength
		}
		WriteBoolean8(e) {
			this.dataView.setInt8(this.position, e ? 1 : 0), this.position = this.position + 1
		}
		WriteCharacter8(e) {
			this.dataView.setInt8(this.position, e), this.position = this.position + 1
		}
		WriteUnsignedCharacter8(e) {
			this.dataView.setUint8(this.position, e), this.position = this.position + 1
		}
		WriteInteger16(e) {
			this.dataView.setInt16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteUnsignedInteger16(e) {
			this.dataView.setUint16(this.position, e, this.isLittleEndian), this.position = this.position + 2
		}
		WriteInteger32(e) {
			this.dataView.setInt32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteUnsignedInteger32(e) {
			this.dataView.setUint32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteFloat32(e) {
			this.dataView.setFloat32(this.position, e, this.isLittleEndian), this.position = this.position + 4
		}
		WriteDouble64(e) {
			this.dataView.setFloat64(this.position, e, this.isLittleEndian), this.position = this.position + 8
		}
	};
	var cf = class extends $n {
		constructor() {
			super(), this.components = {
				index: {
					type: 5125,
					size: 4
				},
				number: {
					type: 5126,
					size: 4
				}
			}
		}
		CanExport(e, t) {
			return e === Dt.Text && t === "gltf" || e === Dt.Binary && t === "glb"
		}
		ExportContent(e, t, n, i) {
			t === Dt.Text ? this.ExportAsciiContent(e, n) : t === Dt.Binary && this.ExportBinaryContent(e, n), i()
		}
		ExportAsciiContent(e, t) {
			let n = new sn("model.gltf"),
				i = new sn("model.bin");
			t.push(n), t.push(i);
			let s = this.GetMeshData(e),
				o = this.GetMainBuffer(s),
				a = this.GetMainJson(s);
			a.buffers.push({
				uri: i.GetName(),
				byteLength: o.byteLength
			});
			let c = new Map;
			this.ExportMaterials(e, a, l => {
				let u = Sn(l.name);
				if (c.has(u)) return c.get(u); {
					let h = new sn(u);
					h.SetBufferContent(l.buffer), t.push(h);
					let f = a.textures.length;
					return c.set(u, f), a.images.push({
						uri: u
					}), a.textures.push({
						source: f
					}), f
				}
			}), n.SetTextContent(JSON.stringify(a, null, 4)), i.SetBufferContent(o)
		}
		ExportBinaryContent(e, t) {
			function n(y) {
				let w = y % 4;
				return w === 0 ? y : y + (4 - w)
			}

			function i(y, w, C) {
				for (let S = 0; S < C; S++) y.WriteUnsignedCharacter8(w)
			}
			let s = new sn("model.glb");
			t.push(s);
			let o = this.GetMeshData(e),
				a = this.GetMainBuffer(o),
				c = this.GetMainJson(o),
				l = [],
				u = a.byteLength,
				h = new Map;
			this.ExportMaterials(e, c, y => {
				let w = Sn(y.name),
					C = cr(y.name);
				if (h.has(w)) return h.get(w); {
					let S = c.bufferViews.length,
						b = c.textures.length;
					h.set(w, b);
					let T = y.buffer;
					return l.push(T), c.bufferViews.push({
						buffer: 0,
						byteOffset: u,
						byteLength: T.byteLength
					}), u += T.byteLength, c.images.push({
						bufferView: S,
						mimeType: "image/" + C
					}), c.textures.push({
						source: b
					}), b
				}
			});
			let f = a.byteLength;
			for (let y = 0; y < l.length; y++) f += l[y].byteLength;
			let p = n(f);
			c.buffers.push({
				byteLength: p
			});
			let g = JSON.stringify(c),
				m = wc(g),
				d = m.byteLength,
				v = n(d),
				x = 12 + 8 + v + 8 + p,
				_ = new hs(x, !0);
			_.WriteUnsignedInteger32(1179937895), _.WriteUnsignedInteger32(2), _.WriteUnsignedInteger32(x), _.WriteUnsignedInteger32(v), _.WriteUnsignedInteger32(1313821514), _.WriteArrayBuffer(m), i(_, 32, v - d), _.WriteUnsignedInteger32(p), _.WriteUnsignedInteger32(5130562), _.WriteArrayBuffer(a);
			for (let y = 0; y < l.length; y++) {
				let w = l[y];
				_.WriteArrayBuffer(w)
			}
			i(_, 0, p - f), s.SetBufferContent(_.GetBuffer())
		}
		GetMeshData(e) {
			let t = [];
			return e.EnumerateTransformedMeshes(n => {
				let i = of (n);
				t.push({
					name: n.GetName(),
					buffer: i,
					offsets: [],
					sizes: []
				})
			}), t
		}
		GetMainBuffer(e) {
			let t = 0;
			for (let i = 0; i < e.length; i++) t += e[i].buffer.GetByteLength(this.components.index.size, this.components.number.size);
			let n = new hs(t, !0);
			for (let i = 0; i < e.length; i++) {
				let s = e[i];
				for (let o = 0; o < s.buffer.PrimitiveCount(); o++) {
					let a = s.buffer.GetPrimitive(o),
						c = n.GetPosition();
					for (let l = 0; l < a.indices.length; l++) n.WriteUnsignedInteger32(a.indices[l]);
					for (let l = 0; l < a.vertices.length; l++) n.WriteFloat32(a.vertices[l]);
					for (let l = 0; l < a.colors.length; l++) n.WriteFloat32(vs(a.colors[l]));
					for (let l = 0; l < a.normals.length; l++) n.WriteFloat32(a.normals[l]);
					for (let l = 0; l < a.uvs.length; l++) {
						let u = a.uvs[l];
						l % 2 === 1 && (u *= -1), n.WriteFloat32(u)
					}
					s.offsets.push(c), s.sizes.push(n.GetPosition() - c)
				}
			}
			return n.GetBuffer()
		}
		GetMainJson(e) {
			class t {
				constructor(s, o) {
					this.mainJson = s, this.byteOffset = o
				}
				AddBufferView(s) {
					return this.mainJson.bufferViews.push({
						buffer: 0,
						byteOffset: this.byteOffset,
						byteLength: s
					}), this.byteOffset += s, this.mainJson.bufferViews.length - 1
				}
			}
			let n = {
				asset: {
					generator: "https://3dviewer.net",
					version: "2.0"
				},
				scene: 0,
				scenes: [{
					nodes: []
				}],
				nodes: [],
				materials: [],
				meshes: [],
				buffers: [],
				bufferViews: [],
				accessors: []
			};
			for (let i = 0; i < e.length; i++) {
				let s = e[i];
				n.scenes[0].nodes.push(i), n.nodes.push({
					mesh: i
				});
				let o = {
						name: this.GetExportedMeshName(s.name),
						primitives: []
					},
					a = s.buffer.primitives;
				for (let c = 0; c < a.length; c++) {
					let l = a[c],
						u = new t(n, s.offsets[c]),
						h = u.AddBufferView(l.indices.length * this.components.index.size),
						f = u.AddBufferView(l.vertices.length * this.components.number.size),
						p = null;
					l.colors.length > 0 && (p = u.AddBufferView(l.colors.length * this.components.number.size));
					let g = u.AddBufferView(l.normals.length * this.components.number.size),
						m = null;
					l.uvs.length > 0 && (m = u.AddBufferView(l.uvs.length * this.components.number.size));
					let d = {
							attributes: {},
							mode: 4,
							material: l.material
						},
						v = l.GetBounds();
					n.accessors.push({
						bufferView: h,
						byteOffset: 0,
						componentType: this.components.index.type,
						count: l.indices.length,
						type: "SCALAR"
					}), d.indices = n.accessors.length - 1, n.accessors.push({
						bufferView: f,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: l.vertices.length / 3,
						min: v.min,
						max: v.max,
						type: "VEC3"
					}), d.attributes.POSITION = n.accessors.length - 1, p !== null && (n.accessors.push({
						bufferView: p,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: l.colors.length / 3,
						type: "VEC3"
					}), d.attributes.COLOR_0 = n.accessors.length - 1), n.accessors.push({
						bufferView: g,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: l.normals.length / 3,
						type: "VEC3"
					}), d.attributes.NORMAL = n.accessors.length - 1, m !== null && (n.accessors.push({
						bufferView: m,
						byteOffset: 0,
						componentType: this.components.number.type,
						count: l.uvs.length / 2,
						type: "VEC2"
					}), d.attributes.TEXCOORD_0 = n.accessors.length - 1), o.primitives.push(d)
				}
				n.meshes.push(o)
			}
			return n
		}
		ExportMaterials(e, t, n) {
			function i(s, o, a, c) {
				function l(d, v) {
					return [vs(d.r / 255), vs(d.g / 255), vs(d.b / 255), v]
				}

				function u(d) {
					return [vs(d.r / 255), vs(d.g / 255), vs(d.b / 255)]
				}

				function h(d, v, x) {
					if (v === null || !v.IsValid()) return null;
					d.images === void 0 && (d.images = []), d.textures === void 0 && (d.textures = []);
					let y = {
						index: x(v)
					};
					if (v.HasTransformation()) {
						let w = "KHR_texture_transform";
						d.extensionsUsed === void 0 && (d.extensionsUsed = []), d.extensionsUsed.indexOf(w) === -1 && d.extensionsUsed.push(w), y.extensions = {
							KHR_texture_transform: {
								offset: [v.offset.x, -v.offset.y],
								scale: [v.scale.x, v.scale.y],
								rotation: -v.rotation
							}
						}
					}
					return y
				}
				let f = {
					name: s.GetExportedMaterialName(a.name),
					pbrMetallicRoughness: {
						baseColorFactor: l(a.color, a.opacity)
					},
					emissiveFactor: u(a.emissive),
					doubleSided: !0,
					alphaMode: "OPAQUE"
				};
				a.transparent && (f.alphaMode = "BLEND");
				let p = h(o, a.diffuseMap, c);
				if (p !== null && (a.multiplyDiffuseMap || (f.pbrMetallicRoughness.baseColorFactor = l(new nt(255, 255, 255), a.opacity)), f.pbrMetallicRoughness.baseColorTexture = p), a.type === on.Physical) {
					let d = h(o, a.metalnessMap, c);
					d !== null ? f.pbrMetallicRoughness.metallicRoughnessTexture = d : (f.pbrMetallicRoughness.metallicFactor = a.metalness, f.pbrMetallicRoughness.roughnessFactor = a.roughness)
				}
				let g = h(o, a.normalMap, c);
				g !== null && (f.normalTexture = g);
				let m = h(o, a.emissiveMap, c);
				m !== null && (f.emissiveTexture = m), o.materials.push(f)
			}
			for (let s = 0; s < e.MaterialCount(); s++) {
				let o = e.GetMaterial(s);
				i(this, t, o, n)
			}
		}
	};
	var fc = class {
			constructor(e) {
				this.transformation = new Jt, this.isMeshVisible = t => !0, qu(e, this)
			}
		},
		sl = class {
			constructor(e, t) {
				this.model = e, this.settings = t || new fc
			}
			GetModel() {
				return this.model
			}
			MaterialCount() {
				return this.model.MaterialCount()
			}
			GetMaterial(e) {
				return this.model.GetMaterial(e)
			}
			VertexCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.VertexCount()
				}), e
			}
			TriangleCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += t.TriangleCount()
				}), e
			}
			MeshInstanceCount() {
				let e = 0;
				return this.EnumerateMeshInstances(t => {
					e += 1
				}), e
			}
			EnumerateMeshInstances(e) {
				this.model.EnumerateMeshInstances(t => {
					this.settings.isMeshVisible(t.GetId()) && e(t)
				})
			}
			EnumerateTransformedMeshes(e) {
				this.EnumerateMeshInstances(t => {
					let n = t.GetTransformation();
					this.settings.transformation.IsIdentity() || n.Append(this.settings.transformation);
					let s = t.GetMesh()
						.Clone();
					n.IsIdentity() || Ws(s, n), e(s)
				})
			}
			EnumerateVerticesAndTriangles(e) {
				let t = [];
				this.EnumerateTransformedMeshes(i => {
					t.push(i)
				});
				for (let i of t) i.EnumerateVertices(s => {
					e.onVertex(s.x, s.y, s.z)
				});
				let n = 0;
				for (let i of t) i.EnumerateTriangleVertexIndices((s, o, a) => {
					e.onTriangle(s + n, o + n, a + n)
				}), n += i.VertexCount()
			}
			EnumerateTrianglesWithNormals(e) {
				this.EnumerateTransformedMeshes(t => {
					t.EnumerateTriangleVertices((n, i, s) => {
						let o = Bl(n, i, s);
						e(n, i, s, o)
					})
				})
			}
		};
	var Yi = class {
		constructor() {
			this.text = "", this.indentation = 0
		}
		GetText() {
			return this.text
		}
		Indent(e) {
			this.indentation += e
		}
		WriteArrayLine(e) {
			this.WriteLine(e.join(" "))
		}
		WriteLine(e) {
			this.WriteIndentation(), this.Write(e + `
`)
		}
		WriteIndentation() {
			for (let e = 0; e < this.indentation; e++) this.Write("  ")
		}
		Write(e) {
			this.text += e
		}
	};
	var uf = class extends $n {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === Dt.Text && t === "obj"
		}
		ExportContent(e, t, n, i) {
			function s(g, m, d, v) {
				if (d === null || !d.IsValid()) return;
				let x = Sn(d.name);
				if (g.WriteArrayLine([m, x]), v.findIndex(y => y.GetName() === x) === -1) {
					let y = new sn(x);
					y.SetBufferContent(d.buffer), v.push(y)
				}
			}
			let o = new sn("model.mtl"),
				a = new sn("model.obj");
			n.push(o), n.push(a);
			let c = new Yi;
			c.WriteLine(this.GetHeaderText());
			for (let g = 0; g < e.MaterialCount(); g++) {
				let m = e.GetMaterial(g);
				c.WriteArrayLine(["newmtl", this.GetExportedMaterialName(m.name)]), c.WriteArrayLine(["Kd", m.color.r / 255, m.color.g / 255, m.color.b / 255]), c.WriteArrayLine(["d", m.opacity]), m.type === on.Phong && (c.WriteArrayLine(["Ka", m.ambient.r / 255, m.ambient.g / 255, m.ambient.b / 255]), c.WriteArrayLine(["Ks", m.specular.r / 255, m.specular.g / 255, m.specular.b / 255]), c.WriteArrayLine(["Ns", m.shininess * 1e3])), s(c, "map_Kd", m.diffuseMap, n), m.type === on.Phong && s(c, "map_Ks", m.specularMap, n), s(c, "bump", m.bumpMap, n)
			}
			o.SetTextContent(c.GetText());
			let l = new Yi;
			l.WriteLine(this.GetHeaderText()), l.WriteArrayLine(["mtllib", o.GetName()]);
			let u = 0,
				h = 0,
				f = 0,
				p = null;
			e.EnumerateTransformedMeshes(g => {
				l.WriteArrayLine(["g", this.GetExportedMeshName(g.GetName())]);
				for (let m = 0; m < g.VertexCount(); m++) {
					let d = g.GetVertex(m);
					l.WriteArrayLine(["v", d.x, d.y, d.z])
				}
				for (let m = 0; m < g.NormalCount(); m++) {
					let d = g.GetNormal(m);
					l.WriteArrayLine(["vn", d.x, d.y, d.z])
				}
				for (let m = 0; m < g.TextureUVCount(); m++) {
					let d = g.GetTextureUV(m);
					l.WriteArrayLine(["vt", d.x, d.y])
				}
				for (let m = 0; m < g.TriangleCount(); m++) {
					let d = g.GetTriangle(m),
						v = d.v0 + u + 1,
						x = d.v1 + u + 1,
						_ = d.v2 + u + 1,
						y = d.n0 + h + 1,
						w = d.n1 + h + 1,
						C = d.n2 + h + 1;
					if (d.mat !== null) {
						let N = e.GetMaterial(d.mat),
							V = this.GetExportedMaterialName(N.name);
						V !== p && (l.WriteArrayLine(["usemtl", V]), p = V)
					}
					let S = "",
						b = "",
						T = "";
					d.HasTextureUVs() && (S = d.u0 + f + 1, b = d.u1 + f + 1, T = d.u2 + f + 1), l.WriteArrayLine(["f", [v, S, y].join("/"), [x, b, w].join("/"), [_, T, C].join("/")])
				}
				u += g.VertexCount(), h += g.NormalCount(), f += g.TextureUVCount()
			}), a.SetTextContent(l.GetText()), i()
		}
		GetHeaderText() {
			return "# exported by https://3dviewer.net"
		}
	};
	var hf = class extends $n {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return e === Dt.Text && t === "off"
		}
		ExportContent(e, t, n, i) {
			let s = new sn("model.off");
			n.push(s);
			let o = new Yi;
			o.WriteLine("OFF"), o.WriteArrayLine([e.VertexCount(), e.TriangleCount(), 0]), e.EnumerateVerticesAndTriangles({
				onVertex: function(a, c, l) {
					o.WriteArrayLine([a, c, l])
				},
				onTriangle: function(a, c, l) {
					o.WriteArrayLine([3, a, c, l])
				}
			}), s.SetTextContent(o.GetText()), i()
		}
	};
	var ff = class extends $n {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === Dt.Text || e === Dt.Binary) && t === "ply"
		}
		ExportContent(e, t, n, i) {
			t === Dt.Text ? this.ExportText(e, n) : this.ExportBinary(e, n), i()
		}
		ExportText(e, t) {
			let n = new sn("model.ply");
			t.push(n);
			let i = new Yi,
				s = e.VertexCount(),
				o = e.TriangleCount(),
				a = this.GetHeaderText("ascii", s, o);
			i.Write(a), e.EnumerateVerticesAndTriangles({
				onVertex: function(c, l, u) {
					i.WriteArrayLine([c, l, u])
				},
				onTriangle: function(c, l, u) {
					i.WriteArrayLine([3, c, l, u])
				}
			}), n.SetTextContent(i.GetText())
		}
		ExportBinary(e, t) {
			let n = new sn("model.ply");
			t.push(n);
			let i = e.VertexCount(),
				s = e.TriangleCount(),
				o = this.GetHeaderText("binary_little_endian", i, s),
				a = o.length + i * 3 * 4 + s * (1 + 3 * 4),
				c = new hs(a, !0);
			for (let l = 0; l < o.length; l++) c.WriteUnsignedCharacter8(o.charCodeAt(l));
			e.EnumerateVerticesAndTriangles({
				onVertex: function(l, u, h) {
					c.WriteFloat32(l), c.WriteFloat32(u), c.WriteFloat32(h)
				},
				onTriangle: function(l, u, h) {
					c.WriteUnsignedCharacter8(3), c.WriteInteger32(l), c.WriteInteger32(u), c.WriteInteger32(h)
				}
			}), n.SetBufferContent(c.GetBuffer())
		}
		GetHeaderText(e, t, n) {
			let i = new Yi;
			return i.WriteLine("ply"), i.WriteLine("format " + e + " 1.0"), i.WriteLine("element vertex " + t), i.WriteLine("property float x"), i.WriteLine("property float y"), i.WriteLine("property float z"), i.WriteLine("element face " + n), i.WriteLine("property list uchar int vertex_index"), i.WriteLine("end_header"), i.GetText()
		}
	};
	var df = class extends $n {
		constructor() {
			super()
		}
		CanExport(e, t) {
			return (e === Dt.Text || e === Dt.Binary) && t === "stl"
		}
		ExportContent(e, t, n, i) {
			t === Dt.Text ? this.ExportText(e, n) : this.ExportBinary(e, n), i()
		}
		ExportText(e, t) {
			let n = new sn("model.stl");
			t.push(n);
			let i = new Yi;
			i.WriteLine("solid Model"), e.EnumerateTrianglesWithNormals((s, o, a, c) => {
				i.WriteArrayLine(["facet", "normal", c.x, c.y, c.z]), i.Indent(1), i.WriteLine("outer loop"), i.Indent(1), i.WriteArrayLine(["vertex", s.x, s.y, s.z]), i.WriteArrayLine(["vertex", o.x, o.y, o.z]), i.WriteArrayLine(["vertex", a.x, a.y, a.z]), i.Indent(-1), i.WriteLine("endloop"), i.Indent(-1), i.WriteLine("endfacet")
			}), i.WriteLine("endsolid Model"), n.SetTextContent(i.GetText())
		}
		ExportBinary(e, t) {
			let n = new sn("model.stl");
			t.push(n);
			let i = e.TriangleCount(),
				s = 80,
				o = s + 4 + i * 50,
				a = new hs(o, !0);
			for (let c = 0; c < s; c++) a.WriteUnsignedCharacter8(0);
			a.WriteUnsignedInteger32(i), e.EnumerateTrianglesWithNormals((c, l, u, h) => {
				a.WriteFloat32(h.x), a.WriteFloat32(h.y), a.WriteFloat32(h.z), a.WriteFloat32(c.x), a.WriteFloat32(c.y), a.WriteFloat32(c.z), a.WriteFloat32(l.x), a.WriteFloat32(l.y), a.WriteFloat32(l.z), a.WriteFloat32(u.x), a.WriteFloat32(u.y), a.WriteFloat32(u.z), a.WriteUnsignedInteger16(0)
			}), n.SetBufferContent(a.GetBuffer())
		}
	};
	var pf = class {
		constructor() {
			this.exporters = [new uf, new df, new ff, new hf, new cf, new af, new lf]
		}
		AddExporter(e) {
			this.exporters.push(e)
		}
		Export(e, t, n, i, s) {
			let o = null;
			for (let c = 0; c < this.exporters.length; c++) {
				let l = this.exporters[c];
				if (l.CanExport(n, i)) {
					o = l;
					break
				}
			}
			if (o === null) {
				s.onError();
				return
			}
			let a = new sl(e, t);
			o.Export(a, n, c => {
				c.length === 0 ? s.onError() : s.onSuccess(c)
			})
		}
	};

	function oy(r, e, t, n, i) {
		let s = Nr(e, null),
			o = t.indexOf(s);
		return gg(r, t, o !== -1 ? o : n, c => {
			Lr(e, t[c]), i && i(c)
		})
	}
	var Zi = class {
			constructor(e, t, n) {
				this.name = e, this.format = t, this.extension = n, this.visibleOnlySelect = null, this.rotationSelect = null
			}
			GetName() {
				return this.name
			}
			GenerateParametersUI(e) {
				function t(n, i, s, o, a) {
					let c = _e(n, "ov_dialog_row");
					_e(c, "ov_dialog_row_name", i);
					let l = _e(c, "ov_dialog_row_value");
					return oy(l, s, o, a)
				}
				this.visibleOnlySelect = t(e, "Scope", "ov_last_scope", ["Entire Model", "Visible Only"], 1), this.rotationSelect = t(e, "Rotation", "ov_last_rotation", ["No Rotation", "-90 Degrees", "90 Degrees"], 0)
			}
			ExportModel(e, t) {
				let n = new fc;
				if (this.visibleOnlySelect.selectedIndex === 1 && (n.isMeshVisible = o => t.isMeshVisible(o)), this.rotationSelect.selectedIndex === 1) {
					let o = new kt()
						.CreateRotationAxisAngle(new Le(1, 0, 0), -Math.PI / 2);
					n.transformation.SetMatrix(o)
				} else if (this.rotationSelect.selectedIndex === 2) {
					let o = new kt()
						.CreateRotationAxisAngle(new Le(1, 0, 0), Math.PI / 2);
					n.transformation.SetMatrix(o)
				}
				if (new sl(e, n)
					.MeshInstanceCount() === 0) {
					cs("Export Failed", "The model doesn't contain any meshes.", null);
					return
				}
				let s = new Ya;
				s.Init("Exporting Model"), s.Open(), Ao(() => {
					new pf()
						.Export(e, n, this.format, this.extension, {
							onError: () => {
								s.Close()
							},
							onSuccess: a => {
								if (a.length === 0) s.Close();
								else if (a.length === 1) {
									s.Close();
									let c = a[0];
									If(c.GetBufferContent(), c.GetName())
								} else if (a.length > 1) {
									let c = {};
									for (let h of a) c[h.name] = new Uint8Array(h.content);
									let u = $x(c)
										.buffer;
									s.Close(), If(u, "model.zip")
								}
							}
						})
				})
			}
		},
		Gm = class {
			constructor(e) {
				this.callbacks = e, this.selectedExporter = null, this.parametersDiv = null, this.exporters = [new Zi("Wavefront (.obj)", Dt.Text, "obj"), new Zi("Stereolithography Text (.stl)", Dt.Text, "stl"), new Zi("Stereolithography Binary (.stl)", Dt.Binary, "stl"), new Zi("Polygon File Format Text (.ply)", Dt.Text, "ply"), new Zi("Polygon File Format Binary (.ply)", Dt.Binary, "ply"), new Zi("glTF Text (.gltf)", Dt.Text, "gltf"), new Zi("glTF Binary (.glb)", Dt.Binary, "glb"), new Zi("Object File Format Text (.off)", Dt.Text, "off"), new Zi("Rhinoceros 3D (.3dm)", Dt.Binary, "3dm"), new Zi("Dotbim (.bim)", Dt.Text, "bim")]
			}
			Open(e, t) {
				let n = new yi,
					i = n.Init("Export", [{
						name: "Close",
						subClass: "outline",
						onClick() {
							n.Close()
						}
					}, {
						name: "Export",
						onClick: () => {
							n.Close(), this.ExportFormat(e, t)
						}
					}]);
				_e(i, "ov_dialog_section", "Select the format from the list below, and adjust the settings of the selected format.");
				let o = _e(i, "ov_dialog_row");
				this.parametersDiv = _e(i);
				let a = this.exporters.map(l => l.GetName()),
					c = oy(o, "ov_last_export_format", a, 6, l => {
						this.OnFormatSelected(l)
					});
				this.OnFormatSelected(c.selectedIndex), n.Open()
			}
			OnFormatSelected(e) {
				li(this.parametersDiv), this.selectedExporter = this.exporters[e], this.selectedExporter.GenerateParametersUI(this.parametersDiv)
			}
			ExportFormat(e, t) {
				this.selectedExporter.ExportModel(e, {
					isMeshVisible: n => this.callbacks.isMeshVisible(n)
				}), vn("model_exported", this.selectedExporter.GetName())
			}
		};

	function ay(r, e, t) {
		new Gm(t)
			.Open(r, e)
	}

	function ly(r) {
		function e(d, v, x, _, y) {
			let w = _e(d, "ov_dialog_row");
			pg(w, v, "snapshot_size", x, _, y)
		}

		function t(d, v) {
			let x = parseInt(v[0], 10),
				_ = parseInt(v[1], 10);
			return x < 1 || _ < 1 ? null : d.GetImageAsDataUrl(v[0], v[1])
		}

		function n(d, v, x) {
			let _ = t(d, x);
			v.src = _
		}

		function i(d, v, x) {
			let _ = d[v];
			_.widthInput.disabled = x !== v, _.heightInput.disabled = x !== v
		}

		function s(d, v) {
			let x = d[v];
			return x.size !== null ? x.size : [x.widthInput.value, x.heightInput.value]
		}

		function o(d, v, x) {
			let _ = _e(d, "ov_dialog_row");
			_e(_, "ov_snapshot_dialog_param_name", v);
			let y = dg(_, "ov_dialog_text", x);
			return y.classList.add("ov_snapshot_dialog_param_value"), y.addEventListener("focus", () => {
				y.setSelectionRange(0, y.value.length)
			}), y
		}
		let a = 0,
			c = 3,
			l = [{
				name: "Small (1280x720)",
				size: [1280, 720]
			}, {
				name: "Medium (1920x1080)",
				size: [1920, 1080]
			}, {
				name: "Large (2560x1440)",
				size: [2560, 1440]
			}, {
				name: "Custom",
				size: null,
				widthInput: null,
				heightInput: null
			}],
			u = new yi,
			h = u.Init("Create Snapshot", [{
				name: "Cancel",
				subClass: "outline",
				onClick() {
					u.Close()
				}
			}, {
				name: "Create",
				onClick() {
					u.Close(), vn("snapshot_created", l[a].name);
					let d = t(r, s(l, a));
					d !== null && Af(d, "model.png")
				}
			}]),
			f = _e(h, "ov_snapshot_dialog_left"),
			p = ms("img", "ov_snapshot_dialog_preview"),
			g = Nr("ov_last_snapshot_size", l[1].name);
		for (let d = 0; d < l.length; d++)
			if (g === l[d].name) {
				a = d;
				break
			} let m = l[c];
		for (let d = 0; d < l.length; d++) {
			let v = l[d],
				x = d === a;
			e(f, "snapshot_" + d.toString(), v.name, x, () => {
				a = d, Lr("ov_last_snapshot_size", v.name), n(r, p, s(l, d)), i(l, c, a)
			})
		}
		return m.widthInput = o(f, "Width", d => {
			n(r, p, s(l, a)), nl("ov_snapshot_custom_width", d)
		}), m.heightInput = o(f, "Height", d => {
			n(r, p, s(l, a)), nl("ov_snapshot_custom_height", d)
		}), m.widthInput.value = tl("ov_snapshot_custom_width", 1e3), m.heightInput.value = tl("ov_snapshot_custom_height", 1e3), i(l, c, a), h.appendChild(p), n(r, p, s(l, a)), u.Open(), u
	}

	function cy(r) {
		let e = new yi,
			t = ms("textarea", "ov_dialog_textarea"),
			n = e.Init("打开 Url", [{
				name: "Cancel",
				subClass: "outline",
				onClick() {
					e.Close()
				}
			}, {
				name: "OK",
				onClick() {
					let s = [];
					Gi(t.value, o => {
						s.push(o)
					}), e.Close(), r(s)
				}
			}]);
		return _e(n, "ov_dialog_section", "Here you can load models based on their urls. You can add more lines if your model builds up from multiple files."), n.appendChild(t), e.Open(), t.focus(), e
	}

	function uy(r, e, t) {
		function n(h, f, p, g) {
			let m = _e(h, "ov_dialog_row"),
				d = Ic(m, p, f, !0, () => {
					g(d.checked)
				})
		}

		function i(h, f) {
			let p = "Copy",
				g = "Copied",
				m = _e(h, "ov_dialog_copyable_input"),
				d = Zt(m, "input", null);
			d.setAttribute("type", "text"), d.readOnly = !0;
			let v = _e(m, "ov_button outline ov_dialog_copyable_input_button", p);
			return v.addEventListener("click", () => {
				ug(f()), v.innerHTML = g, setTimeout(() => {
					v.innerHTML = p
				}, 2e3)
			}), d
		}

		function s(h, f) {
			function p(d) {
				let v = ku();
				v.AddModelUrls(d);
				let x = v.GetParameterList();
				return "https://3dviewer.net#" + x
			}
			let g = _e(h, "ov_dialog_section");
			_e(g, "ov_dialog_inner_title", "Sharing Link");
			let m = i(g, () => (vn("model_shared", "sharing_link"), p(f)));
			m.value = p(f)
		}

		function o(h, f, p, g) {
			function m(y, w, C, S) {
				let b = ku();
				if (b.AddModelUrls(y), w) {
					b.AddCamera(S.GetCamera()), b.AddCameraMode(S.GetCameraMode());
					let V = {
						environmentMapName: C.environmentMapName,
						backgroundIsEnvMap: C.backgroundIsEnvMap
					};
					b.AddEnvironmentSettings(V), b.AddBackgroundColor(C.backgroundColor), b.AddDefaultColor(C.defaultColor);
					let O = {
						showEdges: C.showEdges,
						edgeColor: C.edgeColor,
						edgeThreshold: C.edgeThreshold
					};
					b.AddEdgeSettings(O)
				}
				let T = b.GetParameterList(),
					N = "";
				return N += "<iframe", N += ' width="640" height="480"', N += ' style="border:1px solid #eeeeee;"', N += ' src="https://3dviewer.net/embed.html#' + T + '">', N += "</iframe>", N
			}
			let d = !0,
				v = _e(h, "ov_dialog_section");
			v.style.marginTop = "20px", _e(v, "ov_dialog_inner_title", "Embedding Code");
			let x = _e(v, "ov_dialog_section"),
				_ = i(v, () => (vn("model_shared", "embedding_code"), m(f, d, p, g)));
			n(x, "Use customized settings", "embed_current_settings", y => {
				d = y, _.value = m(f, d, p, g)
			}), _.value = m(f, d, p, g)
		}
		if (!r.IsOnlyUrlSource()) return cs("Sharing Failed", "Sharing works only if you load files by url. Please upload your model files to a web server, open them by url, and try embedding again.", null);
		let a = r.GetFiles(),
			c = [];
		for (let h = 0; h < a.length; h++) {
			let f = a[h];
			f.source === lr.Url && c.push(f.data)
		}
		let l = new yi,
			u = l.Init("Share", [{
				name: "Close",
				onClick() {
					l.Close()
				}
			}]);
		return s(u, c), o(u, c, e, t), l.Open(), l
	}

	function Vm(r) {
		let e = new ke;
		r.object.updateWorldMatrix(!0, !1), e.extractRotation(r.object.matrixWorld);
		let t = r.face.normal.clone();
		return t.applyMatrix4(e), t
	}

	function fy() {
		return new Si({
			color: 2503224,
			depthTest: !1
		})
	}

	function mf(r, e) {
		let t = new bt()
			.setFromPoints(r);
		return new Qr(t, e)
	}
	var zm = class {
		constructor(e, t) {
			this.intersection = null, this.markerObject = new yt;
			let n = fy(),
				i = new xu(0, 0, t, t, 0, 2 * Math.PI, !1, 0);
			this.markerObject.add(mf(i.getPoints(50), n)), this.markerObject.add(mf([new ne(-t, 0, 0), new ne(t, 0, 0)], n)), this.markerObject.add(mf([new ne(0, -t, 0), new ne(0, t, 0)], n)), this.UpdatePosition(e)
		}
		UpdatePosition(e) {
			this.intersection = e;
			let t = Vm(this.intersection);
			this.markerObject.updateMatrixWorld(!0), this.markerObject.position.set(0, 0, 0), this.markerObject.lookAt(t), this.markerObject.position.set(this.intersection.point.x, this.intersection.point.y, this.intersection.point.z)
		}
		Show(e) {
			this.markerObject.visible = e
		}
		GetIntersection() {
			return this.intersection
		}
		GetObject() {
			return this.markerObject
		}
	};

	function x1(r, e) {
		let t = r.GetIntersection(),
			n = e.GetIntersection(),
			i = {
				pointsDistance: null,
				parallelFacesDistance: null,
				facesAngle: null
			},
			s = Vm(t),
			o = Vm(n);
		if (i.pointsDistance = t.point.distanceTo(n.point), i.facesAngle = s.angleTo(o), Mf(i.facesAngle, 0, 1e-4) || Mf(i.facesAngle, Math.PI, 1e-4)) {
			let a = new nr()
				.setFromNormalAndCoplanarPoint(s, t.point);
			i.parallelFacesDistance = Math.abs(a.distanceToPoint(n.point))
		}
		return i
	}
	var gf = class {
		constructor(e, t) {
			this.viewer = e, this.settings = t, this.isActive = !1, this.markers = [], this.tempMarker = null, this.panel = null, this.button = null
		}
		SetButton(e) {
			this.button = e
		}
		IsActive() {
			return this.isActive
		}
		SetActive(e) {
			this.isActive !== e && (this.isActive = e, this.button.SetSelected(e), this.isActive ? (this.panel = _e(document.body, "ov_measure_panel"), this.UpdatePanel(), this.Resize()) : (this.ClearMarkers(), this.panel.remove()))
		}
		Click(e) {
			let t = this.viewer.GetMeshIntersectionUnderMouse(e);
			if (t === null) {
				this.ClearMarkers(), this.UpdatePanel();
				return
			}
			this.markers.length === 2 && this.ClearMarkers(), this.AddMarker(t), this.UpdatePanel()
		}
		MouseMove(e) {
			let t = this.viewer.GetMeshIntersectionUnderMouse(e);
			if (t === null) {
				this.tempMarker !== null && (this.tempMarker.Show(!1), this.viewer.Render());
				return
			}
			this.tempMarker === null && (this.tempMarker = this.GenerateMarker(t)), this.tempMarker.UpdatePosition(t), this.tempMarker.Show(!0), this.viewer.Render()
		}
		AddMarker(e) {
			let t = this.GenerateMarker(e);
			if (this.markers.push(t), this.markers.length === 2) {
				let n = fy(),
					i = this.markers[0].GetIntersection()
					.point,
					s = this.markers[1].GetIntersection()
					.point;
				this.viewer.AddExtraObject(mf([i, s], n))
			}
		}
		GenerateMarker(e) {
			let n = this.viewer.GetBoundingSphere(s => !0)
				.radius / 20,
				i = new zm(e, n);
			return this.viewer.AddExtraObject(i.GetObject()), i
		}
		UpdatePanel() {
			function e(n) {
				let s = window.getComputedStyle(document.body, null)
					.backgroundColor.match(/\d+/g);
				if (s.length < 3) return new nt(n.r, n.g, n.b);
				let o = lo(n.a);
				return new nt(parseInt(s[0], 10) * (1 - o) + n.r * o, parseInt(s[1], 10) * (1 - o) + n.g * o, parseInt(s[2], 10) * (1 - o) + n.b * o)
			}

			function t(n, i, s, o) {
				let a = Xn(n, i, "left_inline");
				a.title = s, _e(n, "ov_measure_value", o)
			}
			if (li(this.panel), this.settings.backgroundIsEnvMap) this.panel.style.color = "#ffffff", this.panel.style.backgroundColor = "rgba(0,0,0,0.5)";
			else {
				let n = e(this.settings.backgroundColor);
				hg(n) ? this.panel.style.color = "#000000" : this.panel.style.color = "#ffffff", this.panel.style.backgroundColor = "transparent"
			}
			if (this.markers.length === 0) this.panel.innerHTML = "Select a point.";
			else if (this.markers.length === 1) this.panel.innerHTML = "Select another point.";
			else {
				let n = x1(this.markers[0], this.markers[1]);
				if (n.pointsDistance !== null && t(this.panel, "measure_distance", "Distance of points", n.pointsDistance.toFixed(3)), n.parallelFacesDistance !== null && t(this.panel, "measure_distance_parallel", "Distance of parallel faces", n.parallelFacesDistance.toFixed(3)), n.facesAngle !== null) {
					let i = n.facesAngle * Km;
					t(this.panel, "measure_angle", "Angle of faces", i.toFixed(1) + "\xB0")
				}
			}
			this.Resize()
		}
		Resize() {
			if (!this.isActive) return;
			let t = this.viewer.GetCanvas()
				.getBoundingClientRect(),
				n = this.panel.getBoundingClientRect(),
				i = t.right - t.left,
				s = n.right - n.left;
			this.panel.style.left = t.left + (i - s) / 2 + "px", this.panel.style.top = t.top + 10 + "px"
		}
		ClearMarkers() {
			this.viewer.ClearExtra(), this.markers = [], this.tempMarker = null
		}
	};
	var Dr = {
			Undefined: 0,
			Intro: 1,
			Model: 2,
			Loading: 3
		},
		vf = class {
			constructor(e) {
				this.parameters = e, this.settings = new il, this.viewer = new Ea, this.measureTool = new gf(this.viewer, this.settings), this.hashHandler = new Xa, this.toolbar = new sf(this.parameters.toolbarDiv), this.navigator = new Jh(this.parameters.navigatorDiv, this.parameters.navigatorSplitterDiv), this.sidebar = new tf(this.parameters.sidebarDiv, this.parameters.sidebarSplitterDiv, this.settings), this.modelLoaderUI = new Ka, this.themeHandler = new nf, this.highlightColor = new Xe(9357808), this.uiState = Dr.Undefined, this.model = null
			}
			Load() {
				this.settings.LoadFromCookies(), this.SwitchTheme(this.settings.themeId, !1), vn("theme_on_load", this.settings.themeId === ii.Light ? "light" : "dark"), this.InitViewer(), this.InitToolbar(), this.InitDragAndDrop(), this.InitSidebar(), this.InitNavigator(), this.viewer.SetMouseClickHandler(this.OnModelClicked.bind(this)), this.viewer.SetMouseMoveHandler(this.OnModelMouseMoved.bind(this)), this.viewer.SetContextMenuHandler(this.OnModelContextMenu.bind(this)), this.Resize(), this.SetUIState(Dr.Intro), this.hashHandler.SetEventListener(this.OnHashChange.bind(this)), this.OnHashChange(), lg(() => {
					this.OnSmallWidthChanged()
				}), window.addEventListener("resize", () => {
					this.Resize()
				})
			}
			Resize() {
				let e = window.innerWidth,
					t = window.innerHeight,
					n = this.parameters.headerDiv.offsetHeight,
					i = 0,
					s = 0,
					o = 0;
				cg() || (i = this.navigator.GetWidth(), s = this.sidebar.GetWidth(), o = 1);
				let a = 50,
					c = e - i - s;
				c < a && (this.sidebar.DecreaseWidth(a - c), c = a);
				let l = t - n;
				gs(this.parameters.introDiv, l), this.navigator.Resize(l), this.sidebar.Resize(l), this.viewer.Resize(c - o, l), this.measureTool.Resize()
			}
			OnSmallWidthChanged() {
				this.uiState === Dr.Model && this.UpdatePanelsVisibility()
			}
			HasLoadedModel() {
				return this.model !== null
			}
			SetUIState(e) {
				function t(n) {
					document.querySelector(":root")
						.style.setProperty("--ov_only_on_model_display", n ? "inherit" : "none")
				}
				this.uiState !== e && (this.uiState = e, this.uiState === Dr.Intro ? (At(this.parameters.introDiv, !0), At(this.parameters.mainDiv, !1), t(!1)) : this.uiState === Dr.Model ? (At(this.parameters.introDiv, !1), At(this.parameters.mainDiv, !0), t(!0), this.UpdatePanelsVisibility()) : this.uiState === Dr.Loading && (At(this.parameters.introDiv, !1), At(this.parameters.mainDiv, !1), t(!1)), this.Resize())
			}
			ClearModel() {
				Am(), this.model = null, this.viewer.Clear(), this.parameters.fileNameDiv.innerHTML = "", this.navigator.Clear(), this.sidebar.Clear(), this.measureTool.SetActive(!1)
			}
			OnModelLoaded(e, t) {
				this.model = e.model, this.parameters.fileNameDiv.innerHTML = e.mainFile, this.viewer.SetMainObject(t), this.viewer.SetUpVector(lt.Y, !1), this.navigator.FillTree(e), this.sidebar.UpdateControlsVisibility(), this.FitModelToWindow(!0)
			}
			OnModelClicked(e, t) {
				if (e !== 1) return;
				if (this.measureTool.IsActive()) {
					this.measureTool.Click(t);
					return
				}
				let n = this.viewer.GetMeshUserDataUnderMouse(t);
				n === null ? this.navigator.SetSelection(null) : this.navigator.SetSelection(new no(Wn.Mesh, n.originalMeshId))
			}
			OnModelMouseMoved(e) {
				this.measureTool.IsActive() && this.measureTool.MouseMove(e)
			}
			OnModelContextMenu(e, t) {
				let n = this.viewer.GetMeshUserDataUnderMouse(t),
					i = [];
				if (n === null) i.push({
					name: "适应窗口",
					icon: "fit",
					onClick: () => {
						this.FitModelToWindow(!1)
					}
				}), this.navigator.HasHiddenMesh() && i.push({
					name: "Show all meshes",
					icon: "visible",
					onClick: () => {
						this.navigator.ShowAllMeshes(!0)
					}
				});
				else if (i.push({
					name: "Hide mesh",
					icon: "hidden",
					onClick: () => {
						this.navigator.ToggleMeshVisibility(n.originalMeshId)
					}
				}), i.push({
					name: "Fit mesh to window",
					icon: "fit",
					onClick: () => {
						this.navigator.FitMeshToWindow(n.originalMeshId)
					}
				}), this.navigator.MeshItemCount() > 1) {
					let s = this.navigator.IsMeshIsolated(n.originalMeshId);
					i.push({
						name: s ? "Remove isolation" : "Isolate mesh",
						icon: s ? "deisolate" : "isolate",
						onClick: () => {
							s ? this.navigator.ShowAllMeshes(!0) : this.navigator.IsolateMesh(n.originalMeshId)
						}
					})
				}
				Za(i, {
					calculatePosition: s => ty(e, s),
					onClick: s => {
						i[s].onClick()
					}
				})
			}
			OnHashChange() {
				if (this.hashHandler.HasHash()) {
					let e = this.hashHandler.GetModelFilesFromHash();
					if (e === null) return;
					Uu(e);
					let t = new No;
					t.defaultColor = this.settings.defaultColor;
					let n = this.hashHandler.GetDefaultColorFromHash();
					n !== null && (t.defaultColor = n), vn("model_load_started", "hash"), this.LoadModelFromUrlList(e, t)
				} else this.ClearModel(), this.SetUIState(Dr.Intro)
			}
			OpenFileBrowserDialog() {
				this.parameters.fileInput.click()
			}
			FitModelToWindow(e) {
				let t = !e,
					n = this.viewer.GetBoundingSphere(i => this.navigator.IsMeshVisible(i.originalMeshId));
				e && this.viewer.AdjustClippingPlanesToSphere(n), this.viewer.FitSphereToWindow(n, t)
			}
			FitMeshToWindow(e) {
				let t = this.viewer.GetBoundingSphere(n => n.originalMeshId.IsEqual(e));
				this.viewer.FitSphereToWindow(t, !0)
			}
			FitMeshesToWindow(e) {
				let t = new Set;
				for (let i of e) t.add(i.GetKey());
				let n = this.viewer.GetBoundingSphere(i => t.has(i.originalMeshId.GetKey()));
				this.viewer.FitSphereToWindow(n, !0)
			}
			UpdateMeshesVisibility() {
				this.viewer.SetMeshesVisibility(e => this.navigator.IsMeshVisible(e.originalMeshId))
			}
			UpdateMeshesSelection() {
				let e = this.navigator.GetSelectedMeshId();
				this.viewer.SetMeshesHighlight(this.highlightColor, t => !!(e !== null && t.originalMeshId.IsEqual(e)))
			}
			LoadModelFromUrlList(e, t) {
				let n = Vu(e);
				this.LoadModelFromInputFiles(n, t), this.ClearHashIfNotOnlyUrlList()
			}
			LoadModelFromFileList(e) {
				let t = new No;
				t.defaultColor = this.settings.defaultColor;
				let n = Rv(e);
				this.LoadModelFromInputFiles(n, t), this.ClearHashIfNotOnlyUrlList()
			}
			LoadModelFromInputFiles(e, t) {
				this.modelLoaderUI.LoadModel(e, t, {
					onStart: () => {
						this.SetUIState(Dr.Loading), this.ClearModel()
					},
					onFinish: (n, i) => {
						this.SetUIState(Dr.Model), this.OnModelLoaded(n, i);
						let s = cr(n.mainFile);
						vn("model_loaded", s)
					},
					onRender: () => {
						this.viewer.Render()
					},
					onError: n => {
						this.SetUIState(Dr.Intro);
						let i = null;
						if (n.mainFile !== null) i = cr(n.mainFile);
						else {
							let s = [],
								a = this.modelLoaderUI.GetImporter()
								.GetFileList()
								.GetFiles();
							for (let c = 0; c < a.length; c++) {
								let l = a[c].extension;
								s.push(l)
							}
							i = s.join(",")
						}
						n.code === Xi.NoImportableFile ? vn("no_importable_file", i) : n.code === Xi.FailedToLoadFile ? vn("failed_to_load_file", i) : n.code === Xi.ImportFailed && vn("import_failed", i, {
							error_message: n.message
						})
					}
				})
			}
			ClearHashIfNotOnlyUrlList() {
				!this.modelLoaderUI.GetImporter()
					.GetFileList()
					.IsOnlyUrlSource() && this.hashHandler.HasHash() && (this.hashHandler.SkipNextEventHandler(), this.hashHandler.ClearHash())
			}
			UpdateEdgeDisplay() {
				this.settings.SaveToCookies(), this.viewer.SetEdgeSettings(this.settings.showEdges, this.settings.edgeColor, this.settings.edgeThreshold)
			}
			UpdateEnvironmentMap() {
				let e = "assets/envmaps/" + this.settings.environmentMapName + "/",
					t = [e + "posx.jpg", e + "negx.jpg", e + "posy.jpg", e + "negy.jpg", e + "posz.jpg", e + "negz.jpg"];
				this.viewer.SetEnvironmentMapSettings(t, this.settings.backgroundIsEnvMap)
			}
			SwitchTheme(e, t) {
				if (this.settings.themeId = e, this.themeHandler.SwitchTheme(this.settings.themeId), this.settings.SaveToCookies(), t) {
					this.viewer.SetBackgroundColor(this.settings.backgroundColor);
					let n = this.modelLoaderUI.GetModelLoader();
					n.GetDefaultMaterial() !== null && (fp(this.model, this.settings.defaultColor), n.ReplaceDefaultMaterialColor(this.settings.defaultColor))
				}
			}
			InitViewer() {
				let e = Zt(this.parameters.viewerDiv, "canvas");
				this.viewer.Init(e), this.viewer.SetEdgeSettings(this.settings.showEdges, this.settings.edgeColor, this.settings.edgeThreshold), this.viewer.SetBackgroundColor(this.settings.backgroundColor), this.UpdateEnvironmentMap()
			}
			InitToolbar() {
				function e(a, c, l, u, h) {
					let f = a.AddImageButton(c, l, () => {
						h()
					});
					for (let p of u) f.AddClass(p);
					return f
				}

				function t(a, c, l, u, h) {
					let f = a.AddImagePushButton(c, l, !1, p => {
						h(p)
					});
					for (let p of u) f.AddClass(p);
					return f
				}

				function n(a, c, l, u, h, f) {
					let p = [];
					for (let m = 0; m < c.length; m++) {
						let d = c[m],
							v = l[m];
						p.push({
							image: d,
							title: v
						})
					}
					let g = a.AddImageRadioButton(p, u, m => {
						f(m)
					});
					for (let m of h)
						for (let d of g) d.AddClass(m)
				}

				function i(a, c) {
					let l = a.AddSeparator();
					if (c !== null)
						for (let u of c) l.classList.add(u)
				}
				let s = this.modelLoaderUI.GetImporter();
				e(this.toolbar, "open", "打开本地", [], () => {
					this.OpenFileBrowserDialog()
				}), i(this.toolbar, ["only_on_model"]), e(this.toolbar, "fit", "适应窗口", ["only_on_model"], () => {
					this.FitModelToWindow(!1)
				}), e(this.toolbar, "up_y", "Y轴承向上", ["only_on_model"], () => {
					this.viewer.SetUpVector(lt.Y, !0)
				}), e(this.toolbar, "up_z", "Z轴向上", ["only_on_model"], () => {
					this.viewer.SetUpVector(lt.Z, !0)
				}), e(this.toolbar, "flip", "向上翻转矢量", ["only_on_model"], () => {
					this.viewer.FlipUpVector()
				}), i(this.toolbar, ["only_on_model"]), n(this.toolbar, ["fix_up_on", "fix_up_off"], ["Fixed up vector", "Free orbit"], 0, ["only_full_width", "only_on_model"], a => {
					a === 0 ? this.viewer.SetFixUpVector(!0) : a === 1 && this.viewer.SetFixUpVector(!1)
				}), i(this.toolbar, ["only_full_width", "only_on_model"]), n(this.toolbar, ["camera_perspective", "camera_orthographic"], ["透视照相机", "正交照相机"], 0, ["only_on_model"], a => {
					a === 0 ? this.viewer.SetCameraMode(Nn.Perspective) : a === 1 && this.viewer.SetCameraMode(Nn.Orthographic), this.sidebar.UpdateControlsVisibility()
				}), i(this.toolbar, ["only_full_width", "only_on_model"]);
				let o = t(this.toolbar, "measure", "测量", ["only_full_width", "only_on_model"], a => {
					vn("measure_tool_activated", a ? "on" : "off"), this.navigator.SetSelection(null), this.measureTool.SetActive(a)
				});
				this.measureTool.SetButton(o), i(this.toolbar, ["only_full_width", "only_on_model"]), e(this.toolbar, "snapshot", "拍照", ["only_full_width", "only_on_model"], () => {
					ly(this.viewer)
				}), e(this.toolbar, "export", "导出", ["only_full_width", "only_on_model"], () => {
					ay(this.model, this.viewer, {
						isMeshVisible: a => this.navigator.IsMeshVisible(a)
					})
				}), this.parameters.fileInput.addEventListener("change", a => {
					a.target.files.length > 0 && (vn("model_load_started", "open_file"), this.LoadModelFromFileList(a.target.files))
				})
			}
			InitDragAndDrop() {
				window.addEventListener("dragstart", e => {
					e.preventDefault()
				}, !1), window.addEventListener("dragover", e => {
					e.stopPropagation(), e.preventDefault(), e.dataTransfer.dropEffect = "copy"
				}, !1), window.addEventListener("drop", e => {
					e.stopPropagation(), e.preventDefault(), fg(e.dataTransfer, t => {
						t.length > 0 && (vn("model_load_started", "drop"), this.LoadModelFromFileList(t))
					})
				}, !1)
			}
			InitSidebar() {
				this.sidebar.Init({
					getShadingType: () => this.viewer.GetShadingType(),
					getCameraMode: () => this.viewer.GetCameraMode(),
					hasDefaultMaterial: () => Nv(this.model),
					onEnvironmentMapChanged: () => {
						this.settings.SaveToCookies(), this.UpdateEnvironmentMap(), this.measureTool.IsActive() && this.measureTool.UpdatePanel()
					},
					onBackgroundColorChanged: () => {
						this.settings.SaveToCookies(), this.viewer.SetBackgroundColor(this.settings.backgroundColor), this.measureTool.IsActive() && this.measureTool.UpdatePanel()
					},
					onDefaultColorChanged: () => {
						this.settings.SaveToCookies();
						let e = this.modelLoaderUI.GetModelLoader();
						e.GetDefaultMaterial() !== null && (fp(this.model, this.settings.defaultColor), e.ReplaceDefaultMaterialColor(this.settings.defaultColor)), this.viewer.Render()
					},
					onEdgeDisplayChanged: () => {
						vn("edge_display_changed", this.settings.showEdges ? "on" : "off"), this.UpdateEdgeDisplay()
					},
					onThemeChanged: () => {
						vn("theme_changed", this.settings.themeId === ii.Light ? "light" : "dark"), this.SwitchTheme(this.settings.themeId, !0)
					},
					onResizeRequested: () => {
						this.Resize()
					},
					onShowHidePanels: e => {
						ko("ov_show_sidebar", e)
					}
				})
			}
			InitNavigator() {
				function e(s, o) {
					let a = null;
					return s.EnumerateMeshesUserData(c => {
						c.originalMeshId.IsEqual(o) && (a = c)
					}), a
				}

				function t(s, o, a) {
					let c = [];
					return s.EnumerateMeshesUserData(l => {
						if (a === null || l.originalMaterials.indexOf(a) !== -1) {
							let u = o.GetMesh(l.originalMeshId.meshIndex);
							c.push({
								meshId: l.originalMeshId,
								name: u.GetName()
							})
						}
					}), c
				}

				function n(s, o) {
					let a = s.GetMaterial(o);
					return {
						index: o,
						name: a.name,
						color: a.color.Clone()
					}
				}

				function i(s, o, a) {
					let c = [];
					if (a === null)
						for (let l = 0; l < o.MaterialCount(); l++) c.push(n(o, l));
					else {
						let l = e(s, a);
						for (let u = 0; u < l.originalMaterials.length; u++) {
							let h = l.originalMaterials[u];
							c.push(n(o, h))
						}
					}
					return c.sort((l, u) => l.index - u.index), c
				}
				this.navigator.Init({
					openFileBrowserDialog: () => {
						this.OpenFileBrowserDialog()
					},
					fitMeshToWindow: s => {
						this.FitMeshToWindow(s)
					},
					fitMeshesToWindow: s => {
						this.FitMeshesToWindow(s)
					},
					getMeshesForMaterial: s => t(this.viewer, this.model, s),
					getMaterialsForMesh: s => i(this.viewer, this.model, s),
					onMeshVisibilityChanged: () => {
						this.UpdateMeshesVisibility()
					},
					onMeshSelectionChanged: () => {
						this.UpdateMeshesSelection()
					},
					onSelectionCleared: () => {
						this.sidebar.AddObject3DProperties(this.model)
					},
					onMeshSelected: s => {
						let o = this.model.GetMeshInstance(s);
						this.sidebar.AddObject3DProperties(o)
					},
					onMaterialSelected: s => {
						this.sidebar.AddMaterialProperties(this.model.GetMaterial(s))
					},
					onResizeRequested: () => {
						this.Resize()
					},
					onShowHidePanels: s => {
						ko("ov_show_navigator", s)
					}
				})
			}
			UpdatePanelsVisibility() {
				let e = Oo("ov_show_navigator", !0),
					t = Oo("ov_show_sidebar", !0);
				this.navigator.ShowPanels(e), this.sidebar.ShowPanels(t)
			}
		};

	function y1(r) {
		vg(r)
	}

	function _1(r) {
		bf(r), window.addEventListener("load", () => {
			new vf({
					headerDiv: document.getElementById("header"),
					toolbarDiv: document.getElementById("toolbar"),
					mainDiv: document.getElementById("main"),
					introDiv: document.getElementById("intro"),
					fileNameDiv: document.getElementById("main_file_name"),
					navigatorDiv: document.getElementById("main_navigator"),
					navigatorSplitterDiv: document.getElementById("main_navigator_splitter"),
					sidebarDiv: document.getElementById("main_sidebar"),
					sidebarSplitterDiv: document.getElementById("main_sidebar_splitter"),
					viewerDiv: document.getElementById("main_viewer"),
					fileInput: document.getElementById("open_file")
				})
				.Load()
		})
	}

	function b1(r) {
		bf(r), window.addEventListener("load", () => {
			new Hh({
					viewerDiv: document.getElementById("embed_viewer"),
					websiteLinkDiv: document.getElementById("website_link")
				})
				.Load()
		})
	}

	function M1(r, e, t, n) {
		let i = ms("a");
		return i.setAttribute("href", n), i.setAttribute("target", "_blank"), i.setAttribute("rel", "noopener noreferrer"), Ec(i, t), Xn(i, e, "header_button"), r.appendChild(i), i
	}
	return My(w1);
})();
