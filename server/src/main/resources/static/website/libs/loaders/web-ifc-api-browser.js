var WebIFC = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = (x) => {
    if (typeof require !== "undefined")
      return require(x);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // dist/web-ifc-mt.js
  var require_web_ifc_mt = __commonJS({
    "dist/web-ifc-mt.js"(exports, module) {
      var WebIFCWasm2 = function() {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir = _scriptDir || __filename;
        return function(WebIFCWasm3) {
          WebIFCWasm3 = WebIFCWasm3 || {};
          function GROWABLE_HEAP_I8() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP8;
          }
          function GROWABLE_HEAP_U8() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU8;
          }
          function GROWABLE_HEAP_I16() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP16;
          }
          function GROWABLE_HEAP_U16() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU16;
          }
          function GROWABLE_HEAP_I32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAP32;
          }
          function GROWABLE_HEAP_U32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPU32;
          }
          function GROWABLE_HEAP_F32() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPF32;
          }
          function GROWABLE_HEAP_F64() {
            if (wasmMemory.buffer != buffer) {
              updateGlobalBufferAndViews(wasmMemory.buffer);
            }
            return HEAPF64;
          }
          var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key];
            }
          }
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window === "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
          var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
          var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;
          var nodeFS;
          var nodePath;
          if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            readAsync = function readAsync2(filename, onload, onerror) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              nodeFS["readFile"](filename, function(err2, data) {
                if (err2)
                  onerror(err2);
                else
                  onload(data.buffer);
              });
            };
            if (process["argv"].length > 1) {
              thisProgram = process["argv"][1].replace(/\\/g, "/");
            }
            arguments_ = process["argv"].slice(2);
            process["on"]("uncaughtException", function(ex) {
              if (!(ex instanceof ExitStatus)) {
                throw ex;
              }
            });
            process["on"]("unhandledRejection", abort);
            quit_ = function(status, toThrow) {
              if (keepRuntimeAlive()) {
                process["exitCode"] = status;
                throw toThrow;
              }
              process["exit"](status);
            };
            Module["inspect"] = function() {
              return "[Emscripten Module object]";
            };
            var nodeWorkerThreads;
            try {
              nodeWorkerThreads = __require("worker_threads");
            } catch (e) {
              console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
              throw e;
            }
            global.Worker = nodeWorkerThreads.Worker;
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document !== "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            if (ENVIRONMENT_IS_NODE) {
              read_ = function shell_read(filename, binary) {
                if (!nodeFS)
                  nodeFS = __require("fs");
                if (!nodePath)
                  nodePath = __require("path");
                filename = nodePath["normalize"](filename);
                return nodeFS["readFileSync"](filename, binary ? null : "utf8");
              };
              readBinary = function readBinary2(filename) {
                var ret = read_(filename, true);
                if (!ret.buffer) {
                  ret = new Uint8Array(ret);
                }
                assert(ret.buffer);
                return ret;
              };
              readAsync = function readAsync2(filename, onload, onerror) {
                if (!nodeFS)
                  nodeFS = __require("fs");
                if (!nodePath)
                  nodePath = __require("path");
                filename = nodePath["normalize"](filename);
                nodeFS["readFile"](filename, function(err2, data) {
                  if (err2)
                    onerror(err2);
                  else
                    onload(data.buffer);
                });
              };
            } else {
              read_ = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = function(url) {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = function(url, onload, onerror) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = function() {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload(xhr.response);
                    return;
                  }
                  onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
              };
            }
            setWindowTitle = function(title) {
              document.title = title;
            };
          } else {
          }
          if (ENVIRONMENT_IS_NODE) {
            if (typeof performance === "undefined") {
              global.performance = __require("perf_hooks").performance;
            }
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var STACK_ALIGN = 16;
          function alignMemory(size, factor) {
            if (!factor)
              factor = STACK_ALIGN;
            return Math.ceil(size / factor) * factor;
          }
          function warnOnce(text) {
            if (!warnOnce.shown)
              warnOnce.shown = {};
            if (!warnOnce.shown[text]) {
              warnOnce.shown[text] = 1;
              err(text);
            }
          }
          var tempRet0 = 0;
          var setTempRet0 = function(value) {
            tempRet0 = value;
          };
          var Atomics_load = Atomics.load;
          var Atomics_store = Atomics.store;
          var Atomics_compareExchange = Atomics.compareExchange;
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime = Module["noExitRuntime"] || true;
          if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var wasmModule;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text);
            }
          }
          function TextDecoderWrapper(encoding) {
            var textDecoder = new TextDecoder(encoding);
            this.decode = function(data) {
              if (data.buffer instanceof SharedArrayBuffer) {
                data = new Uint8Array(data);
              }
              return textDecoder.decode.call(textDecoder, data);
            };
          }
          var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf8") : void 0;
          function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              while (idx < endPtr) {
                var u0 = heap[idx++ >>> 0];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue;
                }
                var u1 = heap[idx++ >>> 0] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode((u0 & 31) << 6 | u1);
                  continue;
                }
                var u2 = heap[idx++ >>> 0] & 63;
                if ((u0 & 240) == 224) {
                  u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                } else {
                  u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0);
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                }
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343)
                u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
              if (u <= 127)
                ++len;
              else if (u <= 2047)
                len += 2;
              else if (u <= 65535)
                len += 3;
              else
                len += 4;
            }
            return len;
          }
          var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf-16le") : void 0;
          function UTF16ToString(ptr, maxBytesToRead) {
            var endPtr = ptr;
            var idx = endPtr >> 1;
            var maxIdx = idx + maxBytesToRead / 2;
            while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx >>> 0])
              ++idx;
            endPtr = idx << 1;
            if (endPtr - ptr > 32 && UTF16Decoder) {
              return UTF16Decoder.decode(GROWABLE_HEAP_U8().subarray(ptr >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
                var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >>> 1];
                if (codeUnit == 0)
                  break;
                str += String.fromCharCode(codeUnit);
              }
              return str;
            }
          }
          function stringToUTF16(str, outPtr, maxBytesToWrite) {
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i = 0; i < numCharsToWrite; ++i) {
              var codeUnit = str.charCodeAt(i);
              GROWABLE_HEAP_I16()[outPtr >>> 1] = codeUnit;
              outPtr += 2;
            }
            GROWABLE_HEAP_I16()[outPtr >>> 1] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF16(str) {
            return str.length * 2;
          }
          function UTF32ToString(ptr, maxBytesToRead) {
            var i = 0;
            var str = "";
            while (!(i >= maxBytesToRead / 4)) {
              var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >>> 2];
              if (utf32 == 0)
                break;
              ++i;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          }
          function stringToUTF32(str, outPtr, maxBytesToWrite) {
            outPtr >>>= 0;
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              GROWABLE_HEAP_I32()[outPtr >>> 2] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            GROWABLE_HEAP_I32()[outPtr >>> 2] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF32(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i;
              len += 4;
            }
            return len;
          }
          function writeArrayToMemory(array, buffer2) {
            GROWABLE_HEAP_I8().set(array, buffer2 >>> 0);
          }
          function writeAsciiToMemory(str, buffer2, dontAddNull) {
            for (var i = 0; i < str.length; ++i) {
              GROWABLE_HEAP_I8()[buffer2++ >>> 0] = str.charCodeAt(i);
            }
            if (!dontAddNull)
              GROWABLE_HEAP_I8()[buffer2 >>> 0] = 0;
          }
          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple;
            }
            return x;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          if (ENVIRONMENT_IS_PTHREAD) {
            buffer = Module["buffer"];
          }
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          if (ENVIRONMENT_IS_PTHREAD) {
            wasmMemory = Module["wasmMemory"];
            buffer = Module["buffer"];
          } else {
            if (Module["wasmMemory"]) {
              wasmMemory = Module["wasmMemory"];
            } else {
              wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536, "shared": true });
              if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
                err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
                if (ENVIRONMENT_IS_NODE) {
                  console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
                }
                throw Error("bad memory");
              }
            }
          }
          if (wasmMemory) {
            buffer = wasmMemory.buffer;
          }
          INITIAL_MEMORY = buffer.byteLength;
          updateGlobalBufferAndViews(buffer);
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATEXIT__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeExited = false;
          var runtimeKeepaliveCounter = 0;
          function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
          }
          function preRun() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            FS.ignorePermissions = false;
            TTY.init();
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            callRuntimeCallbacks(__ATMAIN__);
          }
          function exitRuntime() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            runtimeExited = true;
          }
          function postRun() {
            if (ENVIRONMENT_IS_PTHREAD)
              return;
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module["preloadedImages"] = {};
          Module["preloadedAudios"] = {};
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            if (ENVIRONMENT_IS_PTHREAD)
              console.error("Pthread aborting at " + new Error().stack);
            what += "";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
          }
          function isFileURI(filename) {
            return filename.startsWith("file://");
          }
          var wasmBinaryFile;
          wasmBinaryFile = "web-ifc-mt.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary(file) {
            try {
              if (file == wasmBinaryFile && wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(file);
              } else {
                throw "both async and sync fetching of the wasm failed";
              }
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(function() {
                  return getBinary(wasmBinaryFile);
                });
              } else {
                if (readAsync) {
                  return new Promise(function(resolve, reject) {
                    readAsync(wasmBinaryFile, function(response) {
                      resolve(new Uint8Array(response));
                    }, reject);
                  });
                }
              }
            }
            return Promise.resolve().then(function() {
              return getBinary(wasmBinaryFile);
            });
          }
          function createWasm() {
            var info = { "a": asmLibraryArg };
            function receiveInstance(instance, module2) {
              var exports3 = instance.exports;
              Module["asm"] = exports3;
              wasmTable = Module["asm"]["ta"];
              addOnInit(Module["asm"]["oa"]);
              PThread.tlsInitFunctions.push(Module["asm"]["sa"]);
              wasmModule = module2;
              if (!ENVIRONMENT_IS_PTHREAD) {
                var numWorkersToLoad = PThread.unusedWorkers.length;
                PThread.unusedWorkers.forEach(function(w) {
                  PThread.loadWasmModuleToWorker(w, function() {
                    if (!--numWorkersToLoad)
                      removeRunDependency("wasm-instantiate");
                  });
                });
              }
            }
            if (!ENVIRONMENT_IS_PTHREAD) {
              addRunDependency("wasm-instantiate");
            }
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"], result["module"]);
            }
            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                var result = WebAssembly.instantiate(binary, info);
                return result;
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason);
              });
            }
            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiationResult, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    return instantiateArrayBuffer(receiveInstantiationResult);
                  });
                });
              } else {
                return instantiateArrayBuffer(receiveInstantiationResult);
              }
            }
            if (Module["instantiateWasm"]) {
              try {
                var exports2 = Module["instantiateWasm"](info, receiveInstance);
                return exports2;
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
              }
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          var ASM_CONSTS = { 44848: function() {
            throw "Canceled!";
          }, 44866: function($0, $1) {
            setTimeout(function() {
              __emscripten_do_dispatch_to_thread($0, $1);
            }, 0);
          } };
          function initPthreadsJS() {
            PThread.initRuntime();
          }
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback(Module);
                continue;
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === void 0) {
                  wasmTable.get(func)();
                } else {
                  wasmTable.get(func)(callback.arg);
                }
              } else {
                func(callback.arg === void 0 ? null : callback.arg);
              }
            }
          }
          function _emscripten_futex_wake(addr, count) {
            if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
              return -28;
            if (count == 0)
              return 0;
            if (count >= 2147483647)
              count = Infinity;
            var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2);
            var mainThreadWoken = 0;
            if (mainThreadWaitAddress == addr) {
              var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, mainThreadWaitAddress, 0);
              if (loadedAddr == mainThreadWaitAddress) {
                --count;
                mainThreadWoken = 1;
                if (count <= 0)
                  return 1;
              }
            }
            var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
            if (ret >= 0)
              return ret + mainThreadWoken;
            throw "Atomics.notify returned an unexpected value " + ret;
          }
          Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
          function killThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! killThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in killThread!";
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
            var pthread = PThread.pthreads[pthread_ptr];
            pthread.worker.terminate();
            PThread.freeThreadData(pthread);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
            pthread.worker.pthread = void 0;
          }
          function cancelThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! cancelThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in cancelThread!";
            var pthread = PThread.pthreads[pthread_ptr];
            pthread.worker.postMessage({ "cmd": "cancel" });
          }
          function cleanupThread(pthread_ptr) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
            if (!pthread_ptr)
              throw "Internal Error! Null pthread_ptr in cleanupThread!";
            var pthread = PThread.pthreads[pthread_ptr];
            if (pthread) {
              GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
              var worker = pthread.worker;
              PThread.returnWorkerToPool(worker);
            }
          }
          var PThread = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], initMainThreadBlock: function() {
            var pthreadPoolSize = navigator.hardwareConcurrency;
            for (var i = 0; i < pthreadPoolSize; ++i) {
              PThread.allocateUnusedWorker();
            }
          }, initRuntime: function() {
            var tb = _malloc(228);
            for (var i = 0; i < 228 / 4; ++i)
              GROWABLE_HEAP_U32()[tb / 4 + i >>> 0] = 0;
            GROWABLE_HEAP_I32()[tb + 12 >>> 2] = tb;
            var headPtr = tb + 152;
            GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
            var tlsMemory = _malloc(512);
            for (var i = 0; i < 128; ++i)
              GROWABLE_HEAP_U32()[tlsMemory / 4 + i >>> 0] = 0;
            Atomics.store(GROWABLE_HEAP_U32(), tb + 100 >> 2, tlsMemory);
            Atomics.store(GROWABLE_HEAP_U32(), tb + 40 >> 2, tb);
            __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1);
            _emscripten_register_main_browser_thread_id(tb);
          }, initWorker: function() {
          }, pthreads: {}, threadExitHandlers: [], runExitHandlers: function() {
            while (PThread.threadExitHandlers.length > 0) {
              PThread.threadExitHandlers.pop()();
            }
            ___pthread_tsd_run_dtors();
          }, runExitHandlersAndDeinitThread: function(tb, exitCode) {
            Atomics.store(GROWABLE_HEAP_U32(), tb + 56 >> 2, 1);
            Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 0);
            PThread.runExitHandlers();
            Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
            Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
            _emscripten_futex_wake(tb + 0, 2147483647);
            __emscripten_thread_init(0, 0, 0);
          }, setExitStatus: function(status) {
            EXITSTATUS = status;
          }, threadExit: function(exitCode) {
            var tb = _pthread_self();
            if (tb) {
              PThread.runExitHandlersAndDeinitThread(tb, exitCode);
              if (ENVIRONMENT_IS_PTHREAD) {
                postMessage({ "cmd": "exit" });
              }
            }
          }, threadCancel: function() {
            PThread.runExitHandlersAndDeinitThread(_pthread_self(), -1);
            postMessage({ "cmd": "cancelDone" });
          }, terminateAllThreads: function() {
            for (var t in PThread.pthreads) {
              var pthread = PThread.pthreads[t];
              if (pthread && pthread.worker) {
                PThread.returnWorkerToPool(pthread.worker);
              }
            }
            PThread.pthreads = {};
            for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
              var worker = PThread.unusedWorkers[i];
              worker.terminate();
            }
            PThread.unusedWorkers = [];
            for (var i = 0; i < PThread.runningWorkers.length; ++i) {
              var worker = PThread.runningWorkers[i];
              var pthread = worker.pthread;
              PThread.freeThreadData(pthread);
              worker.terminate();
            }
            PThread.runningWorkers = [];
          }, freeThreadData: function(pthread) {
            if (!pthread)
              return;
            if (pthread.threadInfoStruct) {
              var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2];
              GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2] = 0;
              _free(tlsMemory);
              _free(pthread.threadInfoStruct);
            }
            pthread.threadInfoStruct = 0;
            if (pthread.allocatedOwnStack && pthread.stackBase)
              _free(pthread.stackBase);
            pthread.stackBase = 0;
            if (pthread.worker)
              pthread.worker.pthread = null;
          }, returnWorkerToPool: function(worker) {
            PThread.runWithoutMainThreadQueuedCalls(function() {
              delete PThread.pthreads[worker.pthread.threadInfoStruct];
              PThread.unusedWorkers.push(worker);
              PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
              PThread.freeThreadData(worker.pthread);
              worker.pthread = void 0;
            });
          }, runWithoutMainThreadQueuedCalls: function(func) {
            GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 0;
            try {
              func();
            } finally {
              GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 1;
            }
          }, receiveObjectTransfer: function(data) {
          }, threadInit: function() {
            for (var i in PThread.tlsInitFunctions) {
              PThread.tlsInitFunctions[i]();
            }
          }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
            worker.onmessage = function(e) {
              var d = e["data"];
              var cmd = d["cmd"];
              if (worker.pthread)
                PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
              if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
                var thread = PThread.pthreads[d.targetThread];
                if (thread) {
                  thread.worker.postMessage(e.data, d["transferList"]);
                } else {
                  console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
                }
                PThread.currentProxiedOperationCallerThread = void 0;
                return;
              }
              if (cmd === "processQueuedMainThreadWork") {
                _emscripten_main_thread_process_queued_calls();
              } else if (cmd === "spawnThread") {
                spawnThread(e.data);
              } else if (cmd === "cleanupThread") {
                cleanupThread(d["thread"]);
              } else if (cmd === "killThread") {
                killThread(d["thread"]);
              } else if (cmd === "cancelThread") {
                cancelThread(d["thread"]);
              } else if (cmd === "loaded") {
                worker.loaded = true;
                if (onFinishedLoading)
                  onFinishedLoading(worker);
                if (worker.runPthread) {
                  worker.runPthread();
                  delete worker.runPthread;
                }
              } else if (cmd === "print") {
                out("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "printErr") {
                err("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "alert") {
                alert("Thread " + d["threadId"] + ": " + d["text"]);
              } else if (cmd === "exit") {
                var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.threadInfoStruct + 64 >> 2);
                if (detached) {
                  PThread.returnWorkerToPool(worker);
                }
              } else if (cmd === "exitProcess") {
                try {
                  exit(d["returnCode"]);
                } catch (e2) {
                  if (e2 instanceof ExitStatus)
                    return;
                  throw e2;
                }
              } else if (cmd === "cancelDone") {
                PThread.returnWorkerToPool(worker);
              } else if (cmd === "objectTransfer") {
                PThread.receiveObjectTransfer(e.data);
              } else if (e.data.target === "setimmediate") {
                worker.postMessage(e.data);
              } else {
                err("worker sent an unknown command " + cmd);
              }
              PThread.currentProxiedOperationCallerThread = void 0;
            };
            worker.onerror = function(e) {
              err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
            };
            if (ENVIRONMENT_IS_NODE) {
              worker.on("message", function(data) {
                worker.onmessage({ data });
              });
              worker.on("error", function(data) {
                worker.onerror(data);
              });
              worker.on("exit", function(data) {
              });
            }
            worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
          }, allocateUnusedWorker: function() {
            var pthreadMainJs = locateFile("web-ifc-mt.worker.js");
            PThread.unusedWorkers.push(new Worker(pthreadMainJs));
          }, getNewWorker: function() {
            if (PThread.unusedWorkers.length == 0) {
              PThread.allocateUnusedWorker();
              PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
            }
            return PThread.unusedWorkers.pop();
          }, busySpinWait: function(msecs) {
            var t = performance.now() + msecs;
            while (performance.now() < t) {
            }
          } };
          function establishStackSpace(stackTop, stackMax) {
            _emscripten_stack_set_limits(stackTop, stackMax);
            stackRestore(stackTop);
          }
          Module["establishStackSpace"] = establishStackSpace;
          function invokeEntryPoint(ptr, arg) {
            return wasmTable.get(ptr)(arg);
          }
          Module["invokeEntryPoint"] = invokeEntryPoint;
          function ___assert_fail(condition, filename, line, func) {
            abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            _emscripten_get_now = function() {
              var t = process["hrtime"]();
              return t[0] * 1e3 + t[1] / 1e6;
            };
          } else if (ENVIRONMENT_IS_PTHREAD) {
            _emscripten_get_now = function() {
              return performance.now() - Module["__performance_now_clock_drift"];
            };
          } else
            _emscripten_get_now = function() {
              return performance.now();
            };
          var _emscripten_get_now_is_monotonic = true;
          function setErrNo(value) {
            GROWABLE_HEAP_I32()[___errno_location() >>> 2] = value;
            return value;
          }
          function _clock_gettime(clk_id, tp) {
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
              now = _emscripten_get_now();
            } else {
              setErrNo(28);
              return -1;
            }
            GROWABLE_HEAP_I32()[tp >>> 2] = now / 1e3 | 0;
            GROWABLE_HEAP_I32()[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
            return 0;
          }
          function ___cxa_allocate_exception(size) {
            return _malloc(size + 16) + 16;
          }
          function _atexit(func, arg) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
          }
          function ___cxa_thread_atexit(routine, arg) {
            PThread.threadExitHandlers.push(function() {
              wasmTable.get(routine)(arg);
            });
          }
          function ExceptionInfo(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - 16;
            this.set_type = function(type) {
              GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = type;
            };
            this.get_type = function() {
              return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
            };
            this.set_destructor = function(destructor) {
              GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2] = destructor;
            };
            this.get_destructor = function() {
              return GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2];
            };
            this.set_refcount = function(refcount) {
              GROWABLE_HEAP_I32()[this.ptr >>> 2] = refcount;
            };
            this.set_caught = function(caught) {
              caught = caught ? 1 : 0;
              GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] = caught;
            };
            this.get_caught = function() {
              return GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] != 0;
            };
            this.set_rethrown = function(rethrown) {
              rethrown = rethrown ? 1 : 0;
              GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] = rethrown;
            };
            this.get_rethrown = function() {
              return GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] != 0;
            };
            this.init = function(type, destructor) {
              this.set_type(type);
              this.set_destructor(destructor);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              Atomics.add(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
            };
            this.release_ref = function() {
              var prev = Atomics.sub(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
              return prev === 1;
            };
          }
          var exceptionLast = 0;
          var uncaughtExceptionCount = 0;
          function ___cxa_throw(ptr, type, destructor) {
            var info = new ExceptionInfo(ptr);
            info.init(type, destructor);
            exceptionLast = ptr;
            uncaughtExceptionCount++;
            throw ptr;
          }
          var PATH = { splitPath: function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: function(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: function(path) {
            var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: function(path) {
            if (path === "/")
              return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1)
              return path;
            return path.substr(lastSlash + 1);
          }, extname: function(path) {
            return PATH.splitPath(path)[3];
          }, join: function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, join2: function(l, r) {
            return PATH.normalize(l + "/" + r);
          } };
          function getRandomDevice() {
            if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
              var randomBuffer = new Uint8Array(1);
              return function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = require_crypto();
                return function() {
                  return crypto_module["randomBytes"](1)[0];
                };
              } catch (e) {
              }
            }
            return function() {
              abort("randomDevice");
            };
          }
          var PATH_FS = { resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: function(from, to) {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var TTY = { ttys: [], init: function() {
          }, shutdown: function() {
          }, register: function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open: function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(43);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, flush: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, read: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(60);
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(60);
            }
            try {
              for (var i = 0; i < length; i++) {
                stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
              }
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } }, default_tty_ops: { get_char: function(tty) {
            if (!tty.input.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc(BUFSIZE);
                var bytesRead = 0;
                try {
                  bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              tty.input = intArrayFromString(result, true);
            }
            return tty.input.shift();
          }, put_char: function(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } }, default_tty1_ops: { put_char: function(tty, val) {
            if (val === null || val === 10) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          function zeroMemory(address, size) {
            GROWABLE_HEAP_U8().fill(0, address, address + size);
          }
          function mmapAlloc(size) {
            size = alignMemory(size, 65536);
            var ptr = _memalign(65536, size);
            if (!ptr)
              return 0;
            zeroMemory(ptr, size);
            return ptr;
          }
          var MEMFS = { ops_table: null, mount: function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode: function(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            }
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          }, getFileDataAsTypedArray: function(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage: function(node, newCapacity) {
            newCapacity >>>= 0;
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          }, resizeFileStorage: function(node, newSize) {
            newSize >>>= 0;
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          }, node_ops: { getattr: function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup: function(parent, name2) {
            throw FS.genericErrors[44];
          }, mknod: function(parent, name2, mode, dev) {
            return MEMFS.createNode(parent, name2, mode, dev);
          }, rename: function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i in new_node.contents) {
                  throw new FS.ErrnoError(55);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.parent.timestamp = Date.now();
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            new_dir.timestamp = old_node.parent.timestamp;
            old_node.parent = new_dir;
          }, unlink: function(parent, name2) {
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, rmdir: function(parent, name2) {
            var node = FS.lookupNode(parent, name2);
            for (var i in node.contents) {
              throw new FS.ErrnoError(55);
            }
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink: function(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            return node.link;
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes)
              return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            if (size > 8 && contents.subarray) {
              buffer2.set(contents.subarray(position, position + size), offset);
            } else {
              for (var i = 0; i < size; i++)
                buffer2[offset + i] = contents[position + i];
            }
            return size;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            if (buffer2.buffer === GROWABLE_HEAP_I8().buffer) {
              canOwn = false;
            }
            if (!length)
              return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer2.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = buffer2.slice(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer2.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer2.subarray) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
            } else {
              for (var i = 0; i < length; i++) {
                node.contents[position + i] = buffer2[offset + i];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(28);
            }
            return position;
          }, allocate: function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            if (address !== 0) {
              throw new FS.ErrnoError(28);
            }
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && contents.buffer === buffer) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              allocated = true;
              ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              ptr >>>= 0;
              GROWABLE_HEAP_I8().set(contents, ptr >>> 0);
            }
            return { ptr, allocated };
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
            return 0;
          } } };
          function asyncLoad(url, onload, onerror, noRunDep) {
            var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
            readAsync(url, function(arrayBuffer) {
              assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
              onload(new Uint8Array(arrayBuffer));
              if (dep)
                removeRunDependency(dep);
            }, function(event) {
              if (onerror) {
                onerror();
              } else {
                throw 'Loading data file "' + url + '" failed.';
              }
            });
            if (dep)
              addRunDependency(dep);
          }
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path)
              return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), false);
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath: function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path)
                  return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, hashName: function(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode: function(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          }, createNode: function(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode: function(node) {
            FS.hashRemoveNode(node);
          }, isRoot: function(node) {
            return node === node.parent;
          }, isMountpoint: function(node) {
            return !!node.mounted;
          }, isFile: function(mode) {
            return (mode & 61440) === 32768;
          }, isDir: function(mode) {
            return (mode & 61440) === 16384;
          }, isLink: function(mode) {
            return (mode & 61440) === 40960;
          }, isChrdev: function(mode) {
            return (mode & 61440) === 8192;
          }, isBlkdev: function(mode) {
            return (mode & 61440) === 24576;
          }, isFIFO: function(mode) {
            return (mode & 61440) === 4096;
          }, isSocket: function(mode) {
            return (mode & 49152) === 49152;
          }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, flagsToPermissionString: function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions: function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, mayLookup: function(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          }, mayCreate: function(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete: function(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, mayOpen: function(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          }, getStream: function(fd) {
            return FS.streams[fd];
          }, createStream: function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = { object: { get: function() {
                return this.node;
              }, set: function(val) {
                this.node = val;
              } }, isRead: { get: function() {
                return (this.flags & 2097155) !== 1;
              } }, isWrite: { get: function() {
                return (this.flags & 2097155) !== 0;
              } }, isAppend: { get: function() {
                return this.flags & 1024;
              } } };
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, closeStream: function(fd) {
            FS.streams[fd] = null;
          }, chrdev_stream_ops: { open: function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
          }, llseek: function() {
            throw new FS.ErrnoError(70);
          } }, major: function(dev) {
            return dev >> 8;
          }, minor: function(dev) {
            return dev & 255;
          }, makedev: function(ma, mi) {
            return ma << 8 | mi;
          }, registerDevice: function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: function(dev) {
            return FS.devices[dev];
          }, getMounts: function(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          }, syncfs: function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount: function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount: function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup: function(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          }, mknod: function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          }, create: function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, mkdir: function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, mkdirTree: function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i])
                continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          }, mkdev: function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, symlink: function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename: function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"])
                FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
          }, rmdir: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, unlink: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readlink: function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat: function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, lstat: function(path) {
            return FS.stat(path, true);
          }, chmod: function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
          }, lchmod: function(path, mode) {
            FS.chmod(path, mode, true);
          }, fchmod: function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          }, chown: function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown: function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown: function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          }, truncate: function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate: function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, utime: function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open: function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512 | 131072);
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                err("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            }
            return stream;
          }, close: function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed: function(stream) {
            return stream.fd === null;
          }, llseek: function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read: function(stream, buffer2, offset, length, position) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"])
                FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            }
            return bytesWritten;
          }, allocate: function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            address >>>= 0;
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            offset >>>= 0;
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
          }, munmap: function(stream) {
            return 0;
          }, ioctl: function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile: function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile: function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: function() {
            return FS.currentPath;
          }, chdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories: function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices: function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: function() {
              return 0;
            }, write: function(stream, buffer2, offset, length, pos) {
              return length;
            } });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device = getRandomDevice();
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories: function() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount: function() {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = { lookup: function(parent, name2) {
                var fd = +name2;
                var stream = FS.getStream(fd);
                if (!stream)
                  throw new FS.ErrnoError(8);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                  return stream.path;
                } } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams: function() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
          }, ensureErrnoError: function() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, staticInit: function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { "MEMFS": MEMFS };
          }, init: function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          }, quit: function() {
            FS.init.initialized = false;
            var fflush = Module["_fflush"];
            if (fflush)
              fflush(0);
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, getMode: function(canRead, canWrite) {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          }, findObject: function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              return null;
            }
          }, analyzePath: function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createPath: function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile: function(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, createDevice: function(parent, name2, input, output) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open: function(stream) {
              stream.seekable = false;
            }, close: function(stream) {
              if (output && output.buffer && output.buffer.length) {
                output(10);
              }
            }, read: function(stream, buffer2, offset, length, pos) {
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer2[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write: function(stream, buffer2, offset, length, pos) {
              for (var i = 0; i < length; i++) {
                try {
                  output(buffer2[offset + i]);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            } });
            return FS.mkdev(path, mode, dev);
          }, forceLoadFile: function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = function(from, to) {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined")
                  xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, { length: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              } }, chunkSize: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              } } });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
              FS.forceLoadFile(node);
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents.get(position + i);
                }
              }
              return size;
            };
            node.stream_ops = stream_ops;
            return node;
          }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            var dep = getUniqueRunDependency("cp " + fullname);
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish)
                  preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                if (onload)
                  onload();
                removeRunDependency(dep);
              }
              var handled = false;
              Module["preloadPlugins"].forEach(function(plugin) {
                if (handled)
                  return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror)
                      onerror();
                    removeRunDependency(dep);
                  });
                  handled = true;
                }
              });
              if (!handled)
                finish(byteArray);
            }
            addRunDependency(dep);
            if (typeof url == "string") {
              asyncLoad(url, function(byteArray) {
                processData(byteArray);
              }, onerror);
            } else {
              processData(url);
            }
          }, indexedDB: function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, DB_NAME: function() {
            return "EM_FS_" + window.location.pathname;
          }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
              out("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                putRequest.onerror = function putRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          }, loadFilesFromDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                getRequest.onerror = function getRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          } };
          var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
            if (path[0] === "/") {
              return path;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = FS.getStream(dirfd);
              if (!dirstream)
                throw new FS.ErrnoError(8);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path);
          }, doStat: function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            GROWABLE_HEAP_I32()[buf >>> 2] = stat.dev;
            GROWABLE_HEAP_I32()[buf + 4 >>> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 8 >>> 2] = stat.ino;
            GROWABLE_HEAP_I32()[buf + 12 >>> 2] = stat.mode;
            GROWABLE_HEAP_I32()[buf + 16 >>> 2] = stat.nlink;
            GROWABLE_HEAP_I32()[buf + 20 >>> 2] = stat.uid;
            GROWABLE_HEAP_I32()[buf + 24 >>> 2] = stat.gid;
            GROWABLE_HEAP_I32()[buf + 28 >>> 2] = stat.rdev;
            GROWABLE_HEAP_I32()[buf + 32 >>> 2] = 0;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 40 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >>> 2] = tempI64[1];
            GROWABLE_HEAP_I32()[buf + 48 >>> 2] = 4096;
            GROWABLE_HEAP_I32()[buf + 52 >>> 2] = stat.blocks;
            GROWABLE_HEAP_I32()[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 60 >>> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 68 >>> 2] = 0;
            GROWABLE_HEAP_I32()[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
            GROWABLE_HEAP_I32()[buf + 76 >>> 2] = 0;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 80 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 84 >>> 2] = tempI64[1];
            return 0;
          }, doMsync: function(addr, stream, len, flags, offset) {
            var buffer2 = GROWABLE_HEAP_U8().slice(addr, addr + len);
            FS.msync(stream, buffer2, offset, len, flags);
          }, doMkdir: function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, doMknod: function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, doReadlink: function(path, buf, bufsize) {
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = GROWABLE_HEAP_I8()[buf + len >>> 0];
            stringToUTF8(ret, buf, bufsize + 1);
            GROWABLE_HEAP_I8()[buf + len >>> 0] = endChar;
            return len;
          }, doAccess: function(path, amode) {
            if (amode & ~7) {
              return -28;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          }, doDup: function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest)
              FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, doReadv: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
              var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
              var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len)
                break;
            }
            return ret;
          }, doWritev: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
              var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
              var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
            }
            return ret;
          }, varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >>> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }, getStreamFromFD: function(fd) {
            var stream = FS.getStream(fd);
            if (!stream)
              throw new FS.ErrnoError(8);
            return stream;
          }, get64: function(low, high) {
            return low;
          } };
          function ___sys_fcntl64(fd, cmd, varargs) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(2, 1, fd, cmd, varargs);
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (cmd) {
                case 0: {
                  var arg = SYSCALLS.get();
                  if (arg < 0) {
                    return -28;
                  }
                  var newStream;
                  newStream = FS.open(stream.path, stream.flags, 0, arg);
                  return newStream.fd;
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = SYSCALLS.get();
                  stream.flags |= arg;
                  return 0;
                }
                case 12: {
                  var arg = SYSCALLS.get();
                  var offset = 0;
                  GROWABLE_HEAP_I16()[arg + offset >>> 1] = 2;
                  return 0;
                }
                case 13:
                case 14:
                  return 0;
                case 16:
                case 8:
                  return -28;
                case 9:
                  setErrNo(28);
                  return -1;
                default: {
                  return -28;
                }
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_ioctl(fd, op, varargs) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(3, 1, fd, op, varargs);
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.get();
                  GROWABLE_HEAP_I32()[argp >>> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  abort("bad ioctl syscall " + op);
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_open(path, flags, varargs) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(4, 1, path, flags, varargs);
            SYSCALLS.varargs = varargs;
            try {
              var pathname = SYSCALLS.getStr(path);
              var mode = varargs ? SYSCALLS.get() : 0;
              var stream = FS.open(pathname, flags, mode);
              return stream.fd;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          var tupleRegistrations = {};
          function runDestructors(destructors) {
            while (destructors.length) {
              var ptr = destructors.pop();
              var del = destructors.pop();
              del(ptr);
            }
          }
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](GROWABLE_HEAP_U32()[pointer >>> 2]);
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;
          function makeLegalFunctionName(name2) {
            if (name2 === void 0) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name2;
            } else {
              return name2;
            }
          }
          function createNamedFunction(name2, body) {
            name2 = makeLegalFunctionName(name2);
            return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
          }
          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return this.name + ": " + this.message;
              }
            };
            return errorClass;
          }
          var InternalError = void 0;
          function throwInternalError(message) {
            throw new InternalError(message);
          }
          function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i = 0; i < myTypes.length; ++i) {
                registerType(myTypes[i], myTypeConverters[i]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach(function(dt, i) {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (unregisteredTypes.length === 0) {
              onComplete(typeConverters);
            }
          }
          function __embind_finalize_value_array(rawTupleType) {
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map(function(elt) {
              return elt.getterReturnType;
            }).concat(elements.map(function(elt) {
              return elt.setterArgumentType;
            }));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach(function(elt, i) {
                var getterReturnType = elementTypes2[i];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                };
                elt.write = function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = new Array(elementsLength);
                for (var i = 0; i < elementsLength; ++i) {
                  rv[i] = elements[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                if (elementsLength !== o.length) {
                  throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
                }
                var ptr = rawConstructor();
                for (var i = 0; i < elementsLength; ++i) {
                  elements[i].write(ptr, o[i]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          var structRegistrations = {};
          function __embind_finalize_value_object(structType) {
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map(function(field) {
              return field.getterReturnType;
            }).concat(fieldRecords.map(function(field) {
              return field.setterArgumentType;
            }));
            whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
              var fields = {};
              fieldRecords.forEach(function(field, i) {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = { read: function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                }, write: function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                } };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = {};
                for (var i in fields) {
                  rv[i] = fields[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError('Missing field:  "' + fieldName + '"');
                  }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
          }
          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size);
            }
          }
          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i = 0; i < 256; ++i) {
              codes[i] = String.fromCharCode(i);
            }
            embind_charCodes = codes;
          }
          var embind_charCodes = void 0;
          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (GROWABLE_HEAP_U8()[c >>> 0]) {
              ret += embind_charCodes[GROWABLE_HEAP_U8()[c++ >>> 0]];
            }
            return ret;
          }
          var BindingError = void 0;
          function throwBindingError(message) {
            throw new BindingError(message);
          }
          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError("Cannot register type '" + name2 + "' twice");
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb();
              });
            }
          }
          function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(wt) {
              return !!wt;
            }, "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
              var heap;
              if (size === 1) {
                heap = GROWABLE_HEAP_I8();
              } else if (size === 2) {
                heap = GROWABLE_HEAP_I16();
              } else if (size === 4) {
                heap = GROWABLE_HEAP_I32();
              } else {
                throw new TypeError("Unknown boolean type size: " + name2);
              }
              return this["fromWireType"](heap[pointer >>> shift]);
            }, destructorFunction: null });
          }
          function ClassHandle_isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }
          function shallowCopyInternalPointer(o) {
            return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
          }
          function throwInstanceAlreadyDeleted(obj) {
            function getInstanceTypeName(handle) {
              return handle.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          }
          var finalizationGroup = false;
          function detachFinalizer(handle) {
          }
          function runDestructor($$) {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          }
          function releaseClassHandle($$) {
            $$.count.value -= 1;
            var toDelete = $$.count.value === 0;
            if (toDelete) {
              runDestructor($$);
            }
          }
          function attachFinalizer(handle) {
            if (typeof FinalizationGroup === "undefined") {
              attachFinalizer = function(handle2) {
                return handle2;
              };
              return handle;
            }
            finalizationGroup = new FinalizationGroup(function(iter) {
              for (var result = iter.next(); !result.done; result = iter.next()) {
                var $$ = result.value;
                if (!$$.ptr) {
                  console.warn("object already deleted: " + $$.ptr);
                } else {
                  releaseClassHandle($$);
                }
              }
            });
            attachFinalizer = function(handle2) {
              finalizationGroup.register(handle2, handle2.$$, handle2.$$);
              return handle2;
            };
            detachFinalizer = function(handle2) {
              finalizationGroup.unregister(handle2.$$);
            };
            return attachFinalizer(handle);
          }
          function ClassHandle_clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }
          function ClassHandle_delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }
          function ClassHandle_isDeleted() {
            return !this.$$.ptr;
          }
          var delayFunction = void 0;
          var deletionQueue = [];
          function flushPendingDeletes() {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          }
          function ClassHandle_deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          }
          function init_ClassHandle() {
            ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
            ClassHandle.prototype["clone"] = ClassHandle_clone;
            ClassHandle.prototype["delete"] = ClassHandle_delete;
            ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
            ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
          }
          function ClassHandle() {
          }
          var registeredPointers = {};
          function ensureOverloadTable(proto, methodName, humanName) {
            if (proto[methodName].overloadTable === void 0) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          }
          function exposePublicSymbol(name2, value, numArguments) {
            if (Module.hasOwnProperty(name2)) {
              if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
                throwBindingError("Cannot register public name '" + name2 + "' twice");
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (numArguments !== void 0) {
                Module[name2].numArguments = numArguments;
              }
            }
          }
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          function upcastPointer(ptr, ptrClass, desiredClass) {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
              }
              ptr = ptrClass.upcast(ptr);
              ptrClass = ptrClass.baseClass;
            }
            return ptr;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function genericPointerToWireType(destructors, handle) {
            var ptr;
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
              } else {
                return 0;
              }
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (!this.isConst && handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (handle.$$.smartPtr === void 0) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                  }
                  break;
                case 1:
                  ptr = handle.$$.smartPtr;
                  break;
                case 2:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    var clonedHandle = handle["clone"]();
                    ptr = this.rawShare(ptr, __emval_register(function() {
                      clonedHandle["delete"]();
                    }));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function RegisteredPointer_getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }
          function RegisteredPointer_destructor(ptr) {
            if (this.rawDestructor) {
              this.rawDestructor(ptr);
            }
          }
          function RegisteredPointer_deleteObject(handle) {
            if (handle !== null) {
              handle["delete"]();
            }
          }
          function downcastPointer(ptr, ptrClass, desiredClass) {
            if (ptrClass === desiredClass) {
              return ptr;
            }
            if (desiredClass.baseClass === void 0) {
              return null;
            }
            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          }
          function getInheritedInstanceCount() {
            return Object.keys(registeredInstances).length;
          }
          function getLiveInheritedInstances() {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          }
          function setDelayFunction(fn) {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          }
          function init_embind() {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          }
          var registeredInstances = {};
          function getBasestPointer(class_, ptr) {
            if (ptr === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr = class_.upcast(ptr);
              class_ = class_.baseClass;
            }
            return ptr;
          }
          function getInheritedInstance(class_, ptr) {
            ptr = getBasestPointer(class_, ptr);
            return registeredInstances[ptr];
          }
          function makeClassHandle(prototype, record) {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = { value: 1 };
            return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
          }
          function RegisteredPointer_fromWireType(ptr) {
            var rawPointer = this.getPointee(ptr);
            if (!rawPointer) {
              this.destructor(ptr);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (registeredInstance !== void 0) {
              if (registeredInstance.$$.count.value === 0) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
            }
          }
          function init_RegisteredPointer() {
            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
            RegisteredPointer.prototype["argPackAdvance"] = 8;
            RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
            RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
            RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          function replacePublicSymbol(name2, value, numArguments) {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          }
          function dynCallLegacy(sig, ptr, args) {
            var f = Module["dynCall_" + sig];
            return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
          }
          function dynCall(sig, ptr, args) {
            if (sig.includes("j")) {
              return dynCallLegacy(sig, ptr, args);
            }
            return wasmTable.get(ptr).apply(null, args);
          }
          function getDynCaller(sig, ptr) {
            var argCache = [];
            return function() {
              argCache.length = arguments.length;
              for (var i = 0; i < arguments.length; i++) {
                argCache[i] = arguments[i];
              }
              return dynCall(sig, ptr, argCache);
            };
          }
          function embind__requireFunction(signature, rawFunction) {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.includes("j")) {
                return getDynCaller(signature, rawFunction);
              }
              return wasmTable.get(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp !== "function") {
              throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
            }
            return fp;
          }
          var UnboundTypeError = void 0;
          function getTypeName(type) {
            var ptr = ___getTypeName(type);
            var rv = readLatin1String(ptr);
            _free(ptr);
            return rv;
          }
          function throwUnboundTypeError(message, types) {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
          }
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            if (upcast) {
              upcast = embind__requireFunction(upcastSignature, upcast);
            }
            if (downcast) {
              downcast = embind__requireFunction(downcastSignature, downcast);
            }
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (registeredClass.constructor_body === void 0) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (body === void 0) {
                  throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          function heap32VectorToArray(count, firstElement) {
            var array = [];
            for (var i = 0; i < count; i++) {
              array.push(GROWABLE_HEAP_I32()[(firstElement >> 2) + i >>> 0]);
            }
            return array;
          }
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            assert(argCount > 0);
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = "constructor " + classType.name;
              if (classType.registeredClass.constructor_body === void 0) {
                classType.registeredClass.constructor_body = [];
              }
              if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
                throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              }
              classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                    args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                  }
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
                  return argTypes[0]["fromWireType"](ptr);
                };
                return [];
              });
              return [];
            });
          }
          function new_(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = false;
            for (var i = 1; i < argTypes.length; ++i) {
              if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
                needsDestructorStack = true;
                break;
              }
            }
            var returns = argTypes[0].name !== "void";
            var argsList = "";
            var argsListWired = "";
            for (var i = 0; i < argCount - 2; ++i) {
              argsList += (i !== 0 ? ", " : "") + "arg" + i;
              argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
            }
            var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
            }
            for (var i = 0; i < argCount - 2; ++i) {
              invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
              args1.push("argType" + i);
              args2.push(argTypes[i + 2]);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                  args1.push(paramName + "_dtor");
                  args2.push(argTypes[i].destructorFunction);
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
            } else {
            }
            invokerFnBody += "}\n";
            args1.push(invokerFnBody);
            var invokerFunction = new_(Function, args1).apply(null, args2);
            return invokerFunction;
          }
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = classType.name + "." + methodName;
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                if (proto[methodName].overloadTable === void 0) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function __emval_decref(handle) {
            if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
              emval_handle_array[handle] = void 0;
              emval_free_list.push(handle);
            }
          }
          function count_emval_handles() {
            var count = 0;
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                ++count;
              }
            }
            return count;
          }
          function get_first_emval() {
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                return emval_handle_array[i];
              }
            }
            return null;
          }
          function init_emval() {
            Module["count_emval_handles"] = count_emval_handles;
            Module["get_first_emval"] = get_first_emval;
          }
          function __emval_register(value) {
            switch (value) {
              case void 0: {
                return 1;
              }
              case null: {
                return 2;
              }
              case true: {
                return 3;
              }
              case false: {
                return 4;
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value };
                return handle;
              }
            }
          }
          function __embind_register_emval(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            }, "toWireType": function(destructors, value) {
              return __emval_register(value);
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
          }
          function enumReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();
                  return this["fromWireType"](heap[pointer >>> 0]);
                };
              case 1:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();
                  return this["fromWireType"](heap[pointer >>> 1]);
                };
              case 2:
                return function(pointer) {
                  var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();
                  return this["fromWireType"](heap[pointer >>> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_enum(rawType, name2, size, isSigned) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
              return this.constructor.values[c];
            }, "toWireType": function(destructors, c) {
              return c.value;
            }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
            exposePublicSymbol(name2, ctor);
          }
          function requireRegisteredType(rawType, humanName) {
            var impl = registeredTypes[rawType];
            if (impl === void 0) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          }
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
            }) } });
            Enum.values[enumValue] = Value2;
            Enum[name2] = Value2;
          }
          function _embind_repr(v) {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          }
          function floatReadValueFromPointer(name2, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](GROWABLE_HEAP_F32()[pointer >>> 2]);
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](GROWABLE_HEAP_F64()[pointer >>> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + name2);
            }
          }
          function __embind_register_float(rawType, name2, size) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              return value;
            }, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
            }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
          }
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
              return [];
            });
          }
          function integerReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return GROWABLE_HEAP_I8()[pointer >>> 0];
                } : function readU8FromPointer(pointer) {
                  return GROWABLE_HEAP_U8()[pointer >>> 0];
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return GROWABLE_HEAP_I16()[pointer >>> 1];
                } : function readU16FromPointer(pointer) {
                  return GROWABLE_HEAP_U16()[pointer >>> 1];
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return GROWABLE_HEAP_I32()[pointer >>> 2];
                } : function readU32FromPointer(pointer) {
                  return GROWABLE_HEAP_U32()[pointer >>> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value;
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift;
              };
            }
            var isUnsignedType = name2.includes("unsigned");
            registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
          }
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = GROWABLE_HEAP_U32();
              var size = heap[handle >>> 0];
              var data = heap[handle + 1 >>> 0];
              return new TA(buffer, data, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
          }
          function __embind_register_std_string(rawType, name2) {
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = GROWABLE_HEAP_U32()[value >>> 2];
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i;
                  if (i == length || GROWABLE_HEAP_U8()[currentBytePtr >>> 0] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[value + 4 + i >>> 0]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var getLength;
              var valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              ptr >>>= 0;
              GROWABLE_HEAP_U32()[ptr >>> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i = 0; i < length; ++i) {
                    var charCode = value.charCodeAt(i);
                    if (charCode > 255) {
                      _free(ptr);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = charCode;
                  }
                } else {
                  for (var i = 0; i < length; ++i) {
                    GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = value[i];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_std_wstring(rawType, charSize, name2) {
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = function() {
                return GROWABLE_HEAP_U16();
              };
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = function() {
                return GROWABLE_HEAP_U32();
              };
              shift = 2;
            }
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = GROWABLE_HEAP_U32()[value >>> 2];
              var HEAP = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (!(typeof value === "string")) {
                throwBindingError("Cannot pass non-string to C++ string type " + name2);
              }
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              ptr >>>= 0;
              GROWABLE_HEAP_U32()[ptr >>> 2] = length >> shift;
              encodeString(value, ptr + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
          }
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
          }
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_void(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
              return void 0;
            }, "toWireType": function(destructors, o) {
              return void 0;
            } });
          }
          function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
            if (targetThreadId == mainThreadId) {
              postMessage({ "cmd": "processQueuedMainThreadWork" });
            } else if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
            } else {
              var pthread = PThread.pthreads[targetThreadId];
              var worker = pthread && pthread.worker;
              if (!worker) {
                return;
              }
              worker.postMessage({ "cmd": "processThreadQueue" });
            }
            return 1;
          }
          function requireHandle(handle) {
            if (!handle) {
              throwBindingError("Cannot use deleted val. handle = " + handle);
            }
            return emval_handle_array[handle].value;
          }
          function __emval_as(handle, returnType, destructorsRef) {
            handle = requireHandle(handle);
            returnType = requireRegisteredType(returnType, "emval::as");
            var destructors = [];
            var rd = __emval_register(destructors);
            GROWABLE_HEAP_I32()[destructorsRef >>> 2] = rd;
            return returnType["toWireType"](destructors, handle);
          }
          function __emval_lookupTypes(argCount, argTypes) {
            var a = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              a[i] = requireRegisteredType(GROWABLE_HEAP_I32()[(argTypes >> 2) + i >>> 0], "parameter " + i);
            }
            return a;
          }
          function __emval_call(handle, argCount, argTypes, argv) {
            handle = requireHandle(handle);
            var types = __emval_lookupTypes(argCount, argTypes);
            var args = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              var type = types[i];
              args[i] = type["readValueFromPointer"](argv);
              argv += type["argPackAdvance"];
            }
            var rv = handle.apply(void 0, args);
            return __emval_register(rv);
          }
          var emval_symbols = {};
          function getStringOrSymbol(address) {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            } else {
              return symbol;
            }
          }
          function emval_get_global() {
            if (typeof globalThis === "object") {
              return globalThis;
            }
            return function() {
              return Function;
            }()("return this")();
          }
          function __emval_get_global(name2) {
            if (name2 === 0) {
              return __emval_register(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return __emval_register(emval_get_global()[name2]);
            }
          }
          function __emval_get_property(handle, key2) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            return __emval_register(handle[key2]);
          }
          function __emval_incref(handle) {
            if (handle > 4) {
              emval_handle_array[handle].refcount += 1;
            }
          }
          function __emval_instanceof(object, constructor) {
            object = requireHandle(object);
            constructor = requireHandle(constructor);
            return object instanceof constructor;
          }
          function __emval_is_number(handle) {
            handle = requireHandle(handle);
            return typeof handle === "number";
          }
          function __emval_new_array() {
            return __emval_register([]);
          }
          function __emval_new_cstring(v) {
            return __emval_register(getStringOrSymbol(v));
          }
          function __emval_new_object() {
            return __emval_register({});
          }
          function __emval_run_destructors(handle) {
            var destructors = emval_handle_array[handle].value;
            runDestructors(destructors);
            __emval_decref(handle);
          }
          function __emval_set_property(handle, key2, value) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            value = requireHandle(value);
            handle[key2] = value;
          }
          function __emval_take_value(type, argv) {
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](argv);
            return __emval_register(v);
          }
          function _abort() {
            abort();
          }
          var readAsmConstArgsArray = [];
          function readAsmConstArgs(sigPtr, buf) {
            readAsmConstArgsArray.length = 0;
            var ch;
            buf >>= 2;
            while (ch = GROWABLE_HEAP_U8()[sigPtr++ >>> 0]) {
              var double = ch < 105;
              if (double && buf & 1)
                buf++;
              readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >>> 1] : GROWABLE_HEAP_I32()[buf >>> 0]);
              ++buf;
            }
            return readAsmConstArgsArray;
          }
          function _emscripten_asm_const_int(code, sigPtr, argbuf) {
            var args = readAsmConstArgs(sigPtr, argbuf);
            return ASM_CONSTS[code].apply(null, args);
          }
          function _emscripten_check_blocking_allowed() {
            if (ENVIRONMENT_IS_NODE)
              return;
            if (ENVIRONMENT_IS_WORKER)
              return;
            warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
          }
          function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
          }
          function _emscripten_futex_wait(addr, val, timeout) {
            if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
              return -28;
            if (!ENVIRONMENT_IS_WEB) {
              var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
              if (ret === "timed-out")
                return -73;
              if (ret === "not-equal")
                return -6;
              if (ret === "ok")
                return 0;
              throw "Atomics.wait returned an unexpected value " + ret;
            } else {
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              var tNow = performance.now();
              var tEnd = tNow + timeout;
              var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
              while (1) {
                tNow = performance.now();
                if (tNow > tEnd) {
                  lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                  return -73;
                }
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                if (lastAddr == 0) {
                  break;
                }
                _emscripten_main_thread_process_queued_calls();
                if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                  return -6;
                }
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
              }
              return 0;
            }
          }
          function _emscripten_memcpy_big(dest, src, num) {
            GROWABLE_HEAP_U8().copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          function _emscripten_proxy_to_main_thread_js(index, sync) {
            var numCallArgs = arguments.length - 2;
            var stack = stackSave();
            var serializedNumCallArgs = numCallArgs;
            var args = stackAlloc(serializedNumCallArgs * 8);
            var b = args >> 3;
            for (var i = 0; i < numCallArgs; i++) {
              var arg = arguments[2 + i];
              GROWABLE_HEAP_F64()[b + i >>> 0] = arg;
            }
            var ret = _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
            stackRestore(stack);
            return ret;
          }
          var _emscripten_receive_on_main_thread_js_callArgs = [];
          function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
            _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
            var b = args >> 3;
            for (var i = 0; i < numCallArgs; i++) {
              _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i >>> 0];
            }
            var isEmAsmConst = index < 0;
            var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
            return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
          }
          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            var oldSize = GROWABLE_HEAP_U8().length;
            requestedSize = requestedSize >>> 0;
            if (requestedSize <= oldSize) {
              return false;
            }
            var maxHeapSize = 4294901760;
            if (requestedSize > maxHeapSize) {
              return false;
            }
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
            for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
              JSEvents._removeHandler(i);
            }
            JSEvents.eventHandlers = [];
            JSEvents.deferredCalls = [];
          }, registerRemoveEventListeners: function() {
            if (!JSEvents.removeEventListenersRegistered) {
              __ATEXIT__.push(JSEvents.removeAllEventListeners);
              JSEvents.removeEventListenersRegistered = true;
            }
          }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
            function arraysHaveEqualContent(arrA, arrB) {
              if (arrA.length != arrB.length)
                return false;
              for (var i2 in arrA) {
                if (arrA[i2] != arrB[i2])
                  return false;
              }
              return true;
            }
            for (var i in JSEvents.deferredCalls) {
              var call = JSEvents.deferredCalls[i];
              if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
                return;
              }
            }
            JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
            JSEvents.deferredCalls.sort(function(x, y) {
              return x.precedence < y.precedence;
            });
          }, removeDeferredCalls: function(targetFunction) {
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
              if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
                JSEvents.deferredCalls.splice(i, 1);
                --i;
              }
            }
          }, canPerformEventHandlerRequests: function() {
            return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
          }, runDeferredCalls: function() {
            if (!JSEvents.canPerformEventHandlerRequests()) {
              return;
            }
            for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
              var call = JSEvents.deferredCalls[i];
              JSEvents.deferredCalls.splice(i, 1);
              --i;
              call.targetFunction.apply(null, call.argsList);
            }
          }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
              if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
                JSEvents._removeHandler(i--);
              }
            }
          }, _removeHandler: function(i) {
            var h = JSEvents.eventHandlers[i];
            h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
            JSEvents.eventHandlers.splice(i, 1);
          }, registerOrRemoveHandler: function(eventHandler) {
            var jsEventHandler = function jsEventHandler2(event) {
              ++JSEvents.inEventHandler;
              JSEvents.currentEventHandler = eventHandler;
              JSEvents.runDeferredCalls();
              eventHandler.handlerFunc(event);
              JSEvents.runDeferredCalls();
              --JSEvents.inEventHandler;
            };
            if (eventHandler.callbackfunc) {
              eventHandler.eventListenerFunc = jsEventHandler;
              eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
              JSEvents.eventHandlers.push(eventHandler);
              JSEvents.registerRemoveEventListeners();
            } else {
              for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
                if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                  JSEvents._removeHandler(i--);
                }
              }
            }
          }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
            var stackTop = stackSave();
            var varargs = stackAlloc(12);
            GROWABLE_HEAP_I32()[varargs >>> 2] = eventTypeId;
            GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = eventData;
            GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = userData;
            __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
            stackRestore(stackTop);
          }, getTargetThreadForEventCallback: function(targetThread) {
            switch (targetThread) {
              case 1:
                return 0;
              case 2:
                return PThread.currentProxiedOperationCallerThread;
              default:
                return targetThread;
            }
          }, getNodeNameForTarget: function(target) {
            if (!target)
              return "";
            if (target == window)
              return "#window";
            if (target == screen)
              return "#screen";
            return target && target.nodeName ? target.nodeName : "";
          }, fullscreenEnabled: function() {
            return document.fullscreenEnabled || document.webkitFullscreenEnabled;
          } };
          function stringToNewUTF8(jsString) {
            var length = lengthBytesUTF8(jsString) + 1;
            var cString = _malloc(length);
            stringToUTF8(jsString, cString, length);
            return cString;
          }
          function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
            var stackTop = stackSave();
            var varargs = stackAlloc(12);
            var targetCanvasPtr = 0;
            if (targetCanvas) {
              targetCanvasPtr = stringToNewUTF8(targetCanvas);
            }
            GROWABLE_HEAP_I32()[varargs >>> 2] = targetCanvasPtr;
            GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = width;
            GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = height;
            __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
            stackRestore(stackTop);
          }
          function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
            targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
            _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
          }
          function maybeCStringToJsString(cString) {
            return cString > 2 ? UTF8ToString(cString) : cString;
          }
          var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
          function findEventTarget(target) {
            target = maybeCStringToJsString(target);
            var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
            return domElement;
          }
          function findCanvasEventTarget(target) {
            return findEventTarget(target);
          }
          function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (!canvas)
              return -4;
            if (canvas.canvasSharedPtr) {
              GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >>> 2] = width;
              GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >>> 2] = height;
            }
            if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
              if (canvas.offscreenCanvas)
                canvas = canvas.offscreenCanvas;
              var autoResizeViewport = false;
              if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
                var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
                autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
              }
              canvas.width = width;
              canvas.height = height;
              if (autoResizeViewport) {
                canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
              }
            } else if (canvas.canvasSharedPtr) {
              var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >>> 2];
              _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
              return 1;
            } else {
              return -4;
            }
            return 0;
          }
          function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(5, 1, target, width, height);
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          }
          function _emscripten_set_canvas_element_size(target, width, height) {
            var canvas = findCanvasEventTarget(target);
            if (canvas) {
              return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
            } else {
              return _emscripten_set_canvas_element_size_main_thread(target, width, height);
            }
          }
          function _emscripten_set_current_thread_status(newStatus) {
          }
          function __webgl_enable_ANGLE_instanced_arrays(ctx) {
            var ext = ctx.getExtension("ANGLE_instanced_arrays");
            if (ext) {
              ctx["vertexAttribDivisor"] = function(index, divisor) {
                ext["vertexAttribDivisorANGLE"](index, divisor);
              };
              ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
                ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
              };
              ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
                ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
              };
              return 1;
            }
          }
          function __webgl_enable_OES_vertex_array_object(ctx) {
            var ext = ctx.getExtension("OES_vertex_array_object");
            if (ext) {
              ctx["createVertexArray"] = function() {
                return ext["createVertexArrayOES"]();
              };
              ctx["deleteVertexArray"] = function(vao) {
                ext["deleteVertexArrayOES"](vao);
              };
              ctx["bindVertexArray"] = function(vao) {
                ext["bindVertexArrayOES"](vao);
              };
              ctx["isVertexArray"] = function(vao) {
                return ext["isVertexArrayOES"](vao);
              };
              return 1;
            }
          }
          function __webgl_enable_WEBGL_draw_buffers(ctx) {
            var ext = ctx.getExtension("WEBGL_draw_buffers");
            if (ext) {
              ctx["drawBuffers"] = function(n, bufs) {
                ext["drawBuffersWEBGL"](n, bufs);
              };
              return 1;
            }
          }
          function __webgl_enable_WEBGL_multi_draw(ctx) {
            return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
          }
          var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
            if (!GL.lastError) {
              GL.lastError = errorCode;
            }
          }, getNewId: function(table) {
            var ret = GL.counter++;
            for (var i = table.length; i < ret; i++) {
              table[i] = null;
            }
            return ret;
          }, getSource: function(shader, count, string, length) {
            var source = "";
            for (var i = 0; i < count; ++i) {
              var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >>> 2] : -1;
              source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >>> 2], len < 0 ? void 0 : len);
            }
            return source;
          }, createContext: function(canvas, webGLContextAttributes) {
            if (!canvas.getContextSafariWebGL2Fixed) {
              canvas.getContextSafariWebGL2Fixed = canvas.getContext;
              canvas.getContext = function(ver, attrs) {
                var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
                return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
              };
            }
            var ctx = canvas.getContext("webgl", webGLContextAttributes);
            if (!ctx)
              return 0;
            var handle = GL.registerContext(ctx, webGLContextAttributes);
            return handle;
          }, registerContext: function(ctx, webGLContextAttributes) {
            var handle = _malloc(8);
            GROWABLE_HEAP_I32()[handle + 4 >>> 2] = _pthread_self();
            var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
            if (ctx.canvas)
              ctx.canvas.GLctxObject = context;
            GL.contexts[handle] = context;
            if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
              GL.initExtensions(context);
            }
            return handle;
          }, makeContextCurrent: function(contextHandle) {
            GL.currentContext = GL.contexts[contextHandle];
            Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
            return !(contextHandle && !GLctx);
          }, getContext: function(contextHandle) {
            return GL.contexts[contextHandle];
          }, deleteContext: function(contextHandle) {
            if (GL.currentContext === GL.contexts[contextHandle])
              GL.currentContext = null;
            if (typeof JSEvents === "object")
              JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
            if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
              GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
            _free(GL.contexts[contextHandle].handle);
            GL.contexts[contextHandle] = null;
          }, initExtensions: function(context) {
            if (!context)
              context = GL.currentContext;
            if (context.initExtensionsDone)
              return;
            context.initExtensionsDone = true;
            var GLctx2 = context.GLctx;
            __webgl_enable_ANGLE_instanced_arrays(GLctx2);
            __webgl_enable_OES_vertex_array_object(GLctx2);
            __webgl_enable_WEBGL_draw_buffers(GLctx2);
            {
              GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
            }
            __webgl_enable_WEBGL_multi_draw(GLctx2);
            var exts = GLctx2.getSupportedExtensions() || [];
            exts.forEach(function(ext) {
              if (!ext.includes("lose_context") && !ext.includes("debug")) {
                GLctx2.getExtension(ext);
              }
            });
          } };
          var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
          function _emscripten_webgl_do_create_context(target, attributes) {
            var a = attributes >> 2;
            var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2) >>> 0];
            var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a + (0 >> 2) >>> 0], "depth": !!GROWABLE_HEAP_I32()[a + (4 >> 2) >>> 0], "stencil": !!GROWABLE_HEAP_I32()[a + (8 >> 2) >>> 0], "antialias": !!GROWABLE_HEAP_I32()[a + (12 >> 2) >>> 0], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + (16 >> 2) >>> 0], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + (20 >> 2) >>> 0], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + (28 >> 2) >>> 0], majorVersion: GROWABLE_HEAP_I32()[a + (32 >> 2) >>> 0], minorVersion: GROWABLE_HEAP_I32()[a + (36 >> 2) >>> 0], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + (40 >> 2) >>> 0], explicitSwapControl: GROWABLE_HEAP_I32()[a + (44 >> 2) >>> 0], proxyContextToMainThread: GROWABLE_HEAP_I32()[a + (48 >> 2) >>> 0], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + (52 >> 2) >>> 0] };
            var canvas = findCanvasEventTarget(target);
            if (!canvas) {
              return 0;
            }
            if (contextAttributes.explicitSwapControl) {
              return 0;
            }
            var contextHandle = GL.createContext(canvas, contextAttributes);
            return contextHandle;
          }
          function _emscripten_webgl_create_context(a0, a1) {
            return _emscripten_webgl_do_create_context(a0, a1);
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(x + "=" + env[x]);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function _environ_get(__environ, environ_buf) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(6, 1, __environ, environ_buf);
            try {
              var bufSize = 0;
              getEnvStrings().forEach(function(string, i) {
                var ptr = environ_buf + bufSize;
                GROWABLE_HEAP_I32()[__environ + i * 4 >>> 2] = ptr;
                writeAsciiToMemory(string, ptr);
                bufSize += string.length + 1;
              });
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(7, 1, penviron_count, penviron_buf_size);
            try {
              var strings = getEnvStrings();
              GROWABLE_HEAP_I32()[penviron_count >>> 2] = strings.length;
              var bufSize = 0;
              strings.forEach(function(string) {
                bufSize += string.length + 1;
              });
              GROWABLE_HEAP_I32()[penviron_buf_size >>> 2] = bufSize;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_close(fd) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(8, 1, fd);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(9, 1, fd, iov, iovcnt, pnum);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doReadv(stream, iov, iovcnt);
              GROWABLE_HEAP_I32()[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(10, 1, fd, offset_low, offset_high, whence, newOffset);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[newOffset >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >>> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            if (ENVIRONMENT_IS_PTHREAD)
              return _emscripten_proxy_to_main_thread_js(11, 1, fd, iov, iovcnt, pnum);
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doWritev(stream, iov, iovcnt);
              GROWABLE_HEAP_I32()[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function spawnThread(threadParams) {
            if (ENVIRONMENT_IS_PTHREAD)
              throw "Internal Error! spawnThread() can only ever be called from main application thread!";
            var worker = PThread.getNewWorker();
            if (!worker) {
              return 6;
            }
            if (worker.pthread !== void 0)
              throw "Internal error!";
            if (!threadParams.pthread_ptr)
              throw "Internal error, no pthread ptr!";
            PThread.runningWorkers.push(worker);
            var tlsMemory = _malloc(128 * 4);
            for (var i = 0; i < 128; ++i) {
              GROWABLE_HEAP_I32()[tlsMemory + i * 4 >>> 2] = 0;
            }
            var stackHigh = threadParams.stackBase + threadParams.stackSize;
            var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, threadInfoStruct: threadParams.pthread_ptr };
            var tis = pthread.threadInfoStruct >> 2;
            Atomics.store(GROWABLE_HEAP_U32(), tis + (64 >> 2), threadParams.detached);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (100 >> 2), tlsMemory);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), threadParams.stackSize);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (76 >> 2), stackHigh);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), threadParams.stackSize);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 8 >> 2), stackHigh);
            Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 12 >> 2), threadParams.detached);
            var global_libc = _emscripten_get_global_libc();
            var global_locale = global_libc + 40;
            Atomics.store(GROWABLE_HEAP_U32(), tis + (172 >> 2), global_locale);
            worker.pthread = pthread;
            var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
            worker.runPthread = function() {
              msg.time = performance.now();
              worker.postMessage(msg, threadParams.transferList);
            };
            if (worker.loaded) {
              worker.runPthread();
              delete worker.runPthread;
            }
            return 0;
          }
          function _pthread_create(pthread_ptr, attr, start_routine, arg) {
            if (typeof SharedArrayBuffer === "undefined") {
              err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
              return 6;
            }
            if (!pthread_ptr) {
              err("pthread_create called with a null thread pointer!");
              return 28;
            }
            var transferList = [];
            var error = 0;
            if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
              return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
            }
            if (error)
              return error;
            var stackSize = 0;
            var stackBase = 0;
            var detached = 0;
            if (attr && attr != -1) {
              stackSize = GROWABLE_HEAP_I32()[attr >>> 2];
              stackSize += 81920;
              stackBase = GROWABLE_HEAP_I32()[attr + 8 >>> 2];
              detached = GROWABLE_HEAP_I32()[attr + 12 >>> 2] !== 0;
            } else {
              stackSize = 2097152;
            }
            var allocatedOwnStack = stackBase == 0;
            if (allocatedOwnStack) {
              stackBase = _memalign(16, stackSize);
            } else {
              stackBase -= stackSize;
              assert(stackBase > 0);
            }
            var threadInfoStruct = _malloc(228);
            for (var i = 0; i < 228 >> 2; ++i)
              GROWABLE_HEAP_U32()[(threadInfoStruct >> 2) + i >>> 0] = 0;
            GROWABLE_HEAP_I32()[pthread_ptr >>> 2] = threadInfoStruct;
            GROWABLE_HEAP_I32()[threadInfoStruct + 12 >>> 2] = threadInfoStruct;
            var headPtr = threadInfoStruct + 152;
            GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
            var threadParams = { stackBase, stackSize, allocatedOwnStack, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct, arg, transferList };
            if (ENVIRONMENT_IS_PTHREAD) {
              threadParams.cmd = "spawnThread";
              postMessage(threadParams, transferList);
              return 0;
            }
            return spawnThread(threadParams);
          }
          function _setTempRet0(val) {
            setTempRet0(val);
          }
          function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function __arraySum(array, index) {
            var sum = 0;
            for (var i = 0; i <= index; sum += array[i++]) {
            }
            return sum;
          }
          var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = __isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >>> 2];
            var date = { tm_sec: GROWABLE_HEAP_I32()[tm >>> 2], tm_min: GROWABLE_HEAP_I32()[tm + 4 >>> 2], tm_hour: GROWABLE_HEAP_I32()[tm + 8 >>> 2], tm_mday: GROWABLE_HEAP_I32()[tm + 12 >>> 2], tm_mon: GROWABLE_HEAP_I32()[tm + 16 >>> 2], tm_year: GROWABLE_HEAP_I32()[tm + 20 >>> 2], tm_wday: GROWABLE_HEAP_I32()[tm + 24 >>> 2], tm_yday: GROWABLE_HEAP_I32()[tm + 28 >>> 2], tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >>> 2], tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value === "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                } else {
                  return thisDate.getFullYear();
                }
              } else {
                return thisDate.getFullYear() - 1;
              }
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              } else {
                return "PM";
              }
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var janFirst = new Date(date2.tm_year + 1900, 0, 1);
              var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
            }, "%V": function(date2) {
              var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
              var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
              }
              if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
              }
              var daysDifference;
              if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
                daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
              } else {
                daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
              }
              return leadingNulls(Math.ceil(daysDifference / 7), 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var janFirst = new Date(date2.tm_year, 0, 1);
              var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm) {
            return _strftime(s, maxsize, format, tm);
          }
          if (!ENVIRONMENT_IS_PTHREAD)
            PThread.initMainThreadBlock();
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, { read: { get: function() {
            return (this.mode & readMode) === readMode;
          }, set: function(val) {
            val ? this.mode |= readMode : this.mode &= ~readMode;
          } }, write: { get: function() {
            return (this.mode & writeMode) === writeMode;
          }, set: function(val) {
            val ? this.mode |= writeMode : this.mode &= ~writeMode;
          } }, isFolder: { get: function() {
            return FS.isDir(this.mode);
          } }, isDevice: { get: function() {
            return FS.isChrdev(this.mode);
          } } });
          FS.FSNode = FSNode;
          FS.staticInit();
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          InternalError = Module["InternalError"] = extendError(Error, "InternalError");
          embind_init_charCodes();
          BindingError = Module["BindingError"] = extendError(Error, "BindingError");
          init_ClassHandle();
          init_RegisteredPointer();
          init_embind();
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          init_emval();
          var GLctx;
          var proxiedFunctionTable = [null, _atexit, ___sys_fcntl64, ___sys_ioctl, ___sys_open, _emscripten_set_canvas_element_size_main_thread, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          var asmLibraryArg = { "l": ___assert_fail, "B": ___cxa_allocate_exception, "ka": ___cxa_thread_atexit, "A": ___cxa_throw, "D": ___sys_fcntl64, "V": ___sys_ioctl, "W": ___sys_open, "ma": __embind_finalize_value_array, "s": __embind_finalize_value_object, "O": __embind_register_bigint, "ia": __embind_register_bool, "v": __embind_register_class, "u": __embind_register_class_constructor, "c": __embind_register_class_function, "ha": __embind_register_emval, "la": __embind_register_enum, "y": __embind_register_enum_value, "J": __embind_register_float, "f": __embind_register_function, "p": __embind_register_integer, "k": __embind_register_memory_view, "K": __embind_register_std_string, "z": __embind_register_std_wstring, "na": __embind_register_value_array, "h": __embind_register_value_array_element, "t": __embind_register_value_object, "e": __embind_register_value_object_field, "ja": __embind_register_void, "ea": __emscripten_notify_thread_queue, "n": __emval_as, "L": __emval_call, "b": __emval_decref, "U": __emval_get_global, "o": __emval_get_property, "j": __emval_incref, "ca": __emval_instanceof, "M": __emval_is_number, "C": __emval_new_array, "g": __emval_new_cstring, "w": __emval_new_object, "m": __emval_run_destructors, "i": __emval_set_property, "d": __emval_take_value, "I": _abort, "T": _clock_gettime, "G": _emscripten_asm_const_int, "_": _emscripten_check_blocking_allowed, "F": _emscripten_conditional_set_current_thread_status, "r": _emscripten_futex_wait, "q": _emscripten_futex_wake, "x": _emscripten_get_now, "R": _emscripten_memcpy_big, "$": _emscripten_receive_on_main_thread_js, "S": _emscripten_resize_heap, "aa": _emscripten_set_canvas_element_size, "E": _emscripten_set_current_thread_status, "ba": _emscripten_webgl_create_context, "Y": _environ_get, "Z": _environ_sizes_get, "H": _fd_close, "ga": _fd_read, "N": _fd_seek, "fa": _fd_write, "Q": initPthreadsJS, "a": wasmMemory || Module["wasmMemory"], "da": _pthread_create, "P": _setTempRet0, "X": _strftime_l };
          var asm = createWasm();
          var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["oa"]).apply(null, arguments);
          };
          var _main = Module["_main"] = function() {
            return (_main = Module["_main"] = Module["asm"]["pa"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["qa"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["ra"]).apply(null, arguments);
          };
          var _emscripten_tls_init = Module["_emscripten_tls_init"] = function() {
            return (_emscripten_tls_init = Module["_emscripten_tls_init"] = Module["asm"]["sa"]).apply(null, arguments);
          };
          var ___getTypeName = Module["___getTypeName"] = function() {
            return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ua"]).apply(null, arguments);
          };
          var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
            return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["va"]).apply(null, arguments);
          };
          var _emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = function() {
            return (_emscripten_current_thread_process_queued_calls = Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["wa"]).apply(null, arguments);
          };
          var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
            return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["xa"]).apply(null, arguments);
          };
          var __emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = function() {
            return (__emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = Module["asm"]["ya"]).apply(null, arguments);
          };
          var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
            return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["za"]).apply(null, arguments);
          };
          var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
            return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["Aa"]).apply(null, arguments);
          };
          var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
            return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["Ba"]).apply(null, arguments);
          };
          var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
            return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["Ca"]).apply(null, arguments);
          };
          var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
            return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["Da"]).apply(null, arguments);
          };
          var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
            return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["Ea"]).apply(null, arguments);
          };
          var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["Fa"]).apply(null, arguments);
          };
          var _pthread_self = Module["_pthread_self"] = function() {
            return (_pthread_self = Module["_pthread_self"] = Module["asm"]["Ga"]).apply(null, arguments);
          };
          var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
            return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["Ha"]).apply(null, arguments);
          };
          var stackSave = Module["stackSave"] = function() {
            return (stackSave = Module["stackSave"] = Module["asm"]["Ia"]).apply(null, arguments);
          };
          var stackRestore = Module["stackRestore"] = function() {
            return (stackRestore = Module["stackRestore"] = Module["asm"]["Ja"]).apply(null, arguments);
          };
          var stackAlloc = Module["stackAlloc"] = function() {
            return (stackAlloc = Module["stackAlloc"] = Module["asm"]["Ka"]).apply(null, arguments);
          };
          var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
            return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["La"]).apply(null, arguments);
          };
          var _memalign = Module["_memalign"] = function() {
            return (_memalign = Module["_memalign"] = Module["asm"]["Ma"]).apply(null, arguments);
          };
          var dynCall_jiji = Module["dynCall_jiji"] = function() {
            return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["Na"]).apply(null, arguments);
          };
          var dynCall_viijii = Module["dynCall_viijii"] = function() {
            return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["Oa"]).apply(null, arguments);
          };
          var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
            return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["Pa"]).apply(null, arguments);
          };
          var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
            return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["Qa"]).apply(null, arguments);
          };
          var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
            return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["Ra"]).apply(null, arguments);
          };
          var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 44840;
          var __emscripten_main_thread_futex = Module["__emscripten_main_thread_futex"] = 48292;
          Module["addRunDependency"] = addRunDependency;
          Module["removeRunDependency"] = removeRunDependency;
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          Module["keepRuntimeAlive"] = keepRuntimeAlive;
          Module["FS"] = FS;
          Module["PThread"] = PThread;
          Module["PThread"] = PThread;
          Module["wasmMemory"] = wasmMemory;
          Module["ExitStatus"] = ExitStatus;
          var calledRun;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
          }
          var calledMain = false;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args) {
            var entryFunction = Module["_main"];
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exit(ret, true);
            } catch (e) {
              if (e instanceof ExitStatus || e == "unwind") {
                return;
              }
              var toLog = e;
              if (e && typeof e === "object" && e.stack) {
                toLog = [e, e.stack];
              }
              err("exception thrown: " + toLog);
              quit_(1, e);
            } finally {
              calledMain = true;
            }
          }
          function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
              return;
            }
            if (ENVIRONMENT_IS_PTHREAD) {
              readyPromiseResolve(Module);
              initRuntime();
              postMessage({ "cmd": "loaded" });
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain(args);
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module["run"] = run;
          function exit(status, implicit) {
            EXITSTATUS = status;
            if (!implicit) {
              if (ENVIRONMENT_IS_PTHREAD) {
                postMessage({ "cmd": "exitProcess", "returnCode": status });
                throw new ExitStatus(status);
              } else {
              }
            }
            if (keepRuntimeAlive()) {
            } else {
              PThread.terminateAllThreads();
              exitRuntime();
              if (Module["onExit"])
                Module["onExit"](status);
              ABORT = true;
            }
            quit_(status, new ExitStatus(status));
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          if (ENVIRONMENT_IS_PTHREAD) {
            noExitRuntime = false;
            PThread.initWorker();
          }
          run();
          return WebIFCWasm3.ready;
        };
      }();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = WebIFCWasm2;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return WebIFCWasm2;
        });
      else if (typeof exports === "object")
        exports["WebIFCWasm"] = WebIFCWasm2;
    }
  });

  // dist/web-ifc.js
  var require_web_ifc = __commonJS({
    "dist/web-ifc.js"(exports, module) {
      var WebIFCWasm2 = function() {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir = _scriptDir || __filename;
        return function(WebIFCWasm3) {
          WebIFCWasm3 = WebIFCWasm3 || {};
          var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise(function(resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key];
            }
          }
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = function(status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window === "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
          var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;
          var nodeFS;
          var nodePath;
          if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            readAsync = function readAsync2(filename, onload, onerror) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              nodeFS["readFile"](filename, function(err2, data) {
                if (err2)
                  onerror(err2);
                else
                  onload(data.buffer);
              });
            };
            if (process["argv"].length > 1) {
              thisProgram = process["argv"][1].replace(/\\/g, "/");
            }
            arguments_ = process["argv"].slice(2);
            process["on"]("uncaughtException", function(ex) {
              if (!(ex instanceof ExitStatus)) {
                throw ex;
              }
            });
            process["on"]("unhandledRejection", abort);
            quit_ = function(status, toThrow) {
              if (keepRuntimeAlive()) {
                process["exitCode"] = status;
                throw toThrow;
              }
              process["exit"](status);
            };
            Module["inspect"] = function() {
              return "[Emscripten Module object]";
            };
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document !== "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = function(url) {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = function(url, onload, onerror) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = function() {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload(xhr.response);
                    return;
                  }
                  onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
              };
            }
            setWindowTitle = function(title) {
              document.title = title;
            };
          } else {
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var tempRet0 = 0;
          var setTempRet0 = function(value) {
            tempRet0 = value;
          };
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime = Module["noExitRuntime"] || true;
          if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort("Assertion failed: " + text);
            }
          }
          var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
          function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              while (idx < endPtr) {
                var u0 = heap[idx++ >>> 0];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue;
                }
                var u1 = heap[idx++ >>> 0] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode((u0 & 31) << 6 | u1);
                  continue;
                }
                var u2 = heap[idx++ >>> 0] & 63;
                if ((u0 & 240) == 224) {
                  u0 = (u0 & 15) << 12 | u1 << 6 | u2;
                } else {
                  u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0);
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
                }
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343)
                u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
              if (u <= 127)
                ++len;
              else if (u <= 2047)
                len += 2;
              else if (u <= 65535)
                len += 3;
              else
                len += 4;
            }
            return len;
          }
          var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
          function UTF16ToString(ptr, maxBytesToRead) {
            var endPtr = ptr;
            var idx = endPtr >> 1;
            var maxIdx = idx + maxBytesToRead / 2;
            while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
              ++idx;
            endPtr = idx << 1;
            if (endPtr - ptr > 32 && UTF16Decoder) {
              return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
            } else {
              var str = "";
              for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
                var codeUnit = HEAP16[ptr + i * 2 >>> 1];
                if (codeUnit == 0)
                  break;
                str += String.fromCharCode(codeUnit);
              }
              return str;
            }
          }
          function stringToUTF16(str, outPtr, maxBytesToWrite) {
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 2)
              return 0;
            maxBytesToWrite -= 2;
            var startPtr = outPtr;
            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
            for (var i = 0; i < numCharsToWrite; ++i) {
              var codeUnit = str.charCodeAt(i);
              HEAP16[outPtr >>> 1] = codeUnit;
              outPtr += 2;
            }
            HEAP16[outPtr >>> 1] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF16(str) {
            return str.length * 2;
          }
          function UTF32ToString(ptr, maxBytesToRead) {
            var i = 0;
            var str = "";
            while (!(i >= maxBytesToRead / 4)) {
              var utf32 = HEAP32[ptr + i * 4 >>> 2];
              if (utf32 == 0)
                break;
              ++i;
              if (utf32 >= 65536) {
                var ch = utf32 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              } else {
                str += String.fromCharCode(utf32);
              }
            }
            return str;
          }
          function stringToUTF32(str, outPtr, maxBytesToWrite) {
            outPtr >>>= 0;
            if (maxBytesToWrite === void 0) {
              maxBytesToWrite = 2147483647;
            }
            if (maxBytesToWrite < 4)
              return 0;
            var startPtr = outPtr;
            var endPtr = startPtr + maxBytesToWrite - 4;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343) {
                var trailSurrogate = str.charCodeAt(++i);
                codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
              }
              HEAP32[outPtr >>> 2] = codeUnit;
              outPtr += 4;
              if (outPtr + 4 > endPtr)
                break;
            }
            HEAP32[outPtr >>> 2] = 0;
            return outPtr - startPtr;
          }
          function lengthBytesUTF32(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var codeUnit = str.charCodeAt(i);
              if (codeUnit >= 55296 && codeUnit <= 57343)
                ++i;
              len += 4;
            }
            return len;
          }
          function writeArrayToMemory(array, buffer2) {
            HEAP8.set(array, buffer2 >>> 0);
          }
          function writeAsciiToMemory(str, buffer2, dontAddNull) {
            for (var i = 0; i < str.length; ++i) {
              HEAP8[buffer2++ >>> 0] = str.charCodeAt(i);
            }
            if (!dontAddNull)
              HEAP8[buffer2 >>> 0] = 0;
          }
          function alignUp(x, multiple) {
            if (x % multiple > 0) {
              x += multiple - x % multiple;
            }
            return x;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = HEAP16 = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
          }
          var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeExited = false;
          var runtimeKeepaliveCounter = 0;
          function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
          }
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            if (!Module["noFSInit"] && !FS.init.initialized)
              FS.init();
            FS.ignorePermissions = false;
            TTY.init();
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function exitRuntime() {
            runtimeExited = true;
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function getUniqueRunDependency(id) {
            return id;
          }
          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module["preloadedImages"] = {};
          Module["preloadedAudios"] = {};
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            what += "";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
          }
          function isFileURI(filename) {
            return filename.startsWith("file://");
          }
          var wasmBinaryFile;
          wasmBinaryFile = "web-ifc.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary(file) {
            try {
              if (file == wasmBinaryFile && wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(file);
              } else {
                throw "both async and sync fetching of the wasm failed";
              }
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(function() {
                  return getBinary(wasmBinaryFile);
                });
              } else {
                if (readAsync) {
                  return new Promise(function(resolve, reject) {
                    readAsync(wasmBinaryFile, function(response) {
                      resolve(new Uint8Array(response));
                    }, reject);
                  });
                }
              }
            }
            return Promise.resolve().then(function() {
              return getBinary(wasmBinaryFile);
            });
          }
          function createWasm() {
            var info = { "a": asmLibraryArg };
            function receiveInstance(instance, module2) {
              var exports3 = instance.exports;
              Module["asm"] = exports3;
              wasmMemory = Module["asm"]["$"];
              updateGlobalBufferAndViews(wasmMemory.buffer);
              wasmTable = Module["asm"]["ha"];
              addOnInit(Module["asm"]["aa"]);
              removeRunDependency("wasm-instantiate");
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"]);
            }
            function instantiateArrayBuffer(receiver) {
              return getBinaryPromise().then(function(binary) {
                var result = WebAssembly.instantiate(binary, info);
                return result;
              }).then(receiver, function(reason) {
                err("failed to asynchronously prepare wasm: " + reason);
                abort(reason);
              });
            }
            function instantiateAsync() {
              if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
                return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                  var result = WebAssembly.instantiateStreaming(response, info);
                  return result.then(receiveInstantiationResult, function(reason) {
                    err("wasm streaming compile failed: " + reason);
                    err("falling back to ArrayBuffer instantiation");
                    return instantiateArrayBuffer(receiveInstantiationResult);
                  });
                });
              } else {
                return instantiateArrayBuffer(receiveInstantiationResult);
              }
            }
            if (Module["instantiateWasm"]) {
              try {
                var exports2 = Module["instantiateWasm"](info, receiveInstance);
                return exports2;
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                return false;
              }
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == "function") {
                callback(Module);
                continue;
              }
              var func = callback.func;
              if (typeof func === "number") {
                if (callback.arg === void 0) {
                  wasmTable.get(func)();
                } else {
                  wasmTable.get(func)(callback.arg);
                }
              } else {
                func(callback.arg === void 0 ? null : callback.arg);
              }
            }
          }
          function ___assert_fail(condition, filename, line, func) {
            abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
          }
          function ___cxa_allocate_exception(size) {
            return _malloc(size + 16) + 16;
          }
          function ExceptionInfo(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - 16;
            this.set_type = function(type) {
              HEAP32[this.ptr + 4 >>> 2] = type;
            };
            this.get_type = function() {
              return HEAP32[this.ptr + 4 >>> 2];
            };
            this.set_destructor = function(destructor) {
              HEAP32[this.ptr + 8 >>> 2] = destructor;
            };
            this.get_destructor = function() {
              return HEAP32[this.ptr + 8 >>> 2];
            };
            this.set_refcount = function(refcount) {
              HEAP32[this.ptr >>> 2] = refcount;
            };
            this.set_caught = function(caught) {
              caught = caught ? 1 : 0;
              HEAP8[this.ptr + 12 >>> 0] = caught;
            };
            this.get_caught = function() {
              return HEAP8[this.ptr + 12 >>> 0] != 0;
            };
            this.set_rethrown = function(rethrown) {
              rethrown = rethrown ? 1 : 0;
              HEAP8[this.ptr + 13 >>> 0] = rethrown;
            };
            this.get_rethrown = function() {
              return HEAP8[this.ptr + 13 >>> 0] != 0;
            };
            this.init = function(type, destructor) {
              this.set_type(type);
              this.set_destructor(destructor);
              this.set_refcount(0);
              this.set_caught(false);
              this.set_rethrown(false);
            };
            this.add_ref = function() {
              var value = HEAP32[this.ptr >>> 2];
              HEAP32[this.ptr >>> 2] = value + 1;
            };
            this.release_ref = function() {
              var prev = HEAP32[this.ptr >>> 2];
              HEAP32[this.ptr >>> 2] = prev - 1;
              return prev === 1;
            };
          }
          var exceptionLast = 0;
          var uncaughtExceptionCount = 0;
          function ___cxa_throw(ptr, type, destructor) {
            var info = new ExceptionInfo(ptr);
            info.init(type, destructor);
            exceptionLast = ptr;
            uncaughtExceptionCount++;
            throw ptr;
          }
          function setErrNo(value) {
            HEAP32[___errno_location() >>> 2] = value;
            return value;
          }
          var PATH = { splitPath: function(filename) {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          }, normalizeArray: function(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          }, normalize: function(path) {
            var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          }, dirname: function(path) {
            var result = PATH.splitPath(path), root = result[0], dir = result[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.substr(0, dir.length - 1);
            }
            return root + dir;
          }, basename: function(path) {
            if (path === "/")
              return "/";
            path = PATH.normalize(path);
            path = path.replace(/\/$/, "");
            var lastSlash = path.lastIndexOf("/");
            if (lastSlash === -1)
              return path;
            return path.substr(lastSlash + 1);
          }, extname: function(path) {
            return PATH.splitPath(path)[3];
          }, join: function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return PATH.normalize(paths.join("/"));
          }, join2: function(l, r) {
            return PATH.normalize(l + "/" + r);
          } };
          function getRandomDevice() {
            if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
              var randomBuffer = new Uint8Array(1);
              return function() {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = require_crypto();
                return function() {
                  return crypto_module["randomBytes"](1)[0];
                };
              } catch (e) {
              }
            }
            return function() {
              abort("randomDevice");
            };
          }
          var PATH_FS = { resolve: function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : FS.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          }, relative: function(from, to) {
            from = PATH_FS.resolve(from).substr(1);
            to = PATH_FS.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          } };
          var TTY = { ttys: [], init: function() {
          }, shutdown: function() {
          }, register: function(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          }, stream_ops: { open: function(stream) {
            var tty = TTY.ttys[stream.node.rdev];
            if (!tty) {
              throw new FS.ErrnoError(43);
            }
            stream.tty = tty;
            stream.seekable = false;
          }, close: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, flush: function(stream) {
            stream.tty.ops.flush(stream.tty);
          }, read: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.get_char) {
              throw new FS.ErrnoError(60);
            }
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = stream.tty.ops.get_char(stream.tty);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            if (!stream.tty || !stream.tty.ops.put_char) {
              throw new FS.ErrnoError(60);
            }
            try {
              for (var i = 0; i < length; i++) {
                stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
              }
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } }, default_tty_ops: { get_char: function(tty) {
            if (!tty.input.length) {
              var result = null;
              if (ENVIRONMENT_IS_NODE) {
                var BUFSIZE = 256;
                var buf = Buffer.alloc(BUFSIZE);
                var bytesRead = 0;
                try {
                  bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
                } catch (e) {
                  if (e.toString().includes("EOF"))
                    bytesRead = 0;
                  else
                    throw e;
                }
                if (bytesRead > 0) {
                  result = buf.slice(0, bytesRead).toString("utf-8");
                } else {
                  result = null;
                }
              } else if (typeof window != "undefined" && typeof window.prompt == "function") {
                result = window.prompt("Input: ");
                if (result !== null) {
                  result += "\n";
                }
              } else if (typeof readline == "function") {
                result = readline();
                if (result !== null) {
                  result += "\n";
                }
              }
              if (!result) {
                return null;
              }
              tty.input = intArrayFromString(result, true);
            }
            return tty.input.shift();
          }, put_char: function(tty, val) {
            if (val === null || val === 10) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              out(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } }, default_tty1_ops: { put_char: function(tty, val) {
            if (val === null || val === 10) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            } else {
              if (val != 0)
                tty.output.push(val);
            }
          }, flush: function(tty) {
            if (tty.output && tty.output.length > 0) {
              err(UTF8ArrayToString(tty.output, 0));
              tty.output = [];
            }
          } } };
          function mmapAlloc(size) {
            abort();
          }
          var MEMFS = { ops_table: null, mount: function(mount) {
            return MEMFS.createNode(null, "/", 16384 | 511, 0);
          }, createNode: function(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            if (!MEMFS.ops_table) {
              MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
            }
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.timestamp = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.timestamp = node.timestamp;
            }
            return node;
          }, getFileDataAsTypedArray: function(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          }, expandFileStorage: function(node, newCapacity) {
            newCapacity >>>= 0;
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          }, resizeFileStorage: function(node, newSize) {
            newSize >>>= 0;
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          }, node_ops: { getattr: function(node) {
            var attr = {};
            attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
            attr.ino = node.id;
            attr.mode = node.mode;
            attr.nlink = 1;
            attr.uid = 0;
            attr.gid = 0;
            attr.rdev = node.rdev;
            if (FS.isDir(node.mode)) {
              attr.size = 4096;
            } else if (FS.isFile(node.mode)) {
              attr.size = node.usedBytes;
            } else if (FS.isLink(node.mode)) {
              attr.size = node.link.length;
            } else {
              attr.size = 0;
            }
            attr.atime = new Date(node.timestamp);
            attr.mtime = new Date(node.timestamp);
            attr.ctime = new Date(node.timestamp);
            attr.blksize = 4096;
            attr.blocks = Math.ceil(attr.size / attr.blksize);
            return attr;
          }, setattr: function(node, attr) {
            if (attr.mode !== void 0) {
              node.mode = attr.mode;
            }
            if (attr.timestamp !== void 0) {
              node.timestamp = attr.timestamp;
            }
            if (attr.size !== void 0) {
              MEMFS.resizeFileStorage(node, attr.size);
            }
          }, lookup: function(parent, name2) {
            throw FS.genericErrors[44];
          }, mknod: function(parent, name2, mode, dev) {
            return MEMFS.createNode(parent, name2, mode, dev);
          }, rename: function(old_node, new_dir, new_name) {
            if (FS.isDir(old_node.mode)) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                for (var i in new_node.contents) {
                  throw new FS.ErrnoError(55);
                }
              }
            }
            delete old_node.parent.contents[old_node.name];
            old_node.parent.timestamp = Date.now();
            old_node.name = new_name;
            new_dir.contents[new_name] = old_node;
            new_dir.timestamp = old_node.parent.timestamp;
            old_node.parent = new_dir;
          }, unlink: function(parent, name2) {
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, rmdir: function(parent, name2) {
            var node = FS.lookupNode(parent, name2);
            for (var i in node.contents) {
              throw new FS.ErrnoError(55);
            }
            delete parent.contents[name2];
            parent.timestamp = Date.now();
          }, readdir: function(node) {
            var entries = [".", ".."];
            for (var key2 in node.contents) {
              if (!node.contents.hasOwnProperty(key2)) {
                continue;
              }
              entries.push(key2);
            }
            return entries;
          }, symlink: function(parent, newname, oldpath) {
            var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
            node.link = oldpath;
            return node;
          }, readlink: function(node) {
            if (!FS.isLink(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            return node.link;
          } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
            var contents = stream.node.contents;
            if (position >= stream.node.usedBytes)
              return 0;
            var size = Math.min(stream.node.usedBytes - position, length);
            if (size > 8 && contents.subarray) {
              buffer2.set(contents.subarray(position, position + size), offset);
            } else {
              for (var i = 0; i < size; i++)
                buffer2[offset + i] = contents[position + i];
            }
            return size;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            if (buffer2.buffer === HEAP8.buffer) {
              canOwn = false;
            }
            if (!length)
              return 0;
            var node = stream.node;
            node.timestamp = Date.now();
            if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
              if (canOwn) {
                node.contents = buffer2.subarray(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (node.usedBytes === 0 && position === 0) {
                node.contents = buffer2.slice(offset, offset + length);
                node.usedBytes = length;
                return length;
              } else if (position + length <= node.usedBytes) {
                node.contents.set(buffer2.subarray(offset, offset + length), position);
                return length;
              }
            }
            MEMFS.expandFileStorage(node, position + length);
            if (node.contents.subarray && buffer2.subarray) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
            } else {
              for (var i = 0; i < length; i++) {
                node.contents[position + i] = buffer2[offset + i];
              }
            }
            node.usedBytes = Math.max(node.usedBytes, position + length);
            return length;
          }, llseek: function(stream, offset, whence) {
            var position = offset;
            if (whence === 1) {
              position += stream.position;
            } else if (whence === 2) {
              if (FS.isFile(stream.node.mode)) {
                position += stream.node.usedBytes;
              }
            }
            if (position < 0) {
              throw new FS.ErrnoError(28);
            }
            return position;
          }, allocate: function(stream, offset, length) {
            MEMFS.expandFileStorage(stream.node, offset + length);
            stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            if (address !== 0) {
              throw new FS.ErrnoError(28);
            }
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            var ptr;
            var allocated;
            var contents = stream.node.contents;
            if (!(flags & 2) && contents.buffer === buffer) {
              allocated = false;
              ptr = contents.byteOffset;
            } else {
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              allocated = true;
              ptr = mmapAlloc(length);
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              ptr >>>= 0;
              HEAP8.set(contents, ptr >>> 0);
            }
            return { ptr, allocated };
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (mmapFlags & 2) {
              return 0;
            }
            var bytesWritten = MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
            return 0;
          } } };
          function asyncLoad(url, onload, onerror, noRunDep) {
            var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
            readAsync(url, function(arrayBuffer) {
              assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
              onload(new Uint8Array(arrayBuffer));
              if (dep)
                removeRunDependency(dep);
            }, function(event) {
              if (onerror) {
                onerror();
              } else {
                throw 'Loading data file "' + url + '" failed.';
              }
            });
            if (dep)
              addRunDependency(dep);
          }
          var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
            path = PATH_FS.resolve(FS.cwd(), path);
            opts = opts || {};
            if (!path)
              return { path: "", node: null };
            var defaults = { follow_mount: true, recurse_count: 0 };
            for (var key2 in defaults) {
              if (opts[key2] === void 0) {
                opts[key2] = defaults[key2];
              }
            }
            if (opts.recurse_count > 8) {
              throw new FS.ErrnoError(32);
            }
            var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
              return !!p;
            }), false);
            var current = FS.root;
            var current_path = "/";
            for (var i = 0; i < parts.length; i++) {
              var islast = i === parts.length - 1;
              if (islast && opts.parent) {
                break;
              }
              current = FS.lookupNode(current, parts[i]);
              current_path = PATH.join2(current_path, parts[i]);
              if (FS.isMountpoint(current)) {
                if (!islast || islast && opts.follow_mount) {
                  current = current.mounted.root;
                }
              }
              if (!islast || opts.follow) {
                var count = 0;
                while (FS.isLink(current.mode)) {
                  var link = FS.readlink(current_path);
                  current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                  var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                  current = lookup.node;
                  if (count++ > 40) {
                    throw new FS.ErrnoError(32);
                  }
                }
              }
            }
            return { path: current_path, node: current };
          }, getPath: function(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path)
                  return mount;
                return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
              }
              path = path ? node.name + "/" + path : node.name;
              node = node.parent;
            }
          }, hashName: function(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          }, hashAddNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          }, hashRemoveNode: function(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          }, lookupNode: function(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode, parent);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          }, createNode: function(parent, name2, mode, rdev) {
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          }, destroyNode: function(node) {
            FS.hashRemoveNode(node);
          }, isRoot: function(node) {
            return node === node.parent;
          }, isMountpoint: function(node) {
            return !!node.mounted;
          }, isFile: function(mode) {
            return (mode & 61440) === 32768;
          }, isDir: function(mode) {
            return (mode & 61440) === 16384;
          }, isLink: function(mode) {
            return (mode & 61440) === 40960;
          }, isChrdev: function(mode) {
            return (mode & 61440) === 8192;
          }, isBlkdev: function(mode) {
            return (mode & 61440) === 24576;
          }, isFIFO: function(mode) {
            return (mode & 61440) === 4096;
          }, isSocket: function(mode) {
            return (mode & 49152) === 49152;
          }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
            var flags = FS.flagModes[str];
            if (typeof flags === "undefined") {
              throw new Error("Unknown file open mode: " + str);
            }
            return flags;
          }, flagsToPermissionString: function(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          }, nodePermissions: function(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          }, mayLookup: function(dir) {
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          }, mayCreate: function(dir, name2) {
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          }, mayDelete: function(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          }, mayOpen: function(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
            fd_start = fd_start || 0;
            fd_end = fd_end || FS.MAX_OPEN_FDS;
            for (var fd = fd_start; fd <= fd_end; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          }, getStream: function(fd) {
            return FS.streams[fd];
          }, createStream: function(stream, fd_start, fd_end) {
            if (!FS.FSStream) {
              FS.FSStream = function() {
              };
              FS.FSStream.prototype = { object: { get: function() {
                return this.node;
              }, set: function(val) {
                this.node = val;
              } }, isRead: { get: function() {
                return (this.flags & 2097155) !== 1;
              } }, isWrite: { get: function() {
                return (this.flags & 2097155) !== 0;
              } }, isAppend: { get: function() {
                return this.flags & 1024;
              } } };
            }
            var newStream = new FS.FSStream();
            for (var p in stream) {
              newStream[p] = stream[p];
            }
            stream = newStream;
            var fd = FS.nextfd(fd_start, fd_end);
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          }, closeStream: function(fd) {
            FS.streams[fd] = null;
          }, chrdev_stream_ops: { open: function(stream) {
            var device = FS.getDevice(stream.node.rdev);
            stream.stream_ops = device.stream_ops;
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
          }, llseek: function() {
            throw new FS.ErrnoError(70);
          } }, major: function(dev) {
            return dev >> 8;
          }, minor: function(dev) {
            return dev & 255;
          }, makedev: function(ma, mi) {
            return ma << 8 | mi;
          }, registerDevice: function(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          }, getDevice: function(dev) {
            return FS.devices[dev];
          }, getMounts: function(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push.apply(check, m.mounts);
            }
            return mounts;
          }, syncfs: function(populate, callback) {
            if (typeof populate === "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach(function(mount) {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          }, mount: function(type, opts, mountpoint) {
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = { type, opts, mountpoint, mounts: [] };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          }, unmount: function(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach(function(hash) {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            node.mount.mounts.splice(idx, 1);
          }, lookup: function(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          }, mknod: function(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2 || name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          }, create: function(path, mode) {
            mode = mode !== void 0 ? mode : 438;
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          }, mkdir: function(path, mode) {
            mode = mode !== void 0 ? mode : 511;
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          }, mkdirTree: function(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var i = 0; i < dirs.length; ++i) {
              if (!dirs[i])
                continue;
              d += "/" + dirs[i];
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          }, mkdev: function(path, mode, dev) {
            if (typeof dev === "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          }, symlink: function(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          }, rename: function(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            try {
              if (FS.trackingDelegate["willMovePath"]) {
                FS.trackingDelegate["willMovePath"](old_path, new_path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
            try {
              if (FS.trackingDelegate["onMovePath"])
                FS.trackingDelegate["onMovePath"](old_path, new_path);
            } catch (e) {
              err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
            }
          }, rmdir: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            if (!node.node_ops.readdir) {
              throw new FS.ErrnoError(54);
            }
            return node.node_ops.readdir(node);
          }, unlink: function(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            try {
              if (FS.trackingDelegate["willDeletePath"]) {
                FS.trackingDelegate["willDeletePath"](path);
              }
            } catch (e) {
              err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
            try {
              if (FS.trackingDelegate["onDeletePath"])
                FS.trackingDelegate["onDeletePath"](path);
            } catch (e) {
              err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
            }
          }, readlink: function(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
          }, stat: function(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (!node.node_ops.getattr) {
              throw new FS.ErrnoError(63);
            }
            return node.node_ops.getattr(node);
          }, lstat: function(path) {
            return FS.stat(path, true);
          }, chmod: function(path, mode, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
          }, lchmod: function(path, mode) {
            FS.chmod(path, mode, true);
          }, fchmod: function(fd, mode) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chmod(stream.node, mode);
          }, chown: function(path, uid, gid, dontFollow) {
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            node.node_ops.setattr(node, { timestamp: Date.now() });
          }, lchown: function(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          }, fchown: function(fd, uid, gid) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            FS.chown(stream.node, uid, gid);
          }, truncate: function(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path === "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            if (!node.node_ops.setattr) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
          }, ftruncate: function(fd, len) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.truncate(stream.node, len);
          }, utime: function(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
          }, open: function(path, flags, mode, fd_start, fd_end) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
            mode = typeof mode === "undefined" ? 438 : mode;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            if (typeof path === "object") {
              node = path;
            } else {
              path = PATH.normalize(path);
              try {
                var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                node = lookup.node;
              } catch (e) {
              }
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else {
                node = FS.mknod(path, mode, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= ~512;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512) {
              FS.truncate(node, 0);
            }
            flags &= ~(128 | 512 | 131072);
            var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!FS.readFiles)
                FS.readFiles = {};
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
                err("FS.trackingDelegate error on read file: " + path);
              }
            }
            try {
              if (FS.trackingDelegate["onOpenFile"]) {
                var trackingFlags = 0;
                if ((flags & 2097155) !== 1) {
                  trackingFlags |= FS.tracking.openFlags.READ;
                }
                if ((flags & 2097155) !== 0) {
                  trackingFlags |= FS.tracking.openFlags.WRITE;
                }
                FS.trackingDelegate["onOpenFile"](path, trackingFlags);
              }
            } catch (e) {
              err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
            }
            return stream;
          }, close: function(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          }, isClosed: function(stream) {
            return stream.fd === null;
          }, llseek: function(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          }, read: function(stream, buffer2, offset, length, position) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, position, canOwn) {
            offset >>>= 0;
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position !== "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            try {
              if (stream.path && FS.trackingDelegate["onWriteToFile"])
                FS.trackingDelegate["onWriteToFile"](stream.path);
            } catch (e) {
              err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
            }
            return bytesWritten;
          }, allocate: function(stream, offset, length) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (offset < 0 || length <= 0) {
              throw new FS.ErrnoError(28);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (!stream.stream_ops.allocate) {
              throw new FS.ErrnoError(138);
            }
            stream.stream_ops.allocate(stream, offset, length);
          }, mmap: function(stream, address, length, position, prot, flags) {
            address >>>= 0;
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
          }, msync: function(stream, buffer2, offset, length, mmapFlags) {
            offset >>>= 0;
            if (!stream || !stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
          }, munmap: function(stream) {
            return 0;
          }, ioctl: function(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          }, readFile: function(path, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error('Invalid encoding type "' + opts.encoding + '"');
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf, 0);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          }, writeFile: function(path, data, opts) {
            opts = opts || {};
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data === "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          }, cwd: function() {
            return FS.currentPath;
          }, chdir: function(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          }, createDefaultDirectories: function() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          }, createDefaultDevices: function() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), { read: function() {
              return 0;
            }, write: function(stream, buffer2, offset, length, pos) {
              return length;
            } });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var random_device = getRandomDevice();
            FS.createDevice("/dev", "random", random_device);
            FS.createDevice("/dev", "urandom", random_device);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          }, createSpecialDirectories: function() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({ mount: function() {
              var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
              node.node_ops = { lookup: function(parent, name2) {
                var fd = +name2;
                var stream = FS.getStream(fd);
                if (!stream)
                  throw new FS.ErrnoError(8);
                var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                  return stream.path;
                } } };
                ret.parent = ret;
                return ret;
              } };
              return node;
            } }, {}, "/proc/self/fd");
          }, createStandardStreams: function() {
            if (Module["stdin"]) {
              FS.createDevice("/dev", "stdin", Module["stdin"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (Module["stdout"]) {
              FS.createDevice("/dev", "stdout", null, Module["stdout"]);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (Module["stderr"]) {
              FS.createDevice("/dev", "stderr", null, Module["stderr"]);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
          }, ensureErrnoError: function() {
            if (FS.ErrnoError)
              return;
            FS.ErrnoError = function ErrnoError(errno, node) {
              this.node = node;
              this.setErrno = function(errno2) {
                this.errno = errno2;
              };
              this.setErrno(errno);
              this.message = "FS error";
            };
            FS.ErrnoError.prototype = new Error();
            FS.ErrnoError.prototype.constructor = FS.ErrnoError;
            [44].forEach(function(code) {
              FS.genericErrors[code] = new FS.ErrnoError(code);
              FS.genericErrors[code].stack = "<generic error, no stack>";
            });
          }, staticInit: function() {
            FS.ensureErrnoError();
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = { "MEMFS": MEMFS };
          }, init: function(input, output, error) {
            FS.init.initialized = true;
            FS.ensureErrnoError();
            Module["stdin"] = input || Module["stdin"];
            Module["stdout"] = output || Module["stdout"];
            Module["stderr"] = error || Module["stderr"];
            FS.createStandardStreams();
          }, quit: function() {
            FS.init.initialized = false;
            var fflush = Module["_fflush"];
            if (fflush)
              fflush(0);
            for (var i = 0; i < FS.streams.length; i++) {
              var stream = FS.streams[i];
              if (!stream) {
                continue;
              }
              FS.close(stream);
            }
          }, getMode: function(canRead, canWrite) {
            var mode = 0;
            if (canRead)
              mode |= 292 | 73;
            if (canWrite)
              mode |= 146;
            return mode;
          }, findObject: function(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (ret.exists) {
              return ret.object;
            } else {
              return null;
            }
          }, analyzePath: function(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          }, createPath: function(parent, path, canRead, canWrite) {
            parent = typeof parent === "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
              }
              parent = current;
            }
            return current;
          }, createFile: function(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(canRead, canWrite);
            return FS.create(path, mode);
          }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
            var mode = FS.getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data === "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
            return node;
          }, createDevice: function(parent, name2, input, output) {
            var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
            var mode = FS.getMode(!!input, !!output);
            if (!FS.createDevice.major)
              FS.createDevice.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, { open: function(stream) {
              stream.seekable = false;
            }, close: function(stream) {
              if (output && output.buffer && output.buffer.length) {
                output(10);
              }
            }, read: function(stream, buffer2, offset, length, pos) {
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result;
                try {
                  result = input();
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result === null || result === void 0)
                  break;
                bytesRead++;
                buffer2[offset + i] = result;
              }
              if (bytesRead) {
                stream.node.timestamp = Date.now();
              }
              return bytesRead;
            }, write: function(stream, buffer2, offset, length, pos) {
              for (var i = 0; i < length; i++) {
                try {
                  output(buffer2[offset + i]);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              }
              if (length) {
                stream.node.timestamp = Date.now();
              }
              return i;
            } });
            return FS.mkdev(path, mode, dev);
          }, forceLoadFile: function(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest !== "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else if (read_) {
              try {
                obj.contents = intArrayFromString(read_(obj.url), true);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            } else {
              throw new Error("Cannot load without read() or XMLHttpRequest.");
            }
          }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
            function LazyUint8Array() {
              this.lengthKnown = false;
              this.chunks = [];
            }
            LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
              if (idx > this.length - 1 || idx < 0) {
                return void 0;
              }
              var chunkOffset = idx % this.chunkSize;
              var chunkNum = idx / this.chunkSize | 0;
              return this.getter(chunkNum)[chunkOffset];
            };
            LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
              this.getter = getter;
            };
            LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
              var xhr = new XMLHttpRequest();
              xhr.open("HEAD", url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
              var chunkSize = 1024 * 1024;
              if (!hasByteServing)
                chunkSize = datalength;
              var doXHR = function(from, to) {
                if (from > to)
                  throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength - 1)
                  throw new Error("only " + datalength + " bytes available! programmer error!");
                var xhr2 = new XMLHttpRequest();
                xhr2.open("GET", url, false);
                if (datalength !== chunkSize)
                  xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                if (typeof Uint8Array != "undefined")
                  xhr2.responseType = "arraybuffer";
                if (xhr2.overrideMimeType) {
                  xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                }
                xhr2.send(null);
                if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                  throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                if (xhr2.response !== void 0) {
                  return new Uint8Array(xhr2.response || []);
                } else {
                  return intArrayFromString(xhr2.responseText || "", true);
                }
              };
              var lazyArray2 = this;
              lazyArray2.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum + 1) * chunkSize - 1;
                end = Math.min(end, datalength - 1);
                if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                  lazyArray2.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                  throw new Error("doXHR failed!");
                return lazyArray2.chunks[chunkNum];
              });
              if (usesGzip || !datalength) {
                chunkSize = datalength = 1;
                datalength = this.getter(0).length;
                chunkSize = datalength;
                out("LazyFiles on gzip forces download of the whole file when length is accessed");
              }
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
            };
            if (typeof XMLHttpRequest !== "undefined") {
              if (!ENVIRONMENT_IS_WORKER)
                throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              Object.defineProperties(lazyArray, { length: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              } }, chunkSize: { get: function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              } } });
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, { usedBytes: { get: function() {
              return this.contents.length;
            } } });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach(function(key2) {
              var fn = node.stream_ops[key2];
              stream_ops[key2] = function forceLoadLazyFile() {
                FS.forceLoadFile(node);
                return fn.apply(null, arguments);
              };
            });
            stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
              FS.forceLoadFile(node);
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer2[offset + i] = contents.get(position + i);
                }
              }
              return size;
            };
            node.stream_ops = stream_ops;
            return node;
          }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
            Browser.init();
            var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
            var dep = getUniqueRunDependency("cp " + fullname);
            function processData(byteArray) {
              function finish(byteArray2) {
                if (preFinish)
                  preFinish();
                if (!dontCreateFile) {
                  FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
                }
                if (onload)
                  onload();
                removeRunDependency(dep);
              }
              var handled = false;
              Module["preloadPlugins"].forEach(function(plugin) {
                if (handled)
                  return;
                if (plugin["canHandle"](fullname)) {
                  plugin["handle"](byteArray, fullname, finish, function() {
                    if (onerror)
                      onerror();
                    removeRunDependency(dep);
                  });
                  handled = true;
                }
              });
              if (!handled)
                finish(byteArray);
            }
            addRunDependency(dep);
            if (typeof url == "string") {
              asyncLoad(url, function(byteArray) {
                processData(byteArray);
              }, onerror);
            } else {
              processData(url);
            }
          }, indexedDB: function() {
            return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
          }, DB_NAME: function() {
            return "EM_FS_" + window.location.pathname;
          }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
              out("creating db");
              var db = openRequest.result;
              db.createObjectStore(FS.DB_STORE_NAME);
            };
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                putRequest.onsuccess = function putRequest_onsuccess() {
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                putRequest.onerror = function putRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          }, loadFilesFromDB: function(paths, onload, onerror) {
            onload = onload || function() {
            };
            onerror = onerror || function() {
            };
            var indexedDB = FS.indexedDB();
            try {
              var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
            } catch (e) {
              return onerror(e);
            }
            openRequest.onupgradeneeded = onerror;
            openRequest.onsuccess = function openRequest_onsuccess() {
              var db = openRequest.result;
              try {
                var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
              } catch (e) {
                onerror(e);
                return;
              }
              var files = transaction.objectStore(FS.DB_STORE_NAME);
              var ok = 0, fail = 0, total = paths.length;
              function finish() {
                if (fail == 0)
                  onload();
                else
                  onerror();
              }
              paths.forEach(function(path) {
                var getRequest = files.get(path);
                getRequest.onsuccess = function getRequest_onsuccess() {
                  if (FS.analyzePath(path).exists) {
                    FS.unlink(path);
                  }
                  FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                  ok++;
                  if (ok + fail == total)
                    finish();
                };
                getRequest.onerror = function getRequest_onerror() {
                  fail++;
                  if (ok + fail == total)
                    finish();
                };
              });
              transaction.onerror = onerror;
            };
            openRequest.onerror = onerror;
          } };
          var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
            if (path[0] === "/") {
              return path;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = FS.getStream(dirfd);
              if (!dirstream)
                throw new FS.ErrnoError(8);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return PATH.join2(dir, path);
          }, doStat: function(func, path, buf) {
            try {
              var stat = func(path);
            } catch (e) {
              if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                return -54;
              }
              throw e;
            }
            HEAP32[buf >>> 2] = stat.dev;
            HEAP32[buf + 4 >>> 2] = 0;
            HEAP32[buf + 8 >>> 2] = stat.ino;
            HEAP32[buf + 12 >>> 2] = stat.mode;
            HEAP32[buf + 16 >>> 2] = stat.nlink;
            HEAP32[buf + 20 >>> 2] = stat.uid;
            HEAP32[buf + 24 >>> 2] = stat.gid;
            HEAP32[buf + 28 >>> 2] = stat.rdev;
            HEAP32[buf + 32 >>> 2] = 0;
            tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2] = tempI64[0], HEAP32[buf + 44 >>> 2] = tempI64[1];
            HEAP32[buf + 48 >>> 2] = 4096;
            HEAP32[buf + 52 >>> 2] = stat.blocks;
            HEAP32[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
            HEAP32[buf + 60 >>> 2] = 0;
            HEAP32[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
            HEAP32[buf + 68 >>> 2] = 0;
            HEAP32[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
            HEAP32[buf + 76 >>> 2] = 0;
            tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >>> 2] = tempI64[0], HEAP32[buf + 84 >>> 2] = tempI64[1];
            return 0;
          }, doMsync: function(addr, stream, len, flags, offset) {
            var buffer2 = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer2, offset, len, flags);
          }, doMkdir: function(path, mode) {
            path = PATH.normalize(path);
            if (path[path.length - 1] === "/")
              path = path.substr(0, path.length - 1);
            FS.mkdir(path, mode, 0);
            return 0;
          }, doMknod: function(path, mode, dev) {
            switch (mode & 61440) {
              case 32768:
              case 8192:
              case 24576:
              case 4096:
              case 49152:
                break;
              default:
                return -28;
            }
            FS.mknod(path, mode, dev);
            return 0;
          }, doReadlink: function(path, buf, bufsize) {
            if (bufsize <= 0)
              return -28;
            var ret = FS.readlink(path);
            var len = Math.min(bufsize, lengthBytesUTF8(ret));
            var endChar = HEAP8[buf + len >>> 0];
            stringToUTF8(ret, buf, bufsize + 1);
            HEAP8[buf + len >>> 0] = endChar;
            return len;
          }, doAccess: function(path, amode) {
            if (amode & ~7) {
              return -28;
            }
            var node;
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
            if (!node) {
              return -44;
            }
            var perms = "";
            if (amode & 4)
              perms += "r";
            if (amode & 2)
              perms += "w";
            if (amode & 1)
              perms += "x";
            if (perms && FS.nodePermissions(node, perms)) {
              return -2;
            }
            return 0;
          }, doDup: function(path, flags, suggestFD) {
            var suggest = FS.getStream(suggestFD);
            if (suggest)
              FS.close(suggest);
            return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
          }, doReadv: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >>> 2];
              var len = HEAP32[iov + (i * 8 + 4) >>> 2];
              var curr = FS.read(stream, HEAP8, ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
              if (curr < len)
                break;
            }
            return ret;
          }, doWritev: function(stream, iov, iovcnt, offset) {
            var ret = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAP32[iov + i * 8 >>> 2];
              var len = HEAP32[iov + (i * 8 + 4) >>> 2];
              var curr = FS.write(stream, HEAP8, ptr, len, offset);
              if (curr < 0)
                return -1;
              ret += curr;
            }
            return ret;
          }, varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }, getStreamFromFD: function(fd) {
            var stream = FS.getStream(fd);
            if (!stream)
              throw new FS.ErrnoError(8);
            return stream;
          }, get64: function(low, high) {
            return low;
          } };
          function ___sys_fcntl64(fd, cmd, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (cmd) {
                case 0: {
                  var arg = SYSCALLS.get();
                  if (arg < 0) {
                    return -28;
                  }
                  var newStream;
                  newStream = FS.open(stream.path, stream.flags, 0, arg);
                  return newStream.fd;
                }
                case 1:
                case 2:
                  return 0;
                case 3:
                  return stream.flags;
                case 4: {
                  var arg = SYSCALLS.get();
                  stream.flags |= arg;
                  return 0;
                }
                case 12: {
                  var arg = SYSCALLS.get();
                  var offset = 0;
                  HEAP16[arg + offset >>> 1] = 2;
                  return 0;
                }
                case 13:
                case 14:
                  return 0;
                case 16:
                case 8:
                  return -28;
                case 9:
                  setErrNo(28);
                  return -1;
                default: {
                  return -28;
                }
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_ioctl(fd, op, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              switch (op) {
                case 21509:
                case 21505: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21510:
                case 21511:
                case 21512:
                case 21506:
                case 21507:
                case 21508: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21519: {
                  if (!stream.tty)
                    return -59;
                  var argp = SYSCALLS.get();
                  HEAP32[argp >>> 2] = 0;
                  return 0;
                }
                case 21520: {
                  if (!stream.tty)
                    return -59;
                  return -28;
                }
                case 21531: {
                  var argp = SYSCALLS.get();
                  return FS.ioctl(stream, op, argp);
                }
                case 21523: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                case 21524: {
                  if (!stream.tty)
                    return -59;
                  return 0;
                }
                default:
                  abort("bad ioctl syscall " + op);
              }
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          function ___sys_open(path, flags, varargs) {
            SYSCALLS.varargs = varargs;
            try {
              var pathname = SYSCALLS.getStr(path);
              var mode = varargs ? SYSCALLS.get() : 0;
              var stream = FS.open(pathname, flags, mode);
              return stream.fd;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return -e.errno;
            }
          }
          var tupleRegistrations = {};
          function runDestructors(destructors) {
            while (destructors.length) {
              var ptr = destructors.pop();
              var del = destructors.pop();
              del(ptr);
            }
          }
          function simpleReadValueFromPointer(pointer) {
            return this["fromWireType"](HEAPU32[pointer >>> 2]);
          }
          var awaitingDependencies = {};
          var registeredTypes = {};
          var typeDependencies = {};
          var char_0 = 48;
          var char_9 = 57;
          function makeLegalFunctionName(name2) {
            if (name2 === void 0) {
              return "_unknown";
            }
            name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
            var f = name2.charCodeAt(0);
            if (f >= char_0 && f <= char_9) {
              return "_" + name2;
            } else {
              return name2;
            }
          }
          function createNamedFunction(name2, body) {
            name2 = makeLegalFunctionName(name2);
            return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
          }
          function extendError(baseErrorType, errorName) {
            var errorClass = createNamedFunction(errorName, function(message) {
              this.name = errorName;
              this.message = message;
              var stack = new Error(message).stack;
              if (stack !== void 0) {
                this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
              }
            });
            errorClass.prototype = Object.create(baseErrorType.prototype);
            errorClass.prototype.constructor = errorClass;
            errorClass.prototype.toString = function() {
              if (this.message === void 0) {
                return this.name;
              } else {
                return this.name + ": " + this.message;
              }
            };
            return errorClass;
          }
          var InternalError = void 0;
          function throwInternalError(message) {
            throw new InternalError(message);
          }
          function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
            myTypes.forEach(function(type) {
              typeDependencies[type] = dependentTypes;
            });
            function onComplete(typeConverters2) {
              var myTypeConverters = getTypeConverters(typeConverters2);
              if (myTypeConverters.length !== myTypes.length) {
                throwInternalError("Mismatched type converter count");
              }
              for (var i = 0; i < myTypes.length; ++i) {
                registerType(myTypes[i], myTypeConverters[i]);
              }
            }
            var typeConverters = new Array(dependentTypes.length);
            var unregisteredTypes = [];
            var registered = 0;
            dependentTypes.forEach(function(dt, i) {
              if (registeredTypes.hasOwnProperty(dt)) {
                typeConverters[i] = registeredTypes[dt];
              } else {
                unregisteredTypes.push(dt);
                if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
                }
                awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                  }
                });
              }
            });
            if (unregisteredTypes.length === 0) {
              onComplete(typeConverters);
            }
          }
          function __embind_finalize_value_array(rawTupleType) {
            var reg = tupleRegistrations[rawTupleType];
            delete tupleRegistrations[rawTupleType];
            var elements = reg.elements;
            var elementsLength = elements.length;
            var elementTypes = elements.map(function(elt) {
              return elt.getterReturnType;
            }).concat(elements.map(function(elt) {
              return elt.setterArgumentType;
            }));
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
              elements.forEach(function(elt, i) {
                var getterReturnType = elementTypes2[i];
                var getter = elt.getter;
                var getterContext = elt.getterContext;
                var setterArgumentType = elementTypes2[i + elementsLength];
                var setter = elt.setter;
                var setterContext = elt.setterContext;
                elt.read = function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                };
                elt.write = function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = new Array(elementsLength);
                for (var i = 0; i < elementsLength; ++i) {
                  rv[i] = elements[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                if (elementsLength !== o.length) {
                  throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
                }
                var ptr = rawConstructor();
                for (var i = 0; i < elementsLength; ++i) {
                  elements[i].write(ptr, o[i]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          var structRegistrations = {};
          function __embind_finalize_value_object(structType) {
            var reg = structRegistrations[structType];
            delete structRegistrations[structType];
            var rawConstructor = reg.rawConstructor;
            var rawDestructor = reg.rawDestructor;
            var fieldRecords = reg.fields;
            var fieldTypes = fieldRecords.map(function(field) {
              return field.getterReturnType;
            }).concat(fieldRecords.map(function(field) {
              return field.setterArgumentType;
            }));
            whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
              var fields = {};
              fieldRecords.forEach(function(field, i) {
                var fieldName = field.fieldName;
                var getterReturnType = fieldTypes2[i];
                var getter = field.getter;
                var getterContext = field.getterContext;
                var setterArgumentType = fieldTypes2[i + fieldRecords.length];
                var setter = field.setter;
                var setterContext = field.setterContext;
                fields[fieldName] = { read: function(ptr) {
                  return getterReturnType["fromWireType"](getter(getterContext, ptr));
                }, write: function(ptr, o) {
                  var destructors = [];
                  setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                  runDestructors(destructors);
                } };
              });
              return [{ name: reg.name, "fromWireType": function(ptr) {
                var rv = {};
                for (var i in fields) {
                  rv[i] = fields[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
              }, "toWireType": function(destructors, o) {
                for (var fieldName in fields) {
                  if (!(fieldName in o)) {
                    throw new TypeError('Missing field:  "' + fieldName + '"');
                  }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                  fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                  destructors.push(rawDestructor, ptr);
                }
                return ptr;
              }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
            });
          }
          function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
          }
          function getShiftFromSize(size) {
            switch (size) {
              case 1:
                return 0;
              case 2:
                return 1;
              case 4:
                return 2;
              case 8:
                return 3;
              default:
                throw new TypeError("Unknown type size: " + size);
            }
          }
          function embind_init_charCodes() {
            var codes = new Array(256);
            for (var i = 0; i < 256; ++i) {
              codes[i] = String.fromCharCode(i);
            }
            embind_charCodes = codes;
          }
          var embind_charCodes = void 0;
          function readLatin1String(ptr) {
            var ret = "";
            var c = ptr;
            while (HEAPU8[c >>> 0]) {
              ret += embind_charCodes[HEAPU8[c++ >>> 0]];
            }
            return ret;
          }
          var BindingError = void 0;
          function throwBindingError(message) {
            throw new BindingError(message);
          }
          function registerType(rawType, registeredInstance, options) {
            options = options || {};
            if (!("argPackAdvance" in registeredInstance)) {
              throw new TypeError("registerType registeredInstance requires argPackAdvance");
            }
            var name2 = registeredInstance.name;
            if (!rawType) {
              throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
            }
            if (registeredTypes.hasOwnProperty(rawType)) {
              if (options.ignoreDuplicateRegistrations) {
                return;
              } else {
                throwBindingError("Cannot register type '" + name2 + "' twice");
              }
            }
            registeredTypes[rawType] = registeredInstance;
            delete typeDependencies[rawType];
            if (awaitingDependencies.hasOwnProperty(rawType)) {
              var callbacks = awaitingDependencies[rawType];
              delete awaitingDependencies[rawType];
              callbacks.forEach(function(cb) {
                cb();
              });
            }
          }
          function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(wt) {
              return !!wt;
            }, "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
              var heap;
              if (size === 1) {
                heap = HEAP8;
              } else if (size === 2) {
                heap = HEAP16;
              } else if (size === 4) {
                heap = HEAP32;
              } else {
                throw new TypeError("Unknown boolean type size: " + name2);
              }
              return this["fromWireType"](heap[pointer >>> shift]);
            }, destructorFunction: null });
          }
          function ClassHandle_isAliasOf(other) {
            if (!(this instanceof ClassHandle)) {
              return false;
            }
            if (!(other instanceof ClassHandle)) {
              return false;
            }
            var leftClass = this.$$.ptrType.registeredClass;
            var left = this.$$.ptr;
            var rightClass = other.$$.ptrType.registeredClass;
            var right = other.$$.ptr;
            while (leftClass.baseClass) {
              left = leftClass.upcast(left);
              leftClass = leftClass.baseClass;
            }
            while (rightClass.baseClass) {
              right = rightClass.upcast(right);
              rightClass = rightClass.baseClass;
            }
            return leftClass === rightClass && left === right;
          }
          function shallowCopyInternalPointer(o) {
            return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
          }
          function throwInstanceAlreadyDeleted(obj) {
            function getInstanceTypeName(handle) {
              return handle.$$.ptrType.registeredClass.name;
            }
            throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
          }
          var finalizationGroup = false;
          function detachFinalizer(handle) {
          }
          function runDestructor($$) {
            if ($$.smartPtr) {
              $$.smartPtrType.rawDestructor($$.smartPtr);
            } else {
              $$.ptrType.registeredClass.rawDestructor($$.ptr);
            }
          }
          function releaseClassHandle($$) {
            $$.count.value -= 1;
            var toDelete = $$.count.value === 0;
            if (toDelete) {
              runDestructor($$);
            }
          }
          function attachFinalizer(handle) {
            if (typeof FinalizationGroup === "undefined") {
              attachFinalizer = function(handle2) {
                return handle2;
              };
              return handle;
            }
            finalizationGroup = new FinalizationGroup(function(iter) {
              for (var result = iter.next(); !result.done; result = iter.next()) {
                var $$ = result.value;
                if (!$$.ptr) {
                  console.warn("object already deleted: " + $$.ptr);
                } else {
                  releaseClassHandle($$);
                }
              }
            });
            attachFinalizer = function(handle2) {
              finalizationGroup.register(handle2, handle2.$$, handle2.$$);
              return handle2;
            };
            detachFinalizer = function(handle2) {
              finalizationGroup.unregister(handle2.$$);
            };
            return attachFinalizer(handle);
          }
          function ClassHandle_clone() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.preservePointerOnDelete) {
              this.$$.count.value += 1;
              return this;
            } else {
              var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
              clone.$$.count.value += 1;
              clone.$$.deleteScheduled = false;
              return clone;
            }
          }
          function ClassHandle_delete() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            detachFinalizer(this);
            releaseClassHandle(this.$$);
            if (!this.$$.preservePointerOnDelete) {
              this.$$.smartPtr = void 0;
              this.$$.ptr = void 0;
            }
          }
          function ClassHandle_isDeleted() {
            return !this.$$.ptr;
          }
          var delayFunction = void 0;
          var deletionQueue = [];
          function flushPendingDeletes() {
            while (deletionQueue.length) {
              var obj = deletionQueue.pop();
              obj.$$.deleteScheduled = false;
              obj["delete"]();
            }
          }
          function ClassHandle_deleteLater() {
            if (!this.$$.ptr) {
              throwInstanceAlreadyDeleted(this);
            }
            if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
              throwBindingError("Object already scheduled for deletion");
            }
            deletionQueue.push(this);
            if (deletionQueue.length === 1 && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
            this.$$.deleteScheduled = true;
            return this;
          }
          function init_ClassHandle() {
            ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
            ClassHandle.prototype["clone"] = ClassHandle_clone;
            ClassHandle.prototype["delete"] = ClassHandle_delete;
            ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
            ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
          }
          function ClassHandle() {
          }
          var registeredPointers = {};
          function ensureOverloadTable(proto, methodName, humanName) {
            if (proto[methodName].overloadTable === void 0) {
              var prevFunc = proto[methodName];
              proto[methodName] = function() {
                if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
                }
                return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
              };
              proto[methodName].overloadTable = [];
              proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
            }
          }
          function exposePublicSymbol(name2, value, numArguments) {
            if (Module.hasOwnProperty(name2)) {
              if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
                throwBindingError("Cannot register public name '" + name2 + "' twice");
              }
              ensureOverloadTable(Module, name2, name2);
              if (Module.hasOwnProperty(numArguments)) {
                throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
              }
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              if (numArguments !== void 0) {
                Module[name2].numArguments = numArguments;
              }
            }
          }
          function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
            this.name = name2;
            this.constructor = constructor;
            this.instancePrototype = instancePrototype;
            this.rawDestructor = rawDestructor;
            this.baseClass = baseClass;
            this.getActualType = getActualType;
            this.upcast = upcast;
            this.downcast = downcast;
            this.pureVirtualFunctions = [];
          }
          function upcastPointer(ptr, ptrClass, desiredClass) {
            while (ptrClass !== desiredClass) {
              if (!ptrClass.upcast) {
                throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
              }
              ptr = ptrClass.upcast(ptr);
              ptrClass = ptrClass.baseClass;
            }
            return ptr;
          }
          function constNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function genericPointerToWireType(destructors, handle) {
            var ptr;
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              if (this.isSmartPointer) {
                ptr = this.rawConstructor();
                if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
                }
                return ptr;
              } else {
                return 0;
              }
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (!this.isConst && handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            if (this.isSmartPointer) {
              if (handle.$$.smartPtr === void 0) {
                throwBindingError("Passing raw pointer to smart pointer is illegal");
              }
              switch (this.sharingPolicy) {
                case 0:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                  }
                  break;
                case 1:
                  ptr = handle.$$.smartPtr;
                  break;
                case 2:
                  if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                  } else {
                    var clonedHandle = handle["clone"]();
                    ptr = this.rawShare(ptr, __emval_register(function() {
                      clonedHandle["delete"]();
                    }));
                    if (destructors !== null) {
                      destructors.push(this.rawDestructor, ptr);
                    }
                  }
                  break;
                default:
                  throwBindingError("Unsupporting sharing policy");
              }
            }
            return ptr;
          }
          function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
            if (handle === null) {
              if (this.isReference) {
                throwBindingError("null is not a valid " + this.name);
              }
              return 0;
            }
            if (!handle.$$) {
              throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
            }
            if (!handle.$$.ptr) {
              throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
            }
            if (handle.$$.ptrType.isConst) {
              throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
            }
            var handleClass = handle.$$.ptrType.registeredClass;
            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
            return ptr;
          }
          function RegisteredPointer_getPointee(ptr) {
            if (this.rawGetPointee) {
              ptr = this.rawGetPointee(ptr);
            }
            return ptr;
          }
          function RegisteredPointer_destructor(ptr) {
            if (this.rawDestructor) {
              this.rawDestructor(ptr);
            }
          }
          function RegisteredPointer_deleteObject(handle) {
            if (handle !== null) {
              handle["delete"]();
            }
          }
          function downcastPointer(ptr, ptrClass, desiredClass) {
            if (ptrClass === desiredClass) {
              return ptr;
            }
            if (desiredClass.baseClass === void 0) {
              return null;
            }
            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
            if (rv === null) {
              return null;
            }
            return desiredClass.downcast(rv);
          }
          function getInheritedInstanceCount() {
            return Object.keys(registeredInstances).length;
          }
          function getLiveInheritedInstances() {
            var rv = [];
            for (var k in registeredInstances) {
              if (registeredInstances.hasOwnProperty(k)) {
                rv.push(registeredInstances[k]);
              }
            }
            return rv;
          }
          function setDelayFunction(fn) {
            delayFunction = fn;
            if (deletionQueue.length && delayFunction) {
              delayFunction(flushPendingDeletes);
            }
          }
          function init_embind() {
            Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
            Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
            Module["flushPendingDeletes"] = flushPendingDeletes;
            Module["setDelayFunction"] = setDelayFunction;
          }
          var registeredInstances = {};
          function getBasestPointer(class_, ptr) {
            if (ptr === void 0) {
              throwBindingError("ptr should not be undefined");
            }
            while (class_.baseClass) {
              ptr = class_.upcast(ptr);
              class_ = class_.baseClass;
            }
            return ptr;
          }
          function getInheritedInstance(class_, ptr) {
            ptr = getBasestPointer(class_, ptr);
            return registeredInstances[ptr];
          }
          function makeClassHandle(prototype, record) {
            if (!record.ptrType || !record.ptr) {
              throwInternalError("makeClassHandle requires ptr and ptrType");
            }
            var hasSmartPtrType = !!record.smartPtrType;
            var hasSmartPtr = !!record.smartPtr;
            if (hasSmartPtrType !== hasSmartPtr) {
              throwInternalError("Both smartPtrType and smartPtr must be specified");
            }
            record.count = { value: 1 };
            return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
          }
          function RegisteredPointer_fromWireType(ptr) {
            var rawPointer = this.getPointee(ptr);
            if (!rawPointer) {
              this.destructor(ptr);
              return null;
            }
            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
            if (registeredInstance !== void 0) {
              if (registeredInstance.$$.count.value === 0) {
                registeredInstance.$$.ptr = rawPointer;
                registeredInstance.$$.smartPtr = ptr;
                return registeredInstance["clone"]();
              } else {
                var rv = registeredInstance["clone"]();
                this.destructor(ptr);
                return rv;
              }
            }
            function makeDefaultHandle() {
              if (this.isSmartPointer) {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
              } else {
                return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
              }
            }
            var actualType = this.registeredClass.getActualType(rawPointer);
            var registeredPointerRecord = registeredPointers[actualType];
            if (!registeredPointerRecord) {
              return makeDefaultHandle.call(this);
            }
            var toType;
            if (this.isConst) {
              toType = registeredPointerRecord.constPointerType;
            } else {
              toType = registeredPointerRecord.pointerType;
            }
            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
            if (dp === null) {
              return makeDefaultHandle.call(this);
            }
            if (this.isSmartPointer) {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
            }
          }
          function init_RegisteredPointer() {
            RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
            RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
            RegisteredPointer.prototype["argPackAdvance"] = 8;
            RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
            RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
            RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
          }
          function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
            this.name = name2;
            this.registeredClass = registeredClass;
            this.isReference = isReference;
            this.isConst = isConst;
            this.isSmartPointer = isSmartPointer;
            this.pointeeType = pointeeType;
            this.sharingPolicy = sharingPolicy;
            this.rawGetPointee = rawGetPointee;
            this.rawConstructor = rawConstructor;
            this.rawShare = rawShare;
            this.rawDestructor = rawDestructor;
            if (!isSmartPointer && registeredClass.baseClass === void 0) {
              if (isConst) {
                this["toWireType"] = constNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              } else {
                this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
                this.destructorFunction = null;
              }
            } else {
              this["toWireType"] = genericPointerToWireType;
            }
          }
          function replacePublicSymbol(name2, value, numArguments) {
            if (!Module.hasOwnProperty(name2)) {
              throwInternalError("Replacing nonexistant public symbol");
            }
            if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
              Module[name2].overloadTable[numArguments] = value;
            } else {
              Module[name2] = value;
              Module[name2].argCount = numArguments;
            }
          }
          function dynCallLegacy(sig, ptr, args) {
            var f = Module["dynCall_" + sig];
            return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
          }
          function dynCall(sig, ptr, args) {
            if (sig.includes("j")) {
              return dynCallLegacy(sig, ptr, args);
            }
            return wasmTable.get(ptr).apply(null, args);
          }
          function getDynCaller(sig, ptr) {
            var argCache = [];
            return function() {
              argCache.length = arguments.length;
              for (var i = 0; i < arguments.length; i++) {
                argCache[i] = arguments[i];
              }
              return dynCall(sig, ptr, argCache);
            };
          }
          function embind__requireFunction(signature, rawFunction) {
            signature = readLatin1String(signature);
            function makeDynCaller() {
              if (signature.includes("j")) {
                return getDynCaller(signature, rawFunction);
              }
              return wasmTable.get(rawFunction);
            }
            var fp = makeDynCaller();
            if (typeof fp !== "function") {
              throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
            }
            return fp;
          }
          var UnboundTypeError = void 0;
          function getTypeName(type) {
            var ptr = ___getTypeName(type);
            var rv = readLatin1String(ptr);
            _free(ptr);
            return rv;
          }
          function throwUnboundTypeError(message, types) {
            var unboundTypes = [];
            var seen = {};
            function visit(type) {
              if (seen[type]) {
                return;
              }
              if (registeredTypes[type]) {
                return;
              }
              if (typeDependencies[type]) {
                typeDependencies[type].forEach(visit);
                return;
              }
              unboundTypes.push(type);
              seen[type] = true;
            }
            types.forEach(visit);
            throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
          }
          function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
            name2 = readLatin1String(name2);
            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
            if (upcast) {
              upcast = embind__requireFunction(upcastSignature, upcast);
            }
            if (downcast) {
              downcast = embind__requireFunction(downcastSignature, downcast);
            }
            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
            var legalFunctionName = makeLegalFunctionName(name2);
            exposePublicSymbol(legalFunctionName, function() {
              throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
            });
            whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError("Use 'new' to construct " + name2);
                }
                if (registeredClass.constructor_body === void 0) {
                  throw new BindingError(name2 + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (body === void 0) {
                  throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
              });
              var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
              var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
              var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
              var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
              registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            });
          }
          function heap32VectorToArray(count, firstElement) {
            var array = [];
            for (var i = 0; i < count; i++) {
              array.push(HEAP32[(firstElement >> 2) + i >>> 0]);
            }
            return array;
          }
          function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
            assert(argCount > 0);
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            invoker = embind__requireFunction(invokerSignature, invoker);
            var args = [rawConstructor];
            var destructors = [];
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = "constructor " + classType.name;
              if (classType.registeredClass.constructor_body === void 0) {
                classType.registeredClass.constructor_body = [];
              }
              if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
                throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
              }
              classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
                throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
              };
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                    args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                  }
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
                  return argTypes[0]["fromWireType"](ptr);
                };
                return [];
              });
              return [];
            });
          }
          function new_(constructor, argumentList) {
            if (!(constructor instanceof Function)) {
              throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
            }
            var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
            });
            dummy.prototype = constructor.prototype;
            var obj = new dummy();
            var r = constructor.apply(obj, argumentList);
            return r instanceof Object ? r : obj;
          }
          function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
            var argCount = argTypes.length;
            if (argCount < 2) {
              throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
            }
            var isClassMethodFunc = argTypes[1] !== null && classType !== null;
            var needsDestructorStack = false;
            for (var i = 1; i < argTypes.length; ++i) {
              if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
                needsDestructorStack = true;
                break;
              }
            }
            var returns = argTypes[0].name !== "void";
            var argsList = "";
            var argsListWired = "";
            for (var i = 0; i < argCount - 2; ++i) {
              argsList += (i !== 0 ? ", " : "") + "arg" + i;
              argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
            }
            var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
            if (needsDestructorStack) {
              invokerFnBody += "var destructors = [];\n";
            }
            var dtorStack = needsDestructorStack ? "destructors" : "null";
            var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
            var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
            if (isClassMethodFunc) {
              invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
            }
            for (var i = 0; i < argCount - 2; ++i) {
              invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
              args1.push("argType" + i);
              args2.push(argTypes[i + 2]);
            }
            if (isClassMethodFunc) {
              argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
            }
            invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
            if (needsDestructorStack) {
              invokerFnBody += "runDestructors(destructors);\n";
            } else {
              for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
                var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
                if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                  args1.push(paramName + "_dtor");
                  args2.push(argTypes[i].destructorFunction);
                }
              }
            }
            if (returns) {
              invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
            } else {
            }
            invokerFnBody += "}\n";
            args1.push(invokerFnBody);
            var invokerFunction = new_(Function, args1).apply(null, args2);
            return invokerFunction;
          }
          function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            methodName = readLatin1String(methodName);
            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
            whenDependentTypesAreResolved([], [rawClassType], function(classType) {
              classType = classType[0];
              var humanName = classType.name + "." + methodName;
              if (methodName.startsWith("@@")) {
                methodName = Symbol[methodName.substring(2)];
              }
              if (isPureVirtual) {
                classType.registeredClass.pureVirtualFunctions.push(methodName);
              }
              function unboundTypesHandler() {
                throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
              }
              var proto = classType.registeredClass.instancePrototype;
              var method = proto[methodName];
              if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
                unboundTypesHandler.argCount = argCount - 2;
                unboundTypesHandler.className = classType.name;
                proto[methodName] = unboundTypesHandler;
              } else {
                ensureOverloadTable(proto, methodName, humanName);
                proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
              }
              whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
                var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
                if (proto[methodName].overloadTable === void 0) {
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
                } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
                }
                return [];
              });
              return [];
            });
          }
          var emval_free_list = [];
          var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
          function __emval_decref(handle) {
            if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
              emval_handle_array[handle] = void 0;
              emval_free_list.push(handle);
            }
          }
          function count_emval_handles() {
            var count = 0;
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                ++count;
              }
            }
            return count;
          }
          function get_first_emval() {
            for (var i = 5; i < emval_handle_array.length; ++i) {
              if (emval_handle_array[i] !== void 0) {
                return emval_handle_array[i];
              }
            }
            return null;
          }
          function init_emval() {
            Module["count_emval_handles"] = count_emval_handles;
            Module["get_first_emval"] = get_first_emval;
          }
          function __emval_register(value) {
            switch (value) {
              case void 0: {
                return 1;
              }
              case null: {
                return 2;
              }
              case true: {
                return 3;
              }
              case false: {
                return 4;
              }
              default: {
                var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
                emval_handle_array[handle] = { refcount: 1, value };
                return handle;
              }
            }
          }
          function __embind_register_emval(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
            }, "toWireType": function(destructors, value) {
              return __emval_register(value);
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
          }
          function enumReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return function(pointer) {
                  var heap = signed ? HEAP8 : HEAPU8;
                  return this["fromWireType"](heap[pointer >>> 0]);
                };
              case 1:
                return function(pointer) {
                  var heap = signed ? HEAP16 : HEAPU16;
                  return this["fromWireType"](heap[pointer >>> 1]);
                };
              case 2:
                return function(pointer) {
                  var heap = signed ? HEAP32 : HEAPU32;
                  return this["fromWireType"](heap[pointer >>> 2]);
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_enum(rawType, name2, size, isSigned) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            function ctor() {
            }
            ctor.values = {};
            registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
              return this.constructor.values[c];
            }, "toWireType": function(destructors, c) {
              return c.value;
            }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
            exposePublicSymbol(name2, ctor);
          }
          function requireRegisteredType(rawType, humanName) {
            var impl = registeredTypes[rawType];
            if (impl === void 0) {
              throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
            }
            return impl;
          }
          function __embind_register_enum_value(rawEnumType, name2, enumValue) {
            var enumType = requireRegisteredType(rawEnumType, "enum");
            name2 = readLatin1String(name2);
            var Enum = enumType.constructor;
            var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
            }) } });
            Enum.values[enumValue] = Value2;
            Enum[name2] = Value2;
          }
          function _embind_repr(v) {
            if (v === null) {
              return "null";
            }
            var t = typeof v;
            if (t === "object" || t === "array" || t === "function") {
              return v.toString();
            } else {
              return "" + v;
            }
          }
          function floatReadValueFromPointer(name2, shift) {
            switch (shift) {
              case 2:
                return function(pointer) {
                  return this["fromWireType"](HEAPF32[pointer >>> 2]);
                };
              case 3:
                return function(pointer) {
                  return this["fromWireType"](HEAPF64[pointer >>> 3]);
                };
              default:
                throw new TypeError("Unknown float type: " + name2);
            }
          }
          function __embind_register_float(rawType, name2, size) {
            var shift = getShiftFromSize(size);
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              return value;
            }, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
            }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
          }
          function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
            name2 = readLatin1String(name2);
            rawInvoker = embind__requireFunction(signature, rawInvoker);
            exposePublicSymbol(name2, function() {
              throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
            }, argCount - 1);
            whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
              var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
              replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
              return [];
            });
          }
          function integerReadValueFromPointer(name2, shift, signed) {
            switch (shift) {
              case 0:
                return signed ? function readS8FromPointer(pointer) {
                  return HEAP8[pointer >>> 0];
                } : function readU8FromPointer(pointer) {
                  return HEAPU8[pointer >>> 0];
                };
              case 1:
                return signed ? function readS16FromPointer(pointer) {
                  return HEAP16[pointer >>> 1];
                } : function readU16FromPointer(pointer) {
                  return HEAPU16[pointer >>> 1];
                };
              case 2:
                return signed ? function readS32FromPointer(pointer) {
                  return HEAP32[pointer >>> 2];
                } : function readU32FromPointer(pointer) {
                  return HEAPU32[pointer >>> 2];
                };
              default:
                throw new TypeError("Unknown integer type: " + name2);
            }
          }
          function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
            name2 = readLatin1String(name2);
            if (maxRange === -1) {
              maxRange = 4294967295;
            }
            var shift = getShiftFromSize(size);
            var fromWireType = function(value) {
              return value;
            };
            if (minRange === 0) {
              var bitshift = 32 - 8 * size;
              fromWireType = function(value) {
                return value << bitshift >>> bitshift;
              };
            }
            var isUnsignedType = name2.includes("unsigned");
            registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
              if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
              }
              return isUnsignedType ? value >>> 0 : value | 0;
            }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
          }
          function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
            var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
            var TA = typeMapping[dataTypeIndex];
            function decodeMemoryView(handle) {
              handle = handle >> 2;
              var heap = HEAPU32;
              var size = heap[handle >>> 0];
              var data = heap[handle + 1 >>> 0];
              return new TA(buffer, data, size);
            }
            name2 = readLatin1String(name2);
            registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
          }
          function __embind_register_std_string(rawType, name2) {
            name2 = readLatin1String(name2);
            var stdStringIsUTF8 = name2 === "std::string";
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = HEAPU32[value >>> 2];
              var str;
              if (stdStringIsUTF8) {
                var decodeStartPtr = value + 4;
                for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i;
                  if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              } else {
                var a = new Array(length);
                for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAPU8[value + 4 + i >>> 0]);
                }
                str = a.join("");
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var getLength;
              var valueIsOfTypeString = typeof value === "string";
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                getLength = function() {
                  return lengthBytesUTF8(value);
                };
              } else {
                getLength = function() {
                  return value.length;
                };
              }
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              ptr >>>= 0;
              HEAPU32[ptr >>> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                stringToUTF8(value, ptr + 4, length + 1);
              } else {
                if (valueIsOfTypeString) {
                  for (var i = 0; i < length; ++i) {
                    var charCode = value.charCodeAt(i);
                    if (charCode > 255) {
                      _free(ptr);
                      throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                    }
                    HEAPU8[ptr + 4 + i >>> 0] = charCode;
                  }
                } else {
                  for (var i = 0; i < length; ++i) {
                    HEAPU8[ptr + 4 + i >>> 0] = value[i];
                  }
                }
              }
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_std_wstring(rawType, charSize, name2) {
            name2 = readLatin1String(name2);
            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
            if (charSize === 2) {
              decodeString = UTF16ToString;
              encodeString = stringToUTF16;
              lengthBytesUTF = lengthBytesUTF16;
              getHeap = function() {
                return HEAPU16;
              };
              shift = 1;
            } else if (charSize === 4) {
              decodeString = UTF32ToString;
              encodeString = stringToUTF32;
              lengthBytesUTF = lengthBytesUTF32;
              getHeap = function() {
                return HEAPU32;
              };
              shift = 2;
            }
            registerType(rawType, { name: name2, "fromWireType": function(value) {
              var length = HEAPU32[value >>> 2];
              var HEAP = getHeap();
              var str;
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            }, "toWireType": function(destructors, value) {
              if (!(typeof value === "string")) {
                throwBindingError("Cannot pass non-string to C++ string type " + name2);
              }
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              ptr >>>= 0;
              HEAPU32[ptr >>> 2] = length >> shift;
              encodeString(value, ptr + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
              _free(ptr);
            } });
          }
          function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
          }
          function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
            structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
          }
          function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
            structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
          }
          function __embind_register_void(rawType, name2) {
            name2 = readLatin1String(name2);
            registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
              return void 0;
            }, "toWireType": function(destructors, o) {
              return void 0;
            } });
          }
          function requireHandle(handle) {
            if (!handle) {
              throwBindingError("Cannot use deleted val. handle = " + handle);
            }
            return emval_handle_array[handle].value;
          }
          function __emval_as(handle, returnType, destructorsRef) {
            handle = requireHandle(handle);
            returnType = requireRegisteredType(returnType, "emval::as");
            var destructors = [];
            var rd = __emval_register(destructors);
            HEAP32[destructorsRef >>> 2] = rd;
            return returnType["toWireType"](destructors, handle);
          }
          function __emval_lookupTypes(argCount, argTypes) {
            var a = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i >>> 0], "parameter " + i);
            }
            return a;
          }
          function __emval_call(handle, argCount, argTypes, argv) {
            handle = requireHandle(handle);
            var types = __emval_lookupTypes(argCount, argTypes);
            var args = new Array(argCount);
            for (var i = 0; i < argCount; ++i) {
              var type = types[i];
              args[i] = type["readValueFromPointer"](argv);
              argv += type["argPackAdvance"];
            }
            var rv = handle.apply(void 0, args);
            return __emval_register(rv);
          }
          var emval_symbols = {};
          function getStringOrSymbol(address) {
            var symbol = emval_symbols[address];
            if (symbol === void 0) {
              return readLatin1String(address);
            } else {
              return symbol;
            }
          }
          function emval_get_global() {
            if (typeof globalThis === "object") {
              return globalThis;
            }
            return function() {
              return Function;
            }()("return this")();
          }
          function __emval_get_global(name2) {
            if (name2 === 0) {
              return __emval_register(emval_get_global());
            } else {
              name2 = getStringOrSymbol(name2);
              return __emval_register(emval_get_global()[name2]);
            }
          }
          function __emval_get_property(handle, key2) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            return __emval_register(handle[key2]);
          }
          function __emval_incref(handle) {
            if (handle > 4) {
              emval_handle_array[handle].refcount += 1;
            }
          }
          function __emval_instanceof(object, constructor) {
            object = requireHandle(object);
            constructor = requireHandle(constructor);
            return object instanceof constructor;
          }
          function __emval_is_number(handle) {
            handle = requireHandle(handle);
            return typeof handle === "number";
          }
          function __emval_new_array() {
            return __emval_register([]);
          }
          function __emval_new_cstring(v) {
            return __emval_register(getStringOrSymbol(v));
          }
          function __emval_new_object() {
            return __emval_register({});
          }
          function __emval_run_destructors(handle) {
            var destructors = emval_handle_array[handle].value;
            runDestructors(destructors);
            __emval_decref(handle);
          }
          function __emval_set_property(handle, key2, value) {
            handle = requireHandle(handle);
            key2 = requireHandle(key2);
            value = requireHandle(value);
            handle[key2] = value;
          }
          function __emval_take_value(type, argv) {
            type = requireRegisteredType(type, "_emval_take_value");
            var v = type["readValueFromPointer"](argv);
            return __emval_register(v);
          }
          function _abort() {
            abort();
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            _emscripten_get_now = function() {
              var t = process["hrtime"]();
              return t[0] * 1e3 + t[1] / 1e6;
            };
          } else
            _emscripten_get_now = function() {
              return performance.now();
            };
          var _emscripten_get_now_is_monotonic = true;
          function _clock_gettime(clk_id, tp) {
            var now;
            if (clk_id === 0) {
              now = Date.now();
            } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
              now = _emscripten_get_now();
            } else {
              setErrNo(28);
              return -1;
            }
            HEAP32[tp >>> 2] = now / 1e3 | 0;
            HEAP32[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
            return 0;
          }
          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          function emscripten_realloc_buffer(size) {
            try {
              wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
              updateGlobalBufferAndViews(wasmMemory.buffer);
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            var oldSize = HEAPU8.length;
            requestedSize = requestedSize >>> 0;
            var maxHeapSize = 4294901760;
            if (requestedSize > maxHeapSize) {
              return false;
            }
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(x + "=" + env[x]);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function _environ_get(__environ, environ_buf) {
            try {
              var bufSize = 0;
              getEnvStrings().forEach(function(string, i) {
                var ptr = environ_buf + bufSize;
                HEAP32[__environ + i * 4 >>> 2] = ptr;
                writeAsciiToMemory(string, ptr);
                bufSize += string.length + 1;
              });
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            try {
              var strings = getEnvStrings();
              HEAP32[penviron_count >>> 2] = strings.length;
              var bufSize = 0;
              strings.forEach(function(string) {
                bufSize += string.length + 1;
              });
              HEAP32[penviron_buf_size >>> 2] = bufSize;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_close(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doReadv(stream, iov, iovcnt);
              HEAP32[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
              }
              FS.llseek(stream, offset, whence);
              tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2] = tempI64[0], HEAP32[newOffset + 4 >>> 2] = tempI64[1];
              if (stream.getdents && offset === 0 && whence === 0)
                stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doWritev(stream, iov, iovcnt);
              HEAP32[pnum >>> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
                abort(e);
              return e.errno;
            }
          }
          function _setTempRet0(val) {
            setTempRet0(val);
          }
          function __isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          function __arraySum(array, index) {
            var sum = 0;
            for (var i = 0; i <= index; sum += array[i++]) {
            }
            return sum;
          }
          var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function __addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = __isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = HEAP32[tm + 40 >>> 2];
            var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value === "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                } else {
                  return thisDate.getFullYear();
                }
              } else {
                return thisDate.getFullYear() - 1;
              }
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              } else {
                return "PM";
              }
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var janFirst = new Date(date2.tm_year + 1900, 0, 1);
              var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstSunday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
                var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
            }, "%V": function(date2) {
              var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
              var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
                return "53";
              }
              if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
                return "01";
              }
              var daysDifference;
              if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
                daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
              } else {
                daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
              }
              return leadingNulls(Math.ceil(daysDifference / 7), 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var janFirst = new Date(date2.tm_year, 0, 1);
              var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
              var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
              if (compareByDay(firstMonday, endDate) < 0) {
                var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
                var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
                var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
                return leadingNulls(Math.ceil(days / 7), 2);
              }
              return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm) {
            return _strftime(s, maxsize, format, tm);
          }
          var FSNode = function(parent, name2, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name2;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, { read: { get: function() {
            return (this.mode & readMode) === readMode;
          }, set: function(val) {
            val ? this.mode |= readMode : this.mode &= ~readMode;
          } }, write: { get: function() {
            return (this.mode & writeMode) === writeMode;
          }, set: function(val) {
            val ? this.mode |= writeMode : this.mode &= ~writeMode;
          } }, isFolder: { get: function() {
            return FS.isDir(this.mode);
          } }, isDevice: { get: function() {
            return FS.isChrdev(this.mode);
          } } });
          FS.FSNode = FSNode;
          FS.staticInit();
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          InternalError = Module["InternalError"] = extendError(Error, "InternalError");
          embind_init_charCodes();
          BindingError = Module["BindingError"] = extendError(Error, "BindingError");
          init_ClassHandle();
          init_RegisteredPointer();
          init_embind();
          UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
          init_emval();
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          var asmLibraryArg = { "y": ___assert_fail, "x": ___cxa_allocate_exception, "w": ___cxa_throw, "A": ___sys_fcntl64, "O": ___sys_ioctl, "P": ___sys_open, "Z": __embind_finalize_value_array, "o": __embind_finalize_value_object, "J": __embind_register_bigint, "W": __embind_register_bool, "r": __embind_register_class, "q": __embind_register_class_constructor, "b": __embind_register_class_function, "V": __embind_register_emval, "Y": __embind_register_enum, "t": __embind_register_enum_value, "D": __embind_register_float, "e": __embind_register_function, "n": __embind_register_integer, "j": __embind_register_memory_view, "E": __embind_register_std_string, "v": __embind_register_std_wstring, "_": __embind_register_value_array, "g": __embind_register_value_array_element, "p": __embind_register_value_object, "d": __embind_register_value_object_field, "X": __embind_register_void, "l": __emval_as, "F": __emval_call, "a": __emval_decref, "H": __emval_get_global, "m": __emval_get_property, "i": __emval_incref, "L": __emval_instanceof, "G": __emval_is_number, "z": __emval_new_array, "f": __emval_new_cstring, "s": __emval_new_object, "k": __emval_run_destructors, "h": __emval_set_property, "c": __emval_take_value, "C": _abort, "N": _clock_gettime, "M": _emscripten_memcpy_big, "u": _emscripten_resize_heap, "R": _environ_get, "S": _environ_sizes_get, "B": _fd_close, "U": _fd_read, "I": _fd_seek, "T": _fd_write, "K": _setTempRet0, "Q": _strftime_l };
          var asm = createWasm();
          var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
            return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["aa"]).apply(null, arguments);
          };
          var _main = Module["_main"] = function() {
            return (_main = Module["_main"] = Module["asm"]["ba"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["ca"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["da"]).apply(null, arguments);
          };
          var ___getTypeName = Module["___getTypeName"] = function() {
            return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ea"]).apply(null, arguments);
          };
          var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
            return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["fa"]).apply(null, arguments);
          };
          var ___errno_location = Module["___errno_location"] = function() {
            return (___errno_location = Module["___errno_location"] = Module["asm"]["ga"]).apply(null, arguments);
          };
          var dynCall_jiji = Module["dynCall_jiji"] = function() {
            return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["ia"]).apply(null, arguments);
          };
          var dynCall_viijii = Module["dynCall_viijii"] = function() {
            return (dynCall_viijii = Module["dynCall_viijii"] = Module["asm"]["ja"]).apply(null, arguments);
          };
          var dynCall_iiiiij = Module["dynCall_iiiiij"] = function() {
            return (dynCall_iiiiij = Module["dynCall_iiiiij"] = Module["asm"]["ka"]).apply(null, arguments);
          };
          var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = function() {
            return (dynCall_iiiiijj = Module["dynCall_iiiiijj"] = Module["asm"]["la"]).apply(null, arguments);
          };
          var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = function() {
            return (dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = Module["asm"]["ma"]).apply(null, arguments);
          };
          Module["addRunDependency"] = addRunDependency;
          Module["removeRunDependency"] = removeRunDependency;
          Module["FS_createPath"] = FS.createPath;
          Module["FS_createDataFile"] = FS.createDataFile;
          Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
          Module["FS_createLazyFile"] = FS.createLazyFile;
          Module["FS_createDevice"] = FS.createDevice;
          Module["FS_unlink"] = FS.unlink;
          Module["FS"] = FS;
          var calledRun;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
          }
          var calledMain = false;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain(args) {
            var entryFunction = Module["_main"];
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exit(ret, true);
            } catch (e) {
              if (e instanceof ExitStatus || e == "unwind") {
                return;
              }
              var toLog = e;
              if (e && typeof e === "object" && e.stack) {
                toLog = [e, e.stack];
              }
              err("exception thrown: " + toLog);
              quit_(1, e);
            } finally {
              calledMain = true;
            }
          }
          function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain(args);
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module["run"] = run;
          function exit(status, implicit) {
            EXITSTATUS = status;
            if (keepRuntimeAlive()) {
            } else {
              exitRuntime();
              if (Module["onExit"])
                Module["onExit"](status);
              ABORT = true;
            }
            quit_(status, new ExitStatus(status));
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          run();
          return WebIFCWasm3.ready;
        };
      }();
      if (typeof exports === "object" && typeof module === "object")
        module.exports = WebIFCWasm2;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return WebIFCWasm2;
        });
      else if (typeof exports === "object")
        exports["WebIFCWasm"] = WebIFCWasm2;
    }
  });

  // dist/web-ifc-api.ts
  var web_ifc_api_exports = {};
  __export(web_ifc_api_exports, {
    EMPTY: () => EMPTY,
    ENUM: () => ENUM,
    FromRawLineData: () => FromRawLineData,
    Handle: () => Handle,
    IFCACTIONREQUEST: () => IFCACTIONREQUEST,
    IFCACTOR: () => IFCACTOR,
    IFCACTORROLE: () => IFCACTORROLE,
    IFCACTUATOR: () => IFCACTUATOR,
    IFCACTUATORTYPE: () => IFCACTUATORTYPE,
    IFCADDRESS: () => IFCADDRESS,
    IFCADVANCEDBREP: () => IFCADVANCEDBREP,
    IFCADVANCEDBREPWITHVOIDS: () => IFCADVANCEDBREPWITHVOIDS,
    IFCADVANCEDFACE: () => IFCADVANCEDFACE,
    IFCAIRTERMINAL: () => IFCAIRTERMINAL,
    IFCAIRTERMINALBOX: () => IFCAIRTERMINALBOX,
    IFCAIRTERMINALBOXTYPE: () => IFCAIRTERMINALBOXTYPE,
    IFCAIRTERMINALTYPE: () => IFCAIRTERMINALTYPE,
    IFCAIRTOAIRHEATRECOVERY: () => IFCAIRTOAIRHEATRECOVERY,
    IFCAIRTOAIRHEATRECOVERYTYPE: () => IFCAIRTOAIRHEATRECOVERYTYPE,
    IFCALARM: () => IFCALARM,
    IFCALARMTYPE: () => IFCALARMTYPE,
    IFCALIGNMENT: () => IFCALIGNMENT,
    IFCALIGNMENT2DHORIZONTAL: () => IFCALIGNMENT2DHORIZONTAL,
    IFCALIGNMENT2DHORIZONTALSEGMENT: () => IFCALIGNMENT2DHORIZONTALSEGMENT,
    IFCALIGNMENT2DSEGMENT: () => IFCALIGNMENT2DSEGMENT,
    IFCALIGNMENT2DVERSEGCIRCULARARC: () => IFCALIGNMENT2DVERSEGCIRCULARARC,
    IFCALIGNMENT2DVERSEGLINE: () => IFCALIGNMENT2DVERSEGLINE,
    IFCALIGNMENT2DVERSEGPARABOLICARC: () => IFCALIGNMENT2DVERSEGPARABOLICARC,
    IFCALIGNMENT2DVERTICAL: () => IFCALIGNMENT2DVERTICAL,
    IFCALIGNMENT2DVERTICALSEGMENT: () => IFCALIGNMENT2DVERTICALSEGMENT,
    IFCALIGNMENTCURVE: () => IFCALIGNMENTCURVE,
    IFCANNOTATION: () => IFCANNOTATION,
    IFCANNOTATIONFILLAREA: () => IFCANNOTATIONFILLAREA,
    IFCAPPLICATION: () => IFCAPPLICATION,
    IFCAPPLIEDVALUE: () => IFCAPPLIEDVALUE,
    IFCAPPROVAL: () => IFCAPPROVAL,
    IFCAPPROVALRELATIONSHIP: () => IFCAPPROVALRELATIONSHIP,
    IFCARBITRARYCLOSEDPROFILEDEF: () => IFCARBITRARYCLOSEDPROFILEDEF,
    IFCARBITRARYOPENPROFILEDEF: () => IFCARBITRARYOPENPROFILEDEF,
    IFCARBITRARYPROFILEDEFWITHVOIDS: () => IFCARBITRARYPROFILEDEFWITHVOIDS,
    IFCASSET: () => IFCASSET,
    IFCASYMMETRICISHAPEPROFILEDEF: () => IFCASYMMETRICISHAPEPROFILEDEF,
    IFCAUDIOVISUALAPPLIANCE: () => IFCAUDIOVISUALAPPLIANCE,
    IFCAUDIOVISUALAPPLIANCETYPE: () => IFCAUDIOVISUALAPPLIANCETYPE,
    IFCAXIS1PLACEMENT: () => IFCAXIS1PLACEMENT,
    IFCAXIS2PLACEMENT2D: () => IFCAXIS2PLACEMENT2D,
    IFCAXIS2PLACEMENT3D: () => IFCAXIS2PLACEMENT3D,
    IFCBEAM: () => IFCBEAM,
    IFCBEAMSTANDARDCASE: () => IFCBEAMSTANDARDCASE,
    IFCBEAMTYPE: () => IFCBEAMTYPE,
    IFCBEARING: () => IFCBEARING,
    IFCBEARINGTYPE: () => IFCBEARINGTYPE,
    IFCBLOBTEXTURE: () => IFCBLOBTEXTURE,
    IFCBLOCK: () => IFCBLOCK,
    IFCBOILER: () => IFCBOILER,
    IFCBOILERTYPE: () => IFCBOILERTYPE,
    IFCBOOLEANCLIPPINGRESULT: () => IFCBOOLEANCLIPPINGRESULT,
    IFCBOOLEANRESULT: () => IFCBOOLEANRESULT,
    IFCBOUNDARYCONDITION: () => IFCBOUNDARYCONDITION,
    IFCBOUNDARYCURVE: () => IFCBOUNDARYCURVE,
    IFCBOUNDARYEDGECONDITION: () => IFCBOUNDARYEDGECONDITION,
    IFCBOUNDARYFACECONDITION: () => IFCBOUNDARYFACECONDITION,
    IFCBOUNDARYNODECONDITION: () => IFCBOUNDARYNODECONDITION,
    IFCBOUNDARYNODECONDITIONWARPING: () => IFCBOUNDARYNODECONDITIONWARPING,
    IFCBOUNDEDCURVE: () => IFCBOUNDEDCURVE,
    IFCBOUNDEDSURFACE: () => IFCBOUNDEDSURFACE,
    IFCBOUNDINGBOX: () => IFCBOUNDINGBOX,
    IFCBOXEDHALFSPACE: () => IFCBOXEDHALFSPACE,
    IFCBRIDGE: () => IFCBRIDGE,
    IFCBRIDGEPART: () => IFCBRIDGEPART,
    IFCBSPLINECURVE: () => IFCBSPLINECURVE,
    IFCBSPLINECURVEWITHKNOTS: () => IFCBSPLINECURVEWITHKNOTS,
    IFCBSPLINESURFACE: () => IFCBSPLINESURFACE,
    IFCBSPLINESURFACEWITHKNOTS: () => IFCBSPLINESURFACEWITHKNOTS,
    IFCBUILDING: () => IFCBUILDING,
    IFCBUILDINGELEMENT: () => IFCBUILDINGELEMENT,
    IFCBUILDINGELEMENTPART: () => IFCBUILDINGELEMENTPART,
    IFCBUILDINGELEMENTPARTTYPE: () => IFCBUILDINGELEMENTPARTTYPE,
    IFCBUILDINGELEMENTPROXY: () => IFCBUILDINGELEMENTPROXY,
    IFCBUILDINGELEMENTPROXYTYPE: () => IFCBUILDINGELEMENTPROXYTYPE,
    IFCBUILDINGELEMENTTYPE: () => IFCBUILDINGELEMENTTYPE,
    IFCBUILDINGSTOREY: () => IFCBUILDINGSTOREY,
    IFCBUILDINGSYSTEM: () => IFCBUILDINGSYSTEM,
    IFCBURNER: () => IFCBURNER,
    IFCBURNERTYPE: () => IFCBURNERTYPE,
    IFCCABLECARRIERFITTING: () => IFCCABLECARRIERFITTING,
    IFCCABLECARRIERFITTINGTYPE: () => IFCCABLECARRIERFITTINGTYPE,
    IFCCABLECARRIERSEGMENT: () => IFCCABLECARRIERSEGMENT,
    IFCCABLECARRIERSEGMENTTYPE: () => IFCCABLECARRIERSEGMENTTYPE,
    IFCCABLEFITTING: () => IFCCABLEFITTING,
    IFCCABLEFITTINGTYPE: () => IFCCABLEFITTINGTYPE,
    IFCCABLESEGMENT: () => IFCCABLESEGMENT,
    IFCCABLESEGMENTTYPE: () => IFCCABLESEGMENTTYPE,
    IFCCAISSONFOUNDATION: () => IFCCAISSONFOUNDATION,
    IFCCAISSONFOUNDATIONTYPE: () => IFCCAISSONFOUNDATIONTYPE,
    IFCCARTESIANPOINT: () => IFCCARTESIANPOINT,
    IFCCARTESIANPOINTLIST: () => IFCCARTESIANPOINTLIST,
    IFCCARTESIANPOINTLIST2D: () => IFCCARTESIANPOINTLIST2D,
    IFCCARTESIANPOINTLIST3D: () => IFCCARTESIANPOINTLIST3D,
    IFCCARTESIANTRANSFORMATIONOPERATOR: () => IFCCARTESIANTRANSFORMATIONOPERATOR,
    IFCCARTESIANTRANSFORMATIONOPERATOR2D: () => IFCCARTESIANTRANSFORMATIONOPERATOR2D,
    IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM: () => IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM,
    IFCCARTESIANTRANSFORMATIONOPERATOR3D: () => IFCCARTESIANTRANSFORMATIONOPERATOR3D,
    IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM: () => IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM,
    IFCCENTERLINEPROFILEDEF: () => IFCCENTERLINEPROFILEDEF,
    IFCCHILLER: () => IFCCHILLER,
    IFCCHILLERTYPE: () => IFCCHILLERTYPE,
    IFCCHIMNEY: () => IFCCHIMNEY,
    IFCCHIMNEYTYPE: () => IFCCHIMNEYTYPE,
    IFCCIRCLE: () => IFCCIRCLE,
    IFCCIRCLEHOLLOWPROFILEDEF: () => IFCCIRCLEHOLLOWPROFILEDEF,
    IFCCIRCLEPROFILEDEF: () => IFCCIRCLEPROFILEDEF,
    IFCCIRCULARARCSEGMENT2D: () => IFCCIRCULARARCSEGMENT2D,
    IFCCIVILELEMENT: () => IFCCIVILELEMENT,
    IFCCIVILELEMENTTYPE: () => IFCCIVILELEMENTTYPE,
    IFCCLASSIFICATION: () => IFCCLASSIFICATION,
    IFCCLASSIFICATIONREFERENCE: () => IFCCLASSIFICATIONREFERENCE,
    IFCCLOSEDSHELL: () => IFCCLOSEDSHELL,
    IFCCOIL: () => IFCCOIL,
    IFCCOILTYPE: () => IFCCOILTYPE,
    IFCCOLOURRGB: () => IFCCOLOURRGB,
    IFCCOLOURRGBLIST: () => IFCCOLOURRGBLIST,
    IFCCOLOURSPECIFICATION: () => IFCCOLOURSPECIFICATION,
    IFCCOLUMN: () => IFCCOLUMN,
    IFCCOLUMNSTANDARDCASE: () => IFCCOLUMNSTANDARDCASE,
    IFCCOLUMNTYPE: () => IFCCOLUMNTYPE,
    IFCCOMMUNICATIONSAPPLIANCE: () => IFCCOMMUNICATIONSAPPLIANCE,
    IFCCOMMUNICATIONSAPPLIANCETYPE: () => IFCCOMMUNICATIONSAPPLIANCETYPE,
    IFCCOMPLEXPROPERTY: () => IFCCOMPLEXPROPERTY,
    IFCCOMPLEXPROPERTYTEMPLATE: () => IFCCOMPLEXPROPERTYTEMPLATE,
    IFCCOMPOSITECURVE: () => IFCCOMPOSITECURVE,
    IFCCOMPOSITECURVEONSURFACE: () => IFCCOMPOSITECURVEONSURFACE,
    IFCCOMPOSITECURVESEGMENT: () => IFCCOMPOSITECURVESEGMENT,
    IFCCOMPOSITEPROFILEDEF: () => IFCCOMPOSITEPROFILEDEF,
    IFCCOMPRESSOR: () => IFCCOMPRESSOR,
    IFCCOMPRESSORTYPE: () => IFCCOMPRESSORTYPE,
    IFCCONDENSER: () => IFCCONDENSER,
    IFCCONDENSERTYPE: () => IFCCONDENSERTYPE,
    IFCCONIC: () => IFCCONIC,
    IFCCONNECTEDFACESET: () => IFCCONNECTEDFACESET,
    IFCCONNECTIONCURVEGEOMETRY: () => IFCCONNECTIONCURVEGEOMETRY,
    IFCCONNECTIONGEOMETRY: () => IFCCONNECTIONGEOMETRY,
    IFCCONNECTIONPOINTECCENTRICITY: () => IFCCONNECTIONPOINTECCENTRICITY,
    IFCCONNECTIONPOINTGEOMETRY: () => IFCCONNECTIONPOINTGEOMETRY,
    IFCCONNECTIONSURFACEGEOMETRY: () => IFCCONNECTIONSURFACEGEOMETRY,
    IFCCONNECTIONVOLUMEGEOMETRY: () => IFCCONNECTIONVOLUMEGEOMETRY,
    IFCCONSTRAINT: () => IFCCONSTRAINT,
    IFCCONSTRUCTIONEQUIPMENTRESOURCE: () => IFCCONSTRUCTIONEQUIPMENTRESOURCE,
    IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE: () => IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE,
    IFCCONSTRUCTIONMATERIALRESOURCE: () => IFCCONSTRUCTIONMATERIALRESOURCE,
    IFCCONSTRUCTIONMATERIALRESOURCETYPE: () => IFCCONSTRUCTIONMATERIALRESOURCETYPE,
    IFCCONSTRUCTIONPRODUCTRESOURCE: () => IFCCONSTRUCTIONPRODUCTRESOURCE,
    IFCCONSTRUCTIONPRODUCTRESOURCETYPE: () => IFCCONSTRUCTIONPRODUCTRESOURCETYPE,
    IFCCONSTRUCTIONRESOURCE: () => IFCCONSTRUCTIONRESOURCE,
    IFCCONSTRUCTIONRESOURCETYPE: () => IFCCONSTRUCTIONRESOURCETYPE,
    IFCCONTEXT: () => IFCCONTEXT,
    IFCCONTEXTDEPENDENTUNIT: () => IFCCONTEXTDEPENDENTUNIT,
    IFCCONTROL: () => IFCCONTROL,
    IFCCONTROLLER: () => IFCCONTROLLER,
    IFCCONTROLLERTYPE: () => IFCCONTROLLERTYPE,
    IFCCONVERSIONBASEDUNIT: () => IFCCONVERSIONBASEDUNIT,
    IFCCONVERSIONBASEDUNITWITHOFFSET: () => IFCCONVERSIONBASEDUNITWITHOFFSET,
    IFCCOOLEDBEAM: () => IFCCOOLEDBEAM,
    IFCCOOLEDBEAMTYPE: () => IFCCOOLEDBEAMTYPE,
    IFCCOOLINGTOWER: () => IFCCOOLINGTOWER,
    IFCCOOLINGTOWERTYPE: () => IFCCOOLINGTOWERTYPE,
    IFCCOORDINATEOPERATION: () => IFCCOORDINATEOPERATION,
    IFCCOORDINATEREFERENCESYSTEM: () => IFCCOORDINATEREFERENCESYSTEM,
    IFCCOSTITEM: () => IFCCOSTITEM,
    IFCCOSTSCHEDULE: () => IFCCOSTSCHEDULE,
    IFCCOSTVALUE: () => IFCCOSTVALUE,
    IFCCOVERING: () => IFCCOVERING,
    IFCCOVERINGTYPE: () => IFCCOVERINGTYPE,
    IFCCREWRESOURCE: () => IFCCREWRESOURCE,
    IFCCREWRESOURCETYPE: () => IFCCREWRESOURCETYPE,
    IFCCSGPRIMITIVE3D: () => IFCCSGPRIMITIVE3D,
    IFCCSGSOLID: () => IFCCSGSOLID,
    IFCCSHAPEPROFILEDEF: () => IFCCSHAPEPROFILEDEF,
    IFCCURRENCYRELATIONSHIP: () => IFCCURRENCYRELATIONSHIP,
    IFCCURTAINWALL: () => IFCCURTAINWALL,
    IFCCURTAINWALLTYPE: () => IFCCURTAINWALLTYPE,
    IFCCURVE: () => IFCCURVE,
    IFCCURVEBOUNDEDPLANE: () => IFCCURVEBOUNDEDPLANE,
    IFCCURVEBOUNDEDSURFACE: () => IFCCURVEBOUNDEDSURFACE,
    IFCCURVESEGMENT2D: () => IFCCURVESEGMENT2D,
    IFCCURVESTYLE: () => IFCCURVESTYLE,
    IFCCURVESTYLEFONT: () => IFCCURVESTYLEFONT,
    IFCCURVESTYLEFONTANDSCALING: () => IFCCURVESTYLEFONTANDSCALING,
    IFCCURVESTYLEFONTPATTERN: () => IFCCURVESTYLEFONTPATTERN,
    IFCCYLINDRICALSURFACE: () => IFCCYLINDRICALSURFACE,
    IFCDAMPER: () => IFCDAMPER,
    IFCDAMPERTYPE: () => IFCDAMPERTYPE,
    IFCDEEPFOUNDATION: () => IFCDEEPFOUNDATION,
    IFCDEEPFOUNDATIONTYPE: () => IFCDEEPFOUNDATIONTYPE,
    IFCDERIVEDPROFILEDEF: () => IFCDERIVEDPROFILEDEF,
    IFCDERIVEDUNIT: () => IFCDERIVEDUNIT,
    IFCDERIVEDUNITELEMENT: () => IFCDERIVEDUNITELEMENT,
    IFCDIMENSIONALEXPONENTS: () => IFCDIMENSIONALEXPONENTS,
    IFCDIRECTION: () => IFCDIRECTION,
    IFCDISCRETEACCESSORY: () => IFCDISCRETEACCESSORY,
    IFCDISCRETEACCESSORYTYPE: () => IFCDISCRETEACCESSORYTYPE,
    IFCDISTANCEEXPRESSION: () => IFCDISTANCEEXPRESSION,
    IFCDISTRIBUTIONCHAMBERELEMENT: () => IFCDISTRIBUTIONCHAMBERELEMENT,
    IFCDISTRIBUTIONCHAMBERELEMENTTYPE: () => IFCDISTRIBUTIONCHAMBERELEMENTTYPE,
    IFCDISTRIBUTIONCIRCUIT: () => IFCDISTRIBUTIONCIRCUIT,
    IFCDISTRIBUTIONCONTROLELEMENT: () => IFCDISTRIBUTIONCONTROLELEMENT,
    IFCDISTRIBUTIONCONTROLELEMENTTYPE: () => IFCDISTRIBUTIONCONTROLELEMENTTYPE,
    IFCDISTRIBUTIONELEMENT: () => IFCDISTRIBUTIONELEMENT,
    IFCDISTRIBUTIONELEMENTTYPE: () => IFCDISTRIBUTIONELEMENTTYPE,
    IFCDISTRIBUTIONFLOWELEMENT: () => IFCDISTRIBUTIONFLOWELEMENT,
    IFCDISTRIBUTIONFLOWELEMENTTYPE: () => IFCDISTRIBUTIONFLOWELEMENTTYPE,
    IFCDISTRIBUTIONPORT: () => IFCDISTRIBUTIONPORT,
    IFCDISTRIBUTIONSYSTEM: () => IFCDISTRIBUTIONSYSTEM,
    IFCDOCUMENTINFORMATION: () => IFCDOCUMENTINFORMATION,
    IFCDOCUMENTINFORMATIONRELATIONSHIP: () => IFCDOCUMENTINFORMATIONRELATIONSHIP,
    IFCDOCUMENTREFERENCE: () => IFCDOCUMENTREFERENCE,
    IFCDOOR: () => IFCDOOR,
    IFCDOORLININGPROPERTIES: () => IFCDOORLININGPROPERTIES,
    IFCDOORPANELPROPERTIES: () => IFCDOORPANELPROPERTIES,
    IFCDOORSTANDARDCASE: () => IFCDOORSTANDARDCASE,
    IFCDOORSTYLE: () => IFCDOORSTYLE,
    IFCDOORTYPE: () => IFCDOORTYPE,
    IFCDRAUGHTINGPREDEFINEDCOLOUR: () => IFCDRAUGHTINGPREDEFINEDCOLOUR,
    IFCDRAUGHTINGPREDEFINEDCURVEFONT: () => IFCDRAUGHTINGPREDEFINEDCURVEFONT,
    IFCDUCTFITTING: () => IFCDUCTFITTING,
    IFCDUCTFITTINGTYPE: () => IFCDUCTFITTINGTYPE,
    IFCDUCTSEGMENT: () => IFCDUCTSEGMENT,
    IFCDUCTSEGMENTTYPE: () => IFCDUCTSEGMENTTYPE,
    IFCDUCTSILENCER: () => IFCDUCTSILENCER,
    IFCDUCTSILENCERTYPE: () => IFCDUCTSILENCERTYPE,
    IFCEDGE: () => IFCEDGE,
    IFCEDGECURVE: () => IFCEDGECURVE,
    IFCEDGELOOP: () => IFCEDGELOOP,
    IFCELECTRICAPPLIANCE: () => IFCELECTRICAPPLIANCE,
    IFCELECTRICAPPLIANCETYPE: () => IFCELECTRICAPPLIANCETYPE,
    IFCELECTRICDISTRIBUTIONBOARD: () => IFCELECTRICDISTRIBUTIONBOARD,
    IFCELECTRICDISTRIBUTIONBOARDTYPE: () => IFCELECTRICDISTRIBUTIONBOARDTYPE,
    IFCELECTRICFLOWSTORAGEDEVICE: () => IFCELECTRICFLOWSTORAGEDEVICE,
    IFCELECTRICFLOWSTORAGEDEVICETYPE: () => IFCELECTRICFLOWSTORAGEDEVICETYPE,
    IFCELECTRICGENERATOR: () => IFCELECTRICGENERATOR,
    IFCELECTRICGENERATORTYPE: () => IFCELECTRICGENERATORTYPE,
    IFCELECTRICMOTOR: () => IFCELECTRICMOTOR,
    IFCELECTRICMOTORTYPE: () => IFCELECTRICMOTORTYPE,
    IFCELECTRICTIMECONTROL: () => IFCELECTRICTIMECONTROL,
    IFCELECTRICTIMECONTROLTYPE: () => IFCELECTRICTIMECONTROLTYPE,
    IFCELEMENT: () => IFCELEMENT,
    IFCELEMENTARYSURFACE: () => IFCELEMENTARYSURFACE,
    IFCELEMENTASSEMBLY: () => IFCELEMENTASSEMBLY,
    IFCELEMENTASSEMBLYTYPE: () => IFCELEMENTASSEMBLYTYPE,
    IFCELEMENTCOMPONENT: () => IFCELEMENTCOMPONENT,
    IFCELEMENTCOMPONENTTYPE: () => IFCELEMENTCOMPONENTTYPE,
    IFCELEMENTQUANTITY: () => IFCELEMENTQUANTITY,
    IFCELEMENTTYPE: () => IFCELEMENTTYPE,
    IFCELLIPSE: () => IFCELLIPSE,
    IFCELLIPSEPROFILEDEF: () => IFCELLIPSEPROFILEDEF,
    IFCENERGYCONVERSIONDEVICE: () => IFCENERGYCONVERSIONDEVICE,
    IFCENERGYCONVERSIONDEVICETYPE: () => IFCENERGYCONVERSIONDEVICETYPE,
    IFCENGINE: () => IFCENGINE,
    IFCENGINETYPE: () => IFCENGINETYPE,
    IFCEVAPORATIVECOOLER: () => IFCEVAPORATIVECOOLER,
    IFCEVAPORATIVECOOLERTYPE: () => IFCEVAPORATIVECOOLERTYPE,
    IFCEVAPORATOR: () => IFCEVAPORATOR,
    IFCEVAPORATORTYPE: () => IFCEVAPORATORTYPE,
    IFCEVENT: () => IFCEVENT,
    IFCEVENTTIME: () => IFCEVENTTIME,
    IFCEVENTTYPE: () => IFCEVENTTYPE,
    IFCEXTENDEDPROPERTIES: () => IFCEXTENDEDPROPERTIES,
    IFCEXTERNALINFORMATION: () => IFCEXTERNALINFORMATION,
    IFCEXTERNALLYDEFINEDHATCHSTYLE: () => IFCEXTERNALLYDEFINEDHATCHSTYLE,
    IFCEXTERNALLYDEFINEDSURFACESTYLE: () => IFCEXTERNALLYDEFINEDSURFACESTYLE,
    IFCEXTERNALLYDEFINEDTEXTFONT: () => IFCEXTERNALLYDEFINEDTEXTFONT,
    IFCEXTERNALREFERENCE: () => IFCEXTERNALREFERENCE,
    IFCEXTERNALREFERENCERELATIONSHIP: () => IFCEXTERNALREFERENCERELATIONSHIP,
    IFCEXTERNALSPATIALELEMENT: () => IFCEXTERNALSPATIALELEMENT,
    IFCEXTERNALSPATIALSTRUCTUREELEMENT: () => IFCEXTERNALSPATIALSTRUCTUREELEMENT,
    IFCEXTRUDEDAREASOLID: () => IFCEXTRUDEDAREASOLID,
    IFCEXTRUDEDAREASOLIDTAPERED: () => IFCEXTRUDEDAREASOLIDTAPERED,
    IFCFACE: () => IFCFACE,
    IFCFACEBASEDSURFACEMODEL: () => IFCFACEBASEDSURFACEMODEL,
    IFCFACEBOUND: () => IFCFACEBOUND,
    IFCFACEOUTERBOUND: () => IFCFACEOUTERBOUND,
    IFCFACESURFACE: () => IFCFACESURFACE,
    IFCFACETEDBREP: () => IFCFACETEDBREP,
    IFCFACETEDBREPWITHVOIDS: () => IFCFACETEDBREPWITHVOIDS,
    IFCFACILITY: () => IFCFACILITY,
    IFCFACILITYPART: () => IFCFACILITYPART,
    IFCFAILURECONNECTIONCONDITION: () => IFCFAILURECONNECTIONCONDITION,
    IFCFAN: () => IFCFAN,
    IFCFANTYPE: () => IFCFANTYPE,
    IFCFASTENER: () => IFCFASTENER,
    IFCFASTENERTYPE: () => IFCFASTENERTYPE,
    IFCFEATUREELEMENT: () => IFCFEATUREELEMENT,
    IFCFEATUREELEMENTADDITION: () => IFCFEATUREELEMENTADDITION,
    IFCFEATUREELEMENTSUBTRACTION: () => IFCFEATUREELEMENTSUBTRACTION,
    IFCFILLAREASTYLE: () => IFCFILLAREASTYLE,
    IFCFILLAREASTYLEHATCHING: () => IFCFILLAREASTYLEHATCHING,
    IFCFILLAREASTYLETILES: () => IFCFILLAREASTYLETILES,
    IFCFILTER: () => IFCFILTER,
    IFCFILTERTYPE: () => IFCFILTERTYPE,
    IFCFIRESUPPRESSIONTERMINAL: () => IFCFIRESUPPRESSIONTERMINAL,
    IFCFIRESUPPRESSIONTERMINALTYPE: () => IFCFIRESUPPRESSIONTERMINALTYPE,
    IFCFIXEDREFERENCESWEPTAREASOLID: () => IFCFIXEDREFERENCESWEPTAREASOLID,
    IFCFLOWCONTROLLER: () => IFCFLOWCONTROLLER,
    IFCFLOWCONTROLLERTYPE: () => IFCFLOWCONTROLLERTYPE,
    IFCFLOWFITTING: () => IFCFLOWFITTING,
    IFCFLOWFITTINGTYPE: () => IFCFLOWFITTINGTYPE,
    IFCFLOWINSTRUMENT: () => IFCFLOWINSTRUMENT,
    IFCFLOWINSTRUMENTTYPE: () => IFCFLOWINSTRUMENTTYPE,
    IFCFLOWMETER: () => IFCFLOWMETER,
    IFCFLOWMETERTYPE: () => IFCFLOWMETERTYPE,
    IFCFLOWMOVINGDEVICE: () => IFCFLOWMOVINGDEVICE,
    IFCFLOWMOVINGDEVICETYPE: () => IFCFLOWMOVINGDEVICETYPE,
    IFCFLOWSEGMENT: () => IFCFLOWSEGMENT,
    IFCFLOWSEGMENTTYPE: () => IFCFLOWSEGMENTTYPE,
    IFCFLOWSTORAGEDEVICE: () => IFCFLOWSTORAGEDEVICE,
    IFCFLOWSTORAGEDEVICETYPE: () => IFCFLOWSTORAGEDEVICETYPE,
    IFCFLOWTERMINAL: () => IFCFLOWTERMINAL,
    IFCFLOWTERMINALTYPE: () => IFCFLOWTERMINALTYPE,
    IFCFLOWTREATMENTDEVICE: () => IFCFLOWTREATMENTDEVICE,
    IFCFLOWTREATMENTDEVICETYPE: () => IFCFLOWTREATMENTDEVICETYPE,
    IFCFOOTING: () => IFCFOOTING,
    IFCFOOTINGTYPE: () => IFCFOOTINGTYPE,
    IFCFURNISHINGELEMENT: () => IFCFURNISHINGELEMENT,
    IFCFURNISHINGELEMENTTYPE: () => IFCFURNISHINGELEMENTTYPE,
    IFCFURNITURE: () => IFCFURNITURE,
    IFCFURNITURETYPE: () => IFCFURNITURETYPE,
    IFCGEOGRAPHICELEMENT: () => IFCGEOGRAPHICELEMENT,
    IFCGEOGRAPHICELEMENTTYPE: () => IFCGEOGRAPHICELEMENTTYPE,
    IFCGEOMETRICCURVESET: () => IFCGEOMETRICCURVESET,
    IFCGEOMETRICREPRESENTATIONCONTEXT: () => IFCGEOMETRICREPRESENTATIONCONTEXT,
    IFCGEOMETRICREPRESENTATIONITEM: () => IFCGEOMETRICREPRESENTATIONITEM,
    IFCGEOMETRICREPRESENTATIONSUBCONTEXT: () => IFCGEOMETRICREPRESENTATIONSUBCONTEXT,
    IFCGEOMETRICSET: () => IFCGEOMETRICSET,
    IFCGRID: () => IFCGRID,
    IFCGRIDAXIS: () => IFCGRIDAXIS,
    IFCGRIDPLACEMENT: () => IFCGRIDPLACEMENT,
    IFCGROUP: () => IFCGROUP,
    IFCHALFSPACESOLID: () => IFCHALFSPACESOLID,
    IFCHEATEXCHANGER: () => IFCHEATEXCHANGER,
    IFCHEATEXCHANGERTYPE: () => IFCHEATEXCHANGERTYPE,
    IFCHUMIDIFIER: () => IFCHUMIDIFIER,
    IFCHUMIDIFIERTYPE: () => IFCHUMIDIFIERTYPE,
    IFCIMAGETEXTURE: () => IFCIMAGETEXTURE,
    IFCINDEXEDCOLOURMAP: () => IFCINDEXEDCOLOURMAP,
    IFCINDEXEDPOLYCURVE: () => IFCINDEXEDPOLYCURVE,
    IFCINDEXEDPOLYGONALFACE: () => IFCINDEXEDPOLYGONALFACE,
    IFCINDEXEDPOLYGONALFACEWITHVOIDS: () => IFCINDEXEDPOLYGONALFACEWITHVOIDS,
    IFCINDEXEDTEXTUREMAP: () => IFCINDEXEDTEXTUREMAP,
    IFCINDEXEDTRIANGLETEXTUREMAP: () => IFCINDEXEDTRIANGLETEXTUREMAP,
    IFCINTERCEPTOR: () => IFCINTERCEPTOR,
    IFCINTERCEPTORTYPE: () => IFCINTERCEPTORTYPE,
    IFCINTERSECTIONCURVE: () => IFCINTERSECTIONCURVE,
    IFCINVENTORY: () => IFCINVENTORY,
    IFCIRREGULARTIMESERIES: () => IFCIRREGULARTIMESERIES,
    IFCIRREGULARTIMESERIESVALUE: () => IFCIRREGULARTIMESERIESVALUE,
    IFCISHAPEPROFILEDEF: () => IFCISHAPEPROFILEDEF,
    IFCJUNCTIONBOX: () => IFCJUNCTIONBOX,
    IFCJUNCTIONBOXTYPE: () => IFCJUNCTIONBOXTYPE,
    IFCLABORRESOURCE: () => IFCLABORRESOURCE,
    IFCLABORRESOURCETYPE: () => IFCLABORRESOURCETYPE,
    IFCLAGTIME: () => IFCLAGTIME,
    IFCLAMP: () => IFCLAMP,
    IFCLAMPTYPE: () => IFCLAMPTYPE,
    IFCLIBRARYINFORMATION: () => IFCLIBRARYINFORMATION,
    IFCLIBRARYREFERENCE: () => IFCLIBRARYREFERENCE,
    IFCLIGHTDISTRIBUTIONDATA: () => IFCLIGHTDISTRIBUTIONDATA,
    IFCLIGHTFIXTURE: () => IFCLIGHTFIXTURE,
    IFCLIGHTFIXTURETYPE: () => IFCLIGHTFIXTURETYPE,
    IFCLIGHTINTENSITYDISTRIBUTION: () => IFCLIGHTINTENSITYDISTRIBUTION,
    IFCLIGHTSOURCE: () => IFCLIGHTSOURCE,
    IFCLIGHTSOURCEAMBIENT: () => IFCLIGHTSOURCEAMBIENT,
    IFCLIGHTSOURCEDIRECTIONAL: () => IFCLIGHTSOURCEDIRECTIONAL,
    IFCLIGHTSOURCEGONIOMETRIC: () => IFCLIGHTSOURCEGONIOMETRIC,
    IFCLIGHTSOURCEPOSITIONAL: () => IFCLIGHTSOURCEPOSITIONAL,
    IFCLIGHTSOURCESPOT: () => IFCLIGHTSOURCESPOT,
    IFCLINE: () => IFCLINE,
    IFCLINEARPLACEMENT: () => IFCLINEARPLACEMENT,
    IFCLINEARPOSITIONINGELEMENT: () => IFCLINEARPOSITIONINGELEMENT,
    IFCLINESEGMENT2D: () => IFCLINESEGMENT2D,
    IFCLOCALPLACEMENT: () => IFCLOCALPLACEMENT,
    IFCLOOP: () => IFCLOOP,
    IFCLSHAPEPROFILEDEF: () => IFCLSHAPEPROFILEDEF,
    IFCMANIFOLDSOLIDBREP: () => IFCMANIFOLDSOLIDBREP,
    IFCMAPCONVERSION: () => IFCMAPCONVERSION,
    IFCMAPPEDITEM: () => IFCMAPPEDITEM,
    IFCMATERIAL: () => IFCMATERIAL,
    IFCMATERIALCLASSIFICATIONRELATIONSHIP: () => IFCMATERIALCLASSIFICATIONRELATIONSHIP,
    IFCMATERIALCONSTITUENT: () => IFCMATERIALCONSTITUENT,
    IFCMATERIALCONSTITUENTSET: () => IFCMATERIALCONSTITUENTSET,
    IFCMATERIALDEFINITION: () => IFCMATERIALDEFINITION,
    IFCMATERIALDEFINITIONREPRESENTATION: () => IFCMATERIALDEFINITIONREPRESENTATION,
    IFCMATERIALLAYER: () => IFCMATERIALLAYER,
    IFCMATERIALLAYERSET: () => IFCMATERIALLAYERSET,
    IFCMATERIALLAYERSETUSAGE: () => IFCMATERIALLAYERSETUSAGE,
    IFCMATERIALLAYERWITHOFFSETS: () => IFCMATERIALLAYERWITHOFFSETS,
    IFCMATERIALLIST: () => IFCMATERIALLIST,
    IFCMATERIALPROFILE: () => IFCMATERIALPROFILE,
    IFCMATERIALPROFILESET: () => IFCMATERIALPROFILESET,
    IFCMATERIALPROFILESETUSAGE: () => IFCMATERIALPROFILESETUSAGE,
    IFCMATERIALPROFILESETUSAGETAPERING: () => IFCMATERIALPROFILESETUSAGETAPERING,
    IFCMATERIALPROFILEWITHOFFSETS: () => IFCMATERIALPROFILEWITHOFFSETS,
    IFCMATERIALPROPERTIES: () => IFCMATERIALPROPERTIES,
    IFCMATERIALRELATIONSHIP: () => IFCMATERIALRELATIONSHIP,
    IFCMATERIALUSAGEDEFINITION: () => IFCMATERIALUSAGEDEFINITION,
    IFCMEASUREWITHUNIT: () => IFCMEASUREWITHUNIT,
    IFCMECHANICALFASTENER: () => IFCMECHANICALFASTENER,
    IFCMECHANICALFASTENERTYPE: () => IFCMECHANICALFASTENERTYPE,
    IFCMEDICALDEVICE: () => IFCMEDICALDEVICE,
    IFCMEDICALDEVICETYPE: () => IFCMEDICALDEVICETYPE,
    IFCMEMBER: () => IFCMEMBER,
    IFCMEMBERSTANDARDCASE: () => IFCMEMBERSTANDARDCASE,
    IFCMEMBERTYPE: () => IFCMEMBERTYPE,
    IFCMETRIC: () => IFCMETRIC,
    IFCMIRROREDPROFILEDEF: () => IFCMIRROREDPROFILEDEF,
    IFCMONETARYUNIT: () => IFCMONETARYUNIT,
    IFCMOTORCONNECTION: () => IFCMOTORCONNECTION,
    IFCMOTORCONNECTIONTYPE: () => IFCMOTORCONNECTIONTYPE,
    IFCNAMEDUNIT: () => IFCNAMEDUNIT,
    IFCOBJECT: () => IFCOBJECT,
    IFCOBJECTDEFINITION: () => IFCOBJECTDEFINITION,
    IFCOBJECTIVE: () => IFCOBJECTIVE,
    IFCOBJECTPLACEMENT: () => IFCOBJECTPLACEMENT,
    IFCOCCUPANT: () => IFCOCCUPANT,
    IFCOFFSETCURVE: () => IFCOFFSETCURVE,
    IFCOFFSETCURVE2D: () => IFCOFFSETCURVE2D,
    IFCOFFSETCURVE3D: () => IFCOFFSETCURVE3D,
    IFCOFFSETCURVEBYDISTANCES: () => IFCOFFSETCURVEBYDISTANCES,
    IFCOPENINGELEMENT: () => IFCOPENINGELEMENT,
    IFCOPENINGSTANDARDCASE: () => IFCOPENINGSTANDARDCASE,
    IFCOPENSHELL: () => IFCOPENSHELL,
    IFCORGANIZATION: () => IFCORGANIZATION,
    IFCORGANIZATIONRELATIONSHIP: () => IFCORGANIZATIONRELATIONSHIP,
    IFCORIENTATIONEXPRESSION: () => IFCORIENTATIONEXPRESSION,
    IFCORIENTEDEDGE: () => IFCORIENTEDEDGE,
    IFCOUTERBOUNDARYCURVE: () => IFCOUTERBOUNDARYCURVE,
    IFCOUTLET: () => IFCOUTLET,
    IFCOUTLETTYPE: () => IFCOUTLETTYPE,
    IFCOWNERHISTORY: () => IFCOWNERHISTORY,
    IFCPARAMETERIZEDPROFILEDEF: () => IFCPARAMETERIZEDPROFILEDEF,
    IFCPATH: () => IFCPATH,
    IFCPCURVE: () => IFCPCURVE,
    IFCPERFORMANCEHISTORY: () => IFCPERFORMANCEHISTORY,
    IFCPERMEABLECOVERINGPROPERTIES: () => IFCPERMEABLECOVERINGPROPERTIES,
    IFCPERMIT: () => IFCPERMIT,
    IFCPERSON: () => IFCPERSON,
    IFCPERSONANDORGANIZATION: () => IFCPERSONANDORGANIZATION,
    IFCPHYSICALCOMPLEXQUANTITY: () => IFCPHYSICALCOMPLEXQUANTITY,
    IFCPHYSICALQUANTITY: () => IFCPHYSICALQUANTITY,
    IFCPHYSICALSIMPLEQUANTITY: () => IFCPHYSICALSIMPLEQUANTITY,
    IFCPILE: () => IFCPILE,
    IFCPILETYPE: () => IFCPILETYPE,
    IFCPIPEFITTING: () => IFCPIPEFITTING,
    IFCPIPEFITTINGTYPE: () => IFCPIPEFITTINGTYPE,
    IFCPIPESEGMENT: () => IFCPIPESEGMENT,
    IFCPIPESEGMENTTYPE: () => IFCPIPESEGMENTTYPE,
    IFCPIXELTEXTURE: () => IFCPIXELTEXTURE,
    IFCPLACEMENT: () => IFCPLACEMENT,
    IFCPLANARBOX: () => IFCPLANARBOX,
    IFCPLANAREXTENT: () => IFCPLANAREXTENT,
    IFCPLANE: () => IFCPLANE,
    IFCPLATE: () => IFCPLATE,
    IFCPLATESTANDARDCASE: () => IFCPLATESTANDARDCASE,
    IFCPLATETYPE: () => IFCPLATETYPE,
    IFCPOINT: () => IFCPOINT,
    IFCPOINTONCURVE: () => IFCPOINTONCURVE,
    IFCPOINTONSURFACE: () => IFCPOINTONSURFACE,
    IFCPOLYGONALBOUNDEDHALFSPACE: () => IFCPOLYGONALBOUNDEDHALFSPACE,
    IFCPOLYGONALFACESET: () => IFCPOLYGONALFACESET,
    IFCPOLYLINE: () => IFCPOLYLINE,
    IFCPOLYLOOP: () => IFCPOLYLOOP,
    IFCPORT: () => IFCPORT,
    IFCPOSITIONINGELEMENT: () => IFCPOSITIONINGELEMENT,
    IFCPOSTALADDRESS: () => IFCPOSTALADDRESS,
    IFCPREDEFINEDCOLOUR: () => IFCPREDEFINEDCOLOUR,
    IFCPREDEFINEDCURVEFONT: () => IFCPREDEFINEDCURVEFONT,
    IFCPREDEFINEDITEM: () => IFCPREDEFINEDITEM,
    IFCPREDEFINEDPROPERTIES: () => IFCPREDEFINEDPROPERTIES,
    IFCPREDEFINEDPROPERTYSET: () => IFCPREDEFINEDPROPERTYSET,
    IFCPREDEFINEDTEXTFONT: () => IFCPREDEFINEDTEXTFONT,
    IFCPRESENTATIONITEM: () => IFCPRESENTATIONITEM,
    IFCPRESENTATIONLAYERASSIGNMENT: () => IFCPRESENTATIONLAYERASSIGNMENT,
    IFCPRESENTATIONLAYERWITHSTYLE: () => IFCPRESENTATIONLAYERWITHSTYLE,
    IFCPRESENTATIONSTYLE: () => IFCPRESENTATIONSTYLE,
    IFCPRESENTATIONSTYLEASSIGNMENT: () => IFCPRESENTATIONSTYLEASSIGNMENT,
    IFCPROCEDURE: () => IFCPROCEDURE,
    IFCPROCEDURETYPE: () => IFCPROCEDURETYPE,
    IFCPROCESS: () => IFCPROCESS,
    IFCPRODUCT: () => IFCPRODUCT,
    IFCPRODUCTDEFINITIONSHAPE: () => IFCPRODUCTDEFINITIONSHAPE,
    IFCPRODUCTREPRESENTATION: () => IFCPRODUCTREPRESENTATION,
    IFCPROFILEDEF: () => IFCPROFILEDEF,
    IFCPROFILEPROPERTIES: () => IFCPROFILEPROPERTIES,
    IFCPROJECT: () => IFCPROJECT,
    IFCPROJECTEDCRS: () => IFCPROJECTEDCRS,
    IFCPROJECTIONELEMENT: () => IFCPROJECTIONELEMENT,
    IFCPROJECTLIBRARY: () => IFCPROJECTLIBRARY,
    IFCPROJECTORDER: () => IFCPROJECTORDER,
    IFCPROPERTY: () => IFCPROPERTY,
    IFCPROPERTYABSTRACTION: () => IFCPROPERTYABSTRACTION,
    IFCPROPERTYBOUNDEDVALUE: () => IFCPROPERTYBOUNDEDVALUE,
    IFCPROPERTYDEFINITION: () => IFCPROPERTYDEFINITION,
    IFCPROPERTYDEPENDENCYRELATIONSHIP: () => IFCPROPERTYDEPENDENCYRELATIONSHIP,
    IFCPROPERTYENUMERATEDVALUE: () => IFCPROPERTYENUMERATEDVALUE,
    IFCPROPERTYENUMERATION: () => IFCPROPERTYENUMERATION,
    IFCPROPERTYLISTVALUE: () => IFCPROPERTYLISTVALUE,
    IFCPROPERTYREFERENCEVALUE: () => IFCPROPERTYREFERENCEVALUE,
    IFCPROPERTYSET: () => IFCPROPERTYSET,
    IFCPROPERTYSETDEFINITION: () => IFCPROPERTYSETDEFINITION,
    IFCPROPERTYSETTEMPLATE: () => IFCPROPERTYSETTEMPLATE,
    IFCPROPERTYSINGLEVALUE: () => IFCPROPERTYSINGLEVALUE,
    IFCPROPERTYTABLEVALUE: () => IFCPROPERTYTABLEVALUE,
    IFCPROPERTYTEMPLATE: () => IFCPROPERTYTEMPLATE,
    IFCPROPERTYTEMPLATEDEFINITION: () => IFCPROPERTYTEMPLATEDEFINITION,
    IFCPROTECTIVEDEVICE: () => IFCPROTECTIVEDEVICE,
    IFCPROTECTIVEDEVICETRIPPINGUNIT: () => IFCPROTECTIVEDEVICETRIPPINGUNIT,
    IFCPROTECTIVEDEVICETRIPPINGUNITTYPE: () => IFCPROTECTIVEDEVICETRIPPINGUNITTYPE,
    IFCPROTECTIVEDEVICETYPE: () => IFCPROTECTIVEDEVICETYPE,
    IFCPROXY: () => IFCPROXY,
    IFCPUMP: () => IFCPUMP,
    IFCPUMPTYPE: () => IFCPUMPTYPE,
    IFCQUANTITYAREA: () => IFCQUANTITYAREA,
    IFCQUANTITYCOUNT: () => IFCQUANTITYCOUNT,
    IFCQUANTITYLENGTH: () => IFCQUANTITYLENGTH,
    IFCQUANTITYSET: () => IFCQUANTITYSET,
    IFCQUANTITYTIME: () => IFCQUANTITYTIME,
    IFCQUANTITYVOLUME: () => IFCQUANTITYVOLUME,
    IFCQUANTITYWEIGHT: () => IFCQUANTITYWEIGHT,
    IFCRAILING: () => IFCRAILING,
    IFCRAILINGTYPE: () => IFCRAILINGTYPE,
    IFCRAMP: () => IFCRAMP,
    IFCRAMPFLIGHT: () => IFCRAMPFLIGHT,
    IFCRAMPFLIGHTTYPE: () => IFCRAMPFLIGHTTYPE,
    IFCRAMPTYPE: () => IFCRAMPTYPE,
    IFCRATIONALBSPLINECURVEWITHKNOTS: () => IFCRATIONALBSPLINECURVEWITHKNOTS,
    IFCRATIONALBSPLINESURFACEWITHKNOTS: () => IFCRATIONALBSPLINESURFACEWITHKNOTS,
    IFCRECTANGLEHOLLOWPROFILEDEF: () => IFCRECTANGLEHOLLOWPROFILEDEF,
    IFCRECTANGLEPROFILEDEF: () => IFCRECTANGLEPROFILEDEF,
    IFCRECTANGULARPYRAMID: () => IFCRECTANGULARPYRAMID,
    IFCRECTANGULARTRIMMEDSURFACE: () => IFCRECTANGULARTRIMMEDSURFACE,
    IFCRECURRENCEPATTERN: () => IFCRECURRENCEPATTERN,
    IFCREFERENCE: () => IFCREFERENCE,
    IFCREFERENT: () => IFCREFERENT,
    IFCREGULARTIMESERIES: () => IFCREGULARTIMESERIES,
    IFCREINFORCEMENTBARPROPERTIES: () => IFCREINFORCEMENTBARPROPERTIES,
    IFCREINFORCEMENTDEFINITIONPROPERTIES: () => IFCREINFORCEMENTDEFINITIONPROPERTIES,
    IFCREINFORCINGBAR: () => IFCREINFORCINGBAR,
    IFCREINFORCINGBARTYPE: () => IFCREINFORCINGBARTYPE,
    IFCREINFORCINGELEMENT: () => IFCREINFORCINGELEMENT,
    IFCREINFORCINGELEMENTTYPE: () => IFCREINFORCINGELEMENTTYPE,
    IFCREINFORCINGMESH: () => IFCREINFORCINGMESH,
    IFCREINFORCINGMESHTYPE: () => IFCREINFORCINGMESHTYPE,
    IFCRELAGGREGATES: () => IFCRELAGGREGATES,
    IFCRELASSIGNS: () => IFCRELASSIGNS,
    IFCRELASSIGNSTOACTOR: () => IFCRELASSIGNSTOACTOR,
    IFCRELASSIGNSTOCONTROL: () => IFCRELASSIGNSTOCONTROL,
    IFCRELASSIGNSTOGROUP: () => IFCRELASSIGNSTOGROUP,
    IFCRELASSIGNSTOGROUPBYFACTOR: () => IFCRELASSIGNSTOGROUPBYFACTOR,
    IFCRELASSIGNSTOPROCESS: () => IFCRELASSIGNSTOPROCESS,
    IFCRELASSIGNSTOPRODUCT: () => IFCRELASSIGNSTOPRODUCT,
    IFCRELASSIGNSTORESOURCE: () => IFCRELASSIGNSTORESOURCE,
    IFCRELASSOCIATES: () => IFCRELASSOCIATES,
    IFCRELASSOCIATESAPPROVAL: () => IFCRELASSOCIATESAPPROVAL,
    IFCRELASSOCIATESCLASSIFICATION: () => IFCRELASSOCIATESCLASSIFICATION,
    IFCRELASSOCIATESCONSTRAINT: () => IFCRELASSOCIATESCONSTRAINT,
    IFCRELASSOCIATESDOCUMENT: () => IFCRELASSOCIATESDOCUMENT,
    IFCRELASSOCIATESLIBRARY: () => IFCRELASSOCIATESLIBRARY,
    IFCRELASSOCIATESMATERIAL: () => IFCRELASSOCIATESMATERIAL,
    IFCRELATIONSHIP: () => IFCRELATIONSHIP,
    IFCRELCONNECTS: () => IFCRELCONNECTS,
    IFCRELCONNECTSELEMENTS: () => IFCRELCONNECTSELEMENTS,
    IFCRELCONNECTSPATHELEMENTS: () => IFCRELCONNECTSPATHELEMENTS,
    IFCRELCONNECTSPORTS: () => IFCRELCONNECTSPORTS,
    IFCRELCONNECTSPORTTOELEMENT: () => IFCRELCONNECTSPORTTOELEMENT,
    IFCRELCONNECTSSTRUCTURALACTIVITY: () => IFCRELCONNECTSSTRUCTURALACTIVITY,
    IFCRELCONNECTSSTRUCTURALMEMBER: () => IFCRELCONNECTSSTRUCTURALMEMBER,
    IFCRELCONNECTSWITHECCENTRICITY: () => IFCRELCONNECTSWITHECCENTRICITY,
    IFCRELCONNECTSWITHREALIZINGELEMENTS: () => IFCRELCONNECTSWITHREALIZINGELEMENTS,
    IFCRELCONTAINEDINSPATIALSTRUCTURE: () => IFCRELCONTAINEDINSPATIALSTRUCTURE,
    IFCRELCOVERSBLDGELEMENTS: () => IFCRELCOVERSBLDGELEMENTS,
    IFCRELCOVERSSPACES: () => IFCRELCOVERSSPACES,
    IFCRELDECLARES: () => IFCRELDECLARES,
    IFCRELDECOMPOSES: () => IFCRELDECOMPOSES,
    IFCRELDEFINES: () => IFCRELDEFINES,
    IFCRELDEFINESBYOBJECT: () => IFCRELDEFINESBYOBJECT,
    IFCRELDEFINESBYPROPERTIES: () => IFCRELDEFINESBYPROPERTIES,
    IFCRELDEFINESBYTEMPLATE: () => IFCRELDEFINESBYTEMPLATE,
    IFCRELDEFINESBYTYPE: () => IFCRELDEFINESBYTYPE,
    IFCRELFILLSELEMENT: () => IFCRELFILLSELEMENT,
    IFCRELFLOWCONTROLELEMENTS: () => IFCRELFLOWCONTROLELEMENTS,
    IFCRELINTERFERESELEMENTS: () => IFCRELINTERFERESELEMENTS,
    IFCRELNESTS: () => IFCRELNESTS,
    IFCRELPOSITIONS: () => IFCRELPOSITIONS,
    IFCRELPROJECTSELEMENT: () => IFCRELPROJECTSELEMENT,
    IFCRELREFERENCEDINSPATIALSTRUCTURE: () => IFCRELREFERENCEDINSPATIALSTRUCTURE,
    IFCRELSEQUENCE: () => IFCRELSEQUENCE,
    IFCRELSERVICESBUILDINGS: () => IFCRELSERVICESBUILDINGS,
    IFCRELSPACEBOUNDARY: () => IFCRELSPACEBOUNDARY,
    IFCRELSPACEBOUNDARY1STLEVEL: () => IFCRELSPACEBOUNDARY1STLEVEL,
    IFCRELSPACEBOUNDARY2NDLEVEL: () => IFCRELSPACEBOUNDARY2NDLEVEL,
    IFCRELVOIDSELEMENT: () => IFCRELVOIDSELEMENT,
    IFCREPARAMETRISEDCOMPOSITECURVESEGMENT: () => IFCREPARAMETRISEDCOMPOSITECURVESEGMENT,
    IFCREPRESENTATION: () => IFCREPRESENTATION,
    IFCREPRESENTATIONCONTEXT: () => IFCREPRESENTATIONCONTEXT,
    IFCREPRESENTATIONITEM: () => IFCREPRESENTATIONITEM,
    IFCREPRESENTATIONMAP: () => IFCREPRESENTATIONMAP,
    IFCRESOURCE: () => IFCRESOURCE,
    IFCRESOURCEAPPROVALRELATIONSHIP: () => IFCRESOURCEAPPROVALRELATIONSHIP,
    IFCRESOURCECONSTRAINTRELATIONSHIP: () => IFCRESOURCECONSTRAINTRELATIONSHIP,
    IFCRESOURCELEVELRELATIONSHIP: () => IFCRESOURCELEVELRELATIONSHIP,
    IFCRESOURCETIME: () => IFCRESOURCETIME,
    IFCREVOLVEDAREASOLID: () => IFCREVOLVEDAREASOLID,
    IFCREVOLVEDAREASOLIDTAPERED: () => IFCREVOLVEDAREASOLIDTAPERED,
    IFCRIGHTCIRCULARCONE: () => IFCRIGHTCIRCULARCONE,
    IFCRIGHTCIRCULARCYLINDER: () => IFCRIGHTCIRCULARCYLINDER,
    IFCROOF: () => IFCROOF,
    IFCROOFTYPE: () => IFCROOFTYPE,
    IFCROOT: () => IFCROOT,
    IFCROUNDEDRECTANGLEPROFILEDEF: () => IFCROUNDEDRECTANGLEPROFILEDEF,
    IFCSANITARYTERMINAL: () => IFCSANITARYTERMINAL,
    IFCSANITARYTERMINALTYPE: () => IFCSANITARYTERMINALTYPE,
    IFCSCHEDULINGTIME: () => IFCSCHEDULINGTIME,
    IFCSEAMCURVE: () => IFCSEAMCURVE,
    IFCSECTIONEDSOLID: () => IFCSECTIONEDSOLID,
    IFCSECTIONEDSOLIDHORIZONTAL: () => IFCSECTIONEDSOLIDHORIZONTAL,
    IFCSECTIONEDSPINE: () => IFCSECTIONEDSPINE,
    IFCSECTIONPROPERTIES: () => IFCSECTIONPROPERTIES,
    IFCSECTIONREINFORCEMENTPROPERTIES: () => IFCSECTIONREINFORCEMENTPROPERTIES,
    IFCSENSOR: () => IFCSENSOR,
    IFCSENSORTYPE: () => IFCSENSORTYPE,
    IFCSHADINGDEVICE: () => IFCSHADINGDEVICE,
    IFCSHADINGDEVICETYPE: () => IFCSHADINGDEVICETYPE,
    IFCSHAPEASPECT: () => IFCSHAPEASPECT,
    IFCSHAPEMODEL: () => IFCSHAPEMODEL,
    IFCSHAPEREPRESENTATION: () => IFCSHAPEREPRESENTATION,
    IFCSHELLBASEDSURFACEMODEL: () => IFCSHELLBASEDSURFACEMODEL,
    IFCSIMPLEPROPERTY: () => IFCSIMPLEPROPERTY,
    IFCSIMPLEPROPERTYTEMPLATE: () => IFCSIMPLEPROPERTYTEMPLATE,
    IFCSITE: () => IFCSITE,
    IFCSIUNIT: () => IFCSIUNIT,
    IFCSLAB: () => IFCSLAB,
    IFCSLABELEMENTEDCASE: () => IFCSLABELEMENTEDCASE,
    IFCSLABSTANDARDCASE: () => IFCSLABSTANDARDCASE,
    IFCSLABTYPE: () => IFCSLABTYPE,
    IFCSLIPPAGECONNECTIONCONDITION: () => IFCSLIPPAGECONNECTIONCONDITION,
    IFCSOLARDEVICE: () => IFCSOLARDEVICE,
    IFCSOLARDEVICETYPE: () => IFCSOLARDEVICETYPE,
    IFCSOLIDMODEL: () => IFCSOLIDMODEL,
    IFCSPACE: () => IFCSPACE,
    IFCSPACEHEATER: () => IFCSPACEHEATER,
    IFCSPACEHEATERTYPE: () => IFCSPACEHEATERTYPE,
    IFCSPACETYPE: () => IFCSPACETYPE,
    IFCSPATIALELEMENT: () => IFCSPATIALELEMENT,
    IFCSPATIALELEMENTTYPE: () => IFCSPATIALELEMENTTYPE,
    IFCSPATIALSTRUCTUREELEMENT: () => IFCSPATIALSTRUCTUREELEMENT,
    IFCSPATIALSTRUCTUREELEMENTTYPE: () => IFCSPATIALSTRUCTUREELEMENTTYPE,
    IFCSPATIALZONE: () => IFCSPATIALZONE,
    IFCSPATIALZONETYPE: () => IFCSPATIALZONETYPE,
    IFCSPHERE: () => IFCSPHERE,
    IFCSPHERICALSURFACE: () => IFCSPHERICALSURFACE,
    IFCSTACKTERMINAL: () => IFCSTACKTERMINAL,
    IFCSTACKTERMINALTYPE: () => IFCSTACKTERMINALTYPE,
    IFCSTAIR: () => IFCSTAIR,
    IFCSTAIRFLIGHT: () => IFCSTAIRFLIGHT,
    IFCSTAIRFLIGHTTYPE: () => IFCSTAIRFLIGHTTYPE,
    IFCSTAIRTYPE: () => IFCSTAIRTYPE,
    IFCSTRUCTURALACTION: () => IFCSTRUCTURALACTION,
    IFCSTRUCTURALACTIVITY: () => IFCSTRUCTURALACTIVITY,
    IFCSTRUCTURALANALYSISMODEL: () => IFCSTRUCTURALANALYSISMODEL,
    IFCSTRUCTURALCONNECTION: () => IFCSTRUCTURALCONNECTION,
    IFCSTRUCTURALCONNECTIONCONDITION: () => IFCSTRUCTURALCONNECTIONCONDITION,
    IFCSTRUCTURALCURVEACTION: () => IFCSTRUCTURALCURVEACTION,
    IFCSTRUCTURALCURVECONNECTION: () => IFCSTRUCTURALCURVECONNECTION,
    IFCSTRUCTURALCURVEMEMBER: () => IFCSTRUCTURALCURVEMEMBER,
    IFCSTRUCTURALCURVEMEMBERVARYING: () => IFCSTRUCTURALCURVEMEMBERVARYING,
    IFCSTRUCTURALCURVEREACTION: () => IFCSTRUCTURALCURVEREACTION,
    IFCSTRUCTURALITEM: () => IFCSTRUCTURALITEM,
    IFCSTRUCTURALLINEARACTION: () => IFCSTRUCTURALLINEARACTION,
    IFCSTRUCTURALLOAD: () => IFCSTRUCTURALLOAD,
    IFCSTRUCTURALLOADCASE: () => IFCSTRUCTURALLOADCASE,
    IFCSTRUCTURALLOADCONFIGURATION: () => IFCSTRUCTURALLOADCONFIGURATION,
    IFCSTRUCTURALLOADGROUP: () => IFCSTRUCTURALLOADGROUP,
    IFCSTRUCTURALLOADLINEARFORCE: () => IFCSTRUCTURALLOADLINEARFORCE,
    IFCSTRUCTURALLOADORRESULT: () => IFCSTRUCTURALLOADORRESULT,
    IFCSTRUCTURALLOADPLANARFORCE: () => IFCSTRUCTURALLOADPLANARFORCE,
    IFCSTRUCTURALLOADSINGLEDISPLACEMENT: () => IFCSTRUCTURALLOADSINGLEDISPLACEMENT,
    IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION: () => IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION,
    IFCSTRUCTURALLOADSINGLEFORCE: () => IFCSTRUCTURALLOADSINGLEFORCE,
    IFCSTRUCTURALLOADSINGLEFORCEWARPING: () => IFCSTRUCTURALLOADSINGLEFORCEWARPING,
    IFCSTRUCTURALLOADSTATIC: () => IFCSTRUCTURALLOADSTATIC,
    IFCSTRUCTURALLOADTEMPERATURE: () => IFCSTRUCTURALLOADTEMPERATURE,
    IFCSTRUCTURALMEMBER: () => IFCSTRUCTURALMEMBER,
    IFCSTRUCTURALPLANARACTION: () => IFCSTRUCTURALPLANARACTION,
    IFCSTRUCTURALPOINTACTION: () => IFCSTRUCTURALPOINTACTION,
    IFCSTRUCTURALPOINTCONNECTION: () => IFCSTRUCTURALPOINTCONNECTION,
    IFCSTRUCTURALPOINTREACTION: () => IFCSTRUCTURALPOINTREACTION,
    IFCSTRUCTURALREACTION: () => IFCSTRUCTURALREACTION,
    IFCSTRUCTURALRESULTGROUP: () => IFCSTRUCTURALRESULTGROUP,
    IFCSTRUCTURALSURFACEACTION: () => IFCSTRUCTURALSURFACEACTION,
    IFCSTRUCTURALSURFACECONNECTION: () => IFCSTRUCTURALSURFACECONNECTION,
    IFCSTRUCTURALSURFACEMEMBER: () => IFCSTRUCTURALSURFACEMEMBER,
    IFCSTRUCTURALSURFACEMEMBERVARYING: () => IFCSTRUCTURALSURFACEMEMBERVARYING,
    IFCSTRUCTURALSURFACEREACTION: () => IFCSTRUCTURALSURFACEREACTION,
    IFCSTYLEDITEM: () => IFCSTYLEDITEM,
    IFCSTYLEDREPRESENTATION: () => IFCSTYLEDREPRESENTATION,
    IFCSTYLEMODEL: () => IFCSTYLEMODEL,
    IFCSUBCONTRACTRESOURCE: () => IFCSUBCONTRACTRESOURCE,
    IFCSUBCONTRACTRESOURCETYPE: () => IFCSUBCONTRACTRESOURCETYPE,
    IFCSUBEDGE: () => IFCSUBEDGE,
    IFCSURFACE: () => IFCSURFACE,
    IFCSURFACECURVE: () => IFCSURFACECURVE,
    IFCSURFACECURVESWEPTAREASOLID: () => IFCSURFACECURVESWEPTAREASOLID,
    IFCSURFACEFEATURE: () => IFCSURFACEFEATURE,
    IFCSURFACEOFLINEAREXTRUSION: () => IFCSURFACEOFLINEAREXTRUSION,
    IFCSURFACEOFREVOLUTION: () => IFCSURFACEOFREVOLUTION,
    IFCSURFACEREINFORCEMENTAREA: () => IFCSURFACEREINFORCEMENTAREA,
    IFCSURFACESTYLE: () => IFCSURFACESTYLE,
    IFCSURFACESTYLELIGHTING: () => IFCSURFACESTYLELIGHTING,
    IFCSURFACESTYLEREFRACTION: () => IFCSURFACESTYLEREFRACTION,
    IFCSURFACESTYLERENDERING: () => IFCSURFACESTYLERENDERING,
    IFCSURFACESTYLESHADING: () => IFCSURFACESTYLESHADING,
    IFCSURFACESTYLEWITHTEXTURES: () => IFCSURFACESTYLEWITHTEXTURES,
    IFCSURFACETEXTURE: () => IFCSURFACETEXTURE,
    IFCSWEPTAREASOLID: () => IFCSWEPTAREASOLID,
    IFCSWEPTDISKSOLID: () => IFCSWEPTDISKSOLID,
    IFCSWEPTDISKSOLIDPOLYGONAL: () => IFCSWEPTDISKSOLIDPOLYGONAL,
    IFCSWEPTSURFACE: () => IFCSWEPTSURFACE,
    IFCSWITCHINGDEVICE: () => IFCSWITCHINGDEVICE,
    IFCSWITCHINGDEVICETYPE: () => IFCSWITCHINGDEVICETYPE,
    IFCSYSTEM: () => IFCSYSTEM,
    IFCSYSTEMFURNITUREELEMENT: () => IFCSYSTEMFURNITUREELEMENT,
    IFCSYSTEMFURNITUREELEMENTTYPE: () => IFCSYSTEMFURNITUREELEMENTTYPE,
    IFCTABLE: () => IFCTABLE,
    IFCTABLECOLUMN: () => IFCTABLECOLUMN,
    IFCTABLEROW: () => IFCTABLEROW,
    IFCTANK: () => IFCTANK,
    IFCTANKTYPE: () => IFCTANKTYPE,
    IFCTASK: () => IFCTASK,
    IFCTASKTIME: () => IFCTASKTIME,
    IFCTASKTIMERECURRING: () => IFCTASKTIMERECURRING,
    IFCTASKTYPE: () => IFCTASKTYPE,
    IFCTELECOMADDRESS: () => IFCTELECOMADDRESS,
    IFCTENDON: () => IFCTENDON,
    IFCTENDONANCHOR: () => IFCTENDONANCHOR,
    IFCTENDONANCHORTYPE: () => IFCTENDONANCHORTYPE,
    IFCTENDONCONDUIT: () => IFCTENDONCONDUIT,
    IFCTENDONCONDUITTYPE: () => IFCTENDONCONDUITTYPE,
    IFCTENDONTYPE: () => IFCTENDONTYPE,
    IFCTESSELLATEDFACESET: () => IFCTESSELLATEDFACESET,
    IFCTESSELLATEDITEM: () => IFCTESSELLATEDITEM,
    IFCTEXTLITERAL: () => IFCTEXTLITERAL,
    IFCTEXTLITERALWITHEXTENT: () => IFCTEXTLITERALWITHEXTENT,
    IFCTEXTSTYLE: () => IFCTEXTSTYLE,
    IFCTEXTSTYLEFONTMODEL: () => IFCTEXTSTYLEFONTMODEL,
    IFCTEXTSTYLEFORDEFINEDFONT: () => IFCTEXTSTYLEFORDEFINEDFONT,
    IFCTEXTSTYLETEXTMODEL: () => IFCTEXTSTYLETEXTMODEL,
    IFCTEXTURECOORDINATE: () => IFCTEXTURECOORDINATE,
    IFCTEXTURECOORDINATEGENERATOR: () => IFCTEXTURECOORDINATEGENERATOR,
    IFCTEXTUREMAP: () => IFCTEXTUREMAP,
    IFCTEXTUREVERTEX: () => IFCTEXTUREVERTEX,
    IFCTEXTUREVERTEXLIST: () => IFCTEXTUREVERTEXLIST,
    IFCTIMEPERIOD: () => IFCTIMEPERIOD,
    IFCTIMESERIES: () => IFCTIMESERIES,
    IFCTIMESERIESVALUE: () => IFCTIMESERIESVALUE,
    IFCTOPOLOGICALREPRESENTATIONITEM: () => IFCTOPOLOGICALREPRESENTATIONITEM,
    IFCTOPOLOGYREPRESENTATION: () => IFCTOPOLOGYREPRESENTATION,
    IFCTOROIDALSURFACE: () => IFCTOROIDALSURFACE,
    IFCTRANSFORMER: () => IFCTRANSFORMER,
    IFCTRANSFORMERTYPE: () => IFCTRANSFORMERTYPE,
    IFCTRANSITIONCURVESEGMENT2D: () => IFCTRANSITIONCURVESEGMENT2D,
    IFCTRANSPORTELEMENT: () => IFCTRANSPORTELEMENT,
    IFCTRANSPORTELEMENTTYPE: () => IFCTRANSPORTELEMENTTYPE,
    IFCTRAPEZIUMPROFILEDEF: () => IFCTRAPEZIUMPROFILEDEF,
    IFCTRIANGULATEDFACESET: () => IFCTRIANGULATEDFACESET,
    IFCTRIANGULATEDIRREGULARNETWORK: () => IFCTRIANGULATEDIRREGULARNETWORK,
    IFCTRIMMEDCURVE: () => IFCTRIMMEDCURVE,
    IFCTSHAPEPROFILEDEF: () => IFCTSHAPEPROFILEDEF,
    IFCTUBEBUNDLE: () => IFCTUBEBUNDLE,
    IFCTUBEBUNDLETYPE: () => IFCTUBEBUNDLETYPE,
    IFCTYPEOBJECT: () => IFCTYPEOBJECT,
    IFCTYPEPROCESS: () => IFCTYPEPROCESS,
    IFCTYPEPRODUCT: () => IFCTYPEPRODUCT,
    IFCTYPERESOURCE: () => IFCTYPERESOURCE,
    IFCUNITARYCONTROLELEMENT: () => IFCUNITARYCONTROLELEMENT,
    IFCUNITARYCONTROLELEMENTTYPE: () => IFCUNITARYCONTROLELEMENTTYPE,
    IFCUNITARYEQUIPMENT: () => IFCUNITARYEQUIPMENT,
    IFCUNITARYEQUIPMENTTYPE: () => IFCUNITARYEQUIPMENTTYPE,
    IFCUNITASSIGNMENT: () => IFCUNITASSIGNMENT,
    IFCUSHAPEPROFILEDEF: () => IFCUSHAPEPROFILEDEF,
    IFCVALVE: () => IFCVALVE,
    IFCVALVETYPE: () => IFCVALVETYPE,
    IFCVECTOR: () => IFCVECTOR,
    IFCVERTEX: () => IFCVERTEX,
    IFCVERTEXLOOP: () => IFCVERTEXLOOP,
    IFCVERTEXPOINT: () => IFCVERTEXPOINT,
    IFCVIBRATIONDAMPER: () => IFCVIBRATIONDAMPER,
    IFCVIBRATIONDAMPERTYPE: () => IFCVIBRATIONDAMPERTYPE,
    IFCVIBRATIONISOLATOR: () => IFCVIBRATIONISOLATOR,
    IFCVIBRATIONISOLATORTYPE: () => IFCVIBRATIONISOLATORTYPE,
    IFCVIRTUALELEMENT: () => IFCVIRTUALELEMENT,
    IFCVIRTUALGRIDINTERSECTION: () => IFCVIRTUALGRIDINTERSECTION,
    IFCVOIDINGFEATURE: () => IFCVOIDINGFEATURE,
    IFCWALL: () => IFCWALL,
    IFCWALLELEMENTEDCASE: () => IFCWALLELEMENTEDCASE,
    IFCWALLSTANDARDCASE: () => IFCWALLSTANDARDCASE,
    IFCWALLTYPE: () => IFCWALLTYPE,
    IFCWASTETERMINAL: () => IFCWASTETERMINAL,
    IFCWASTETERMINALTYPE: () => IFCWASTETERMINALTYPE,
    IFCWINDOW: () => IFCWINDOW,
    IFCWINDOWLININGPROPERTIES: () => IFCWINDOWLININGPROPERTIES,
    IFCWINDOWPANELPROPERTIES: () => IFCWINDOWPANELPROPERTIES,
    IFCWINDOWSTANDARDCASE: () => IFCWINDOWSTANDARDCASE,
    IFCWINDOWSTYLE: () => IFCWINDOWSTYLE,
    IFCWINDOWTYPE: () => IFCWINDOWTYPE,
    IFCWORKCALENDAR: () => IFCWORKCALENDAR,
    IFCWORKCONTROL: () => IFCWORKCONTROL,
    IFCWORKPLAN: () => IFCWORKPLAN,
    IFCWORKSCHEDULE: () => IFCWORKSCHEDULE,
    IFCWORKTIME: () => IFCWORKTIME,
    IFCZONE: () => IFCZONE,
    IFCZSHAPEPROFILEDEF: () => IFCZSHAPEPROFILEDEF,
    IfcAPI: () => IfcAPI2,
    IfcAbsorbedDoseMeasure: () => IfcAbsorbedDoseMeasure,
    IfcAccelerationMeasure: () => IfcAccelerationMeasure,
    IfcActionRequest: () => IfcActionRequest,
    IfcActionRequestTypeEnum: () => IfcActionRequestTypeEnum,
    IfcActionSourceTypeEnum: () => IfcActionSourceTypeEnum,
    IfcActionTypeEnum: () => IfcActionTypeEnum,
    IfcActor: () => IfcActor,
    IfcActorRole: () => IfcActorRole,
    IfcActuator: () => IfcActuator,
    IfcActuatorType: () => IfcActuatorType,
    IfcActuatorTypeEnum: () => IfcActuatorTypeEnum,
    IfcAddress: () => IfcAddress,
    IfcAddressTypeEnum: () => IfcAddressTypeEnum,
    IfcAdvancedBrep: () => IfcAdvancedBrep,
    IfcAdvancedBrepWithVoids: () => IfcAdvancedBrepWithVoids,
    IfcAdvancedFace: () => IfcAdvancedFace,
    IfcAirTerminal: () => IfcAirTerminal,
    IfcAirTerminalBox: () => IfcAirTerminalBox,
    IfcAirTerminalBoxType: () => IfcAirTerminalBoxType,
    IfcAirTerminalBoxTypeEnum: () => IfcAirTerminalBoxTypeEnum,
    IfcAirTerminalType: () => IfcAirTerminalType,
    IfcAirTerminalTypeEnum: () => IfcAirTerminalTypeEnum,
    IfcAirToAirHeatRecovery: () => IfcAirToAirHeatRecovery,
    IfcAirToAirHeatRecoveryType: () => IfcAirToAirHeatRecoveryType,
    IfcAirToAirHeatRecoveryTypeEnum: () => IfcAirToAirHeatRecoveryTypeEnum,
    IfcAlarm: () => IfcAlarm,
    IfcAlarmType: () => IfcAlarmType,
    IfcAlarmTypeEnum: () => IfcAlarmTypeEnum,
    IfcAlignment: () => IfcAlignment,
    IfcAlignment2DHorizontal: () => IfcAlignment2DHorizontal,
    IfcAlignment2DHorizontalSegment: () => IfcAlignment2DHorizontalSegment,
    IfcAlignment2DSegment: () => IfcAlignment2DSegment,
    IfcAlignment2DVerSegCircularArc: () => IfcAlignment2DVerSegCircularArc,
    IfcAlignment2DVerSegLine: () => IfcAlignment2DVerSegLine,
    IfcAlignment2DVerSegParabolicArc: () => IfcAlignment2DVerSegParabolicArc,
    IfcAlignment2DVertical: () => IfcAlignment2DVertical,
    IfcAlignment2DVerticalSegment: () => IfcAlignment2DVerticalSegment,
    IfcAlignmentCurve: () => IfcAlignmentCurve,
    IfcAlignmentTypeEnum: () => IfcAlignmentTypeEnum,
    IfcAmountOfSubstanceMeasure: () => IfcAmountOfSubstanceMeasure,
    IfcAnalysisModelTypeEnum: () => IfcAnalysisModelTypeEnum,
    IfcAnalysisTheoryTypeEnum: () => IfcAnalysisTheoryTypeEnum,
    IfcAngularVelocityMeasure: () => IfcAngularVelocityMeasure,
    IfcAnnotation: () => IfcAnnotation,
    IfcAnnotationFillArea: () => IfcAnnotationFillArea,
    IfcApplication: () => IfcApplication,
    IfcAppliedValue: () => IfcAppliedValue,
    IfcApproval: () => IfcApproval,
    IfcApprovalRelationship: () => IfcApprovalRelationship,
    IfcArbitraryClosedProfileDef: () => IfcArbitraryClosedProfileDef,
    IfcArbitraryOpenProfileDef: () => IfcArbitraryOpenProfileDef,
    IfcArbitraryProfileDefWithVoids: () => IfcArbitraryProfileDefWithVoids,
    IfcAreaDensityMeasure: () => IfcAreaDensityMeasure,
    IfcAreaMeasure: () => IfcAreaMeasure,
    IfcArithmeticOperatorEnum: () => IfcArithmeticOperatorEnum,
    IfcAssemblyPlaceEnum: () => IfcAssemblyPlaceEnum,
    IfcAsset: () => IfcAsset,
    IfcAsymmetricIShapeProfileDef: () => IfcAsymmetricIShapeProfileDef,
    IfcAudioVisualAppliance: () => IfcAudioVisualAppliance,
    IfcAudioVisualApplianceType: () => IfcAudioVisualApplianceType,
    IfcAudioVisualApplianceTypeEnum: () => IfcAudioVisualApplianceTypeEnum,
    IfcAxis1Placement: () => IfcAxis1Placement,
    IfcAxis2Placement2D: () => IfcAxis2Placement2D,
    IfcAxis2Placement3D: () => IfcAxis2Placement3D,
    IfcBSplineCurve: () => IfcBSplineCurve,
    IfcBSplineCurveForm: () => IfcBSplineCurveForm,
    IfcBSplineCurveWithKnots: () => IfcBSplineCurveWithKnots,
    IfcBSplineSurface: () => IfcBSplineSurface,
    IfcBSplineSurfaceForm: () => IfcBSplineSurfaceForm,
    IfcBSplineSurfaceWithKnots: () => IfcBSplineSurfaceWithKnots,
    IfcBeam: () => IfcBeam,
    IfcBeamStandardCase: () => IfcBeamStandardCase,
    IfcBeamType: () => IfcBeamType,
    IfcBeamTypeEnum: () => IfcBeamTypeEnum,
    IfcBearing: () => IfcBearing,
    IfcBearingType: () => IfcBearingType,
    IfcBearingTypeDisplacementEnum: () => IfcBearingTypeDisplacementEnum,
    IfcBearingTypeEnum: () => IfcBearingTypeEnum,
    IfcBenchmarkEnum: () => IfcBenchmarkEnum,
    IfcBinary: () => IfcBinary,
    IfcBlobTexture: () => IfcBlobTexture,
    IfcBlock: () => IfcBlock,
    IfcBoiler: () => IfcBoiler,
    IfcBoilerType: () => IfcBoilerType,
    IfcBoilerTypeEnum: () => IfcBoilerTypeEnum,
    IfcBoolean: () => IfcBoolean,
    IfcBooleanClippingResult: () => IfcBooleanClippingResult,
    IfcBooleanOperator: () => IfcBooleanOperator,
    IfcBooleanResult: () => IfcBooleanResult,
    IfcBoundaryCondition: () => IfcBoundaryCondition,
    IfcBoundaryCurve: () => IfcBoundaryCurve,
    IfcBoundaryEdgeCondition: () => IfcBoundaryEdgeCondition,
    IfcBoundaryFaceCondition: () => IfcBoundaryFaceCondition,
    IfcBoundaryNodeCondition: () => IfcBoundaryNodeCondition,
    IfcBoundaryNodeConditionWarping: () => IfcBoundaryNodeConditionWarping,
    IfcBoundedCurve: () => IfcBoundedCurve,
    IfcBoundedSurface: () => IfcBoundedSurface,
    IfcBoundingBox: () => IfcBoundingBox,
    IfcBoxAlignment: () => IfcBoxAlignment,
    IfcBoxedHalfSpace: () => IfcBoxedHalfSpace,
    IfcBridge: () => IfcBridge,
    IfcBridgePart: () => IfcBridgePart,
    IfcBridgePartTypeEnum: () => IfcBridgePartTypeEnum,
    IfcBridgeTypeEnum: () => IfcBridgeTypeEnum,
    IfcBuilding: () => IfcBuilding,
    IfcBuildingElement: () => IfcBuildingElement,
    IfcBuildingElementPart: () => IfcBuildingElementPart,
    IfcBuildingElementPartType: () => IfcBuildingElementPartType,
    IfcBuildingElementPartTypeEnum: () => IfcBuildingElementPartTypeEnum,
    IfcBuildingElementProxy: () => IfcBuildingElementProxy,
    IfcBuildingElementProxyType: () => IfcBuildingElementProxyType,
    IfcBuildingElementProxyTypeEnum: () => IfcBuildingElementProxyTypeEnum,
    IfcBuildingElementType: () => IfcBuildingElementType,
    IfcBuildingStorey: () => IfcBuildingStorey,
    IfcBuildingSystem: () => IfcBuildingSystem,
    IfcBuildingSystemTypeEnum: () => IfcBuildingSystemTypeEnum,
    IfcBurner: () => IfcBurner,
    IfcBurnerType: () => IfcBurnerType,
    IfcBurnerTypeEnum: () => IfcBurnerTypeEnum,
    IfcCShapeProfileDef: () => IfcCShapeProfileDef,
    IfcCableCarrierFitting: () => IfcCableCarrierFitting,
    IfcCableCarrierFittingType: () => IfcCableCarrierFittingType,
    IfcCableCarrierFittingTypeEnum: () => IfcCableCarrierFittingTypeEnum,
    IfcCableCarrierSegment: () => IfcCableCarrierSegment,
    IfcCableCarrierSegmentType: () => IfcCableCarrierSegmentType,
    IfcCableCarrierSegmentTypeEnum: () => IfcCableCarrierSegmentTypeEnum,
    IfcCableFitting: () => IfcCableFitting,
    IfcCableFittingType: () => IfcCableFittingType,
    IfcCableFittingTypeEnum: () => IfcCableFittingTypeEnum,
    IfcCableSegment: () => IfcCableSegment,
    IfcCableSegmentType: () => IfcCableSegmentType,
    IfcCableSegmentTypeEnum: () => IfcCableSegmentTypeEnum,
    IfcCaissonFoundation: () => IfcCaissonFoundation,
    IfcCaissonFoundationType: () => IfcCaissonFoundationType,
    IfcCaissonFoundationTypeEnum: () => IfcCaissonFoundationTypeEnum,
    IfcCardinalPointReference: () => IfcCardinalPointReference,
    IfcCartesianPoint: () => IfcCartesianPoint,
    IfcCartesianPointList: () => IfcCartesianPointList,
    IfcCartesianPointList2D: () => IfcCartesianPointList2D,
    IfcCartesianPointList3D: () => IfcCartesianPointList3D,
    IfcCartesianTransformationOperator: () => IfcCartesianTransformationOperator,
    IfcCartesianTransformationOperator2D: () => IfcCartesianTransformationOperator2D,
    IfcCartesianTransformationOperator2DnonUniform: () => IfcCartesianTransformationOperator2DnonUniform,
    IfcCartesianTransformationOperator3D: () => IfcCartesianTransformationOperator3D,
    IfcCartesianTransformationOperator3DnonUniform: () => IfcCartesianTransformationOperator3DnonUniform,
    IfcCenterLineProfileDef: () => IfcCenterLineProfileDef,
    IfcChangeActionEnum: () => IfcChangeActionEnum,
    IfcChiller: () => IfcChiller,
    IfcChillerType: () => IfcChillerType,
    IfcChillerTypeEnum: () => IfcChillerTypeEnum,
    IfcChimney: () => IfcChimney,
    IfcChimneyType: () => IfcChimneyType,
    IfcChimneyTypeEnum: () => IfcChimneyTypeEnum,
    IfcCircle: () => IfcCircle,
    IfcCircleHollowProfileDef: () => IfcCircleHollowProfileDef,
    IfcCircleProfileDef: () => IfcCircleProfileDef,
    IfcCircularArcSegment2D: () => IfcCircularArcSegment2D,
    IfcCivilElement: () => IfcCivilElement,
    IfcCivilElementType: () => IfcCivilElementType,
    IfcClassification: () => IfcClassification,
    IfcClassificationReference: () => IfcClassificationReference,
    IfcClosedShell: () => IfcClosedShell,
    IfcCoil: () => IfcCoil,
    IfcCoilType: () => IfcCoilType,
    IfcCoilTypeEnum: () => IfcCoilTypeEnum,
    IfcColourRgb: () => IfcColourRgb,
    IfcColourRgbList: () => IfcColourRgbList,
    IfcColourSpecification: () => IfcColourSpecification,
    IfcColumn: () => IfcColumn,
    IfcColumnStandardCase: () => IfcColumnStandardCase,
    IfcColumnType: () => IfcColumnType,
    IfcColumnTypeEnum: () => IfcColumnTypeEnum,
    IfcCommunicationsAppliance: () => IfcCommunicationsAppliance,
    IfcCommunicationsApplianceType: () => IfcCommunicationsApplianceType,
    IfcCommunicationsApplianceTypeEnum: () => IfcCommunicationsApplianceTypeEnum,
    IfcComplexProperty: () => IfcComplexProperty,
    IfcComplexPropertyTemplate: () => IfcComplexPropertyTemplate,
    IfcComplexPropertyTemplateTypeEnum: () => IfcComplexPropertyTemplateTypeEnum,
    IfcCompositeCurve: () => IfcCompositeCurve,
    IfcCompositeCurveOnSurface: () => IfcCompositeCurveOnSurface,
    IfcCompositeCurveSegment: () => IfcCompositeCurveSegment,
    IfcCompositeProfileDef: () => IfcCompositeProfileDef,
    IfcCompressor: () => IfcCompressor,
    IfcCompressorType: () => IfcCompressorType,
    IfcCompressorTypeEnum: () => IfcCompressorTypeEnum,
    IfcCondenser: () => IfcCondenser,
    IfcCondenserType: () => IfcCondenserType,
    IfcCondenserTypeEnum: () => IfcCondenserTypeEnum,
    IfcConic: () => IfcConic,
    IfcConnectedFaceSet: () => IfcConnectedFaceSet,
    IfcConnectionCurveGeometry: () => IfcConnectionCurveGeometry,
    IfcConnectionGeometry: () => IfcConnectionGeometry,
    IfcConnectionPointEccentricity: () => IfcConnectionPointEccentricity,
    IfcConnectionPointGeometry: () => IfcConnectionPointGeometry,
    IfcConnectionSurfaceGeometry: () => IfcConnectionSurfaceGeometry,
    IfcConnectionTypeEnum: () => IfcConnectionTypeEnum,
    IfcConnectionVolumeGeometry: () => IfcConnectionVolumeGeometry,
    IfcConstraint: () => IfcConstraint,
    IfcConstraintEnum: () => IfcConstraintEnum,
    IfcConstructionEquipmentResource: () => IfcConstructionEquipmentResource,
    IfcConstructionEquipmentResourceType: () => IfcConstructionEquipmentResourceType,
    IfcConstructionEquipmentResourceTypeEnum: () => IfcConstructionEquipmentResourceTypeEnum,
    IfcConstructionMaterialResource: () => IfcConstructionMaterialResource,
    IfcConstructionMaterialResourceType: () => IfcConstructionMaterialResourceType,
    IfcConstructionMaterialResourceTypeEnum: () => IfcConstructionMaterialResourceTypeEnum,
    IfcConstructionProductResource: () => IfcConstructionProductResource,
    IfcConstructionProductResourceType: () => IfcConstructionProductResourceType,
    IfcConstructionProductResourceTypeEnum: () => IfcConstructionProductResourceTypeEnum,
    IfcConstructionResource: () => IfcConstructionResource,
    IfcConstructionResourceType: () => IfcConstructionResourceType,
    IfcContext: () => IfcContext,
    IfcContextDependentMeasure: () => IfcContextDependentMeasure,
    IfcContextDependentUnit: () => IfcContextDependentUnit,
    IfcControl: () => IfcControl,
    IfcController: () => IfcController,
    IfcControllerType: () => IfcControllerType,
    IfcControllerTypeEnum: () => IfcControllerTypeEnum,
    IfcConversionBasedUnit: () => IfcConversionBasedUnit,
    IfcConversionBasedUnitWithOffset: () => IfcConversionBasedUnitWithOffset,
    IfcCooledBeam: () => IfcCooledBeam,
    IfcCooledBeamType: () => IfcCooledBeamType,
    IfcCooledBeamTypeEnum: () => IfcCooledBeamTypeEnum,
    IfcCoolingTower: () => IfcCoolingTower,
    IfcCoolingTowerType: () => IfcCoolingTowerType,
    IfcCoolingTowerTypeEnum: () => IfcCoolingTowerTypeEnum,
    IfcCoordinateOperation: () => IfcCoordinateOperation,
    IfcCoordinateReferenceSystem: () => IfcCoordinateReferenceSystem,
    IfcCostItem: () => IfcCostItem,
    IfcCostItemTypeEnum: () => IfcCostItemTypeEnum,
    IfcCostSchedule: () => IfcCostSchedule,
    IfcCostScheduleTypeEnum: () => IfcCostScheduleTypeEnum,
    IfcCostValue: () => IfcCostValue,
    IfcCountMeasure: () => IfcCountMeasure,
    IfcCovering: () => IfcCovering,
    IfcCoveringType: () => IfcCoveringType,
    IfcCoveringTypeEnum: () => IfcCoveringTypeEnum,
    IfcCrewResource: () => IfcCrewResource,
    IfcCrewResourceType: () => IfcCrewResourceType,
    IfcCrewResourceTypeEnum: () => IfcCrewResourceTypeEnum,
    IfcCsgPrimitive3D: () => IfcCsgPrimitive3D,
    IfcCsgSolid: () => IfcCsgSolid,
    IfcCurrencyRelationship: () => IfcCurrencyRelationship,
    IfcCurtainWall: () => IfcCurtainWall,
    IfcCurtainWallType: () => IfcCurtainWallType,
    IfcCurtainWallTypeEnum: () => IfcCurtainWallTypeEnum,
    IfcCurvatureMeasure: () => IfcCurvatureMeasure,
    IfcCurve: () => IfcCurve,
    IfcCurveBoundedPlane: () => IfcCurveBoundedPlane,
    IfcCurveBoundedSurface: () => IfcCurveBoundedSurface,
    IfcCurveInterpolationEnum: () => IfcCurveInterpolationEnum,
    IfcCurveSegment2D: () => IfcCurveSegment2D,
    IfcCurveStyle: () => IfcCurveStyle,
    IfcCurveStyleFont: () => IfcCurveStyleFont,
    IfcCurveStyleFontAndScaling: () => IfcCurveStyleFontAndScaling,
    IfcCurveStyleFontPattern: () => IfcCurveStyleFontPattern,
    IfcCylindricalSurface: () => IfcCylindricalSurface,
    IfcDamper: () => IfcDamper,
    IfcDamperType: () => IfcDamperType,
    IfcDamperTypeEnum: () => IfcDamperTypeEnum,
    IfcDataOriginEnum: () => IfcDataOriginEnum,
    IfcDate: () => IfcDate,
    IfcDateTime: () => IfcDateTime,
    IfcDayInMonthNumber: () => IfcDayInMonthNumber,
    IfcDayInWeekNumber: () => IfcDayInWeekNumber,
    IfcDeepFoundation: () => IfcDeepFoundation,
    IfcDeepFoundationType: () => IfcDeepFoundationType,
    IfcDerivedProfileDef: () => IfcDerivedProfileDef,
    IfcDerivedUnit: () => IfcDerivedUnit,
    IfcDerivedUnitElement: () => IfcDerivedUnitElement,
    IfcDerivedUnitEnum: () => IfcDerivedUnitEnum,
    IfcDescriptiveMeasure: () => IfcDescriptiveMeasure,
    IfcDimensionCount: () => IfcDimensionCount,
    IfcDimensionalExponents: () => IfcDimensionalExponents,
    IfcDirection: () => IfcDirection,
    IfcDirectionSenseEnum: () => IfcDirectionSenseEnum,
    IfcDiscreteAccessory: () => IfcDiscreteAccessory,
    IfcDiscreteAccessoryType: () => IfcDiscreteAccessoryType,
    IfcDiscreteAccessoryTypeEnum: () => IfcDiscreteAccessoryTypeEnum,
    IfcDistanceExpression: () => IfcDistanceExpression,
    IfcDistributionChamberElement: () => IfcDistributionChamberElement,
    IfcDistributionChamberElementType: () => IfcDistributionChamberElementType,
    IfcDistributionChamberElementTypeEnum: () => IfcDistributionChamberElementTypeEnum,
    IfcDistributionCircuit: () => IfcDistributionCircuit,
    IfcDistributionControlElement: () => IfcDistributionControlElement,
    IfcDistributionControlElementType: () => IfcDistributionControlElementType,
    IfcDistributionElement: () => IfcDistributionElement,
    IfcDistributionElementType: () => IfcDistributionElementType,
    IfcDistributionFlowElement: () => IfcDistributionFlowElement,
    IfcDistributionFlowElementType: () => IfcDistributionFlowElementType,
    IfcDistributionPort: () => IfcDistributionPort,
    IfcDistributionPortTypeEnum: () => IfcDistributionPortTypeEnum,
    IfcDistributionSystem: () => IfcDistributionSystem,
    IfcDistributionSystemEnum: () => IfcDistributionSystemEnum,
    IfcDocumentConfidentialityEnum: () => IfcDocumentConfidentialityEnum,
    IfcDocumentInformation: () => IfcDocumentInformation,
    IfcDocumentInformationRelationship: () => IfcDocumentInformationRelationship,
    IfcDocumentReference: () => IfcDocumentReference,
    IfcDocumentStatusEnum: () => IfcDocumentStatusEnum,
    IfcDoor: () => IfcDoor,
    IfcDoorLiningProperties: () => IfcDoorLiningProperties,
    IfcDoorPanelOperationEnum: () => IfcDoorPanelOperationEnum,
    IfcDoorPanelPositionEnum: () => IfcDoorPanelPositionEnum,
    IfcDoorPanelProperties: () => IfcDoorPanelProperties,
    IfcDoorStandardCase: () => IfcDoorStandardCase,
    IfcDoorStyle: () => IfcDoorStyle,
    IfcDoorStyleConstructionEnum: () => IfcDoorStyleConstructionEnum,
    IfcDoorStyleOperationEnum: () => IfcDoorStyleOperationEnum,
    IfcDoorType: () => IfcDoorType,
    IfcDoorTypeEnum: () => IfcDoorTypeEnum,
    IfcDoorTypeOperationEnum: () => IfcDoorTypeOperationEnum,
    IfcDoseEquivalentMeasure: () => IfcDoseEquivalentMeasure,
    IfcDraughtingPreDefinedColour: () => IfcDraughtingPreDefinedColour,
    IfcDraughtingPreDefinedCurveFont: () => IfcDraughtingPreDefinedCurveFont,
    IfcDuctFitting: () => IfcDuctFitting,
    IfcDuctFittingType: () => IfcDuctFittingType,
    IfcDuctFittingTypeEnum: () => IfcDuctFittingTypeEnum,
    IfcDuctSegment: () => IfcDuctSegment,
    IfcDuctSegmentType: () => IfcDuctSegmentType,
    IfcDuctSegmentTypeEnum: () => IfcDuctSegmentTypeEnum,
    IfcDuctSilencer: () => IfcDuctSilencer,
    IfcDuctSilencerType: () => IfcDuctSilencerType,
    IfcDuctSilencerTypeEnum: () => IfcDuctSilencerTypeEnum,
    IfcDuration: () => IfcDuration,
    IfcDynamicViscosityMeasure: () => IfcDynamicViscosityMeasure,
    IfcEdge: () => IfcEdge,
    IfcEdgeCurve: () => IfcEdgeCurve,
    IfcEdgeLoop: () => IfcEdgeLoop,
    IfcElectricAppliance: () => IfcElectricAppliance,
    IfcElectricApplianceType: () => IfcElectricApplianceType,
    IfcElectricApplianceTypeEnum: () => IfcElectricApplianceTypeEnum,
    IfcElectricCapacitanceMeasure: () => IfcElectricCapacitanceMeasure,
    IfcElectricChargeMeasure: () => IfcElectricChargeMeasure,
    IfcElectricConductanceMeasure: () => IfcElectricConductanceMeasure,
    IfcElectricCurrentMeasure: () => IfcElectricCurrentMeasure,
    IfcElectricDistributionBoard: () => IfcElectricDistributionBoard,
    IfcElectricDistributionBoardType: () => IfcElectricDistributionBoardType,
    IfcElectricDistributionBoardTypeEnum: () => IfcElectricDistributionBoardTypeEnum,
    IfcElectricFlowStorageDevice: () => IfcElectricFlowStorageDevice,
    IfcElectricFlowStorageDeviceType: () => IfcElectricFlowStorageDeviceType,
    IfcElectricFlowStorageDeviceTypeEnum: () => IfcElectricFlowStorageDeviceTypeEnum,
    IfcElectricGenerator: () => IfcElectricGenerator,
    IfcElectricGeneratorType: () => IfcElectricGeneratorType,
    IfcElectricGeneratorTypeEnum: () => IfcElectricGeneratorTypeEnum,
    IfcElectricMotor: () => IfcElectricMotor,
    IfcElectricMotorType: () => IfcElectricMotorType,
    IfcElectricMotorTypeEnum: () => IfcElectricMotorTypeEnum,
    IfcElectricResistanceMeasure: () => IfcElectricResistanceMeasure,
    IfcElectricTimeControl: () => IfcElectricTimeControl,
    IfcElectricTimeControlType: () => IfcElectricTimeControlType,
    IfcElectricTimeControlTypeEnum: () => IfcElectricTimeControlTypeEnum,
    IfcElectricVoltageMeasure: () => IfcElectricVoltageMeasure,
    IfcElement: () => IfcElement,
    IfcElementAssembly: () => IfcElementAssembly,
    IfcElementAssemblyType: () => IfcElementAssemblyType,
    IfcElementAssemblyTypeEnum: () => IfcElementAssemblyTypeEnum,
    IfcElementComponent: () => IfcElementComponent,
    IfcElementComponentType: () => IfcElementComponentType,
    IfcElementCompositionEnum: () => IfcElementCompositionEnum,
    IfcElementQuantity: () => IfcElementQuantity,
    IfcElementType: () => IfcElementType,
    IfcElementarySurface: () => IfcElementarySurface,
    IfcElements: () => IfcElements,
    IfcEllipse: () => IfcEllipse,
    IfcEllipseProfileDef: () => IfcEllipseProfileDef,
    IfcEnergyConversionDevice: () => IfcEnergyConversionDevice,
    IfcEnergyConversionDeviceType: () => IfcEnergyConversionDeviceType,
    IfcEnergyMeasure: () => IfcEnergyMeasure,
    IfcEngine: () => IfcEngine,
    IfcEngineType: () => IfcEngineType,
    IfcEngineTypeEnum: () => IfcEngineTypeEnum,
    IfcEvaporativeCooler: () => IfcEvaporativeCooler,
    IfcEvaporativeCoolerType: () => IfcEvaporativeCoolerType,
    IfcEvaporativeCoolerTypeEnum: () => IfcEvaporativeCoolerTypeEnum,
    IfcEvaporator: () => IfcEvaporator,
    IfcEvaporatorType: () => IfcEvaporatorType,
    IfcEvaporatorTypeEnum: () => IfcEvaporatorTypeEnum,
    IfcEvent: () => IfcEvent,
    IfcEventTime: () => IfcEventTime,
    IfcEventTriggerTypeEnum: () => IfcEventTriggerTypeEnum,
    IfcEventType: () => IfcEventType,
    IfcEventTypeEnum: () => IfcEventTypeEnum,
    IfcExtendedProperties: () => IfcExtendedProperties,
    IfcExternalInformation: () => IfcExternalInformation,
    IfcExternalReference: () => IfcExternalReference,
    IfcExternalReferenceRelationship: () => IfcExternalReferenceRelationship,
    IfcExternalSpatialElement: () => IfcExternalSpatialElement,
    IfcExternalSpatialElementTypeEnum: () => IfcExternalSpatialElementTypeEnum,
    IfcExternalSpatialStructureElement: () => IfcExternalSpatialStructureElement,
    IfcExternallyDefinedHatchStyle: () => IfcExternallyDefinedHatchStyle,
    IfcExternallyDefinedSurfaceStyle: () => IfcExternallyDefinedSurfaceStyle,
    IfcExternallyDefinedTextFont: () => IfcExternallyDefinedTextFont,
    IfcExtrudedAreaSolid: () => IfcExtrudedAreaSolid,
    IfcExtrudedAreaSolidTapered: () => IfcExtrudedAreaSolidTapered,
    IfcFace: () => IfcFace,
    IfcFaceBasedSurfaceModel: () => IfcFaceBasedSurfaceModel,
    IfcFaceBound: () => IfcFaceBound,
    IfcFaceOuterBound: () => IfcFaceOuterBound,
    IfcFaceSurface: () => IfcFaceSurface,
    IfcFacetedBrep: () => IfcFacetedBrep,
    IfcFacetedBrepWithVoids: () => IfcFacetedBrepWithVoids,
    IfcFacility: () => IfcFacility,
    IfcFacilityPart: () => IfcFacilityPart,
    IfcFailureConnectionCondition: () => IfcFailureConnectionCondition,
    IfcFan: () => IfcFan,
    IfcFanType: () => IfcFanType,
    IfcFanTypeEnum: () => IfcFanTypeEnum,
    IfcFastener: () => IfcFastener,
    IfcFastenerType: () => IfcFastenerType,
    IfcFastenerTypeEnum: () => IfcFastenerTypeEnum,
    IfcFeatureElement: () => IfcFeatureElement,
    IfcFeatureElementAddition: () => IfcFeatureElementAddition,
    IfcFeatureElementSubtraction: () => IfcFeatureElementSubtraction,
    IfcFillAreaStyle: () => IfcFillAreaStyle,
    IfcFillAreaStyleHatching: () => IfcFillAreaStyleHatching,
    IfcFillAreaStyleTiles: () => IfcFillAreaStyleTiles,
    IfcFilter: () => IfcFilter,
    IfcFilterType: () => IfcFilterType,
    IfcFilterTypeEnum: () => IfcFilterTypeEnum,
    IfcFireSuppressionTerminal: () => IfcFireSuppressionTerminal,
    IfcFireSuppressionTerminalType: () => IfcFireSuppressionTerminalType,
    IfcFireSuppressionTerminalTypeEnum: () => IfcFireSuppressionTerminalTypeEnum,
    IfcFixedReferenceSweptAreaSolid: () => IfcFixedReferenceSweptAreaSolid,
    IfcFlowController: () => IfcFlowController,
    IfcFlowControllerType: () => IfcFlowControllerType,
    IfcFlowDirectionEnum: () => IfcFlowDirectionEnum,
    IfcFlowFitting: () => IfcFlowFitting,
    IfcFlowFittingType: () => IfcFlowFittingType,
    IfcFlowInstrument: () => IfcFlowInstrument,
    IfcFlowInstrumentType: () => IfcFlowInstrumentType,
    IfcFlowInstrumentTypeEnum: () => IfcFlowInstrumentTypeEnum,
    IfcFlowMeter: () => IfcFlowMeter,
    IfcFlowMeterType: () => IfcFlowMeterType,
    IfcFlowMeterTypeEnum: () => IfcFlowMeterTypeEnum,
    IfcFlowMovingDevice: () => IfcFlowMovingDevice,
    IfcFlowMovingDeviceType: () => IfcFlowMovingDeviceType,
    IfcFlowSegment: () => IfcFlowSegment,
    IfcFlowSegmentType: () => IfcFlowSegmentType,
    IfcFlowStorageDevice: () => IfcFlowStorageDevice,
    IfcFlowStorageDeviceType: () => IfcFlowStorageDeviceType,
    IfcFlowTerminal: () => IfcFlowTerminal,
    IfcFlowTerminalType: () => IfcFlowTerminalType,
    IfcFlowTreatmentDevice: () => IfcFlowTreatmentDevice,
    IfcFlowTreatmentDeviceType: () => IfcFlowTreatmentDeviceType,
    IfcFontStyle: () => IfcFontStyle,
    IfcFontVariant: () => IfcFontVariant,
    IfcFontWeight: () => IfcFontWeight,
    IfcFooting: () => IfcFooting,
    IfcFootingType: () => IfcFootingType,
    IfcFootingTypeEnum: () => IfcFootingTypeEnum,
    IfcForceMeasure: () => IfcForceMeasure,
    IfcFrequencyMeasure: () => IfcFrequencyMeasure,
    IfcFurnishingElement: () => IfcFurnishingElement,
    IfcFurnishingElementType: () => IfcFurnishingElementType,
    IfcFurniture: () => IfcFurniture,
    IfcFurnitureType: () => IfcFurnitureType,
    IfcFurnitureTypeEnum: () => IfcFurnitureTypeEnum,
    IfcGeographicElement: () => IfcGeographicElement,
    IfcGeographicElementType: () => IfcGeographicElementType,
    IfcGeographicElementTypeEnum: () => IfcGeographicElementTypeEnum,
    IfcGeometricCurveSet: () => IfcGeometricCurveSet,
    IfcGeometricProjectionEnum: () => IfcGeometricProjectionEnum,
    IfcGeometricRepresentationContext: () => IfcGeometricRepresentationContext,
    IfcGeometricRepresentationItem: () => IfcGeometricRepresentationItem,
    IfcGeometricRepresentationSubContext: () => IfcGeometricRepresentationSubContext,
    IfcGeometricSet: () => IfcGeometricSet,
    IfcGlobalOrLocalEnum: () => IfcGlobalOrLocalEnum,
    IfcGloballyUniqueId: () => IfcGloballyUniqueId,
    IfcGrid: () => IfcGrid,
    IfcGridAxis: () => IfcGridAxis,
    IfcGridPlacement: () => IfcGridPlacement,
    IfcGridTypeEnum: () => IfcGridTypeEnum,
    IfcGroup: () => IfcGroup,
    IfcHalfSpaceSolid: () => IfcHalfSpaceSolid,
    IfcHeatExchanger: () => IfcHeatExchanger,
    IfcHeatExchangerType: () => IfcHeatExchangerType,
    IfcHeatExchangerTypeEnum: () => IfcHeatExchangerTypeEnum,
    IfcHeatFluxDensityMeasure: () => IfcHeatFluxDensityMeasure,
    IfcHeatingValueMeasure: () => IfcHeatingValueMeasure,
    IfcHumidifier: () => IfcHumidifier,
    IfcHumidifierType: () => IfcHumidifierType,
    IfcHumidifierTypeEnum: () => IfcHumidifierTypeEnum,
    IfcIShapeProfileDef: () => IfcIShapeProfileDef,
    IfcIdentifier: () => IfcIdentifier,
    IfcIlluminanceMeasure: () => IfcIlluminanceMeasure,
    IfcImageTexture: () => IfcImageTexture,
    IfcIndexedColourMap: () => IfcIndexedColourMap,
    IfcIndexedPolyCurve: () => IfcIndexedPolyCurve,
    IfcIndexedPolygonalFace: () => IfcIndexedPolygonalFace,
    IfcIndexedPolygonalFaceWithVoids: () => IfcIndexedPolygonalFaceWithVoids,
    IfcIndexedTextureMap: () => IfcIndexedTextureMap,
    IfcIndexedTriangleTextureMap: () => IfcIndexedTriangleTextureMap,
    IfcInductanceMeasure: () => IfcInductanceMeasure,
    IfcInteger: () => IfcInteger,
    IfcIntegerCountRateMeasure: () => IfcIntegerCountRateMeasure,
    IfcInterceptor: () => IfcInterceptor,
    IfcInterceptorType: () => IfcInterceptorType,
    IfcInterceptorTypeEnum: () => IfcInterceptorTypeEnum,
    IfcInternalOrExternalEnum: () => IfcInternalOrExternalEnum,
    IfcIntersectionCurve: () => IfcIntersectionCurve,
    IfcInventory: () => IfcInventory,
    IfcInventoryTypeEnum: () => IfcInventoryTypeEnum,
    IfcIonConcentrationMeasure: () => IfcIonConcentrationMeasure,
    IfcIrregularTimeSeries: () => IfcIrregularTimeSeries,
    IfcIrregularTimeSeriesValue: () => IfcIrregularTimeSeriesValue,
    IfcIsothermalMoistureCapacityMeasure: () => IfcIsothermalMoistureCapacityMeasure,
    IfcJunctionBox: () => IfcJunctionBox,
    IfcJunctionBoxType: () => IfcJunctionBoxType,
    IfcJunctionBoxTypeEnum: () => IfcJunctionBoxTypeEnum,
    IfcKinematicViscosityMeasure: () => IfcKinematicViscosityMeasure,
    IfcKnotType: () => IfcKnotType,
    IfcLShapeProfileDef: () => IfcLShapeProfileDef,
    IfcLabel: () => IfcLabel,
    IfcLaborResource: () => IfcLaborResource,
    IfcLaborResourceType: () => IfcLaborResourceType,
    IfcLaborResourceTypeEnum: () => IfcLaborResourceTypeEnum,
    IfcLagTime: () => IfcLagTime,
    IfcLamp: () => IfcLamp,
    IfcLampType: () => IfcLampType,
    IfcLampTypeEnum: () => IfcLampTypeEnum,
    IfcLanguageId: () => IfcLanguageId,
    IfcLayerSetDirectionEnum: () => IfcLayerSetDirectionEnum,
    IfcLengthMeasure: () => IfcLengthMeasure,
    IfcLibraryInformation: () => IfcLibraryInformation,
    IfcLibraryReference: () => IfcLibraryReference,
    IfcLightDistributionCurveEnum: () => IfcLightDistributionCurveEnum,
    IfcLightDistributionData: () => IfcLightDistributionData,
    IfcLightEmissionSourceEnum: () => IfcLightEmissionSourceEnum,
    IfcLightFixture: () => IfcLightFixture,
    IfcLightFixtureType: () => IfcLightFixtureType,
    IfcLightFixtureTypeEnum: () => IfcLightFixtureTypeEnum,
    IfcLightIntensityDistribution: () => IfcLightIntensityDistribution,
    IfcLightSource: () => IfcLightSource,
    IfcLightSourceAmbient: () => IfcLightSourceAmbient,
    IfcLightSourceDirectional: () => IfcLightSourceDirectional,
    IfcLightSourceGoniometric: () => IfcLightSourceGoniometric,
    IfcLightSourcePositional: () => IfcLightSourcePositional,
    IfcLightSourceSpot: () => IfcLightSourceSpot,
    IfcLine: () => IfcLine,
    IfcLineSegment2D: () => IfcLineSegment2D,
    IfcLinearForceMeasure: () => IfcLinearForceMeasure,
    IfcLinearMomentMeasure: () => IfcLinearMomentMeasure,
    IfcLinearPlacement: () => IfcLinearPlacement,
    IfcLinearPositioningElement: () => IfcLinearPositioningElement,
    IfcLinearStiffnessMeasure: () => IfcLinearStiffnessMeasure,
    IfcLinearVelocityMeasure: () => IfcLinearVelocityMeasure,
    IfcLoadGroupTypeEnum: () => IfcLoadGroupTypeEnum,
    IfcLocalPlacement: () => IfcLocalPlacement,
    IfcLogical: () => IfcLogical,
    IfcLogicalOperatorEnum: () => IfcLogicalOperatorEnum,
    IfcLoop: () => IfcLoop,
    IfcLuminousFluxMeasure: () => IfcLuminousFluxMeasure,
    IfcLuminousIntensityDistributionMeasure: () => IfcLuminousIntensityDistributionMeasure,
    IfcLuminousIntensityMeasure: () => IfcLuminousIntensityMeasure,
    IfcMagneticFluxDensityMeasure: () => IfcMagneticFluxDensityMeasure,
    IfcMagneticFluxMeasure: () => IfcMagneticFluxMeasure,
    IfcManifoldSolidBrep: () => IfcManifoldSolidBrep,
    IfcMapConversion: () => IfcMapConversion,
    IfcMappedItem: () => IfcMappedItem,
    IfcMassDensityMeasure: () => IfcMassDensityMeasure,
    IfcMassFlowRateMeasure: () => IfcMassFlowRateMeasure,
    IfcMassMeasure: () => IfcMassMeasure,
    IfcMassPerLengthMeasure: () => IfcMassPerLengthMeasure,
    IfcMaterial: () => IfcMaterial,
    IfcMaterialClassificationRelationship: () => IfcMaterialClassificationRelationship,
    IfcMaterialConstituent: () => IfcMaterialConstituent,
    IfcMaterialConstituentSet: () => IfcMaterialConstituentSet,
    IfcMaterialDefinition: () => IfcMaterialDefinition,
    IfcMaterialDefinitionRepresentation: () => IfcMaterialDefinitionRepresentation,
    IfcMaterialLayer: () => IfcMaterialLayer,
    IfcMaterialLayerSet: () => IfcMaterialLayerSet,
    IfcMaterialLayerSetUsage: () => IfcMaterialLayerSetUsage,
    IfcMaterialLayerWithOffsets: () => IfcMaterialLayerWithOffsets,
    IfcMaterialList: () => IfcMaterialList,
    IfcMaterialProfile: () => IfcMaterialProfile,
    IfcMaterialProfileSet: () => IfcMaterialProfileSet,
    IfcMaterialProfileSetUsage: () => IfcMaterialProfileSetUsage,
    IfcMaterialProfileSetUsageTapering: () => IfcMaterialProfileSetUsageTapering,
    IfcMaterialProfileWithOffsets: () => IfcMaterialProfileWithOffsets,
    IfcMaterialProperties: () => IfcMaterialProperties,
    IfcMaterialRelationship: () => IfcMaterialRelationship,
    IfcMaterialUsageDefinition: () => IfcMaterialUsageDefinition,
    IfcMeasureWithUnit: () => IfcMeasureWithUnit,
    IfcMechanicalFastener: () => IfcMechanicalFastener,
    IfcMechanicalFastenerType: () => IfcMechanicalFastenerType,
    IfcMechanicalFastenerTypeEnum: () => IfcMechanicalFastenerTypeEnum,
    IfcMedicalDevice: () => IfcMedicalDevice,
    IfcMedicalDeviceType: () => IfcMedicalDeviceType,
    IfcMedicalDeviceTypeEnum: () => IfcMedicalDeviceTypeEnum,
    IfcMember: () => IfcMember,
    IfcMemberStandardCase: () => IfcMemberStandardCase,
    IfcMemberType: () => IfcMemberType,
    IfcMemberTypeEnum: () => IfcMemberTypeEnum,
    IfcMetric: () => IfcMetric,
    IfcMirroredProfileDef: () => IfcMirroredProfileDef,
    IfcModulusOfElasticityMeasure: () => IfcModulusOfElasticityMeasure,
    IfcModulusOfLinearSubgradeReactionMeasure: () => IfcModulusOfLinearSubgradeReactionMeasure,
    IfcModulusOfRotationalSubgradeReactionMeasure: () => IfcModulusOfRotationalSubgradeReactionMeasure,
    IfcModulusOfSubgradeReactionMeasure: () => IfcModulusOfSubgradeReactionMeasure,
    IfcMoistureDiffusivityMeasure: () => IfcMoistureDiffusivityMeasure,
    IfcMolecularWeightMeasure: () => IfcMolecularWeightMeasure,
    IfcMomentOfInertiaMeasure: () => IfcMomentOfInertiaMeasure,
    IfcMonetaryMeasure: () => IfcMonetaryMeasure,
    IfcMonetaryUnit: () => IfcMonetaryUnit,
    IfcMonthInYearNumber: () => IfcMonthInYearNumber,
    IfcMotorConnection: () => IfcMotorConnection,
    IfcMotorConnectionType: () => IfcMotorConnectionType,
    IfcMotorConnectionTypeEnum: () => IfcMotorConnectionTypeEnum,
    IfcNamedUnit: () => IfcNamedUnit,
    IfcNonNegativeLengthMeasure: () => IfcNonNegativeLengthMeasure,
    IfcNormalisedRatioMeasure: () => IfcNormalisedRatioMeasure,
    IfcNullStyle: () => IfcNullStyle,
    IfcNumericMeasure: () => IfcNumericMeasure,
    IfcObject: () => IfcObject,
    IfcObjectDefinition: () => IfcObjectDefinition,
    IfcObjectPlacement: () => IfcObjectPlacement,
    IfcObjectTypeEnum: () => IfcObjectTypeEnum,
    IfcObjective: () => IfcObjective,
    IfcObjectiveEnum: () => IfcObjectiveEnum,
    IfcOccupant: () => IfcOccupant,
    IfcOccupantTypeEnum: () => IfcOccupantTypeEnum,
    IfcOffsetCurve: () => IfcOffsetCurve,
    IfcOffsetCurve2D: () => IfcOffsetCurve2D,
    IfcOffsetCurve3D: () => IfcOffsetCurve3D,
    IfcOffsetCurveByDistances: () => IfcOffsetCurveByDistances,
    IfcOpenShell: () => IfcOpenShell,
    IfcOpeningElement: () => IfcOpeningElement,
    IfcOpeningElementTypeEnum: () => IfcOpeningElementTypeEnum,
    IfcOpeningStandardCase: () => IfcOpeningStandardCase,
    IfcOrganization: () => IfcOrganization,
    IfcOrganizationRelationship: () => IfcOrganizationRelationship,
    IfcOrientationExpression: () => IfcOrientationExpression,
    IfcOrientedEdge: () => IfcOrientedEdge,
    IfcOuterBoundaryCurve: () => IfcOuterBoundaryCurve,
    IfcOutlet: () => IfcOutlet,
    IfcOutletType: () => IfcOutletType,
    IfcOutletTypeEnum: () => IfcOutletTypeEnum,
    IfcOwnerHistory: () => IfcOwnerHistory,
    IfcPHMeasure: () => IfcPHMeasure,
    IfcParameterValue: () => IfcParameterValue,
    IfcParameterizedProfileDef: () => IfcParameterizedProfileDef,
    IfcPath: () => IfcPath,
    IfcPcurve: () => IfcPcurve,
    IfcPerformanceHistory: () => IfcPerformanceHistory,
    IfcPerformanceHistoryTypeEnum: () => IfcPerformanceHistoryTypeEnum,
    IfcPermeableCoveringOperationEnum: () => IfcPermeableCoveringOperationEnum,
    IfcPermeableCoveringProperties: () => IfcPermeableCoveringProperties,
    IfcPermit: () => IfcPermit,
    IfcPermitTypeEnum: () => IfcPermitTypeEnum,
    IfcPerson: () => IfcPerson,
    IfcPersonAndOrganization: () => IfcPersonAndOrganization,
    IfcPhysicalComplexQuantity: () => IfcPhysicalComplexQuantity,
    IfcPhysicalOrVirtualEnum: () => IfcPhysicalOrVirtualEnum,
    IfcPhysicalQuantity: () => IfcPhysicalQuantity,
    IfcPhysicalSimpleQuantity: () => IfcPhysicalSimpleQuantity,
    IfcPile: () => IfcPile,
    IfcPileConstructionEnum: () => IfcPileConstructionEnum,
    IfcPileType: () => IfcPileType,
    IfcPileTypeEnum: () => IfcPileTypeEnum,
    IfcPipeFitting: () => IfcPipeFitting,
    IfcPipeFittingType: () => IfcPipeFittingType,
    IfcPipeFittingTypeEnum: () => IfcPipeFittingTypeEnum,
    IfcPipeSegment: () => IfcPipeSegment,
    IfcPipeSegmentType: () => IfcPipeSegmentType,
    IfcPipeSegmentTypeEnum: () => IfcPipeSegmentTypeEnum,
    IfcPixelTexture: () => IfcPixelTexture,
    IfcPlacement: () => IfcPlacement,
    IfcPlanarBox: () => IfcPlanarBox,
    IfcPlanarExtent: () => IfcPlanarExtent,
    IfcPlanarForceMeasure: () => IfcPlanarForceMeasure,
    IfcPlane: () => IfcPlane,
    IfcPlaneAngleMeasure: () => IfcPlaneAngleMeasure,
    IfcPlate: () => IfcPlate,
    IfcPlateStandardCase: () => IfcPlateStandardCase,
    IfcPlateType: () => IfcPlateType,
    IfcPlateTypeEnum: () => IfcPlateTypeEnum,
    IfcPoint: () => IfcPoint,
    IfcPointOnCurve: () => IfcPointOnCurve,
    IfcPointOnSurface: () => IfcPointOnSurface,
    IfcPolyLoop: () => IfcPolyLoop,
    IfcPolygonalBoundedHalfSpace: () => IfcPolygonalBoundedHalfSpace,
    IfcPolygonalFaceSet: () => IfcPolygonalFaceSet,
    IfcPolyline: () => IfcPolyline,
    IfcPort: () => IfcPort,
    IfcPositioningElement: () => IfcPositioningElement,
    IfcPositiveInteger: () => IfcPositiveInteger,
    IfcPositiveLengthMeasure: () => IfcPositiveLengthMeasure,
    IfcPositivePlaneAngleMeasure: () => IfcPositivePlaneAngleMeasure,
    IfcPositiveRatioMeasure: () => IfcPositiveRatioMeasure,
    IfcPostalAddress: () => IfcPostalAddress,
    IfcPowerMeasure: () => IfcPowerMeasure,
    IfcPreDefinedColour: () => IfcPreDefinedColour,
    IfcPreDefinedCurveFont: () => IfcPreDefinedCurveFont,
    IfcPreDefinedItem: () => IfcPreDefinedItem,
    IfcPreDefinedProperties: () => IfcPreDefinedProperties,
    IfcPreDefinedPropertySet: () => IfcPreDefinedPropertySet,
    IfcPreDefinedTextFont: () => IfcPreDefinedTextFont,
    IfcPreferredSurfaceCurveRepresentation: () => IfcPreferredSurfaceCurveRepresentation,
    IfcPresentableText: () => IfcPresentableText,
    IfcPresentationItem: () => IfcPresentationItem,
    IfcPresentationLayerAssignment: () => IfcPresentationLayerAssignment,
    IfcPresentationLayerWithStyle: () => IfcPresentationLayerWithStyle,
    IfcPresentationStyle: () => IfcPresentationStyle,
    IfcPresentationStyleAssignment: () => IfcPresentationStyleAssignment,
    IfcPressureMeasure: () => IfcPressureMeasure,
    IfcProcedure: () => IfcProcedure,
    IfcProcedureType: () => IfcProcedureType,
    IfcProcedureTypeEnum: () => IfcProcedureTypeEnum,
    IfcProcess: () => IfcProcess,
    IfcProduct: () => IfcProduct,
    IfcProductDefinitionShape: () => IfcProductDefinitionShape,
    IfcProductRepresentation: () => IfcProductRepresentation,
    IfcProfileDef: () => IfcProfileDef,
    IfcProfileProperties: () => IfcProfileProperties,
    IfcProfileTypeEnum: () => IfcProfileTypeEnum,
    IfcProject: () => IfcProject,
    IfcProjectLibrary: () => IfcProjectLibrary,
    IfcProjectOrder: () => IfcProjectOrder,
    IfcProjectOrderTypeEnum: () => IfcProjectOrderTypeEnum,
    IfcProjectedCRS: () => IfcProjectedCRS,
    IfcProjectedOrTrueLengthEnum: () => IfcProjectedOrTrueLengthEnum,
    IfcProjectionElement: () => IfcProjectionElement,
    IfcProjectionElementTypeEnum: () => IfcProjectionElementTypeEnum,
    IfcProperty: () => IfcProperty,
    IfcPropertyAbstraction: () => IfcPropertyAbstraction,
    IfcPropertyBoundedValue: () => IfcPropertyBoundedValue,
    IfcPropertyDefinition: () => IfcPropertyDefinition,
    IfcPropertyDependencyRelationship: () => IfcPropertyDependencyRelationship,
    IfcPropertyEnumeratedValue: () => IfcPropertyEnumeratedValue,
    IfcPropertyEnumeration: () => IfcPropertyEnumeration,
    IfcPropertyListValue: () => IfcPropertyListValue,
    IfcPropertyReferenceValue: () => IfcPropertyReferenceValue,
    IfcPropertySet: () => IfcPropertySet,
    IfcPropertySetDefinition: () => IfcPropertySetDefinition,
    IfcPropertySetTemplate: () => IfcPropertySetTemplate,
    IfcPropertySetTemplateTypeEnum: () => IfcPropertySetTemplateTypeEnum,
    IfcPropertySingleValue: () => IfcPropertySingleValue,
    IfcPropertyTableValue: () => IfcPropertyTableValue,
    IfcPropertyTemplate: () => IfcPropertyTemplate,
    IfcPropertyTemplateDefinition: () => IfcPropertyTemplateDefinition,
    IfcProtectiveDevice: () => IfcProtectiveDevice,
    IfcProtectiveDeviceTrippingUnit: () => IfcProtectiveDeviceTrippingUnit,
    IfcProtectiveDeviceTrippingUnitType: () => IfcProtectiveDeviceTrippingUnitType,
    IfcProtectiveDeviceTrippingUnitTypeEnum: () => IfcProtectiveDeviceTrippingUnitTypeEnum,
    IfcProtectiveDeviceType: () => IfcProtectiveDeviceType,
    IfcProtectiveDeviceTypeEnum: () => IfcProtectiveDeviceTypeEnum,
    IfcProxy: () => IfcProxy,
    IfcPump: () => IfcPump,
    IfcPumpType: () => IfcPumpType,
    IfcPumpTypeEnum: () => IfcPumpTypeEnum,
    IfcQuantityArea: () => IfcQuantityArea,
    IfcQuantityCount: () => IfcQuantityCount,
    IfcQuantityLength: () => IfcQuantityLength,
    IfcQuantitySet: () => IfcQuantitySet,
    IfcQuantityTime: () => IfcQuantityTime,
    IfcQuantityVolume: () => IfcQuantityVolume,
    IfcQuantityWeight: () => IfcQuantityWeight,
    IfcRadioActivityMeasure: () => IfcRadioActivityMeasure,
    IfcRailing: () => IfcRailing,
    IfcRailingType: () => IfcRailingType,
    IfcRailingTypeEnum: () => IfcRailingTypeEnum,
    IfcRamp: () => IfcRamp,
    IfcRampFlight: () => IfcRampFlight,
    IfcRampFlightType: () => IfcRampFlightType,
    IfcRampFlightTypeEnum: () => IfcRampFlightTypeEnum,
    IfcRampType: () => IfcRampType,
    IfcRampTypeEnum: () => IfcRampTypeEnum,
    IfcRatioMeasure: () => IfcRatioMeasure,
    IfcRationalBSplineCurveWithKnots: () => IfcRationalBSplineCurveWithKnots,
    IfcRationalBSplineSurfaceWithKnots: () => IfcRationalBSplineSurfaceWithKnots,
    IfcReal: () => IfcReal,
    IfcRectangleHollowProfileDef: () => IfcRectangleHollowProfileDef,
    IfcRectangleProfileDef: () => IfcRectangleProfileDef,
    IfcRectangularPyramid: () => IfcRectangularPyramid,
    IfcRectangularTrimmedSurface: () => IfcRectangularTrimmedSurface,
    IfcRecurrencePattern: () => IfcRecurrencePattern,
    IfcRecurrenceTypeEnum: () => IfcRecurrenceTypeEnum,
    IfcReference: () => IfcReference,
    IfcReferent: () => IfcReferent,
    IfcReferentTypeEnum: () => IfcReferentTypeEnum,
    IfcReflectanceMethodEnum: () => IfcReflectanceMethodEnum,
    IfcRegularTimeSeries: () => IfcRegularTimeSeries,
    IfcReinforcementBarProperties: () => IfcReinforcementBarProperties,
    IfcReinforcementDefinitionProperties: () => IfcReinforcementDefinitionProperties,
    IfcReinforcingBar: () => IfcReinforcingBar,
    IfcReinforcingBarRoleEnum: () => IfcReinforcingBarRoleEnum,
    IfcReinforcingBarSurfaceEnum: () => IfcReinforcingBarSurfaceEnum,
    IfcReinforcingBarType: () => IfcReinforcingBarType,
    IfcReinforcingBarTypeEnum: () => IfcReinforcingBarTypeEnum,
    IfcReinforcingElement: () => IfcReinforcingElement,
    IfcReinforcingElementType: () => IfcReinforcingElementType,
    IfcReinforcingMesh: () => IfcReinforcingMesh,
    IfcReinforcingMeshType: () => IfcReinforcingMeshType,
    IfcReinforcingMeshTypeEnum: () => IfcReinforcingMeshTypeEnum,
    IfcRelAggregates: () => IfcRelAggregates,
    IfcRelAssigns: () => IfcRelAssigns,
    IfcRelAssignsToActor: () => IfcRelAssignsToActor,
    IfcRelAssignsToControl: () => IfcRelAssignsToControl,
    IfcRelAssignsToGroup: () => IfcRelAssignsToGroup,
    IfcRelAssignsToGroupByFactor: () => IfcRelAssignsToGroupByFactor,
    IfcRelAssignsToProcess: () => IfcRelAssignsToProcess,
    IfcRelAssignsToProduct: () => IfcRelAssignsToProduct,
    IfcRelAssignsToResource: () => IfcRelAssignsToResource,
    IfcRelAssociates: () => IfcRelAssociates,
    IfcRelAssociatesApproval: () => IfcRelAssociatesApproval,
    IfcRelAssociatesClassification: () => IfcRelAssociatesClassification,
    IfcRelAssociatesConstraint: () => IfcRelAssociatesConstraint,
    IfcRelAssociatesDocument: () => IfcRelAssociatesDocument,
    IfcRelAssociatesLibrary: () => IfcRelAssociatesLibrary,
    IfcRelAssociatesMaterial: () => IfcRelAssociatesMaterial,
    IfcRelConnects: () => IfcRelConnects,
    IfcRelConnectsElements: () => IfcRelConnectsElements,
    IfcRelConnectsPathElements: () => IfcRelConnectsPathElements,
    IfcRelConnectsPortToElement: () => IfcRelConnectsPortToElement,
    IfcRelConnectsPorts: () => IfcRelConnectsPorts,
    IfcRelConnectsStructuralActivity: () => IfcRelConnectsStructuralActivity,
    IfcRelConnectsStructuralMember: () => IfcRelConnectsStructuralMember,
    IfcRelConnectsWithEccentricity: () => IfcRelConnectsWithEccentricity,
    IfcRelConnectsWithRealizingElements: () => IfcRelConnectsWithRealizingElements,
    IfcRelContainedInSpatialStructure: () => IfcRelContainedInSpatialStructure,
    IfcRelCoversBldgElements: () => IfcRelCoversBldgElements,
    IfcRelCoversSpaces: () => IfcRelCoversSpaces,
    IfcRelDeclares: () => IfcRelDeclares,
    IfcRelDecomposes: () => IfcRelDecomposes,
    IfcRelDefines: () => IfcRelDefines,
    IfcRelDefinesByObject: () => IfcRelDefinesByObject,
    IfcRelDefinesByProperties: () => IfcRelDefinesByProperties,
    IfcRelDefinesByTemplate: () => IfcRelDefinesByTemplate,
    IfcRelDefinesByType: () => IfcRelDefinesByType,
    IfcRelFillsElement: () => IfcRelFillsElement,
    IfcRelFlowControlElements: () => IfcRelFlowControlElements,
    IfcRelInterferesElements: () => IfcRelInterferesElements,
    IfcRelNests: () => IfcRelNests,
    IfcRelPositions: () => IfcRelPositions,
    IfcRelProjectsElement: () => IfcRelProjectsElement,
    IfcRelReferencedInSpatialStructure: () => IfcRelReferencedInSpatialStructure,
    IfcRelSequence: () => IfcRelSequence,
    IfcRelServicesBuildings: () => IfcRelServicesBuildings,
    IfcRelSpaceBoundary: () => IfcRelSpaceBoundary,
    IfcRelSpaceBoundary1stLevel: () => IfcRelSpaceBoundary1stLevel,
    IfcRelSpaceBoundary2ndLevel: () => IfcRelSpaceBoundary2ndLevel,
    IfcRelVoidsElement: () => IfcRelVoidsElement,
    IfcRelationship: () => IfcRelationship,
    IfcReparametrisedCompositeCurveSegment: () => IfcReparametrisedCompositeCurveSegment,
    IfcRepresentation: () => IfcRepresentation,
    IfcRepresentationContext: () => IfcRepresentationContext,
    IfcRepresentationItem: () => IfcRepresentationItem,
    IfcRepresentationMap: () => IfcRepresentationMap,
    IfcResource: () => IfcResource,
    IfcResourceApprovalRelationship: () => IfcResourceApprovalRelationship,
    IfcResourceConstraintRelationship: () => IfcResourceConstraintRelationship,
    IfcResourceLevelRelationship: () => IfcResourceLevelRelationship,
    IfcResourceTime: () => IfcResourceTime,
    IfcRevolvedAreaSolid: () => IfcRevolvedAreaSolid,
    IfcRevolvedAreaSolidTapered: () => IfcRevolvedAreaSolidTapered,
    IfcRightCircularCone: () => IfcRightCircularCone,
    IfcRightCircularCylinder: () => IfcRightCircularCylinder,
    IfcRoleEnum: () => IfcRoleEnum,
    IfcRoof: () => IfcRoof,
    IfcRoofType: () => IfcRoofType,
    IfcRoofTypeEnum: () => IfcRoofTypeEnum,
    IfcRoot: () => IfcRoot,
    IfcRotationalFrequencyMeasure: () => IfcRotationalFrequencyMeasure,
    IfcRotationalMassMeasure: () => IfcRotationalMassMeasure,
    IfcRotationalStiffnessMeasure: () => IfcRotationalStiffnessMeasure,
    IfcRoundedRectangleProfileDef: () => IfcRoundedRectangleProfileDef,
    IfcSIPrefix: () => IfcSIPrefix,
    IfcSIUnit: () => IfcSIUnit,
    IfcSIUnitName: () => IfcSIUnitName,
    IfcSanitaryTerminal: () => IfcSanitaryTerminal,
    IfcSanitaryTerminalType: () => IfcSanitaryTerminalType,
    IfcSanitaryTerminalTypeEnum: () => IfcSanitaryTerminalTypeEnum,
    IfcSchedulingTime: () => IfcSchedulingTime,
    IfcSeamCurve: () => IfcSeamCurve,
    IfcSectionModulusMeasure: () => IfcSectionModulusMeasure,
    IfcSectionProperties: () => IfcSectionProperties,
    IfcSectionReinforcementProperties: () => IfcSectionReinforcementProperties,
    IfcSectionTypeEnum: () => IfcSectionTypeEnum,
    IfcSectionalAreaIntegralMeasure: () => IfcSectionalAreaIntegralMeasure,
    IfcSectionedSolid: () => IfcSectionedSolid,
    IfcSectionedSolidHorizontal: () => IfcSectionedSolidHorizontal,
    IfcSectionedSpine: () => IfcSectionedSpine,
    IfcSensor: () => IfcSensor,
    IfcSensorType: () => IfcSensorType,
    IfcSensorTypeEnum: () => IfcSensorTypeEnum,
    IfcSequenceEnum: () => IfcSequenceEnum,
    IfcShadingDevice: () => IfcShadingDevice,
    IfcShadingDeviceType: () => IfcShadingDeviceType,
    IfcShadingDeviceTypeEnum: () => IfcShadingDeviceTypeEnum,
    IfcShapeAspect: () => IfcShapeAspect,
    IfcShapeModel: () => IfcShapeModel,
    IfcShapeRepresentation: () => IfcShapeRepresentation,
    IfcShearModulusMeasure: () => IfcShearModulusMeasure,
    IfcShellBasedSurfaceModel: () => IfcShellBasedSurfaceModel,
    IfcSimpleProperty: () => IfcSimpleProperty,
    IfcSimplePropertyTemplate: () => IfcSimplePropertyTemplate,
    IfcSimplePropertyTemplateTypeEnum: () => IfcSimplePropertyTemplateTypeEnum,
    IfcSite: () => IfcSite,
    IfcSlab: () => IfcSlab,
    IfcSlabElementedCase: () => IfcSlabElementedCase,
    IfcSlabStandardCase: () => IfcSlabStandardCase,
    IfcSlabType: () => IfcSlabType,
    IfcSlabTypeEnum: () => IfcSlabTypeEnum,
    IfcSlippageConnectionCondition: () => IfcSlippageConnectionCondition,
    IfcSolarDevice: () => IfcSolarDevice,
    IfcSolarDeviceType: () => IfcSolarDeviceType,
    IfcSolarDeviceTypeEnum: () => IfcSolarDeviceTypeEnum,
    IfcSolidAngleMeasure: () => IfcSolidAngleMeasure,
    IfcSolidModel: () => IfcSolidModel,
    IfcSoundPowerLevelMeasure: () => IfcSoundPowerLevelMeasure,
    IfcSoundPowerMeasure: () => IfcSoundPowerMeasure,
    IfcSoundPressureLevelMeasure: () => IfcSoundPressureLevelMeasure,
    IfcSoundPressureMeasure: () => IfcSoundPressureMeasure,
    IfcSpace: () => IfcSpace,
    IfcSpaceHeater: () => IfcSpaceHeater,
    IfcSpaceHeaterType: () => IfcSpaceHeaterType,
    IfcSpaceHeaterTypeEnum: () => IfcSpaceHeaterTypeEnum,
    IfcSpaceType: () => IfcSpaceType,
    IfcSpaceTypeEnum: () => IfcSpaceTypeEnum,
    IfcSpatialElement: () => IfcSpatialElement,
    IfcSpatialElementType: () => IfcSpatialElementType,
    IfcSpatialStructureElement: () => IfcSpatialStructureElement,
    IfcSpatialStructureElementType: () => IfcSpatialStructureElementType,
    IfcSpatialZone: () => IfcSpatialZone,
    IfcSpatialZoneType: () => IfcSpatialZoneType,
    IfcSpatialZoneTypeEnum: () => IfcSpatialZoneTypeEnum,
    IfcSpecificHeatCapacityMeasure: () => IfcSpecificHeatCapacityMeasure,
    IfcSpecularExponent: () => IfcSpecularExponent,
    IfcSpecularRoughness: () => IfcSpecularRoughness,
    IfcSphere: () => IfcSphere,
    IfcSphericalSurface: () => IfcSphericalSurface,
    IfcStackTerminal: () => IfcStackTerminal,
    IfcStackTerminalType: () => IfcStackTerminalType,
    IfcStackTerminalTypeEnum: () => IfcStackTerminalTypeEnum,
    IfcStair: () => IfcStair,
    IfcStairFlight: () => IfcStairFlight,
    IfcStairFlightType: () => IfcStairFlightType,
    IfcStairFlightTypeEnum: () => IfcStairFlightTypeEnum,
    IfcStairType: () => IfcStairType,
    IfcStairTypeEnum: () => IfcStairTypeEnum,
    IfcStateEnum: () => IfcStateEnum,
    IfcStructuralAction: () => IfcStructuralAction,
    IfcStructuralActivity: () => IfcStructuralActivity,
    IfcStructuralAnalysisModel: () => IfcStructuralAnalysisModel,
    IfcStructuralConnection: () => IfcStructuralConnection,
    IfcStructuralConnectionCondition: () => IfcStructuralConnectionCondition,
    IfcStructuralCurveAction: () => IfcStructuralCurveAction,
    IfcStructuralCurveActivityTypeEnum: () => IfcStructuralCurveActivityTypeEnum,
    IfcStructuralCurveConnection: () => IfcStructuralCurveConnection,
    IfcStructuralCurveMember: () => IfcStructuralCurveMember,
    IfcStructuralCurveMemberTypeEnum: () => IfcStructuralCurveMemberTypeEnum,
    IfcStructuralCurveMemberVarying: () => IfcStructuralCurveMemberVarying,
    IfcStructuralCurveReaction: () => IfcStructuralCurveReaction,
    IfcStructuralItem: () => IfcStructuralItem,
    IfcStructuralLinearAction: () => IfcStructuralLinearAction,
    IfcStructuralLoad: () => IfcStructuralLoad,
    IfcStructuralLoadCase: () => IfcStructuralLoadCase,
    IfcStructuralLoadConfiguration: () => IfcStructuralLoadConfiguration,
    IfcStructuralLoadGroup: () => IfcStructuralLoadGroup,
    IfcStructuralLoadLinearForce: () => IfcStructuralLoadLinearForce,
    IfcStructuralLoadOrResult: () => IfcStructuralLoadOrResult,
    IfcStructuralLoadPlanarForce: () => IfcStructuralLoadPlanarForce,
    IfcStructuralLoadSingleDisplacement: () => IfcStructuralLoadSingleDisplacement,
    IfcStructuralLoadSingleDisplacementDistortion: () => IfcStructuralLoadSingleDisplacementDistortion,
    IfcStructuralLoadSingleForce: () => IfcStructuralLoadSingleForce,
    IfcStructuralLoadSingleForceWarping: () => IfcStructuralLoadSingleForceWarping,
    IfcStructuralLoadStatic: () => IfcStructuralLoadStatic,
    IfcStructuralLoadTemperature: () => IfcStructuralLoadTemperature,
    IfcStructuralMember: () => IfcStructuralMember,
    IfcStructuralPlanarAction: () => IfcStructuralPlanarAction,
    IfcStructuralPointAction: () => IfcStructuralPointAction,
    IfcStructuralPointConnection: () => IfcStructuralPointConnection,
    IfcStructuralPointReaction: () => IfcStructuralPointReaction,
    IfcStructuralReaction: () => IfcStructuralReaction,
    IfcStructuralResultGroup: () => IfcStructuralResultGroup,
    IfcStructuralSurfaceAction: () => IfcStructuralSurfaceAction,
    IfcStructuralSurfaceActivityTypeEnum: () => IfcStructuralSurfaceActivityTypeEnum,
    IfcStructuralSurfaceConnection: () => IfcStructuralSurfaceConnection,
    IfcStructuralSurfaceMember: () => IfcStructuralSurfaceMember,
    IfcStructuralSurfaceMemberTypeEnum: () => IfcStructuralSurfaceMemberTypeEnum,
    IfcStructuralSurfaceMemberVarying: () => IfcStructuralSurfaceMemberVarying,
    IfcStructuralSurfaceReaction: () => IfcStructuralSurfaceReaction,
    IfcStyleModel: () => IfcStyleModel,
    IfcStyledItem: () => IfcStyledItem,
    IfcStyledRepresentation: () => IfcStyledRepresentation,
    IfcSubContractResource: () => IfcSubContractResource,
    IfcSubContractResourceType: () => IfcSubContractResourceType,
    IfcSubContractResourceTypeEnum: () => IfcSubContractResourceTypeEnum,
    IfcSubedge: () => IfcSubedge,
    IfcSurface: () => IfcSurface,
    IfcSurfaceCurve: () => IfcSurfaceCurve,
    IfcSurfaceCurveSweptAreaSolid: () => IfcSurfaceCurveSweptAreaSolid,
    IfcSurfaceFeature: () => IfcSurfaceFeature,
    IfcSurfaceFeatureTypeEnum: () => IfcSurfaceFeatureTypeEnum,
    IfcSurfaceOfLinearExtrusion: () => IfcSurfaceOfLinearExtrusion,
    IfcSurfaceOfRevolution: () => IfcSurfaceOfRevolution,
    IfcSurfaceReinforcementArea: () => IfcSurfaceReinforcementArea,
    IfcSurfaceSide: () => IfcSurfaceSide,
    IfcSurfaceStyle: () => IfcSurfaceStyle,
    IfcSurfaceStyleLighting: () => IfcSurfaceStyleLighting,
    IfcSurfaceStyleRefraction: () => IfcSurfaceStyleRefraction,
    IfcSurfaceStyleRendering: () => IfcSurfaceStyleRendering,
    IfcSurfaceStyleShading: () => IfcSurfaceStyleShading,
    IfcSurfaceStyleWithTextures: () => IfcSurfaceStyleWithTextures,
    IfcSurfaceTexture: () => IfcSurfaceTexture,
    IfcSweptAreaSolid: () => IfcSweptAreaSolid,
    IfcSweptDiskSolid: () => IfcSweptDiskSolid,
    IfcSweptDiskSolidPolygonal: () => IfcSweptDiskSolidPolygonal,
    IfcSweptSurface: () => IfcSweptSurface,
    IfcSwitchingDevice: () => IfcSwitchingDevice,
    IfcSwitchingDeviceType: () => IfcSwitchingDeviceType,
    IfcSwitchingDeviceTypeEnum: () => IfcSwitchingDeviceTypeEnum,
    IfcSystem: () => IfcSystem,
    IfcSystemFurnitureElement: () => IfcSystemFurnitureElement,
    IfcSystemFurnitureElementType: () => IfcSystemFurnitureElementType,
    IfcSystemFurnitureElementTypeEnum: () => IfcSystemFurnitureElementTypeEnum,
    IfcTShapeProfileDef: () => IfcTShapeProfileDef,
    IfcTable: () => IfcTable,
    IfcTableColumn: () => IfcTableColumn,
    IfcTableRow: () => IfcTableRow,
    IfcTank: () => IfcTank,
    IfcTankType: () => IfcTankType,
    IfcTankTypeEnum: () => IfcTankTypeEnum,
    IfcTask: () => IfcTask,
    IfcTaskDurationEnum: () => IfcTaskDurationEnum,
    IfcTaskTime: () => IfcTaskTime,
    IfcTaskTimeRecurring: () => IfcTaskTimeRecurring,
    IfcTaskType: () => IfcTaskType,
    IfcTaskTypeEnum: () => IfcTaskTypeEnum,
    IfcTelecomAddress: () => IfcTelecomAddress,
    IfcTemperatureGradientMeasure: () => IfcTemperatureGradientMeasure,
    IfcTemperatureRateOfChangeMeasure: () => IfcTemperatureRateOfChangeMeasure,
    IfcTendon: () => IfcTendon,
    IfcTendonAnchor: () => IfcTendonAnchor,
    IfcTendonAnchorType: () => IfcTendonAnchorType,
    IfcTendonAnchorTypeEnum: () => IfcTendonAnchorTypeEnum,
    IfcTendonConduit: () => IfcTendonConduit,
    IfcTendonConduitType: () => IfcTendonConduitType,
    IfcTendonConduitTypeEnum: () => IfcTendonConduitTypeEnum,
    IfcTendonType: () => IfcTendonType,
    IfcTendonTypeEnum: () => IfcTendonTypeEnum,
    IfcTessellatedFaceSet: () => IfcTessellatedFaceSet,
    IfcTessellatedItem: () => IfcTessellatedItem,
    IfcText: () => IfcText,
    IfcTextAlignment: () => IfcTextAlignment,
    IfcTextDecoration: () => IfcTextDecoration,
    IfcTextFontName: () => IfcTextFontName,
    IfcTextLiteral: () => IfcTextLiteral,
    IfcTextLiteralWithExtent: () => IfcTextLiteralWithExtent,
    IfcTextPath: () => IfcTextPath,
    IfcTextStyle: () => IfcTextStyle,
    IfcTextStyleFontModel: () => IfcTextStyleFontModel,
    IfcTextStyleForDefinedFont: () => IfcTextStyleForDefinedFont,
    IfcTextStyleTextModel: () => IfcTextStyleTextModel,
    IfcTextTransformation: () => IfcTextTransformation,
    IfcTextureCoordinate: () => IfcTextureCoordinate,
    IfcTextureCoordinateGenerator: () => IfcTextureCoordinateGenerator,
    IfcTextureMap: () => IfcTextureMap,
    IfcTextureVertex: () => IfcTextureVertex,
    IfcTextureVertexList: () => IfcTextureVertexList,
    IfcThermalAdmittanceMeasure: () => IfcThermalAdmittanceMeasure,
    IfcThermalConductivityMeasure: () => IfcThermalConductivityMeasure,
    IfcThermalExpansionCoefficientMeasure: () => IfcThermalExpansionCoefficientMeasure,
    IfcThermalResistanceMeasure: () => IfcThermalResistanceMeasure,
    IfcThermalTransmittanceMeasure: () => IfcThermalTransmittanceMeasure,
    IfcThermodynamicTemperatureMeasure: () => IfcThermodynamicTemperatureMeasure,
    IfcTime: () => IfcTime,
    IfcTimeMeasure: () => IfcTimeMeasure,
    IfcTimePeriod: () => IfcTimePeriod,
    IfcTimeSeries: () => IfcTimeSeries,
    IfcTimeSeriesDataTypeEnum: () => IfcTimeSeriesDataTypeEnum,
    IfcTimeSeriesValue: () => IfcTimeSeriesValue,
    IfcTimeStamp: () => IfcTimeStamp,
    IfcTopologicalRepresentationItem: () => IfcTopologicalRepresentationItem,
    IfcTopologyRepresentation: () => IfcTopologyRepresentation,
    IfcToroidalSurface: () => IfcToroidalSurface,
    IfcTorqueMeasure: () => IfcTorqueMeasure,
    IfcTransformer: () => IfcTransformer,
    IfcTransformerType: () => IfcTransformerType,
    IfcTransformerTypeEnum: () => IfcTransformerTypeEnum,
    IfcTransitionCode: () => IfcTransitionCode,
    IfcTransitionCurveSegment2D: () => IfcTransitionCurveSegment2D,
    IfcTransitionCurveType: () => IfcTransitionCurveType,
    IfcTransportElement: () => IfcTransportElement,
    IfcTransportElementType: () => IfcTransportElementType,
    IfcTransportElementTypeEnum: () => IfcTransportElementTypeEnum,
    IfcTrapeziumProfileDef: () => IfcTrapeziumProfileDef,
    IfcTriangulatedFaceSet: () => IfcTriangulatedFaceSet,
    IfcTriangulatedIrregularNetwork: () => IfcTriangulatedIrregularNetwork,
    IfcTrimmedCurve: () => IfcTrimmedCurve,
    IfcTrimmingPreference: () => IfcTrimmingPreference,
    IfcTubeBundle: () => IfcTubeBundle,
    IfcTubeBundleType: () => IfcTubeBundleType,
    IfcTubeBundleTypeEnum: () => IfcTubeBundleTypeEnum,
    IfcTypeObject: () => IfcTypeObject,
    IfcTypeProcess: () => IfcTypeProcess,
    IfcTypeProduct: () => IfcTypeProduct,
    IfcTypeResource: () => IfcTypeResource,
    IfcURIReference: () => IfcURIReference,
    IfcUShapeProfileDef: () => IfcUShapeProfileDef,
    IfcUnitAssignment: () => IfcUnitAssignment,
    IfcUnitEnum: () => IfcUnitEnum,
    IfcUnitaryControlElement: () => IfcUnitaryControlElement,
    IfcUnitaryControlElementType: () => IfcUnitaryControlElementType,
    IfcUnitaryControlElementTypeEnum: () => IfcUnitaryControlElementTypeEnum,
    IfcUnitaryEquipment: () => IfcUnitaryEquipment,
    IfcUnitaryEquipmentType: () => IfcUnitaryEquipmentType,
    IfcUnitaryEquipmentTypeEnum: () => IfcUnitaryEquipmentTypeEnum,
    IfcValve: () => IfcValve,
    IfcValveType: () => IfcValveType,
    IfcValveTypeEnum: () => IfcValveTypeEnum,
    IfcVaporPermeabilityMeasure: () => IfcVaporPermeabilityMeasure,
    IfcVector: () => IfcVector,
    IfcVertex: () => IfcVertex,
    IfcVertexLoop: () => IfcVertexLoop,
    IfcVertexPoint: () => IfcVertexPoint,
    IfcVibrationDamper: () => IfcVibrationDamper,
    IfcVibrationDamperType: () => IfcVibrationDamperType,
    IfcVibrationDamperTypeEnum: () => IfcVibrationDamperTypeEnum,
    IfcVibrationIsolator: () => IfcVibrationIsolator,
    IfcVibrationIsolatorType: () => IfcVibrationIsolatorType,
    IfcVibrationIsolatorTypeEnum: () => IfcVibrationIsolatorTypeEnum,
    IfcVirtualElement: () => IfcVirtualElement,
    IfcVirtualGridIntersection: () => IfcVirtualGridIntersection,
    IfcVoidingFeature: () => IfcVoidingFeature,
    IfcVoidingFeatureTypeEnum: () => IfcVoidingFeatureTypeEnum,
    IfcVolumeMeasure: () => IfcVolumeMeasure,
    IfcVolumetricFlowRateMeasure: () => IfcVolumetricFlowRateMeasure,
    IfcWall: () => IfcWall,
    IfcWallElementedCase: () => IfcWallElementedCase,
    IfcWallStandardCase: () => IfcWallStandardCase,
    IfcWallType: () => IfcWallType,
    IfcWallTypeEnum: () => IfcWallTypeEnum,
    IfcWarpingConstantMeasure: () => IfcWarpingConstantMeasure,
    IfcWarpingMomentMeasure: () => IfcWarpingMomentMeasure,
    IfcWasteTerminal: () => IfcWasteTerminal,
    IfcWasteTerminalType: () => IfcWasteTerminalType,
    IfcWasteTerminalTypeEnum: () => IfcWasteTerminalTypeEnum,
    IfcWindow: () => IfcWindow,
    IfcWindowLiningProperties: () => IfcWindowLiningProperties,
    IfcWindowPanelOperationEnum: () => IfcWindowPanelOperationEnum,
    IfcWindowPanelPositionEnum: () => IfcWindowPanelPositionEnum,
    IfcWindowPanelProperties: () => IfcWindowPanelProperties,
    IfcWindowStandardCase: () => IfcWindowStandardCase,
    IfcWindowStyle: () => IfcWindowStyle,
    IfcWindowStyleConstructionEnum: () => IfcWindowStyleConstructionEnum,
    IfcWindowStyleOperationEnum: () => IfcWindowStyleOperationEnum,
    IfcWindowType: () => IfcWindowType,
    IfcWindowTypeEnum: () => IfcWindowTypeEnum,
    IfcWindowTypePartitioningEnum: () => IfcWindowTypePartitioningEnum,
    IfcWorkCalendar: () => IfcWorkCalendar,
    IfcWorkCalendarTypeEnum: () => IfcWorkCalendarTypeEnum,
    IfcWorkControl: () => IfcWorkControl,
    IfcWorkPlan: () => IfcWorkPlan,
    IfcWorkPlanTypeEnum: () => IfcWorkPlanTypeEnum,
    IfcWorkSchedule: () => IfcWorkSchedule,
    IfcWorkScheduleTypeEnum: () => IfcWorkScheduleTypeEnum,
    IfcWorkTime: () => IfcWorkTime,
    IfcZShapeProfileDef: () => IfcZShapeProfileDef,
    IfcZone: () => IfcZone,
    LABEL: () => LABEL,
    LINE_END: () => LINE_END,
    REAL: () => REAL,
    REF: () => REF,
    SET_BEGIN: () => SET_BEGIN,
    SET_END: () => SET_END,
    STRING: () => STRING,
    UNKNOWN: () => UNKNOWN,
    Value: () => Value,
    ms: () => ms
  });

  // dist/ifc2x4.ts
  var IFCACTIONREQUEST = 3821786052;
  var IFCACTOR = 2296667514;
  var IFCACTORROLE = 3630933823;
  var IFCACTUATOR = 4288193352;
  var IFCACTUATORTYPE = 2874132201;
  var IFCADDRESS = 618182010;
  var IFCADVANCEDBREP = 1635779807;
  var IFCADVANCEDBREPWITHVOIDS = 2603310189;
  var IFCADVANCEDFACE = 3406155212;
  var IFCAIRTERMINAL = 1634111441;
  var IFCAIRTERMINALBOX = 177149247;
  var IFCAIRTERMINALBOXTYPE = 1411407467;
  var IFCAIRTERMINALTYPE = 3352864051;
  var IFCAIRTOAIRHEATRECOVERY = 2056796094;
  var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
  var IFCALARM = 3087945054;
  var IFCALARMTYPE = 3001207471;
  var IFCALIGNMENT = 325726236;
  var IFCALIGNMENT2DHORIZONTAL = 749761778;
  var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
  var IFCALIGNMENT2DSEGMENT = 2483840362;
  var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
  var IFCALIGNMENT2DVERSEGLINE = 3239324667;
  var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
  var IFCALIGNMENT2DVERTICAL = 53199957;
  var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
  var IFCALIGNMENTCURVE = 3512275521;
  var IFCANNOTATION = 1674181508;
  var IFCANNOTATIONFILLAREA = 669184980;
  var IFCAPPLICATION = 639542469;
  var IFCAPPLIEDVALUE = 411424972;
  var IFCAPPROVAL = 130549933;
  var IFCAPPROVALRELATIONSHIP = 3869604511;
  var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
  var IFCARBITRARYOPENPROFILEDEF = 1310608509;
  var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
  var IFCASSET = 3460190687;
  var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
  var IFCAUDIOVISUALAPPLIANCE = 277319702;
  var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
  var IFCAXIS1PLACEMENT = 4261334040;
  var IFCAXIS2PLACEMENT2D = 3125803723;
  var IFCAXIS2PLACEMENT3D = 2740243338;
  var IFCBSPLINECURVE = 1967976161;
  var IFCBSPLINECURVEWITHKNOTS = 2461110595;
  var IFCBSPLINESURFACE = 2887950389;
  var IFCBSPLINESURFACEWITHKNOTS = 167062518;
  var IFCBEAM = 753842376;
  var IFCBEAMSTANDARDCASE = 2906023776;
  var IFCBEAMTYPE = 819618141;
  var IFCBEARING = 4196446775;
  var IFCBEARINGTYPE = 3649138523;
  var IFCBLOBTEXTURE = 616511568;
  var IFCBLOCK = 1334484129;
  var IFCBOILER = 32344328;
  var IFCBOILERTYPE = 231477066;
  var IFCBOOLEANCLIPPINGRESULT = 3649129432;
  var IFCBOOLEANRESULT = 2736907675;
  var IFCBOUNDARYCONDITION = 4037036970;
  var IFCBOUNDARYCURVE = 1136057603;
  var IFCBOUNDARYEDGECONDITION = 1560379544;
  var IFCBOUNDARYFACECONDITION = 3367102660;
  var IFCBOUNDARYNODECONDITION = 1387855156;
  var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
  var IFCBOUNDEDCURVE = 1260505505;
  var IFCBOUNDEDSURFACE = 4182860854;
  var IFCBOUNDINGBOX = 2581212453;
  var IFCBOXEDHALFSPACE = 2713105998;
  var IFCBRIDGE = 644574406;
  var IFCBRIDGEPART = 963979645;
  var IFCBUILDING = 4031249490;
  var IFCBUILDINGELEMENT = 3299480353;
  var IFCBUILDINGELEMENTPART = 2979338954;
  var IFCBUILDINGELEMENTPARTTYPE = 39481116;
  var IFCBUILDINGELEMENTPROXY = 1095909175;
  var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
  var IFCBUILDINGELEMENTTYPE = 1950629157;
  var IFCBUILDINGSTOREY = 3124254112;
  var IFCBUILDINGSYSTEM = 1177604601;
  var IFCBURNER = 2938176219;
  var IFCBURNERTYPE = 2188180465;
  var IFCCSHAPEPROFILEDEF = 2898889636;
  var IFCCABLECARRIERFITTING = 635142910;
  var IFCCABLECARRIERFITTINGTYPE = 395041908;
  var IFCCABLECARRIERSEGMENT = 3758799889;
  var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
  var IFCCABLEFITTING = 1051757585;
  var IFCCABLEFITTINGTYPE = 2674252688;
  var IFCCABLESEGMENT = 4217484030;
  var IFCCABLESEGMENTTYPE = 1285652485;
  var IFCCAISSONFOUNDATION = 3999819293;
  var IFCCAISSONFOUNDATIONTYPE = 3203706013;
  var IFCCARTESIANPOINT = 1123145078;
  var IFCCARTESIANPOINTLIST = 574549367;
  var IFCCARTESIANPOINTLIST2D = 1675464909;
  var IFCCARTESIANPOINTLIST3D = 2059837836;
  var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
  var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
  var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
  var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
  var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
  var IFCCENTERLINEPROFILEDEF = 3150382593;
  var IFCCHILLER = 3902619387;
  var IFCCHILLERTYPE = 2951183804;
  var IFCCHIMNEY = 3296154744;
  var IFCCHIMNEYTYPE = 2197970202;
  var IFCCIRCLE = 2611217952;
  var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
  var IFCCIRCLEPROFILEDEF = 1383045692;
  var IFCCIRCULARARCSEGMENT2D = 1062206242;
  var IFCCIVILELEMENT = 1677625105;
  var IFCCIVILELEMENTTYPE = 3893394355;
  var IFCCLASSIFICATION = 747523909;
  var IFCCLASSIFICATIONREFERENCE = 647927063;
  var IFCCLOSEDSHELL = 2205249479;
  var IFCCOIL = 639361253;
  var IFCCOILTYPE = 2301859152;
  var IFCCOLOURRGB = 776857604;
  var IFCCOLOURRGBLIST = 3285139300;
  var IFCCOLOURSPECIFICATION = 3264961684;
  var IFCCOLUMN = 843113511;
  var IFCCOLUMNSTANDARDCASE = 905975707;
  var IFCCOLUMNTYPE = 300633059;
  var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
  var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
  var IFCCOMPLEXPROPERTY = 2542286263;
  var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
  var IFCCOMPOSITECURVE = 3732776249;
  var IFCCOMPOSITECURVEONSURFACE = 15328376;
  var IFCCOMPOSITECURVESEGMENT = 2485617015;
  var IFCCOMPOSITEPROFILEDEF = 1485152156;
  var IFCCOMPRESSOR = 3571504051;
  var IFCCOMPRESSORTYPE = 3850581409;
  var IFCCONDENSER = 2272882330;
  var IFCCONDENSERTYPE = 2816379211;
  var IFCCONIC = 2510884976;
  var IFCCONNECTEDFACESET = 370225590;
  var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
  var IFCCONNECTIONGEOMETRY = 2859738748;
  var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
  var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
  var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
  var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
  var IFCCONSTRAINT = 1959218052;
  var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
  var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
  var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
  var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
  var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
  var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
  var IFCCONSTRUCTIONRESOURCE = 2559216714;
  var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
  var IFCCONTEXT = 3419103109;
  var IFCCONTEXTDEPENDENTUNIT = 3050246964;
  var IFCCONTROL = 3293443760;
  var IFCCONTROLLER = 25142252;
  var IFCCONTROLLERTYPE = 578613899;
  var IFCCONVERSIONBASEDUNIT = 2889183280;
  var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
  var IFCCOOLEDBEAM = 4136498852;
  var IFCCOOLEDBEAMTYPE = 335055490;
  var IFCCOOLINGTOWER = 3640358203;
  var IFCCOOLINGTOWERTYPE = 2954562838;
  var IFCCOORDINATEOPERATION = 1785450214;
  var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
  var IFCCOSTITEM = 3895139033;
  var IFCCOSTSCHEDULE = 1419761937;
  var IFCCOSTVALUE = 602808272;
  var IFCCOVERING = 1973544240;
  var IFCCOVERINGTYPE = 1916426348;
  var IFCCREWRESOURCE = 3295246426;
  var IFCCREWRESOURCETYPE = 1815067380;
  var IFCCSGPRIMITIVE3D = 2506170314;
  var IFCCSGSOLID = 2147822146;
  var IFCCURRENCYRELATIONSHIP = 539742890;
  var IFCCURTAINWALL = 3495092785;
  var IFCCURTAINWALLTYPE = 1457835157;
  var IFCCURVE = 2601014836;
  var IFCCURVEBOUNDEDPLANE = 2827736869;
  var IFCCURVEBOUNDEDSURFACE = 2629017746;
  var IFCCURVESEGMENT2D = 1186437898;
  var IFCCURVESTYLE = 3800577675;
  var IFCCURVESTYLEFONT = 1105321065;
  var IFCCURVESTYLEFONTANDSCALING = 2367409068;
  var IFCCURVESTYLEFONTPATTERN = 3510044353;
  var IFCCYLINDRICALSURFACE = 1213902940;
  var IFCDAMPER = 4074379575;
  var IFCDAMPERTYPE = 3961806047;
  var IFCDEEPFOUNDATION = 3426335179;
  var IFCDEEPFOUNDATIONTYPE = 1306400036;
  var IFCDERIVEDPROFILEDEF = 3632507154;
  var IFCDERIVEDUNIT = 1765591967;
  var IFCDERIVEDUNITELEMENT = 1045800335;
  var IFCDIMENSIONALEXPONENTS = 2949456006;
  var IFCDIRECTION = 32440307;
  var IFCDISCRETEACCESSORY = 1335981549;
  var IFCDISCRETEACCESSORYTYPE = 2635815018;
  var IFCDISTANCEEXPRESSION = 1945343521;
  var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
  var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
  var IFCDISTRIBUTIONCIRCUIT = 562808652;
  var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
  var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
  var IFCDISTRIBUTIONELEMENT = 1945004755;
  var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
  var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
  var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
  var IFCDISTRIBUTIONPORT = 3041715199;
  var IFCDISTRIBUTIONSYSTEM = 3205830791;
  var IFCDOCUMENTINFORMATION = 1154170062;
  var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
  var IFCDOCUMENTREFERENCE = 3732053477;
  var IFCDOOR = 395920057;
  var IFCDOORLININGPROPERTIES = 2963535650;
  var IFCDOORPANELPROPERTIES = 1714330368;
  var IFCDOORSTANDARDCASE = 3242481149;
  var IFCDOORSTYLE = 526551008;
  var IFCDOORTYPE = 2323601079;
  var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
  var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
  var IFCDUCTFITTING = 342316401;
  var IFCDUCTFITTINGTYPE = 869906466;
  var IFCDUCTSEGMENT = 3518393246;
  var IFCDUCTSEGMENTTYPE = 3760055223;
  var IFCDUCTSILENCER = 1360408905;
  var IFCDUCTSILENCERTYPE = 2030761528;
  var IFCEDGE = 3900360178;
  var IFCEDGECURVE = 476780140;
  var IFCEDGELOOP = 1472233963;
  var IFCELECTRICAPPLIANCE = 1904799276;
  var IFCELECTRICAPPLIANCETYPE = 663422040;
  var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
  var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
  var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
  var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
  var IFCELECTRICGENERATOR = 264262732;
  var IFCELECTRICGENERATORTYPE = 1534661035;
  var IFCELECTRICMOTOR = 402227799;
  var IFCELECTRICMOTORTYPE = 1217240411;
  var IFCELECTRICTIMECONTROL = 1003880860;
  var IFCELECTRICTIMECONTROLTYPE = 712377611;
  var IFCELEMENT = 1758889154;
  var IFCELEMENTASSEMBLY = 4123344466;
  var IFCELEMENTASSEMBLYTYPE = 2397081782;
  var IFCELEMENTCOMPONENT = 1623761950;
  var IFCELEMENTCOMPONENTTYPE = 2590856083;
  var IFCELEMENTQUANTITY = 1883228015;
  var IFCELEMENTTYPE = 339256511;
  var IFCELEMENTARYSURFACE = 2777663545;
  var IFCELLIPSE = 1704287377;
  var IFCELLIPSEPROFILEDEF = 2835456948;
  var IFCENERGYCONVERSIONDEVICE = 1658829314;
  var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
  var IFCENGINE = 2814081492;
  var IFCENGINETYPE = 132023988;
  var IFCEVAPORATIVECOOLER = 3747195512;
  var IFCEVAPORATIVECOOLERTYPE = 3174744832;
  var IFCEVAPORATOR = 484807127;
  var IFCEVAPORATORTYPE = 3390157468;
  var IFCEVENT = 4148101412;
  var IFCEVENTTIME = 211053100;
  var IFCEVENTTYPE = 4024345920;
  var IFCEXTENDEDPROPERTIES = 297599258;
  var IFCEXTERNALINFORMATION = 4294318154;
  var IFCEXTERNALREFERENCE = 3200245327;
  var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
  var IFCEXTERNALSPATIALELEMENT = 1209101575;
  var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
  var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
  var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
  var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
  var IFCEXTRUDEDAREASOLID = 477187591;
  var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
  var IFCFACE = 2556980723;
  var IFCFACEBASEDSURFACEMODEL = 2047409740;
  var IFCFACEBOUND = 1809719519;
  var IFCFACEOUTERBOUND = 803316827;
  var IFCFACESURFACE = 3008276851;
  var IFCFACETEDBREP = 807026263;
  var IFCFACETEDBREPWITHVOIDS = 3737207727;
  var IFCFACILITY = 24185140;
  var IFCFACILITYPART = 1310830890;
  var IFCFAILURECONNECTIONCONDITION = 4219587988;
  var IFCFAN = 3415622556;
  var IFCFANTYPE = 346874300;
  var IFCFASTENER = 647756555;
  var IFCFASTENERTYPE = 2489546625;
  var IFCFEATUREELEMENT = 2827207264;
  var IFCFEATUREELEMENTADDITION = 2143335405;
  var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
  var IFCFILLAREASTYLE = 738692330;
  var IFCFILLAREASTYLEHATCHING = 374418227;
  var IFCFILLAREASTYLETILES = 315944413;
  var IFCFILTER = 819412036;
  var IFCFILTERTYPE = 1810631287;
  var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
  var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
  var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
  var IFCFLOWCONTROLLER = 2058353004;
  var IFCFLOWCONTROLLERTYPE = 3907093117;
  var IFCFLOWFITTING = 4278956645;
  var IFCFLOWFITTINGTYPE = 3198132628;
  var IFCFLOWINSTRUMENT = 182646315;
  var IFCFLOWINSTRUMENTTYPE = 4037862832;
  var IFCFLOWMETER = 2188021234;
  var IFCFLOWMETERTYPE = 3815607619;
  var IFCFLOWMOVINGDEVICE = 3132237377;
  var IFCFLOWMOVINGDEVICETYPE = 1482959167;
  var IFCFLOWSEGMENT = 987401354;
  var IFCFLOWSEGMENTTYPE = 1834744321;
  var IFCFLOWSTORAGEDEVICE = 707683696;
  var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
  var IFCFLOWTERMINAL = 2223149337;
  var IFCFLOWTERMINALTYPE = 2297155007;
  var IFCFLOWTREATMENTDEVICE = 3508470533;
  var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
  var IFCFOOTING = 900683007;
  var IFCFOOTINGTYPE = 1893162501;
  var IFCFURNISHINGELEMENT = 263784265;
  var IFCFURNISHINGELEMENTTYPE = 4238390223;
  var IFCFURNITURE = 1509553395;
  var IFCFURNITURETYPE = 1268542332;
  var IFCGEOGRAPHICELEMENT = 3493046030;
  var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
  var IFCGEOMETRICCURVESET = 987898635;
  var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
  var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
  var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
  var IFCGEOMETRICSET = 3590301190;
  var IFCGRID = 3009204131;
  var IFCGRIDAXIS = 852622518;
  var IFCGRIDPLACEMENT = 178086475;
  var IFCGROUP = 2706460486;
  var IFCHALFSPACESOLID = 812098782;
  var IFCHEATEXCHANGER = 3319311131;
  var IFCHEATEXCHANGERTYPE = 1251058090;
  var IFCHUMIDIFIER = 2068733104;
  var IFCHUMIDIFIERTYPE = 1806887404;
  var IFCISHAPEPROFILEDEF = 1484403080;
  var IFCIMAGETEXTURE = 3905492369;
  var IFCINDEXEDCOLOURMAP = 3570813810;
  var IFCINDEXEDPOLYCURVE = 2571569899;
  var IFCINDEXEDPOLYGONALFACE = 178912537;
  var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
  var IFCINDEXEDTEXTUREMAP = 1437953363;
  var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
  var IFCINTERCEPTOR = 4175244083;
  var IFCINTERCEPTORTYPE = 3946677679;
  var IFCINTERSECTIONCURVE = 3113134337;
  var IFCINVENTORY = 2391368822;
  var IFCIRREGULARTIMESERIES = 3741457305;
  var IFCIRREGULARTIMESERIESVALUE = 3020489413;
  var IFCJUNCTIONBOX = 2176052936;
  var IFCJUNCTIONBOXTYPE = 4288270099;
  var IFCLSHAPEPROFILEDEF = 572779678;
  var IFCLABORRESOURCE = 3827777499;
  var IFCLABORRESOURCETYPE = 428585644;
  var IFCLAGTIME = 1585845231;
  var IFCLAMP = 76236018;
  var IFCLAMPTYPE = 1051575348;
  var IFCLIBRARYINFORMATION = 2655187982;
  var IFCLIBRARYREFERENCE = 3452421091;
  var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
  var IFCLIGHTFIXTURE = 629592764;
  var IFCLIGHTFIXTURETYPE = 1161773419;
  var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
  var IFCLIGHTSOURCE = 1402838566;
  var IFCLIGHTSOURCEAMBIENT = 125510826;
  var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
  var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
  var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
  var IFCLIGHTSOURCESPOT = 3422422726;
  var IFCLINE = 1281925730;
  var IFCLINESEGMENT2D = 3092502836;
  var IFCLINEARPLACEMENT = 388784114;
  var IFCLINEARPOSITIONINGELEMENT = 1154579445;
  var IFCLOCALPLACEMENT = 2624227202;
  var IFCLOOP = 1008929658;
  var IFCMANIFOLDSOLIDBREP = 1425443689;
  var IFCMAPCONVERSION = 3057273783;
  var IFCMAPPEDITEM = 2347385850;
  var IFCMATERIAL = 1838606355;
  var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
  var IFCMATERIALCONSTITUENT = 3708119e3;
  var IFCMATERIALCONSTITUENTSET = 2852063980;
  var IFCMATERIALDEFINITION = 760658860;
  var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
  var IFCMATERIALLAYER = 248100487;
  var IFCMATERIALLAYERSET = 3303938423;
  var IFCMATERIALLAYERSETUSAGE = 1303795690;
  var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
  var IFCMATERIALLIST = 2199411900;
  var IFCMATERIALPROFILE = 2235152071;
  var IFCMATERIALPROFILESET = 164193824;
  var IFCMATERIALPROFILESETUSAGE = 3079605661;
  var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
  var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
  var IFCMATERIALPROPERTIES = 3265635763;
  var IFCMATERIALRELATIONSHIP = 853536259;
  var IFCMATERIALUSAGEDEFINITION = 1507914824;
  var IFCMEASUREWITHUNIT = 2597039031;
  var IFCMECHANICALFASTENER = 377706215;
  var IFCMECHANICALFASTENERTYPE = 2108223431;
  var IFCMEDICALDEVICE = 1437502449;
  var IFCMEDICALDEVICETYPE = 1114901282;
  var IFCMEMBER = 1073191201;
  var IFCMEMBERSTANDARDCASE = 1911478936;
  var IFCMEMBERTYPE = 3181161470;
  var IFCMETRIC = 3368373690;
  var IFCMIRROREDPROFILEDEF = 2998442950;
  var IFCMONETARYUNIT = 2706619895;
  var IFCMOTORCONNECTION = 2474470126;
  var IFCMOTORCONNECTIONTYPE = 977012517;
  var IFCNAMEDUNIT = 1918398963;
  var IFCOBJECT = 3888040117;
  var IFCOBJECTDEFINITION = 219451334;
  var IFCOBJECTPLACEMENT = 3701648758;
  var IFCOBJECTIVE = 2251480897;
  var IFCOCCUPANT = 4143007308;
  var IFCOFFSETCURVE = 590820931;
  var IFCOFFSETCURVE2D = 3388369263;
  var IFCOFFSETCURVE3D = 3505215534;
  var IFCOFFSETCURVEBYDISTANCES = 2485787929;
  var IFCOPENSHELL = 2665983363;
  var IFCOPENINGELEMENT = 3588315303;
  var IFCOPENINGSTANDARDCASE = 3079942009;
  var IFCORGANIZATION = 4251960020;
  var IFCORGANIZATIONRELATIONSHIP = 1411181986;
  var IFCORIENTATIONEXPRESSION = 643959842;
  var IFCORIENTEDEDGE = 1029017970;
  var IFCOUTERBOUNDARYCURVE = 144952367;
  var IFCOUTLET = 3694346114;
  var IFCOUTLETTYPE = 2837617999;
  var IFCOWNERHISTORY = 1207048766;
  var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
  var IFCPATH = 2519244187;
  var IFCPCURVE = 1682466193;
  var IFCPERFORMANCEHISTORY = 2382730787;
  var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
  var IFCPERMIT = 3327091369;
  var IFCPERSON = 2077209135;
  var IFCPERSONANDORGANIZATION = 101040310;
  var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
  var IFCPHYSICALQUANTITY = 2483315170;
  var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
  var IFCPILE = 1687234759;
  var IFCPILETYPE = 1158309216;
  var IFCPIPEFITTING = 310824031;
  var IFCPIPEFITTINGTYPE = 804291784;
  var IFCPIPESEGMENT = 3612865200;
  var IFCPIPESEGMENTTYPE = 4231323485;
  var IFCPIXELTEXTURE = 597895409;
  var IFCPLACEMENT = 2004835150;
  var IFCPLANARBOX = 603570806;
  var IFCPLANAREXTENT = 1663979128;
  var IFCPLANE = 220341763;
  var IFCPLATE = 3171933400;
  var IFCPLATESTANDARDCASE = 1156407060;
  var IFCPLATETYPE = 4017108033;
  var IFCPOINT = 2067069095;
  var IFCPOINTONCURVE = 4022376103;
  var IFCPOINTONSURFACE = 1423911732;
  var IFCPOLYLOOP = 2924175390;
  var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
  var IFCPOLYGONALFACESET = 2839578677;
  var IFCPOLYLINE = 3724593414;
  var IFCPORT = 3740093272;
  var IFCPOSITIONINGELEMENT = 1946335990;
  var IFCPOSTALADDRESS = 3355820592;
  var IFCPREDEFINEDCOLOUR = 759155922;
  var IFCPREDEFINEDCURVEFONT = 2559016684;
  var IFCPREDEFINEDITEM = 3727388367;
  var IFCPREDEFINEDPROPERTIES = 3778827333;
  var IFCPREDEFINEDPROPERTYSET = 3967405729;
  var IFCPREDEFINEDTEXTFONT = 1775413392;
  var IFCPRESENTATIONITEM = 677532197;
  var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
  var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
  var IFCPRESENTATIONSTYLE = 3119450353;
  var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
  var IFCPROCEDURE = 2744685151;
  var IFCPROCEDURETYPE = 569719735;
  var IFCPROCESS = 2945172077;
  var IFCPRODUCT = 4208778838;
  var IFCPRODUCTDEFINITIONSHAPE = 673634403;
  var IFCPRODUCTREPRESENTATION = 2095639259;
  var IFCPROFILEDEF = 3958567839;
  var IFCPROFILEPROPERTIES = 2802850158;
  var IFCPROJECT = 103090709;
  var IFCPROJECTLIBRARY = 653396225;
  var IFCPROJECTORDER = 2904328755;
  var IFCPROJECTEDCRS = 3843373140;
  var IFCPROJECTIONELEMENT = 3651124850;
  var IFCPROPERTY = 2598011224;
  var IFCPROPERTYABSTRACTION = 986844984;
  var IFCPROPERTYBOUNDEDVALUE = 871118103;
  var IFCPROPERTYDEFINITION = 1680319473;
  var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
  var IFCPROPERTYENUMERATEDVALUE = 4166981789;
  var IFCPROPERTYENUMERATION = 3710013099;
  var IFCPROPERTYLISTVALUE = 2752243245;
  var IFCPROPERTYREFERENCEVALUE = 941946838;
  var IFCPROPERTYSET = 1451395588;
  var IFCPROPERTYSETDEFINITION = 3357820518;
  var IFCPROPERTYSETTEMPLATE = 492091185;
  var IFCPROPERTYSINGLEVALUE = 3650150729;
  var IFCPROPERTYTABLEVALUE = 110355661;
  var IFCPROPERTYTEMPLATE = 3521284610;
  var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
  var IFCPROTECTIVEDEVICE = 738039164;
  var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
  var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
  var IFCPROTECTIVEDEVICETYPE = 1842657554;
  var IFCPROXY = 3219374653;
  var IFCPUMP = 90941305;
  var IFCPUMPTYPE = 2250791053;
  var IFCQUANTITYAREA = 2044713172;
  var IFCQUANTITYCOUNT = 2093928680;
  var IFCQUANTITYLENGTH = 931644368;
  var IFCQUANTITYSET = 2090586900;
  var IFCQUANTITYTIME = 3252649465;
  var IFCQUANTITYVOLUME = 2405470396;
  var IFCQUANTITYWEIGHT = 825690147;
  var IFCRAILING = 2262370178;
  var IFCRAILINGTYPE = 2893384427;
  var IFCRAMP = 3024970846;
  var IFCRAMPFLIGHT = 3283111854;
  var IFCRAMPFLIGHTTYPE = 2324767716;
  var IFCRAMPTYPE = 1469900589;
  var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
  var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
  var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
  var IFCRECTANGLEPROFILEDEF = 3615266464;
  var IFCRECTANGULARPYRAMID = 2798486643;
  var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
  var IFCRECURRENCEPATTERN = 3915482550;
  var IFCREFERENCE = 2433181523;
  var IFCREFERENT = 4021432810;
  var IFCREGULARTIMESERIES = 3413951693;
  var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
  var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
  var IFCREINFORCINGBAR = 979691226;
  var IFCREINFORCINGBARTYPE = 2572171363;
  var IFCREINFORCINGELEMENT = 3027567501;
  var IFCREINFORCINGELEMENTTYPE = 964333572;
  var IFCREINFORCINGMESH = 2320036040;
  var IFCREINFORCINGMESHTYPE = 2310774935;
  var IFCRELAGGREGATES = 160246688;
  var IFCRELASSIGNS = 3939117080;
  var IFCRELASSIGNSTOACTOR = 1683148259;
  var IFCRELASSIGNSTOCONTROL = 2495723537;
  var IFCRELASSIGNSTOGROUP = 1307041759;
  var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
  var IFCRELASSIGNSTOPROCESS = 4278684876;
  var IFCRELASSIGNSTOPRODUCT = 2857406711;
  var IFCRELASSIGNSTORESOURCE = 205026976;
  var IFCRELASSOCIATES = 1865459582;
  var IFCRELASSOCIATESAPPROVAL = 4095574036;
  var IFCRELASSOCIATESCLASSIFICATION = 919958153;
  var IFCRELASSOCIATESCONSTRAINT = 2728634034;
  var IFCRELASSOCIATESDOCUMENT = 982818633;
  var IFCRELASSOCIATESLIBRARY = 3840914261;
  var IFCRELASSOCIATESMATERIAL = 2655215786;
  var IFCRELCONNECTS = 826625072;
  var IFCRELCONNECTSELEMENTS = 1204542856;
  var IFCRELCONNECTSPATHELEMENTS = 3945020480;
  var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
  var IFCRELCONNECTSPORTS = 3190031847;
  var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
  var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
  var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
  var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
  var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
  var IFCRELCOVERSBLDGELEMENTS = 886880790;
  var IFCRELCOVERSSPACES = 2802773753;
  var IFCRELDECLARES = 2565941209;
  var IFCRELDECOMPOSES = 2551354335;
  var IFCRELDEFINES = 693640335;
  var IFCRELDEFINESBYOBJECT = 1462361463;
  var IFCRELDEFINESBYPROPERTIES = 4186316022;
  var IFCRELDEFINESBYTEMPLATE = 307848117;
  var IFCRELDEFINESBYTYPE = 781010003;
  var IFCRELFILLSELEMENT = 3940055652;
  var IFCRELFLOWCONTROLELEMENTS = 279856033;
  var IFCRELINTERFERESELEMENTS = 427948657;
  var IFCRELNESTS = 3268803585;
  var IFCRELPOSITIONS = 1441486842;
  var IFCRELPROJECTSELEMENT = 750771296;
  var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
  var IFCRELSEQUENCE = 4122056220;
  var IFCRELSERVICESBUILDINGS = 366585022;
  var IFCRELSPACEBOUNDARY = 3451746338;
  var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
  var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
  var IFCRELVOIDSELEMENT = 1401173127;
  var IFCRELATIONSHIP = 478536968;
  var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
  var IFCREPRESENTATION = 1076942058;
  var IFCREPRESENTATIONCONTEXT = 3377609919;
  var IFCREPRESENTATIONITEM = 3008791417;
  var IFCREPRESENTATIONMAP = 1660063152;
  var IFCRESOURCE = 2914609552;
  var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
  var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
  var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
  var IFCRESOURCETIME = 1042787934;
  var IFCREVOLVEDAREASOLID = 1856042241;
  var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
  var IFCRIGHTCIRCULARCONE = 4158566097;
  var IFCRIGHTCIRCULARCYLINDER = 3626867408;
  var IFCROOF = 2016517767;
  var IFCROOFTYPE = 2781568857;
  var IFCROOT = 2341007311;
  var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
  var IFCSIUNIT = 448429030;
  var IFCSANITARYTERMINAL = 3053780830;
  var IFCSANITARYTERMINALTYPE = 1768891740;
  var IFCSCHEDULINGTIME = 1054537805;
  var IFCSEAMCURVE = 2157484638;
  var IFCSECTIONPROPERTIES = 2042790032;
  var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
  var IFCSECTIONEDSOLID = 1862484736;
  var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
  var IFCSECTIONEDSPINE = 1509187699;
  var IFCSENSOR = 4086658281;
  var IFCSENSORTYPE = 1783015770;
  var IFCSHADINGDEVICE = 1329646415;
  var IFCSHADINGDEVICETYPE = 4074543187;
  var IFCSHAPEASPECT = 867548509;
  var IFCSHAPEMODEL = 3982875396;
  var IFCSHAPEREPRESENTATION = 4240577450;
  var IFCSHELLBASEDSURFACEMODEL = 4124623270;
  var IFCSIMPLEPROPERTY = 3692461612;
  var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
  var IFCSITE = 4097777520;
  var IFCSLAB = 1529196076;
  var IFCSLABELEMENTEDCASE = 3127900445;
  var IFCSLABSTANDARDCASE = 3027962421;
  var IFCSLABTYPE = 2533589738;
  var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
  var IFCSOLARDEVICE = 3420628829;
  var IFCSOLARDEVICETYPE = 1072016465;
  var IFCSOLIDMODEL = 723233188;
  var IFCSPACE = 3856911033;
  var IFCSPACEHEATER = 1999602285;
  var IFCSPACEHEATERTYPE = 1305183839;
  var IFCSPACETYPE = 3812236995;
  var IFCSPATIALELEMENT = 1412071761;
  var IFCSPATIALELEMENTTYPE = 710998568;
  var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
  var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
  var IFCSPATIALZONE = 463610769;
  var IFCSPATIALZONETYPE = 2481509218;
  var IFCSPHERE = 451544542;
  var IFCSPHERICALSURFACE = 4015995234;
  var IFCSTACKTERMINAL = 1404847402;
  var IFCSTACKTERMINALTYPE = 3112655638;
  var IFCSTAIR = 331165859;
  var IFCSTAIRFLIGHT = 4252922144;
  var IFCSTAIRFLIGHTTYPE = 1039846685;
  var IFCSTAIRTYPE = 338393293;
  var IFCSTRUCTURALACTION = 682877961;
  var IFCSTRUCTURALACTIVITY = 3544373492;
  var IFCSTRUCTURALANALYSISMODEL = 2515109513;
  var IFCSTRUCTURALCONNECTION = 1179482911;
  var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
  var IFCSTRUCTURALCURVEACTION = 1004757350;
  var IFCSTRUCTURALCURVECONNECTION = 4243806635;
  var IFCSTRUCTURALCURVEMEMBER = 214636428;
  var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
  var IFCSTRUCTURALCURVEREACTION = 2757150158;
  var IFCSTRUCTURALITEM = 3136571912;
  var IFCSTRUCTURALLINEARACTION = 1807405624;
  var IFCSTRUCTURALLOAD = 2162789131;
  var IFCSTRUCTURALLOADCASE = 385403989;
  var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
  var IFCSTRUCTURALLOADGROUP = 1252848954;
  var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
  var IFCSTRUCTURALLOADORRESULT = 609421318;
  var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
  var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
  var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
  var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
  var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
  var IFCSTRUCTURALLOADSTATIC = 2525727697;
  var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
  var IFCSTRUCTURALMEMBER = 530289379;
  var IFCSTRUCTURALPLANARACTION = 1621171031;
  var IFCSTRUCTURALPOINTACTION = 2082059205;
  var IFCSTRUCTURALPOINTCONNECTION = 734778138;
  var IFCSTRUCTURALPOINTREACTION = 1235345126;
  var IFCSTRUCTURALREACTION = 3689010777;
  var IFCSTRUCTURALRESULTGROUP = 2986769608;
  var IFCSTRUCTURALSURFACEACTION = 3657597509;
  var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
  var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
  var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
  var IFCSTRUCTURALSURFACEREACTION = 603775116;
  var IFCSTYLEMODEL = 2830218821;
  var IFCSTYLEDITEM = 3958052878;
  var IFCSTYLEDREPRESENTATION = 3049322572;
  var IFCSUBCONTRACTRESOURCE = 148013059;
  var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
  var IFCSUBEDGE = 2233826070;
  var IFCSURFACE = 2513912981;
  var IFCSURFACECURVE = 699246055;
  var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
  var IFCSURFACEFEATURE = 3101698114;
  var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
  var IFCSURFACEOFREVOLUTION = 4124788165;
  var IFCSURFACEREINFORCEMENTAREA = 2934153892;
  var IFCSURFACESTYLE = 1300840506;
  var IFCSURFACESTYLELIGHTING = 3303107099;
  var IFCSURFACESTYLEREFRACTION = 1607154358;
  var IFCSURFACESTYLERENDERING = 1878645084;
  var IFCSURFACESTYLESHADING = 846575682;
  var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
  var IFCSURFACETEXTURE = 626085974;
  var IFCSWEPTAREASOLID = 2247615214;
  var IFCSWEPTDISKSOLID = 1260650574;
  var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
  var IFCSWEPTSURFACE = 230924584;
  var IFCSWITCHINGDEVICE = 1162798199;
  var IFCSWITCHINGDEVICETYPE = 2315554128;
  var IFCSYSTEM = 2254336722;
  var IFCSYSTEMFURNITUREELEMENT = 413509423;
  var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
  var IFCTSHAPEPROFILEDEF = 3071757647;
  var IFCTABLE = 985171141;
  var IFCTABLECOLUMN = 2043862942;
  var IFCTABLEROW = 531007025;
  var IFCTANK = 812556717;
  var IFCTANKTYPE = 5716631;
  var IFCTASK = 3473067441;
  var IFCTASKTIME = 1549132990;
  var IFCTASKTIMERECURRING = 2771591690;
  var IFCTASKTYPE = 3206491090;
  var IFCTELECOMADDRESS = 912023232;
  var IFCTENDON = 3824725483;
  var IFCTENDONANCHOR = 2347447852;
  var IFCTENDONANCHORTYPE = 3081323446;
  var IFCTENDONCONDUIT = 3663046924;
  var IFCTENDONCONDUITTYPE = 2281632017;
  var IFCTENDONTYPE = 2415094496;
  var IFCTESSELLATEDFACESET = 2387106220;
  var IFCTESSELLATEDITEM = 901063453;
  var IFCTEXTLITERAL = 4282788508;
  var IFCTEXTLITERALWITHEXTENT = 3124975700;
  var IFCTEXTSTYLE = 1447204868;
  var IFCTEXTSTYLEFONTMODEL = 1983826977;
  var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
  var IFCTEXTSTYLETEXTMODEL = 1640371178;
  var IFCTEXTURECOORDINATE = 280115917;
  var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
  var IFCTEXTUREMAP = 2552916305;
  var IFCTEXTUREVERTEX = 1210645708;
  var IFCTEXTUREVERTEXLIST = 3611470254;
  var IFCTIMEPERIOD = 1199560280;
  var IFCTIMESERIES = 3101149627;
  var IFCTIMESERIESVALUE = 581633288;
  var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
  var IFCTOPOLOGYREPRESENTATION = 1735638870;
  var IFCTOROIDALSURFACE = 1935646853;
  var IFCTRANSFORMER = 3825984169;
  var IFCTRANSFORMERTYPE = 1692211062;
  var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
  var IFCTRANSPORTELEMENT = 1620046519;
  var IFCTRANSPORTELEMENTTYPE = 2097647324;
  var IFCTRAPEZIUMPROFILEDEF = 2715220739;
  var IFCTRIANGULATEDFACESET = 2916149573;
  var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
  var IFCTRIMMEDCURVE = 3593883385;
  var IFCTUBEBUNDLE = 3026737570;
  var IFCTUBEBUNDLETYPE = 1600972822;
  var IFCTYPEOBJECT = 1628702193;
  var IFCTYPEPROCESS = 3736923433;
  var IFCTYPEPRODUCT = 2347495698;
  var IFCTYPERESOURCE = 3698973494;
  var IFCUSHAPEPROFILEDEF = 427810014;
  var IFCUNITASSIGNMENT = 180925521;
  var IFCUNITARYCONTROLELEMENT = 630975310;
  var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
  var IFCUNITARYEQUIPMENT = 4292641817;
  var IFCUNITARYEQUIPMENTTYPE = 1911125066;
  var IFCVALVE = 4207607924;
  var IFCVALVETYPE = 728799441;
  var IFCVECTOR = 1417489154;
  var IFCVERTEX = 2799835756;
  var IFCVERTEXLOOP = 2759199220;
  var IFCVERTEXPOINT = 1907098498;
  var IFCVIBRATIONDAMPER = 1530820697;
  var IFCVIBRATIONDAMPERTYPE = 3956297820;
  var IFCVIBRATIONISOLATOR = 2391383451;
  var IFCVIBRATIONISOLATORTYPE = 3313531582;
  var IFCVIRTUALELEMENT = 2769231204;
  var IFCVIRTUALGRIDINTERSECTION = 891718957;
  var IFCVOIDINGFEATURE = 926996030;
  var IFCWALL = 2391406946;
  var IFCWALLELEMENTEDCASE = 4156078855;
  var IFCWALLSTANDARDCASE = 3512223829;
  var IFCWALLTYPE = 1898987631;
  var IFCWASTETERMINAL = 4237592921;
  var IFCWASTETERMINALTYPE = 1133259667;
  var IFCWINDOW = 3304561284;
  var IFCWINDOWLININGPROPERTIES = 336235671;
  var IFCWINDOWPANELPROPERTIES = 512836454;
  var IFCWINDOWSTANDARDCASE = 486154966;
  var IFCWINDOWSTYLE = 1299126871;
  var IFCWINDOWTYPE = 4009809668;
  var IFCWORKCALENDAR = 4088093105;
  var IFCWORKCONTROL = 1028945134;
  var IFCWORKPLAN = 4218914973;
  var IFCWORKSCHEDULE = 3342526732;
  var IFCWORKTIME = 1236880293;
  var IFCZSHAPEPROFILEDEF = 2543172580;
  var IFCZONE = 1033361043;
  var IfcElements = [
    IFCACTUATOR,
    IFCAIRTERMINAL,
    IFCAIRTERMINALBOX,
    IFCAIRTOAIRHEATRECOVERY,
    IFCALARM,
    IFCALIGNMENT,
    IFCANNOTATION,
    IFCAUDIOVISUALAPPLIANCE,
    IFCBEAM,
    IFCBEAMSTANDARDCASE,
    IFCBEARING,
    IFCBOILER,
    IFCBRIDGE,
    IFCBRIDGEPART,
    IFCBUILDING,
    IFCBUILDINGELEMENT,
    IFCBUILDINGELEMENTPART,
    IFCBUILDINGELEMENTPROXY,
    IFCBUILDINGSTOREY,
    IFCBURNER,
    IFCCABLECARRIERFITTING,
    IFCCABLECARRIERSEGMENT,
    IFCCABLEFITTING,
    IFCCABLESEGMENT,
    IFCCAISSONFOUNDATION,
    IFCCHILLER,
    IFCCHIMNEY,
    IFCCIVILELEMENT,
    IFCCOIL,
    IFCCOLUMN,
    IFCCOLUMNSTANDARDCASE,
    IFCCOMMUNICATIONSAPPLIANCE,
    IFCCOMPRESSOR,
    IFCCONDENSER,
    IFCCONTROLLER,
    IFCCOOLEDBEAM,
    IFCCOOLINGTOWER,
    IFCCOVERING,
    IFCCURTAINWALL,
    IFCDAMPER,
    IFCDEEPFOUNDATION,
    IFCDISCRETEACCESSORY,
    IFCDISTRIBUTIONCHAMBERELEMENT,
    IFCDISTRIBUTIONCONTROLELEMENT,
    IFCDISTRIBUTIONELEMENT,
    IFCDISTRIBUTIONFLOWELEMENT,
    IFCDISTRIBUTIONPORT,
    IFCDOOR,
    IFCDOORSTANDARDCASE,
    IFCDUCTFITTING,
    IFCDUCTSEGMENT,
    IFCDUCTSILENCER,
    IFCELECTRICAPPLIANCE,
    IFCELECTRICDISTRIBUTIONBOARD,
    IFCELECTRICFLOWSTORAGEDEVICE,
    IFCELECTRICGENERATOR,
    IFCELECTRICMOTOR,
    IFCELECTRICTIMECONTROL,
    IFCELEMENT,
    IFCELEMENTASSEMBLY,
    IFCELEMENTCOMPONENT,
    IFCENERGYCONVERSIONDEVICE,
    IFCENGINE,
    IFCEVAPORATIVECOOLER,
    IFCEVAPORATOR,
    IFCEXTERNALSPATIALELEMENT,
    IFCEXTERNALSPATIALSTRUCTUREELEMENT,
    IFCFACILITY,
    IFCFACILITYPART,
    IFCFAN,
    IFCFASTENER,
    IFCFEATUREELEMENT,
    IFCFEATUREELEMENTADDITION,
    IFCFEATUREELEMENTSUBTRACTION,
    IFCFILTER,
    IFCFIRESUPPRESSIONTERMINAL,
    IFCFLOWCONTROLLER,
    IFCFLOWFITTING,
    IFCFLOWINSTRUMENT,
    IFCFLOWMETER,
    IFCFLOWMOVINGDEVICE,
    IFCFLOWSEGMENT,
    IFCFLOWSTORAGEDEVICE,
    IFCFLOWTERMINAL,
    IFCFLOWTREATMENTDEVICE,
    IFCFOOTING,
    IFCFURNISHINGELEMENT,
    IFCFURNITURE,
    IFCGEOGRAPHICELEMENT,
    IFCGRID,
    IFCHEATEXCHANGER,
    IFCHUMIDIFIER,
    IFCINTERCEPTOR,
    IFCJUNCTIONBOX,
    IFCLAMP,
    IFCLIGHTFIXTURE,
    IFCLINEARPOSITIONINGELEMENT,
    IFCMECHANICALFASTENER,
    IFCMEDICALDEVICE,
    IFCMEMBER,
    IFCMEMBERSTANDARDCASE,
    IFCMOTORCONNECTION,
    IFCOPENINGELEMENT,
    IFCOPENINGSTANDARDCASE,
    IFCOUTLET,
    IFCPILE,
    IFCPIPEFITTING,
    IFCPIPESEGMENT,
    IFCPLATE,
    IFCPLATESTANDARDCASE,
    IFCPORT,
    IFCPOSITIONINGELEMENT,
    IFCPROJECTIONELEMENT,
    IFCPROTECTIVEDEVICE,
    IFCPROTECTIVEDEVICETRIPPINGUNIT,
    IFCPROXY,
    IFCPUMP,
    IFCRAILING,
    IFCRAMP,
    IFCRAMPFLIGHT,
    IFCREFERENT,
    IFCREINFORCINGBAR,
    IFCREINFORCINGELEMENT,
    IFCREINFORCINGMESH,
    IFCROOF,
    IFCSANITARYTERMINAL,
    IFCSENSOR,
    IFCSHADINGDEVICE,
    IFCSITE,
    IFCSLAB,
    IFCSLABELEMENTEDCASE,
    IFCSLABSTANDARDCASE,
    IFCSOLARDEVICE,
    IFCSPACE,
    IFCSPACEHEATER,
    IFCSPATIALELEMENT,
    IFCSPATIALSTRUCTUREELEMENT,
    IFCSPATIALZONE,
    IFCSTACKTERMINAL,
    IFCSTAIR,
    IFCSTAIRFLIGHT,
    IFCSTRUCTURALACTION,
    IFCSTRUCTURALACTIVITY,
    IFCSTRUCTURALCONNECTION,
    IFCSTRUCTURALCURVEACTION,
    IFCSTRUCTURALCURVECONNECTION,
    IFCSTRUCTURALCURVEMEMBER,
    IFCSTRUCTURALCURVEMEMBERVARYING,
    IFCSTRUCTURALCURVEREACTION,
    IFCSTRUCTURALITEM,
    IFCSTRUCTURALLINEARACTION,
    IFCSTRUCTURALMEMBER,
    IFCSTRUCTURALPLANARACTION,
    IFCSTRUCTURALPOINTACTION,
    IFCSTRUCTURALPOINTCONNECTION,
    IFCSTRUCTURALPOINTREACTION,
    IFCSTRUCTURALREACTION,
    IFCSTRUCTURALSURFACEACTION,
    IFCSTRUCTURALSURFACECONNECTION,
    IFCSTRUCTURALSURFACEMEMBER,
    IFCSTRUCTURALSURFACEMEMBERVARYING,
    IFCSTRUCTURALSURFACEREACTION,
    IFCSURFACEFEATURE,
    IFCSWITCHINGDEVICE,
    IFCSYSTEMFURNITUREELEMENT,
    IFCTANK,
    IFCTENDON,
    IFCTENDONANCHOR,
    IFCTENDONCONDUIT,
    IFCTRANSFORMER,
    IFCTRANSPORTELEMENT,
    IFCTUBEBUNDLE,
    IFCUNITARYCONTROLELEMENT,
    IFCUNITARYEQUIPMENT,
    IFCVALVE,
    IFCVIBRATIONDAMPER,
    IFCVIBRATIONISOLATOR,
    IFCVIRTUALELEMENT,
    IFCVOIDINGFEATURE,
    IFCWALL,
    IFCWALLELEMENTEDCASE,
    IFCWALLSTANDARDCASE,
    IFCWASTETERMINAL,
    IFCWINDOW,
    IFCWINDOWSTANDARDCASE
  ];

  // dist/ifc2x4_helper.ts
  var FromRawLineData = {};
  FromRawLineData[IFCACTIONREQUEST] = (d) => {
    return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTOR] = (d) => {
    return IfcActor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTORROLE] = (d) => {
    return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTUATOR] = (d) => {
    return IfcActuator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCACTUATORTYPE] = (d) => {
    return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADDRESS] = (d) => {
    return IfcAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDBREP] = (d) => {
    return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
    return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCADVANCEDFACE] = (d) => {
    return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINAL] = (d) => {
    return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
    return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
    return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
    return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
    return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
    return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALARM] = (d) => {
    return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALARMTYPE] = (d) => {
    return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT] = (d) => {
    return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
    return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
    return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
    return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
    return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
    return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
    return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
    return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
    return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
    return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCANNOTATION] = (d) => {
    return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
    return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPLICATION] = (d) => {
    return IfcApplication.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
    return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPROVAL] = (d) => {
    return IfcApproval.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
    return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
    return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
    return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
    return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCASSET] = (d) => {
    return IfcAsset.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
    return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
    return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
    return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
    return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
    return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
    return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINECURVE] = (d) => {
    return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
    return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINESURFACE] = (d) => {
    return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
    return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAM] = (d) => {
    return IfcBeam.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
    return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEAMTYPE] = (d) => {
    return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEARING] = (d) => {
    return IfcBearing.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBEARINGTYPE] = (d) => {
    return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBLOBTEXTURE] = (d) => {
    return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBLOCK] = (d) => {
    return IfcBlock.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOILER] = (d) => {
    return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOILERTYPE] = (d) => {
    return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
    return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOOLEANRESULT] = (d) => {
    return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
    return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
    return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
    return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
    return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
    return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
    return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
    return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
    return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOUNDINGBOX] = (d) => {
    return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
    return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBRIDGE] = (d) => {
    return IfcBridge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBRIDGEPART] = (d) => {
    return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDING] = (d) => {
    return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
    return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
    return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
    return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
    return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
    return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
    return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
    return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
    return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBURNER] = (d) => {
    return IfcBurner.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCBURNERTYPE] = (d) => {
    return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
    return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
    return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
    return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
    return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
    return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLEFITTING] = (d) => {
    return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
    return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLESEGMENT] = (d) => {
    return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
    return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
    return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
    return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINT] = (d) => {
    return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
    return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
    return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
    return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
    return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
    return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
    return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
    return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
    return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
    return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHILLER] = (d) => {
    return IfcChiller.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHILLERTYPE] = (d) => {
    return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHIMNEY] = (d) => {
    return IfcChimney.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
    return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLE] = (d) => {
    return IfcCircle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
    return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
    return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
    return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIVILELEMENT] = (d) => {
    return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
    return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLASSIFICATION] = (d) => {
    return IfcClassification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
    return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCLOSEDSHELL] = (d) => {
    return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOIL] = (d) => {
    return IfcCoil.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOILTYPE] = (d) => {
    return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURRGB] = (d) => {
    return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
    return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
    return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMN] = (d) => {
    return IfcColumn.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
    return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOLUMNTYPE] = (d) => {
    return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
    return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
    return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
    return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
    return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
    return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
    return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
    return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
    return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPRESSOR] = (d) => {
    return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
    return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONDENSER] = (d) => {
    return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONDENSERTYPE] = (d) => {
    return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONIC] = (d) => {
    return IfcConic.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
    return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
    return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
    return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
    return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
    return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
    return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
    return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRAINT] = (d) => {
    return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
    return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
    return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
    return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
    return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
    return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
    return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
    return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
    return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTEXT] = (d) => {
    return IfcContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
    return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROL] = (d) => {
    return IfcControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROLLER] = (d) => {
    return IfcController.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
    return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
    return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
    return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLEDBEAM] = (d) => {
    return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
    return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLINGTOWER] = (d) => {
    return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
    return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
    return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
    return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTITEM] = (d) => {
    return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
    return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOSTVALUE] = (d) => {
    return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOVERING] = (d) => {
    return IfcCovering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCOVERINGTYPE] = (d) => {
    return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCREWRESOURCE] = (d) => {
    return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
    return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
    return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCSGSOLID] = (d) => {
    return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
    return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURTAINWALL] = (d) => {
    return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
    return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVE] = (d) => {
    return IfcCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
    return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
    return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
    return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLE] = (d) => {
    return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
    return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
    return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
    return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
    return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDAMPER] = (d) => {
    return IfcDamper.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDAMPERTYPE] = (d) => {
    return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
    return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
    return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
    return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDUNIT] = (d) => {
    return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
    return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
    return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDIRECTION] = (d) => {
    return IfcDirection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
    return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
    return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
    return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
    return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
    return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
    return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
    return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
    return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
    return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
    return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
    return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
    return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
    return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
    return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
    return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
    return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
    return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOOR] = (d) => {
    return IfcDoor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
    return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
    return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
    return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORSTYLE] = (d) => {
    return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDOORTYPE] = (d) => {
    return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
    return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
    return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTFITTING] = (d) => {
    return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
    return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSEGMENT] = (d) => {
    return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
    return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSILENCER] = (d) => {
    return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
    return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGE] = (d) => {
    return IfcEdge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGECURVE] = (d) => {
    return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEDGELOOP] = (d) => {
    return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
    return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
    return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
    return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
    return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
    return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
    return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
    return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
    return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICMOTOR] = (d) => {
    return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
    return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
    return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
    return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENT] = (d) => {
    return IfcElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
    return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
    return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
    return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
    return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
    return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTTYPE] = (d) => {
    return IfcElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
    return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELLIPSE] = (d) => {
    return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
    return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
    return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
    return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENGINE] = (d) => {
    return IfcEngine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCENGINETYPE] = (d) => {
    return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
    return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
    return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATOR] = (d) => {
    return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
    return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENT] = (d) => {
    return IfcEvent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENTTIME] = (d) => {
    return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEVENTTYPE] = (d) => {
    return IfcEventType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
    return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
    return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
    return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
    return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
    return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
    return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
    return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
    return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
    return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
    return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
    return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACE] = (d) => {
    return IfcFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
    return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEBOUND] = (d) => {
    return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
    return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACESURFACE] = (d) => {
    return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACETEDBREP] = (d) => {
    return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
    return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACILITY] = (d) => {
    return IfcFacility.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFACILITYPART] = (d) => {
    return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
    return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFAN] = (d) => {
    return IfcFan.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFANTYPE] = (d) => {
    return IfcFanType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFASTENER] = (d) => {
    return IfcFastener.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFASTENERTYPE] = (d) => {
    return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENT] = (d) => {
    return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
    return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
    return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLE] = (d) => {
    return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
    return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
    return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILTER] = (d) => {
    return IfcFilter.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFILTERTYPE] = (d) => {
    return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
    return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
    return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
    return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
    return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
    return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWFITTING] = (d) => {
    return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
    return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
    return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
    return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMETER] = (d) => {
    return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
    return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
    return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
    return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSEGMENT] = (d) => {
    return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
    return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
    return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
    return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTERMINAL] = (d) => {
    return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
    return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
    return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
    return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFOOTING] = (d) => {
    return IfcFooting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFOOTINGTYPE] = (d) => {
    return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
    return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
    return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNITURE] = (d) => {
    return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCFURNITURETYPE] = (d) => {
    return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
    return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
    return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
    return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
    return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
    return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
    return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGEOMETRICSET] = (d) => {
    return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRID] = (d) => {
    return IfcGrid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRIDAXIS] = (d) => {
    return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
    return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCGROUP] = (d) => {
    return IfcGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHALFSPACESOLID] = (d) => {
    return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHEATEXCHANGER] = (d) => {
    return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
    return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHUMIDIFIER] = (d) => {
    return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
    return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
    return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIMAGETEXTURE] = (d) => {
    return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
    return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
    return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
    return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
    return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
    return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
    return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERCEPTOR] = (d) => {
    return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
    return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
    return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCINVENTORY] = (d) => {
    return IfcInventory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
    return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
    return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCJUNCTIONBOX] = (d) => {
    return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
    return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
    return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLABORRESOURCE] = (d) => {
    return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
    return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAGTIME] = (d) => {
    return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAMP] = (d) => {
    return IfcLamp.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLAMPTYPE] = (d) => {
    return IfcLampType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
    return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
    return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
    return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
    return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
    return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
    return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCE] = (d) => {
    return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
    return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
    return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
    return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
    return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
    return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINE] = (d) => {
    return IfcLine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINESEGMENT2D] = (d) => {
    return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
    return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
    return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
    return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCLOOP] = (d) => {
    return IfcLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
    return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMAPCONVERSION] = (d) => {
    return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMAPPEDITEM] = (d) => {
    return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIAL] = (d) => {
    return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
    return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
    return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
    return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
    return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
    return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYER] = (d) => {
    return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
    return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
    return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
    return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALLIST] = (d) => {
    return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILE] = (d) => {
    return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
    return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
    return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
    return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
    return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
    return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
    return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
    return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
    return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
    return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
    return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEDICALDEVICE] = (d) => {
    return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
    return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBER] = (d) => {
    return IfcMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
    return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMEMBERTYPE] = (d) => {
    return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMETRIC] = (d) => {
    return IfcMetric.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
    return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMONETARYUNIT] = (d) => {
    return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMOTORCONNECTION] = (d) => {
    return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
    return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCNAMEDUNIT] = (d) => {
    return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECT] = (d) => {
    return IfcObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
    return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
    return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOBJECTIVE] = (d) => {
    return IfcObjective.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOCCUPANT] = (d) => {
    return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE] = (d) => {
    return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
    return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
    return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
    return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENSHELL] = (d) => {
    return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENINGELEMENT] = (d) => {
    return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
    return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORGANIZATION] = (d) => {
    return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
    return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
    return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCORIENTEDEDGE] = (d) => {
    return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
    return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTLET] = (d) => {
    return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOUTLETTYPE] = (d) => {
    return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCOWNERHISTORY] = (d) => {
    return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
    return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPATH] = (d) => {
    return IfcPath.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPCURVE] = (d) => {
    return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
    return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
    return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERMIT] = (d) => {
    return IfcPermit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERSON] = (d) => {
    return IfcPerson.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
    return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
    return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
    return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
    return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPILE] = (d) => {
    return IfcPile.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPILETYPE] = (d) => {
    return IfcPileType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPEFITTING] = (d) => {
    return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
    return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPESEGMENT] = (d) => {
    return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
    return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPIXELTEXTURE] = (d) => {
    return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLACEMENT] = (d) => {
    return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANARBOX] = (d) => {
    return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANAREXTENT] = (d) => {
    return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLANE] = (d) => {
    return IfcPlane.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATE] = (d) => {
    return IfcPlate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
    return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPLATETYPE] = (d) => {
    return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINT] = (d) => {
    return IfcPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINTONCURVE] = (d) => {
    return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOINTONSURFACE] = (d) => {
    return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYLOOP] = (d) => {
    return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
    return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
    return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOLYLINE] = (d) => {
    return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPORT] = (d) => {
    return IfcPort.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
    return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPOSTALADDRESS] = (d) => {
    return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
    return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
    return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
    return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
    return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
    return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
    return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
    return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
    return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
    return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
    return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
    return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCEDURE] = (d) => {
    return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCEDURETYPE] = (d) => {
    return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROCESS] = (d) => {
    return IfcProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCT] = (d) => {
    return IfcProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
    return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
    return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROFILEDEF] = (d) => {
    return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
    return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECT] = (d) => {
    return IfcProject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
    return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTORDER] = (d) => {
    return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTEDCRS] = (d) => {
    return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
    return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTY] = (d) => {
    return IfcProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
    return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
    return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
    return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
    return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
    return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
    return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
    return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
    return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSET] = (d) => {
    return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
    return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
    return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
    return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
    return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
    return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
    return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
    return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
    return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
    return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
    return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPROXY] = (d) => {
    return IfcProxy.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPUMP] = (d) => {
    return IfcPump.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCPUMPTYPE] = (d) => {
    return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYAREA] = (d) => {
    return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
    return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
    return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYSET] = (d) => {
    return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYTIME] = (d) => {
    return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
    return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
    return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAILING] = (d) => {
    return IfcRailing.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAILINGTYPE] = (d) => {
    return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMP] = (d) => {
    return IfcRamp.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPFLIGHT] = (d) => {
    return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
    return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRAMPTYPE] = (d) => {
    return IfcRampType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
    return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
    return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
    return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
    return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
    return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
    return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
    return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREFERENCE] = (d) => {
    return IfcReference.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREFERENT] = (d) => {
    return IfcReferent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
    return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
    return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
    return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGBAR] = (d) => {
    return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
    return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
    return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
    return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGMESH] = (d) => {
    return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
    return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELAGGREGATES] = (d) => {
    return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNS] = (d) => {
    return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
    return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
    return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
    return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
    return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
    return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
    return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
    return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATES] = (d) => {
    return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
    return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
    return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
    return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
    return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
    return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
    return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTS] = (d) => {
    return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
    return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
    return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
    return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
    return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
    return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
    return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
    return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
    return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
    return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
    return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
    return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDECLARES] = (d) => {
    return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDECOMPOSES] = (d) => {
    return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINES] = (d) => {
    return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
    return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
    return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
    return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
    return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
    return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
    return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
    return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELNESTS] = (d) => {
    return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELPOSITIONS] = (d) => {
    return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
    return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
    return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSEQUENCE] = (d) => {
    return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
    return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
    return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
    return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
    return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
    return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRELATIONSHIP] = (d) => {
    return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
    return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATION] = (d) => {
    return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
    return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
    return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
    return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCE] = (d) => {
    return IfcResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
    return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
    return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
    return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRESOURCETIME] = (d) => {
    return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
    return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
    return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
    return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
    return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOF] = (d) => {
    return IfcRoof.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOFTYPE] = (d) => {
    return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROOT] = (d) => {
    return IfcRoot.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
    return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIUNIT] = (d) => {
    return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
    return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
    return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
    return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSEAMCURVE] = (d) => {
    return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
    return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
    return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
    return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
    return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
    return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSENSOR] = (d) => {
    return IfcSensor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSENSORTYPE] = (d) => {
    return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHADINGDEVICE] = (d) => {
    return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
    return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEASPECT] = (d) => {
    return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEMODEL] = (d) => {
    return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
    return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
    return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
    return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
    return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSITE] = (d) => {
    return IfcSite.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLAB] = (d) => {
    return IfcSlab.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
    return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
    return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLABTYPE] = (d) => {
    return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
    return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLARDEVICE] = (d) => {
    return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
    return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSOLIDMODEL] = (d) => {
    return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACE] = (d) => {
    return IfcSpace.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACEHEATER] = (d) => {
    return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
    return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPACETYPE] = (d) => {
    return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALELEMENT] = (d) => {
    return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
    return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
    return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
    return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALZONE] = (d) => {
    return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
    return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPHERE] = (d) => {
    return IfcSphere.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
    return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTACKTERMINAL] = (d) => {
    return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
    return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIR] = (d) => {
    return IfcStair.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
    return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
    return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTAIRTYPE] = (d) => {
    return IfcStairType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
    return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
    return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
    return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
    return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
    return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
    return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
    return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
    return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
    return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
    return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
    return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
    return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
    return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
    return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
    return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
    return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
    return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
    return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
    return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
    return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
    return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
    return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
    return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
    return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
    return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
    return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
    return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
    return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
    return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
    return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
    return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
    return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
    return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
    return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
    return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
    return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
    return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEMODEL] = (d) => {
    return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEDITEM] = (d) => {
    return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
    return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
    return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
    return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSUBEDGE] = (d) => {
    return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACE] = (d) => {
    return IfcSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACECURVE] = (d) => {
    return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
    return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEFEATURE] = (d) => {
    return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
    return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
    return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
    return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLE] = (d) => {
    return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
    return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
    return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
    return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
    return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
    return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSURFACETEXTURE] = (d) => {
    return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
    return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
    return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
    return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWEPTSURFACE] = (d) => {
    return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
    return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
    return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEM] = (d) => {
    return IfcSystem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
    return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
    return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
    return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLE] = (d) => {
    return IfcTable.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLECOLUMN] = (d) => {
    return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTABLEROW] = (d) => {
    return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTANK] = (d) => {
    return IfcTank.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTANKTYPE] = (d) => {
    return IfcTankType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASK] = (d) => {
    return IfcTask.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTIME] = (d) => {
    return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
    return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTASKTYPE] = (d) => {
    return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTELECOMADDRESS] = (d) => {
    return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDON] = (d) => {
    return IfcTendon.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONANCHOR] = (d) => {
    return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
    return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONCONDUIT] = (d) => {
    return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
    return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTENDONTYPE] = (d) => {
    return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
    return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
    return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTLITERAL] = (d) => {
    return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
    return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLE] = (d) => {
    return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
    return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
    return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
    return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
    return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
    return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREMAP] = (d) => {
    return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
    return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
    return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMEPERIOD] = (d) => {
    return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMESERIES] = (d) => {
    return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
    return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
    return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
    return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
    return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSFORMER] = (d) => {
    return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
    return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
    return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
    return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
    return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
    return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
    return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
    return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
    return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTUBEBUNDLE] = (d) => {
    return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
    return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEOBJECT] = (d) => {
    return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEPROCESS] = (d) => {
    return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPEPRODUCT] = (d) => {
    return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCTYPERESOURCE] = (d) => {
    return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
    return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
    return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
    return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
    return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
    return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
    return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVALVE] = (d) => {
    return IfcValve.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVALVETYPE] = (d) => {
    return IfcValveType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVECTOR] = (d) => {
    return IfcVector.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEX] = (d) => {
    return IfcVertex.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEXLOOP] = (d) => {
    return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVERTEXPOINT] = (d) => {
    return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
    return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
    return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
    return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
    return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
    return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
    return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
    return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALL] = (d) => {
    return IfcWall.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
    return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
    return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWALLTYPE] = (d) => {
    return IfcWallType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWASTETERMINAL] = (d) => {
    return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
    return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOW] = (d) => {
    return IfcWindow.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
    return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
    return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
    return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWSTYLE] = (d) => {
    return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWINDOWTYPE] = (d) => {
    return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKCALENDAR] = (d) => {
    return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKCONTROL] = (d) => {
    return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKPLAN] = (d) => {
    return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKSCHEDULE] = (d) => {
    return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCWORKTIME] = (d) => {
    return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
    return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
  };
  FromRawLineData[IFCZONE] = (d) => {
    return IfcZone.FromTape(d.ID, d.type, d.arguments);
  };
  var Handle = class {
    constructor(id) {
      this.value = id;
    }
    toTape(args) {
      args.push({ type: 5, value: this.value });
    }
  };
  function Value(type, value) {
    return { t: type, v: value };
  }
  var IfcAbsorbedDoseMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcAccelerationMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcAmountOfSubstanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcAngularVelocityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcAreaDensityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcAreaMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcBinary = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcBoolean = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcBoxAlignment = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcCardinalPointReference = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcContextDependentMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcCountMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcCurvatureMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDate = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDateTime = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDayInMonthNumber = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDayInWeekNumber = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDescriptiveMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDimensionCount = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDoseEquivalentMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDuration = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcDynamicViscosityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricCapacitanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricChargeMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricConductanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricCurrentMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricResistanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcElectricVoltageMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcEnergyMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcFontStyle = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcFontVariant = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcFontWeight = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcForceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcFrequencyMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcGloballyUniqueId = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcHeatFluxDensityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcHeatingValueMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcIdentifier = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcIlluminanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcInductanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcInteger = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcIntegerCountRateMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcIonConcentrationMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcIsothermalMoistureCapacityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcKinematicViscosityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLabel = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLanguageId = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLengthMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLinearForceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLinearMomentMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLinearStiffnessMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLinearVelocityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLogical = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLuminousFluxMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLuminousIntensityDistributionMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcLuminousIntensityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMagneticFluxDensityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMagneticFluxMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMassDensityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMassFlowRateMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMassMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMassPerLengthMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcModulusOfElasticityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcModulusOfLinearSubgradeReactionMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcModulusOfRotationalSubgradeReactionMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcModulusOfSubgradeReactionMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMoistureDiffusivityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMolecularWeightMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMomentOfInertiaMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMonetaryMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcMonthInYearNumber = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcNonNegativeLengthMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcNormalisedRatioMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcNumericMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPHMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcParameterValue = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPlanarForceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPlaneAngleMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPositiveInteger = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPositiveLengthMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPositivePlaneAngleMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPositiveRatioMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPowerMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPresentableText = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcPressureMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcRadioActivityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcRatioMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcReal = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcRotationalFrequencyMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcRotationalMassMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcRotationalStiffnessMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSectionModulusMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSectionalAreaIntegralMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcShearModulusMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSolidAngleMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSoundPowerLevelMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSoundPowerMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSoundPressureLevelMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSoundPressureMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSpecificHeatCapacityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSpecularExponent = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcSpecularRoughness = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTemperatureGradientMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTemperatureRateOfChangeMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcText = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTextAlignment = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTextDecoration = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTextFontName = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTextTransformation = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermalAdmittanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermalConductivityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermalExpansionCoefficientMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermalResistanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermalTransmittanceMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcThermodynamicTemperatureMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTime = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTimeMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTimeStamp = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcTorqueMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcURIReference = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcVaporPermeabilityMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcVolumeMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcVolumetricFlowRateMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcWarpingConstantMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcWarpingMomentMeasure = class {
    constructor(v) {
      this.value = v;
    }
  };
  var IfcActionRequestTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcActionRequestTypeEnum.EMAIL = "EMAIL";
  IfcActionRequestTypeEnum.FAX = "FAX";
  IfcActionRequestTypeEnum.PHONE = "PHONE";
  IfcActionRequestTypeEnum.POST = "POST";
  IfcActionRequestTypeEnum.VERBAL = "VERBAL";
  IfcActionRequestTypeEnum.USERDEFINED = "USERDEFINED";
  IfcActionRequestTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcActionSourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcActionSourceTypeEnum.DEAD_LOAD_G = "DEAD_LOAD_G";
  IfcActionSourceTypeEnum.COMPLETION_G1 = "COMPLETION_G1";
  IfcActionSourceTypeEnum.LIVE_LOAD_Q = "LIVE_LOAD_Q";
  IfcActionSourceTypeEnum.SNOW_S = "SNOW_S";
  IfcActionSourceTypeEnum.WIND_W = "WIND_W";
  IfcActionSourceTypeEnum.PRESTRESSING_P = "PRESTRESSING_P";
  IfcActionSourceTypeEnum.SETTLEMENT_U = "SETTLEMENT_U";
  IfcActionSourceTypeEnum.TEMPERATURE_T = "TEMPERATURE_T";
  IfcActionSourceTypeEnum.EARTHQUAKE_E = "EARTHQUAKE_E";
  IfcActionSourceTypeEnum.FIRE = "FIRE";
  IfcActionSourceTypeEnum.IMPULSE = "IMPULSE";
  IfcActionSourceTypeEnum.IMPACT = "IMPACT";
  IfcActionSourceTypeEnum.TRANSPORT = "TRANSPORT";
  IfcActionSourceTypeEnum.ERECTION = "ERECTION";
  IfcActionSourceTypeEnum.PROPPING = "PROPPING";
  IfcActionSourceTypeEnum.SYSTEM_IMPERFECTION = "SYSTEM_IMPERFECTION";
  IfcActionSourceTypeEnum.SHRINKAGE = "SHRINKAGE";
  IfcActionSourceTypeEnum.CREEP = "CREEP";
  IfcActionSourceTypeEnum.LACK_OF_FIT = "LACK_OF_FIT";
  IfcActionSourceTypeEnum.BUOYANCY = "BUOYANCY";
  IfcActionSourceTypeEnum.ICE = "ICE";
  IfcActionSourceTypeEnum.CURRENT = "CURRENT";
  IfcActionSourceTypeEnum.WAVE = "WAVE";
  IfcActionSourceTypeEnum.RAIN = "RAIN";
  IfcActionSourceTypeEnum.BRAKES = "BRAKES";
  IfcActionSourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcActionSourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcActionTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcActionTypeEnum.PERMANENT_G = "PERMANENT_G";
  IfcActionTypeEnum.VARIABLE_Q = "VARIABLE_Q";
  IfcActionTypeEnum.EXTRAORDINARY_A = "EXTRAORDINARY_A";
  IfcActionTypeEnum.USERDEFINED = "USERDEFINED";
  IfcActionTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcActuatorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcActuatorTypeEnum.ELECTRICACTUATOR = "ELECTRICACTUATOR";
  IfcActuatorTypeEnum.HANDOPERATEDACTUATOR = "HANDOPERATEDACTUATOR";
  IfcActuatorTypeEnum.HYDRAULICACTUATOR = "HYDRAULICACTUATOR";
  IfcActuatorTypeEnum.PNEUMATICACTUATOR = "PNEUMATICACTUATOR";
  IfcActuatorTypeEnum.THERMOSTATICACTUATOR = "THERMOSTATICACTUATOR";
  IfcActuatorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcActuatorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAddressTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAddressTypeEnum.OFFICE = "OFFICE";
  IfcAddressTypeEnum.SITE = "SITE";
  IfcAddressTypeEnum.HOME = "HOME";
  IfcAddressTypeEnum.DISTRIBUTIONPOINT = "DISTRIBUTIONPOINT";
  IfcAddressTypeEnum.USERDEFINED = "USERDEFINED";
  var IfcAirTerminalBoxTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAirTerminalBoxTypeEnum.CONSTANTFLOW = "CONSTANTFLOW";
  IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREDEPENDANT = "VARIABLEFLOWPRESSUREDEPENDANT";
  IfcAirTerminalBoxTypeEnum.VARIABLEFLOWPRESSUREINDEPENDANT = "VARIABLEFLOWPRESSUREINDEPENDANT";
  IfcAirTerminalBoxTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAirTerminalBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAirTerminalTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAirTerminalTypeEnum.DIFFUSER = "DIFFUSER";
  IfcAirTerminalTypeEnum.GRILLE = "GRILLE";
  IfcAirTerminalTypeEnum.LOUVRE = "LOUVRE";
  IfcAirTerminalTypeEnum.REGISTER = "REGISTER";
  IfcAirTerminalTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAirTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAirToAirHeatRecoveryTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECOUNTERFLOWEXCHANGER = "FIXEDPLATECOUNTERFLOWEXCHANGER";
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATECROSSFLOWEXCHANGER = "FIXEDPLATECROSSFLOWEXCHANGER";
  IfcAirToAirHeatRecoveryTypeEnum.FIXEDPLATEPARALLELFLOWEXCHANGER = "FIXEDPLATEPARALLELFLOWEXCHANGER";
  IfcAirToAirHeatRecoveryTypeEnum.ROTARYWHEEL = "ROTARYWHEEL";
  IfcAirToAirHeatRecoveryTypeEnum.RUNAROUNDCOILLOOP = "RUNAROUNDCOILLOOP";
  IfcAirToAirHeatRecoveryTypeEnum.HEATPIPE = "HEATPIPE";
  IfcAirToAirHeatRecoveryTypeEnum.TWINTOWERENTHALPYRECOVERYLOOPS = "TWINTOWERENTHALPYRECOVERYLOOPS";
  IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONSEALEDTUBEHEATEXCHANGERS = "THERMOSIPHONSEALEDTUBEHEATEXCHANGERS";
  IfcAirToAirHeatRecoveryTypeEnum.THERMOSIPHONCOILTYPEHEATEXCHANGERS = "THERMOSIPHONCOILTYPEHEATEXCHANGERS";
  IfcAirToAirHeatRecoveryTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAirToAirHeatRecoveryTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAlarmTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAlarmTypeEnum.BELL = "BELL";
  IfcAlarmTypeEnum.BREAKGLASSBUTTON = "BREAKGLASSBUTTON";
  IfcAlarmTypeEnum.LIGHT = "LIGHT";
  IfcAlarmTypeEnum.MANUALPULLBOX = "MANUALPULLBOX";
  IfcAlarmTypeEnum.SIREN = "SIREN";
  IfcAlarmTypeEnum.WHISTLE = "WHISTLE";
  IfcAlarmTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAlarmTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAlignmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAlignmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAlignmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAnalysisModelTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAnalysisModelTypeEnum.IN_PLANE_LOADING_2D = "IN_PLANE_LOADING_2D";
  IfcAnalysisModelTypeEnum.OUT_PLANE_LOADING_2D = "OUT_PLANE_LOADING_2D";
  IfcAnalysisModelTypeEnum.LOADING_3D = "LOADING_3D";
  IfcAnalysisModelTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAnalysisModelTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAnalysisTheoryTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAnalysisTheoryTypeEnum.FIRST_ORDER_THEORY = "FIRST_ORDER_THEORY";
  IfcAnalysisTheoryTypeEnum.SECOND_ORDER_THEORY = "SECOND_ORDER_THEORY";
  IfcAnalysisTheoryTypeEnum.THIRD_ORDER_THEORY = "THIRD_ORDER_THEORY";
  IfcAnalysisTheoryTypeEnum.FULL_NONLINEAR_THEORY = "FULL_NONLINEAR_THEORY";
  IfcAnalysisTheoryTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAnalysisTheoryTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcArithmeticOperatorEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcArithmeticOperatorEnum.ADD = "ADD";
  IfcArithmeticOperatorEnum.DIVIDE = "DIVIDE";
  IfcArithmeticOperatorEnum.MULTIPLY = "MULTIPLY";
  IfcArithmeticOperatorEnum.SUBTRACT = "SUBTRACT";
  var IfcAssemblyPlaceEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAssemblyPlaceEnum.SITE = "SITE";
  IfcAssemblyPlaceEnum.FACTORY = "FACTORY";
  IfcAssemblyPlaceEnum.NOTDEFINED = "NOTDEFINED";
  var IfcAudioVisualApplianceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcAudioVisualApplianceTypeEnum.AMPLIFIER = "AMPLIFIER";
  IfcAudioVisualApplianceTypeEnum.CAMERA = "CAMERA";
  IfcAudioVisualApplianceTypeEnum.DISPLAY = "DISPLAY";
  IfcAudioVisualApplianceTypeEnum.MICROPHONE = "MICROPHONE";
  IfcAudioVisualApplianceTypeEnum.PLAYER = "PLAYER";
  IfcAudioVisualApplianceTypeEnum.PROJECTOR = "PROJECTOR";
  IfcAudioVisualApplianceTypeEnum.RECEIVER = "RECEIVER";
  IfcAudioVisualApplianceTypeEnum.SPEAKER = "SPEAKER";
  IfcAudioVisualApplianceTypeEnum.SWITCHER = "SWITCHER";
  IfcAudioVisualApplianceTypeEnum.TELEPHONE = "TELEPHONE";
  IfcAudioVisualApplianceTypeEnum.TUNER = "TUNER";
  IfcAudioVisualApplianceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcAudioVisualApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBSplineCurveForm = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBSplineCurveForm.POLYLINE_FORM = "POLYLINE_FORM";
  IfcBSplineCurveForm.CIRCULAR_ARC = "CIRCULAR_ARC";
  IfcBSplineCurveForm.ELLIPTIC_ARC = "ELLIPTIC_ARC";
  IfcBSplineCurveForm.PARABOLIC_ARC = "PARABOLIC_ARC";
  IfcBSplineCurveForm.HYPERBOLIC_ARC = "HYPERBOLIC_ARC";
  IfcBSplineCurveForm.UNSPECIFIED = "UNSPECIFIED";
  var IfcBSplineSurfaceForm = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBSplineSurfaceForm.PLANE_SURF = "PLANE_SURF";
  IfcBSplineSurfaceForm.CYLINDRICAL_SURF = "CYLINDRICAL_SURF";
  IfcBSplineSurfaceForm.CONICAL_SURF = "CONICAL_SURF";
  IfcBSplineSurfaceForm.SPHERICAL_SURF = "SPHERICAL_SURF";
  IfcBSplineSurfaceForm.TOROIDAL_SURF = "TOROIDAL_SURF";
  IfcBSplineSurfaceForm.SURF_OF_REVOLUTION = "SURF_OF_REVOLUTION";
  IfcBSplineSurfaceForm.RULED_SURF = "RULED_SURF";
  IfcBSplineSurfaceForm.GENERALISED_CONE = "GENERALISED_CONE";
  IfcBSplineSurfaceForm.QUADRIC_SURF = "QUADRIC_SURF";
  IfcBSplineSurfaceForm.SURF_OF_LINEAR_EXTRUSION = "SURF_OF_LINEAR_EXTRUSION";
  IfcBSplineSurfaceForm.UNSPECIFIED = "UNSPECIFIED";
  var IfcBeamTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBeamTypeEnum.BEAM = "BEAM";
  IfcBeamTypeEnum.JOIST = "JOIST";
  IfcBeamTypeEnum.HOLLOWCORE = "HOLLOWCORE";
  IfcBeamTypeEnum.LINTEL = "LINTEL";
  IfcBeamTypeEnum.SPANDREL = "SPANDREL";
  IfcBeamTypeEnum.T_BEAM = "T_BEAM";
  IfcBeamTypeEnum.GIRDER_SEGMENT = "GIRDER_SEGMENT";
  IfcBeamTypeEnum.DIAPHRAGM = "DIAPHRAGM";
  IfcBeamTypeEnum.PIERCAP = "PIERCAP";
  IfcBeamTypeEnum.HATSTONE = "HATSTONE";
  IfcBeamTypeEnum.CORNICE = "CORNICE";
  IfcBeamTypeEnum.EDGEBEAM = "EDGEBEAM";
  IfcBeamTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBearingTypeDisplacementEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBearingTypeDisplacementEnum.FIXED_MOVEMENT = "FIXED_MOVEMENT";
  IfcBearingTypeDisplacementEnum.GUIDED_LONGITUDINAL = "GUIDED_LONGITUDINAL";
  IfcBearingTypeDisplacementEnum.GUIDED_TRANSVERSAL = "GUIDED_TRANSVERSAL";
  IfcBearingTypeDisplacementEnum.FREE_MOVEMENT = "FREE_MOVEMENT";
  IfcBearingTypeDisplacementEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBearingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBearingTypeEnum.CYLINDRICAL = "CYLINDRICAL";
  IfcBearingTypeEnum.SPHERICAL = "SPHERICAL";
  IfcBearingTypeEnum.ELASTOMERIC = "ELASTOMERIC";
  IfcBearingTypeEnum.POT = "POT";
  IfcBearingTypeEnum.GUIDE = "GUIDE";
  IfcBearingTypeEnum.ROCKER = "ROCKER";
  IfcBearingTypeEnum.ROLLER = "ROLLER";
  IfcBearingTypeEnum.DISK = "DISK";
  IfcBearingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBearingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBenchmarkEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBenchmarkEnum.GREATERTHAN = "GREATERTHAN";
  IfcBenchmarkEnum.GREATERTHANOREQUALTO = "GREATERTHANOREQUALTO";
  IfcBenchmarkEnum.LESSTHAN = "LESSTHAN";
  IfcBenchmarkEnum.LESSTHANOREQUALTO = "LESSTHANOREQUALTO";
  IfcBenchmarkEnum.EQUALTO = "EQUALTO";
  IfcBenchmarkEnum.NOTEQUALTO = "NOTEQUALTO";
  IfcBenchmarkEnum.INCLUDES = "INCLUDES";
  IfcBenchmarkEnum.NOTINCLUDES = "NOTINCLUDES";
  IfcBenchmarkEnum.INCLUDEDIN = "INCLUDEDIN";
  IfcBenchmarkEnum.NOTINCLUDEDIN = "NOTINCLUDEDIN";
  var IfcBoilerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBoilerTypeEnum.WATER = "WATER";
  IfcBoilerTypeEnum.STEAM = "STEAM";
  IfcBoilerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBoilerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBooleanOperator = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBooleanOperator.UNION = "UNION";
  IfcBooleanOperator.INTERSECTION = "INTERSECTION";
  IfcBooleanOperator.DIFFERENCE = "DIFFERENCE";
  var IfcBridgePartTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBridgePartTypeEnum.ABUTMENT = "ABUTMENT";
  IfcBridgePartTypeEnum.DECK = "DECK";
  IfcBridgePartTypeEnum.DECK_SEGMENT = "DECK_SEGMENT";
  IfcBridgePartTypeEnum.FOUNDATION = "FOUNDATION";
  IfcBridgePartTypeEnum.PIER = "PIER";
  IfcBridgePartTypeEnum.PIER_SEGMENT = "PIER_SEGMENT";
  IfcBridgePartTypeEnum.PYLON = "PYLON";
  IfcBridgePartTypeEnum.SUBSTRUCTURE = "SUBSTRUCTURE";
  IfcBridgePartTypeEnum.SUPERSTRUCTURE = "SUPERSTRUCTURE";
  IfcBridgePartTypeEnum.SURFACESTRUCTURE = "SURFACESTRUCTURE";
  IfcBridgePartTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBridgePartTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBridgeTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBridgeTypeEnum.ARCHED = "ARCHED";
  IfcBridgeTypeEnum.CABLE_STAYED = "CABLE_STAYED";
  IfcBridgeTypeEnum.CANTILEVER = "CANTILEVER";
  IfcBridgeTypeEnum.CULVERT = "CULVERT";
  IfcBridgeTypeEnum.FRAMEWORK = "FRAMEWORK";
  IfcBridgeTypeEnum.GIRDER = "GIRDER";
  IfcBridgeTypeEnum.SUSPENSION = "SUSPENSION";
  IfcBridgeTypeEnum.TRUSS = "TRUSS";
  IfcBridgeTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBridgeTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBuildingElementPartTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBuildingElementPartTypeEnum.INSULATION = "INSULATION";
  IfcBuildingElementPartTypeEnum.PRECASTPANEL = "PRECASTPANEL";
  IfcBuildingElementPartTypeEnum.APRON = "APRON";
  IfcBuildingElementPartTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBuildingElementPartTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBuildingElementProxyTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBuildingElementProxyTypeEnum.COMPLEX = "COMPLEX";
  IfcBuildingElementProxyTypeEnum.ELEMENT = "ELEMENT";
  IfcBuildingElementProxyTypeEnum.PARTIAL = "PARTIAL";
  IfcBuildingElementProxyTypeEnum.PROVISIONFORVOID = "PROVISIONFORVOID";
  IfcBuildingElementProxyTypeEnum.PROVISIONFORSPACE = "PROVISIONFORSPACE";
  IfcBuildingElementProxyTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBuildingElementProxyTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBuildingSystemTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBuildingSystemTypeEnum.FENESTRATION = "FENESTRATION";
  IfcBuildingSystemTypeEnum.FOUNDATION = "FOUNDATION";
  IfcBuildingSystemTypeEnum.LOADBEARING = "LOADBEARING";
  IfcBuildingSystemTypeEnum.OUTERSHELL = "OUTERSHELL";
  IfcBuildingSystemTypeEnum.SHADING = "SHADING";
  IfcBuildingSystemTypeEnum.TRANSPORT = "TRANSPORT";
  IfcBuildingSystemTypeEnum.REINFORCING = "REINFORCING";
  IfcBuildingSystemTypeEnum.PRESTRESSING = "PRESTRESSING";
  IfcBuildingSystemTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBuildingSystemTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcBurnerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcBurnerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcBurnerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCableCarrierFittingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCableCarrierFittingTypeEnum.BEND = "BEND";
  IfcCableCarrierFittingTypeEnum.CROSS = "CROSS";
  IfcCableCarrierFittingTypeEnum.REDUCER = "REDUCER";
  IfcCableCarrierFittingTypeEnum.TEE = "TEE";
  IfcCableCarrierFittingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCableCarrierFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCableCarrierSegmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCableCarrierSegmentTypeEnum.CABLELADDERSEGMENT = "CABLELADDERSEGMENT";
  IfcCableCarrierSegmentTypeEnum.CABLETRAYSEGMENT = "CABLETRAYSEGMENT";
  IfcCableCarrierSegmentTypeEnum.CABLETRUNKINGSEGMENT = "CABLETRUNKINGSEGMENT";
  IfcCableCarrierSegmentTypeEnum.CONDUITSEGMENT = "CONDUITSEGMENT";
  IfcCableCarrierSegmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCableCarrierSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCableFittingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCableFittingTypeEnum.CONNECTOR = "CONNECTOR";
  IfcCableFittingTypeEnum.ENTRY = "ENTRY";
  IfcCableFittingTypeEnum.EXIT = "EXIT";
  IfcCableFittingTypeEnum.JUNCTION = "JUNCTION";
  IfcCableFittingTypeEnum.TRANSITION = "TRANSITION";
  IfcCableFittingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCableFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCableSegmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCableSegmentTypeEnum.BUSBARSEGMENT = "BUSBARSEGMENT";
  IfcCableSegmentTypeEnum.CABLESEGMENT = "CABLESEGMENT";
  IfcCableSegmentTypeEnum.CONDUCTORSEGMENT = "CONDUCTORSEGMENT";
  IfcCableSegmentTypeEnum.CORESEGMENT = "CORESEGMENT";
  IfcCableSegmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCableSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCaissonFoundationTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCaissonFoundationTypeEnum.WELL = "WELL";
  IfcCaissonFoundationTypeEnum.CAISSON = "CAISSON";
  IfcCaissonFoundationTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCaissonFoundationTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcChangeActionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcChangeActionEnum.NOCHANGE = "NOCHANGE";
  IfcChangeActionEnum.MODIFIED = "MODIFIED";
  IfcChangeActionEnum.ADDED = "ADDED";
  IfcChangeActionEnum.DELETED = "DELETED";
  IfcChangeActionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcChillerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcChillerTypeEnum.AIRCOOLED = "AIRCOOLED";
  IfcChillerTypeEnum.WATERCOOLED = "WATERCOOLED";
  IfcChillerTypeEnum.HEATRECOVERY = "HEATRECOVERY";
  IfcChillerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcChillerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcChimneyTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcChimneyTypeEnum.USERDEFINED = "USERDEFINED";
  IfcChimneyTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCoilTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCoilTypeEnum.DXCOOLINGCOIL = "DXCOOLINGCOIL";
  IfcCoilTypeEnum.ELECTRICHEATINGCOIL = "ELECTRICHEATINGCOIL";
  IfcCoilTypeEnum.GASHEATINGCOIL = "GASHEATINGCOIL";
  IfcCoilTypeEnum.HYDRONICCOIL = "HYDRONICCOIL";
  IfcCoilTypeEnum.STEAMHEATINGCOIL = "STEAMHEATINGCOIL";
  IfcCoilTypeEnum.WATERCOOLINGCOIL = "WATERCOOLINGCOIL";
  IfcCoilTypeEnum.WATERHEATINGCOIL = "WATERHEATINGCOIL";
  IfcCoilTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCoilTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcColumnTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcColumnTypeEnum.COLUMN = "COLUMN";
  IfcColumnTypeEnum.PILASTER = "PILASTER";
  IfcColumnTypeEnum.PIERSTEM = "PIERSTEM";
  IfcColumnTypeEnum.PIERSTEM_SEGMENT = "PIERSTEM_SEGMENT";
  IfcColumnTypeEnum.STANDCOLUMN = "STANDCOLUMN";
  IfcColumnTypeEnum.USERDEFINED = "USERDEFINED";
  IfcColumnTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCommunicationsApplianceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCommunicationsApplianceTypeEnum.ANTENNA = "ANTENNA";
  IfcCommunicationsApplianceTypeEnum.COMPUTER = "COMPUTER";
  IfcCommunicationsApplianceTypeEnum.FAX = "FAX";
  IfcCommunicationsApplianceTypeEnum.GATEWAY = "GATEWAY";
  IfcCommunicationsApplianceTypeEnum.MODEM = "MODEM";
  IfcCommunicationsApplianceTypeEnum.NETWORKAPPLIANCE = "NETWORKAPPLIANCE";
  IfcCommunicationsApplianceTypeEnum.NETWORKBRIDGE = "NETWORKBRIDGE";
  IfcCommunicationsApplianceTypeEnum.NETWORKHUB = "NETWORKHUB";
  IfcCommunicationsApplianceTypeEnum.PRINTER = "PRINTER";
  IfcCommunicationsApplianceTypeEnum.REPEATER = "REPEATER";
  IfcCommunicationsApplianceTypeEnum.ROUTER = "ROUTER";
  IfcCommunicationsApplianceTypeEnum.SCANNER = "SCANNER";
  IfcCommunicationsApplianceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCommunicationsApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcComplexPropertyTemplateTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcComplexPropertyTemplateTypeEnum.P_COMPLEX = "P_COMPLEX";
  IfcComplexPropertyTemplateTypeEnum.Q_COMPLEX = "Q_COMPLEX";
  var IfcCompressorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCompressorTypeEnum.DYNAMIC = "DYNAMIC";
  IfcCompressorTypeEnum.RECIPROCATING = "RECIPROCATING";
  IfcCompressorTypeEnum.ROTARY = "ROTARY";
  IfcCompressorTypeEnum.SCROLL = "SCROLL";
  IfcCompressorTypeEnum.TROCHOIDAL = "TROCHOIDAL";
  IfcCompressorTypeEnum.SINGLESTAGE = "SINGLESTAGE";
  IfcCompressorTypeEnum.BOOSTER = "BOOSTER";
  IfcCompressorTypeEnum.OPENTYPE = "OPENTYPE";
  IfcCompressorTypeEnum.HERMETIC = "HERMETIC";
  IfcCompressorTypeEnum.SEMIHERMETIC = "SEMIHERMETIC";
  IfcCompressorTypeEnum.WELDEDSHELLHERMETIC = "WELDEDSHELLHERMETIC";
  IfcCompressorTypeEnum.ROLLINGPISTON = "ROLLINGPISTON";
  IfcCompressorTypeEnum.ROTARYVANE = "ROTARYVANE";
  IfcCompressorTypeEnum.SINGLESCREW = "SINGLESCREW";
  IfcCompressorTypeEnum.TWINSCREW = "TWINSCREW";
  IfcCompressorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCompressorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCondenserTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCondenserTypeEnum.AIRCOOLED = "AIRCOOLED";
  IfcCondenserTypeEnum.EVAPORATIVECOOLED = "EVAPORATIVECOOLED";
  IfcCondenserTypeEnum.WATERCOOLED = "WATERCOOLED";
  IfcCondenserTypeEnum.WATERCOOLEDBRAZEDPLATE = "WATERCOOLEDBRAZEDPLATE";
  IfcCondenserTypeEnum.WATERCOOLEDSHELLCOIL = "WATERCOOLEDSHELLCOIL";
  IfcCondenserTypeEnum.WATERCOOLEDSHELLTUBE = "WATERCOOLEDSHELLTUBE";
  IfcCondenserTypeEnum.WATERCOOLEDTUBEINTUBE = "WATERCOOLEDTUBEINTUBE";
  IfcCondenserTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCondenserTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcConnectionTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcConnectionTypeEnum.ATPATH = "ATPATH";
  IfcConnectionTypeEnum.ATSTART = "ATSTART";
  IfcConnectionTypeEnum.ATEND = "ATEND";
  IfcConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcConstraintEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcConstraintEnum.HARD = "HARD";
  IfcConstraintEnum.SOFT = "SOFT";
  IfcConstraintEnum.ADVISORY = "ADVISORY";
  IfcConstraintEnum.USERDEFINED = "USERDEFINED";
  IfcConstraintEnum.NOTDEFINED = "NOTDEFINED";
  var IfcConstructionEquipmentResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcConstructionEquipmentResourceTypeEnum.DEMOLISHING = "DEMOLISHING";
  IfcConstructionEquipmentResourceTypeEnum.EARTHMOVING = "EARTHMOVING";
  IfcConstructionEquipmentResourceTypeEnum.ERECTING = "ERECTING";
  IfcConstructionEquipmentResourceTypeEnum.HEATING = "HEATING";
  IfcConstructionEquipmentResourceTypeEnum.LIGHTING = "LIGHTING";
  IfcConstructionEquipmentResourceTypeEnum.PAVING = "PAVING";
  IfcConstructionEquipmentResourceTypeEnum.PUMPING = "PUMPING";
  IfcConstructionEquipmentResourceTypeEnum.TRANSPORTING = "TRANSPORTING";
  IfcConstructionEquipmentResourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcConstructionEquipmentResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcConstructionMaterialResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcConstructionMaterialResourceTypeEnum.AGGREGATES = "AGGREGATES";
  IfcConstructionMaterialResourceTypeEnum.CONCRETE = "CONCRETE";
  IfcConstructionMaterialResourceTypeEnum.DRYWALL = "DRYWALL";
  IfcConstructionMaterialResourceTypeEnum.FUEL = "FUEL";
  IfcConstructionMaterialResourceTypeEnum.GYPSUM = "GYPSUM";
  IfcConstructionMaterialResourceTypeEnum.MASONRY = "MASONRY";
  IfcConstructionMaterialResourceTypeEnum.METAL = "METAL";
  IfcConstructionMaterialResourceTypeEnum.PLASTIC = "PLASTIC";
  IfcConstructionMaterialResourceTypeEnum.WOOD = "WOOD";
  IfcConstructionMaterialResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  IfcConstructionMaterialResourceTypeEnum.USERDEFINED = "USERDEFINED";
  var IfcConstructionProductResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcConstructionProductResourceTypeEnum.ASSEMBLY = "ASSEMBLY";
  IfcConstructionProductResourceTypeEnum.FORMWORK = "FORMWORK";
  IfcConstructionProductResourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcConstructionProductResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcControllerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcControllerTypeEnum.FLOATING = "FLOATING";
  IfcControllerTypeEnum.PROGRAMMABLE = "PROGRAMMABLE";
  IfcControllerTypeEnum.PROPORTIONAL = "PROPORTIONAL";
  IfcControllerTypeEnum.MULTIPOSITION = "MULTIPOSITION";
  IfcControllerTypeEnum.TWOPOSITION = "TWOPOSITION";
  IfcControllerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcControllerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCooledBeamTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCooledBeamTypeEnum.ACTIVE = "ACTIVE";
  IfcCooledBeamTypeEnum.PASSIVE = "PASSIVE";
  IfcCooledBeamTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCooledBeamTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCoolingTowerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCoolingTowerTypeEnum.NATURALDRAFT = "NATURALDRAFT";
  IfcCoolingTowerTypeEnum.MECHANICALINDUCEDDRAFT = "MECHANICALINDUCEDDRAFT";
  IfcCoolingTowerTypeEnum.MECHANICALFORCEDDRAFT = "MECHANICALFORCEDDRAFT";
  IfcCoolingTowerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCoolingTowerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCostItemTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCostItemTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCostItemTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCostScheduleTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCostScheduleTypeEnum.BUDGET = "BUDGET";
  IfcCostScheduleTypeEnum.COSTPLAN = "COSTPLAN";
  IfcCostScheduleTypeEnum.ESTIMATE = "ESTIMATE";
  IfcCostScheduleTypeEnum.TENDER = "TENDER";
  IfcCostScheduleTypeEnum.PRICEDBILLOFQUANTITIES = "PRICEDBILLOFQUANTITIES";
  IfcCostScheduleTypeEnum.UNPRICEDBILLOFQUANTITIES = "UNPRICEDBILLOFQUANTITIES";
  IfcCostScheduleTypeEnum.SCHEDULEOFRATES = "SCHEDULEOFRATES";
  IfcCostScheduleTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCostScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCoveringTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCoveringTypeEnum.CEILING = "CEILING";
  IfcCoveringTypeEnum.FLOORING = "FLOORING";
  IfcCoveringTypeEnum.CLADDING = "CLADDING";
  IfcCoveringTypeEnum.ROOFING = "ROOFING";
  IfcCoveringTypeEnum.MOLDING = "MOLDING";
  IfcCoveringTypeEnum.SKIRTINGBOARD = "SKIRTINGBOARD";
  IfcCoveringTypeEnum.INSULATION = "INSULATION";
  IfcCoveringTypeEnum.MEMBRANE = "MEMBRANE";
  IfcCoveringTypeEnum.SLEEVING = "SLEEVING";
  IfcCoveringTypeEnum.WRAPPING = "WRAPPING";
  IfcCoveringTypeEnum.COPING = "COPING";
  IfcCoveringTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCoveringTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCrewResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCrewResourceTypeEnum.OFFICE = "OFFICE";
  IfcCrewResourceTypeEnum.SITE = "SITE";
  IfcCrewResourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCrewResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCurtainWallTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCurtainWallTypeEnum.USERDEFINED = "USERDEFINED";
  IfcCurtainWallTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcCurveInterpolationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcCurveInterpolationEnum.LINEAR = "LINEAR";
  IfcCurveInterpolationEnum.LOG_LINEAR = "LOG_LINEAR";
  IfcCurveInterpolationEnum.LOG_LOG = "LOG_LOG";
  IfcCurveInterpolationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDamperTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDamperTypeEnum.BACKDRAFTDAMPER = "BACKDRAFTDAMPER";
  IfcDamperTypeEnum.BALANCINGDAMPER = "BALANCINGDAMPER";
  IfcDamperTypeEnum.BLASTDAMPER = "BLASTDAMPER";
  IfcDamperTypeEnum.CONTROLDAMPER = "CONTROLDAMPER";
  IfcDamperTypeEnum.FIREDAMPER = "FIREDAMPER";
  IfcDamperTypeEnum.FIRESMOKEDAMPER = "FIRESMOKEDAMPER";
  IfcDamperTypeEnum.FUMEHOODEXHAUST = "FUMEHOODEXHAUST";
  IfcDamperTypeEnum.GRAVITYDAMPER = "GRAVITYDAMPER";
  IfcDamperTypeEnum.GRAVITYRELIEFDAMPER = "GRAVITYRELIEFDAMPER";
  IfcDamperTypeEnum.RELIEFDAMPER = "RELIEFDAMPER";
  IfcDamperTypeEnum.SMOKEDAMPER = "SMOKEDAMPER";
  IfcDamperTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDataOriginEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDataOriginEnum.MEASURED = "MEASURED";
  IfcDataOriginEnum.PREDICTED = "PREDICTED";
  IfcDataOriginEnum.SIMULATED = "SIMULATED";
  IfcDataOriginEnum.USERDEFINED = "USERDEFINED";
  IfcDataOriginEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDerivedUnitEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDerivedUnitEnum.ANGULARVELOCITYUNIT = "ANGULARVELOCITYUNIT";
  IfcDerivedUnitEnum.AREADENSITYUNIT = "AREADENSITYUNIT";
  IfcDerivedUnitEnum.COMPOUNDPLANEANGLEUNIT = "COMPOUNDPLANEANGLEUNIT";
  IfcDerivedUnitEnum.DYNAMICVISCOSITYUNIT = "DYNAMICVISCOSITYUNIT";
  IfcDerivedUnitEnum.HEATFLUXDENSITYUNIT = "HEATFLUXDENSITYUNIT";
  IfcDerivedUnitEnum.INTEGERCOUNTRATEUNIT = "INTEGERCOUNTRATEUNIT";
  IfcDerivedUnitEnum.ISOTHERMALMOISTURECAPACITYUNIT = "ISOTHERMALMOISTURECAPACITYUNIT";
  IfcDerivedUnitEnum.KINEMATICVISCOSITYUNIT = "KINEMATICVISCOSITYUNIT";
  IfcDerivedUnitEnum.LINEARVELOCITYUNIT = "LINEARVELOCITYUNIT";
  IfcDerivedUnitEnum.MASSDENSITYUNIT = "MASSDENSITYUNIT";
  IfcDerivedUnitEnum.MASSFLOWRATEUNIT = "MASSFLOWRATEUNIT";
  IfcDerivedUnitEnum.MOISTUREDIFFUSIVITYUNIT = "MOISTUREDIFFUSIVITYUNIT";
  IfcDerivedUnitEnum.MOLECULARWEIGHTUNIT = "MOLECULARWEIGHTUNIT";
  IfcDerivedUnitEnum.SPECIFICHEATCAPACITYUNIT = "SPECIFICHEATCAPACITYUNIT";
  IfcDerivedUnitEnum.THERMALADMITTANCEUNIT = "THERMALADMITTANCEUNIT";
  IfcDerivedUnitEnum.THERMALCONDUCTANCEUNIT = "THERMALCONDUCTANCEUNIT";
  IfcDerivedUnitEnum.THERMALRESISTANCEUNIT = "THERMALRESISTANCEUNIT";
  IfcDerivedUnitEnum.THERMALTRANSMITTANCEUNIT = "THERMALTRANSMITTANCEUNIT";
  IfcDerivedUnitEnum.VAPORPERMEABILITYUNIT = "VAPORPERMEABILITYUNIT";
  IfcDerivedUnitEnum.VOLUMETRICFLOWRATEUNIT = "VOLUMETRICFLOWRATEUNIT";
  IfcDerivedUnitEnum.ROTATIONALFREQUENCYUNIT = "ROTATIONALFREQUENCYUNIT";
  IfcDerivedUnitEnum.TORQUEUNIT = "TORQUEUNIT";
  IfcDerivedUnitEnum.MOMENTOFINERTIAUNIT = "MOMENTOFINERTIAUNIT";
  IfcDerivedUnitEnum.LINEARMOMENTUNIT = "LINEARMOMENTUNIT";
  IfcDerivedUnitEnum.LINEARFORCEUNIT = "LINEARFORCEUNIT";
  IfcDerivedUnitEnum.PLANARFORCEUNIT = "PLANARFORCEUNIT";
  IfcDerivedUnitEnum.MODULUSOFELASTICITYUNIT = "MODULUSOFELASTICITYUNIT";
  IfcDerivedUnitEnum.SHEARMODULUSUNIT = "SHEARMODULUSUNIT";
  IfcDerivedUnitEnum.LINEARSTIFFNESSUNIT = "LINEARSTIFFNESSUNIT";
  IfcDerivedUnitEnum.ROTATIONALSTIFFNESSUNIT = "ROTATIONALSTIFFNESSUNIT";
  IfcDerivedUnitEnum.MODULUSOFSUBGRADEREACTIONUNIT = "MODULUSOFSUBGRADEREACTIONUNIT";
  IfcDerivedUnitEnum.ACCELERATIONUNIT = "ACCELERATIONUNIT";
  IfcDerivedUnitEnum.CURVATUREUNIT = "CURVATUREUNIT";
  IfcDerivedUnitEnum.HEATINGVALUEUNIT = "HEATINGVALUEUNIT";
  IfcDerivedUnitEnum.IONCONCENTRATIONUNIT = "IONCONCENTRATIONUNIT";
  IfcDerivedUnitEnum.LUMINOUSINTENSITYDISTRIBUTIONUNIT = "LUMINOUSINTENSITYDISTRIBUTIONUNIT";
  IfcDerivedUnitEnum.MASSPERLENGTHUNIT = "MASSPERLENGTHUNIT";
  IfcDerivedUnitEnum.MODULUSOFLINEARSUBGRADEREACTIONUNIT = "MODULUSOFLINEARSUBGRADEREACTIONUNIT";
  IfcDerivedUnitEnum.MODULUSOFROTATIONALSUBGRADEREACTIONUNIT = "MODULUSOFROTATIONALSUBGRADEREACTIONUNIT";
  IfcDerivedUnitEnum.PHUNIT = "PHUNIT";
  IfcDerivedUnitEnum.ROTATIONALMASSUNIT = "ROTATIONALMASSUNIT";
  IfcDerivedUnitEnum.SECTIONAREAINTEGRALUNIT = "SECTIONAREAINTEGRALUNIT";
  IfcDerivedUnitEnum.SECTIONMODULUSUNIT = "SECTIONMODULUSUNIT";
  IfcDerivedUnitEnum.SOUNDPOWERLEVELUNIT = "SOUNDPOWERLEVELUNIT";
  IfcDerivedUnitEnum.SOUNDPOWERUNIT = "SOUNDPOWERUNIT";
  IfcDerivedUnitEnum.SOUNDPRESSURELEVELUNIT = "SOUNDPRESSURELEVELUNIT";
  IfcDerivedUnitEnum.SOUNDPRESSUREUNIT = "SOUNDPRESSUREUNIT";
  IfcDerivedUnitEnum.TEMPERATUREGRADIENTUNIT = "TEMPERATUREGRADIENTUNIT";
  IfcDerivedUnitEnum.TEMPERATURERATEOFCHANGEUNIT = "TEMPERATURERATEOFCHANGEUNIT";
  IfcDerivedUnitEnum.THERMALEXPANSIONCOEFFICIENTUNIT = "THERMALEXPANSIONCOEFFICIENTUNIT";
  IfcDerivedUnitEnum.WARPINGCONSTANTUNIT = "WARPINGCONSTANTUNIT";
  IfcDerivedUnitEnum.WARPINGMOMENTUNIT = "WARPINGMOMENTUNIT";
  IfcDerivedUnitEnum.USERDEFINED = "USERDEFINED";
  var IfcDirectionSenseEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDirectionSenseEnum.POSITIVE = "POSITIVE";
  IfcDirectionSenseEnum.NEGATIVE = "NEGATIVE";
  var IfcDiscreteAccessoryTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDiscreteAccessoryTypeEnum.ANCHORPLATE = "ANCHORPLATE";
  IfcDiscreteAccessoryTypeEnum.BRACKET = "BRACKET";
  IfcDiscreteAccessoryTypeEnum.SHOE = "SHOE";
  IfcDiscreteAccessoryTypeEnum.EXPANSION_JOINT_DEVICE = "EXPANSION_JOINT_DEVICE";
  IfcDiscreteAccessoryTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDiscreteAccessoryTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDistributionChamberElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDistributionChamberElementTypeEnum.FORMEDDUCT = "FORMEDDUCT";
  IfcDistributionChamberElementTypeEnum.INSPECTIONCHAMBER = "INSPECTIONCHAMBER";
  IfcDistributionChamberElementTypeEnum.INSPECTIONPIT = "INSPECTIONPIT";
  IfcDistributionChamberElementTypeEnum.MANHOLE = "MANHOLE";
  IfcDistributionChamberElementTypeEnum.METERCHAMBER = "METERCHAMBER";
  IfcDistributionChamberElementTypeEnum.SUMP = "SUMP";
  IfcDistributionChamberElementTypeEnum.TRENCH = "TRENCH";
  IfcDistributionChamberElementTypeEnum.VALVECHAMBER = "VALVECHAMBER";
  IfcDistributionChamberElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDistributionChamberElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDistributionPortTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDistributionPortTypeEnum.CABLE = "CABLE";
  IfcDistributionPortTypeEnum.CABLECARRIER = "CABLECARRIER";
  IfcDistributionPortTypeEnum.DUCT = "DUCT";
  IfcDistributionPortTypeEnum.PIPE = "PIPE";
  IfcDistributionPortTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDistributionPortTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDistributionSystemEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDistributionSystemEnum.AIRCONDITIONING = "AIRCONDITIONING";
  IfcDistributionSystemEnum.AUDIOVISUAL = "AUDIOVISUAL";
  IfcDistributionSystemEnum.CHEMICAL = "CHEMICAL";
  IfcDistributionSystemEnum.CHILLEDWATER = "CHILLEDWATER";
  IfcDistributionSystemEnum.COMMUNICATION = "COMMUNICATION";
  IfcDistributionSystemEnum.COMPRESSEDAIR = "COMPRESSEDAIR";
  IfcDistributionSystemEnum.CONDENSERWATER = "CONDENSERWATER";
  IfcDistributionSystemEnum.CONTROL = "CONTROL";
  IfcDistributionSystemEnum.CONVEYING = "CONVEYING";
  IfcDistributionSystemEnum.DATA = "DATA";
  IfcDistributionSystemEnum.DISPOSAL = "DISPOSAL";
  IfcDistributionSystemEnum.DOMESTICCOLDWATER = "DOMESTICCOLDWATER";
  IfcDistributionSystemEnum.DOMESTICHOTWATER = "DOMESTICHOTWATER";
  IfcDistributionSystemEnum.DRAINAGE = "DRAINAGE";
  IfcDistributionSystemEnum.EARTHING = "EARTHING";
  IfcDistributionSystemEnum.ELECTRICAL = "ELECTRICAL";
  IfcDistributionSystemEnum.ELECTROACOUSTIC = "ELECTROACOUSTIC";
  IfcDistributionSystemEnum.EXHAUST = "EXHAUST";
  IfcDistributionSystemEnum.FIREPROTECTION = "FIREPROTECTION";
  IfcDistributionSystemEnum.FUEL = "FUEL";
  IfcDistributionSystemEnum.GAS = "GAS";
  IfcDistributionSystemEnum.HAZARDOUS = "HAZARDOUS";
  IfcDistributionSystemEnum.HEATING = "HEATING";
  IfcDistributionSystemEnum.LIGHTING = "LIGHTING";
  IfcDistributionSystemEnum.LIGHTNINGPROTECTION = "LIGHTNINGPROTECTION";
  IfcDistributionSystemEnum.MUNICIPALSOLIDWASTE = "MUNICIPALSOLIDWASTE";
  IfcDistributionSystemEnum.OIL = "OIL";
  IfcDistributionSystemEnum.OPERATIONAL = "OPERATIONAL";
  IfcDistributionSystemEnum.POWERGENERATION = "POWERGENERATION";
  IfcDistributionSystemEnum.RAINWATER = "RAINWATER";
  IfcDistributionSystemEnum.REFRIGERATION = "REFRIGERATION";
  IfcDistributionSystemEnum.SECURITY = "SECURITY";
  IfcDistributionSystemEnum.SEWAGE = "SEWAGE";
  IfcDistributionSystemEnum.SIGNAL = "SIGNAL";
  IfcDistributionSystemEnum.STORMWATER = "STORMWATER";
  IfcDistributionSystemEnum.TELEPHONE = "TELEPHONE";
  IfcDistributionSystemEnum.TV = "TV";
  IfcDistributionSystemEnum.VACUUM = "VACUUM";
  IfcDistributionSystemEnum.VENT = "VENT";
  IfcDistributionSystemEnum.VENTILATION = "VENTILATION";
  IfcDistributionSystemEnum.WASTEWATER = "WASTEWATER";
  IfcDistributionSystemEnum.WATERSUPPLY = "WATERSUPPLY";
  IfcDistributionSystemEnum.USERDEFINED = "USERDEFINED";
  IfcDistributionSystemEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDocumentConfidentialityEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDocumentConfidentialityEnum.PUBLIC = "PUBLIC";
  IfcDocumentConfidentialityEnum.RESTRICTED = "RESTRICTED";
  IfcDocumentConfidentialityEnum.CONFIDENTIAL = "CONFIDENTIAL";
  IfcDocumentConfidentialityEnum.PERSONAL = "PERSONAL";
  IfcDocumentConfidentialityEnum.USERDEFINED = "USERDEFINED";
  IfcDocumentConfidentialityEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDocumentStatusEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDocumentStatusEnum.DRAFT = "DRAFT";
  IfcDocumentStatusEnum.FINALDRAFT = "FINALDRAFT";
  IfcDocumentStatusEnum.FINAL = "FINAL";
  IfcDocumentStatusEnum.REVISION = "REVISION";
  IfcDocumentStatusEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorPanelOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorPanelOperationEnum.SWINGING = "SWINGING";
  IfcDoorPanelOperationEnum.DOUBLE_ACTING = "DOUBLE_ACTING";
  IfcDoorPanelOperationEnum.SLIDING = "SLIDING";
  IfcDoorPanelOperationEnum.FOLDING = "FOLDING";
  IfcDoorPanelOperationEnum.REVOLVING = "REVOLVING";
  IfcDoorPanelOperationEnum.ROLLINGUP = "ROLLINGUP";
  IfcDoorPanelOperationEnum.FIXEDPANEL = "FIXEDPANEL";
  IfcDoorPanelOperationEnum.USERDEFINED = "USERDEFINED";
  IfcDoorPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorPanelPositionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorPanelPositionEnum.LEFT = "LEFT";
  IfcDoorPanelPositionEnum.MIDDLE = "MIDDLE";
  IfcDoorPanelPositionEnum.RIGHT = "RIGHT";
  IfcDoorPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorStyleConstructionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
  IfcDoorStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
  IfcDoorStyleConstructionEnum.STEEL = "STEEL";
  IfcDoorStyleConstructionEnum.WOOD = "WOOD";
  IfcDoorStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
  IfcDoorStyleConstructionEnum.ALUMINIUM_PLASTIC = "ALUMINIUM_PLASTIC";
  IfcDoorStyleConstructionEnum.PLASTIC = "PLASTIC";
  IfcDoorStyleConstructionEnum.USERDEFINED = "USERDEFINED";
  IfcDoorStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorStyleOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorStyleOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
  IfcDoorStyleOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
  IfcDoorStyleOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
  IfcDoorStyleOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
  IfcDoorStyleOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
  IfcDoorStyleOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
  IfcDoorStyleOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
  IfcDoorStyleOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
  IfcDoorStyleOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
  IfcDoorStyleOperationEnum.REVOLVING = "REVOLVING";
  IfcDoorStyleOperationEnum.ROLLINGUP = "ROLLINGUP";
  IfcDoorStyleOperationEnum.USERDEFINED = "USERDEFINED";
  IfcDoorStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorTypeEnum.DOOR = "DOOR";
  IfcDoorTypeEnum.GATE = "GATE";
  IfcDoorTypeEnum.TRAPDOOR = "TRAPDOOR";
  IfcDoorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDoorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDoorTypeOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDoorTypeOperationEnum.SINGLE_SWING_LEFT = "SINGLE_SWING_LEFT";
  IfcDoorTypeOperationEnum.SINGLE_SWING_RIGHT = "SINGLE_SWING_RIGHT";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING = "DOUBLE_DOOR_SINGLE_SWING";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_LEFT";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT = "DOUBLE_DOOR_SINGLE_SWING_OPPOSITE_RIGHT";
  IfcDoorTypeOperationEnum.DOUBLE_SWING_LEFT = "DOUBLE_SWING_LEFT";
  IfcDoorTypeOperationEnum.DOUBLE_SWING_RIGHT = "DOUBLE_SWING_RIGHT";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_DOUBLE_SWING = "DOUBLE_DOOR_DOUBLE_SWING";
  IfcDoorTypeOperationEnum.SLIDING_TO_LEFT = "SLIDING_TO_LEFT";
  IfcDoorTypeOperationEnum.SLIDING_TO_RIGHT = "SLIDING_TO_RIGHT";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_SLIDING = "DOUBLE_DOOR_SLIDING";
  IfcDoorTypeOperationEnum.FOLDING_TO_LEFT = "FOLDING_TO_LEFT";
  IfcDoorTypeOperationEnum.FOLDING_TO_RIGHT = "FOLDING_TO_RIGHT";
  IfcDoorTypeOperationEnum.DOUBLE_DOOR_FOLDING = "DOUBLE_DOOR_FOLDING";
  IfcDoorTypeOperationEnum.REVOLVING = "REVOLVING";
  IfcDoorTypeOperationEnum.ROLLINGUP = "ROLLINGUP";
  IfcDoorTypeOperationEnum.SWING_FIXED_LEFT = "SWING_FIXED_LEFT";
  IfcDoorTypeOperationEnum.SWING_FIXED_RIGHT = "SWING_FIXED_RIGHT";
  IfcDoorTypeOperationEnum.USERDEFINED = "USERDEFINED";
  IfcDoorTypeOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDuctFittingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDuctFittingTypeEnum.BEND = "BEND";
  IfcDuctFittingTypeEnum.CONNECTOR = "CONNECTOR";
  IfcDuctFittingTypeEnum.ENTRY = "ENTRY";
  IfcDuctFittingTypeEnum.EXIT = "EXIT";
  IfcDuctFittingTypeEnum.JUNCTION = "JUNCTION";
  IfcDuctFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
  IfcDuctFittingTypeEnum.TRANSITION = "TRANSITION";
  IfcDuctFittingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDuctFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDuctSegmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDuctSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
  IfcDuctSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
  IfcDuctSegmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDuctSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcDuctSilencerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcDuctSilencerTypeEnum.FLATOVAL = "FLATOVAL";
  IfcDuctSilencerTypeEnum.RECTANGULAR = "RECTANGULAR";
  IfcDuctSilencerTypeEnum.ROUND = "ROUND";
  IfcDuctSilencerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcDuctSilencerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricApplianceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricApplianceTypeEnum.DISHWASHER = "DISHWASHER";
  IfcElectricApplianceTypeEnum.ELECTRICCOOKER = "ELECTRICCOOKER";
  IfcElectricApplianceTypeEnum.FREESTANDINGELECTRICHEATER = "FREESTANDINGELECTRICHEATER";
  IfcElectricApplianceTypeEnum.FREESTANDINGFAN = "FREESTANDINGFAN";
  IfcElectricApplianceTypeEnum.FREESTANDINGWATERHEATER = "FREESTANDINGWATERHEATER";
  IfcElectricApplianceTypeEnum.FREESTANDINGWATERCOOLER = "FREESTANDINGWATERCOOLER";
  IfcElectricApplianceTypeEnum.FREEZER = "FREEZER";
  IfcElectricApplianceTypeEnum.FRIDGE_FREEZER = "FRIDGE_FREEZER";
  IfcElectricApplianceTypeEnum.HANDDRYER = "HANDDRYER";
  IfcElectricApplianceTypeEnum.KITCHENMACHINE = "KITCHENMACHINE";
  IfcElectricApplianceTypeEnum.MICROWAVE = "MICROWAVE";
  IfcElectricApplianceTypeEnum.PHOTOCOPIER = "PHOTOCOPIER";
  IfcElectricApplianceTypeEnum.REFRIGERATOR = "REFRIGERATOR";
  IfcElectricApplianceTypeEnum.TUMBLEDRYER = "TUMBLEDRYER";
  IfcElectricApplianceTypeEnum.VENDINGMACHINE = "VENDINGMACHINE";
  IfcElectricApplianceTypeEnum.WASHINGMACHINE = "WASHINGMACHINE";
  IfcElectricApplianceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricApplianceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricDistributionBoardTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricDistributionBoardTypeEnum.CONSUMERUNIT = "CONSUMERUNIT";
  IfcElectricDistributionBoardTypeEnum.DISTRIBUTIONBOARD = "DISTRIBUTIONBOARD";
  IfcElectricDistributionBoardTypeEnum.MOTORCONTROLCENTRE = "MOTORCONTROLCENTRE";
  IfcElectricDistributionBoardTypeEnum.SWITCHBOARD = "SWITCHBOARD";
  IfcElectricDistributionBoardTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricDistributionBoardTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricFlowStorageDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricFlowStorageDeviceTypeEnum.BATTERY = "BATTERY";
  IfcElectricFlowStorageDeviceTypeEnum.CAPACITORBANK = "CAPACITORBANK";
  IfcElectricFlowStorageDeviceTypeEnum.HARMONICFILTER = "HARMONICFILTER";
  IfcElectricFlowStorageDeviceTypeEnum.INDUCTORBANK = "INDUCTORBANK";
  IfcElectricFlowStorageDeviceTypeEnum.UPS = "UPS";
  IfcElectricFlowStorageDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricFlowStorageDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricGeneratorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricGeneratorTypeEnum.CHP = "CHP";
  IfcElectricGeneratorTypeEnum.ENGINEGENERATOR = "ENGINEGENERATOR";
  IfcElectricGeneratorTypeEnum.STANDALONE = "STANDALONE";
  IfcElectricGeneratorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricGeneratorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricMotorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricMotorTypeEnum.DC = "DC";
  IfcElectricMotorTypeEnum.INDUCTION = "INDUCTION";
  IfcElectricMotorTypeEnum.POLYPHASE = "POLYPHASE";
  IfcElectricMotorTypeEnum.RELUCTANCESYNCHRONOUS = "RELUCTANCESYNCHRONOUS";
  IfcElectricMotorTypeEnum.SYNCHRONOUS = "SYNCHRONOUS";
  IfcElectricMotorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricMotorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElectricTimeControlTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElectricTimeControlTypeEnum.TIMECLOCK = "TIMECLOCK";
  IfcElectricTimeControlTypeEnum.TIMEDELAY = "TIMEDELAY";
  IfcElectricTimeControlTypeEnum.RELAY = "RELAY";
  IfcElectricTimeControlTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElectricTimeControlTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElementAssemblyTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElementAssemblyTypeEnum.ACCESSORY_ASSEMBLY = "ACCESSORY_ASSEMBLY";
  IfcElementAssemblyTypeEnum.ARCH = "ARCH";
  IfcElementAssemblyTypeEnum.BEAM_GRID = "BEAM_GRID";
  IfcElementAssemblyTypeEnum.BRACED_FRAME = "BRACED_FRAME";
  IfcElementAssemblyTypeEnum.GIRDER = "GIRDER";
  IfcElementAssemblyTypeEnum.REINFORCEMENT_UNIT = "REINFORCEMENT_UNIT";
  IfcElementAssemblyTypeEnum.RIGID_FRAME = "RIGID_FRAME";
  IfcElementAssemblyTypeEnum.SLAB_FIELD = "SLAB_FIELD";
  IfcElementAssemblyTypeEnum.TRUSS = "TRUSS";
  IfcElementAssemblyTypeEnum.ABUTMENT = "ABUTMENT";
  IfcElementAssemblyTypeEnum.PIER = "PIER";
  IfcElementAssemblyTypeEnum.PYLON = "PYLON";
  IfcElementAssemblyTypeEnum.CROSS_BRACING = "CROSS_BRACING";
  IfcElementAssemblyTypeEnum.DECK = "DECK";
  IfcElementAssemblyTypeEnum.USERDEFINED = "USERDEFINED";
  IfcElementAssemblyTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcElementCompositionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcElementCompositionEnum.COMPLEX = "COMPLEX";
  IfcElementCompositionEnum.ELEMENT = "ELEMENT";
  IfcElementCompositionEnum.PARTIAL = "PARTIAL";
  var IfcEngineTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcEngineTypeEnum.EXTERNALCOMBUSTION = "EXTERNALCOMBUSTION";
  IfcEngineTypeEnum.INTERNALCOMBUSTION = "INTERNALCOMBUSTION";
  IfcEngineTypeEnum.USERDEFINED = "USERDEFINED";
  IfcEngineTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcEvaporativeCoolerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER = "DIRECTEVAPORATIVERANDOMMEDIAAIRCOOLER";
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER = "DIRECTEVAPORATIVERIGIDMEDIAAIRCOOLER";
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER = "DIRECTEVAPORATIVESLINGERSPACKAGEDAIRCOOLER";
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER = "DIRECTEVAPORATIVEPACKAGEDROTARYAIRCOOLER";
  IfcEvaporativeCoolerTypeEnum.DIRECTEVAPORATIVEAIRWASHER = "DIRECTEVAPORATIVEAIRWASHER";
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEPACKAGEAIRCOOLER = "INDIRECTEVAPORATIVEPACKAGEAIRCOOLER";
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVEWETCOIL = "INDIRECTEVAPORATIVEWETCOIL";
  IfcEvaporativeCoolerTypeEnum.INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER = "INDIRECTEVAPORATIVECOOLINGTOWERORCOILCOOLER";
  IfcEvaporativeCoolerTypeEnum.INDIRECTDIRECTCOMBINATION = "INDIRECTDIRECTCOMBINATION";
  IfcEvaporativeCoolerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcEvaporativeCoolerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcEvaporatorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcEvaporatorTypeEnum.DIRECTEXPANSION = "DIRECTEXPANSION";
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONSHELLANDTUBE = "DIRECTEXPANSIONSHELLANDTUBE";
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONTUBEINTUBE = "DIRECTEXPANSIONTUBEINTUBE";
  IfcEvaporatorTypeEnum.DIRECTEXPANSIONBRAZEDPLATE = "DIRECTEXPANSIONBRAZEDPLATE";
  IfcEvaporatorTypeEnum.FLOODEDSHELLANDTUBE = "FLOODEDSHELLANDTUBE";
  IfcEvaporatorTypeEnum.SHELLANDCOIL = "SHELLANDCOIL";
  IfcEvaporatorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcEvaporatorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcEventTriggerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcEventTriggerTypeEnum.EVENTRULE = "EVENTRULE";
  IfcEventTriggerTypeEnum.EVENTMESSAGE = "EVENTMESSAGE";
  IfcEventTriggerTypeEnum.EVENTTIME = "EVENTTIME";
  IfcEventTriggerTypeEnum.EVENTCOMPLEX = "EVENTCOMPLEX";
  IfcEventTriggerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcEventTriggerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcEventTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcEventTypeEnum.STARTEVENT = "STARTEVENT";
  IfcEventTypeEnum.ENDEVENT = "ENDEVENT";
  IfcEventTypeEnum.INTERMEDIATEEVENT = "INTERMEDIATEEVENT";
  IfcEventTypeEnum.USERDEFINED = "USERDEFINED";
  IfcEventTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcExternalSpatialElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcExternalSpatialElementTypeEnum.EXTERNAL = "EXTERNAL";
  IfcExternalSpatialElementTypeEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
  IfcExternalSpatialElementTypeEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
  IfcExternalSpatialElementTypeEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
  IfcExternalSpatialElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcExternalSpatialElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFanTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFanTypeEnum.CENTRIFUGALFORWARDCURVED = "CENTRIFUGALFORWARDCURVED";
  IfcFanTypeEnum.CENTRIFUGALRADIAL = "CENTRIFUGALRADIAL";
  IfcFanTypeEnum.CENTRIFUGALBACKWARDINCLINEDCURVED = "CENTRIFUGALBACKWARDINCLINEDCURVED";
  IfcFanTypeEnum.CENTRIFUGALAIRFOIL = "CENTRIFUGALAIRFOIL";
  IfcFanTypeEnum.TUBEAXIAL = "TUBEAXIAL";
  IfcFanTypeEnum.VANEAXIAL = "VANEAXIAL";
  IfcFanTypeEnum.PROPELLORAXIAL = "PROPELLORAXIAL";
  IfcFanTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFanTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFastenerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFastenerTypeEnum.GLUE = "GLUE";
  IfcFastenerTypeEnum.MORTAR = "MORTAR";
  IfcFastenerTypeEnum.WELD = "WELD";
  IfcFastenerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFilterTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFilterTypeEnum.AIRPARTICLEFILTER = "AIRPARTICLEFILTER";
  IfcFilterTypeEnum.COMPRESSEDAIRFILTER = "COMPRESSEDAIRFILTER";
  IfcFilterTypeEnum.ODORFILTER = "ODORFILTER";
  IfcFilterTypeEnum.OILFILTER = "OILFILTER";
  IfcFilterTypeEnum.STRAINER = "STRAINER";
  IfcFilterTypeEnum.WATERFILTER = "WATERFILTER";
  IfcFilterTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFilterTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFireSuppressionTerminalTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFireSuppressionTerminalTypeEnum.BREECHINGINLET = "BREECHINGINLET";
  IfcFireSuppressionTerminalTypeEnum.FIREHYDRANT = "FIREHYDRANT";
  IfcFireSuppressionTerminalTypeEnum.HOSEREEL = "HOSEREEL";
  IfcFireSuppressionTerminalTypeEnum.SPRINKLER = "SPRINKLER";
  IfcFireSuppressionTerminalTypeEnum.SPRINKLERDEFLECTOR = "SPRINKLERDEFLECTOR";
  IfcFireSuppressionTerminalTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFireSuppressionTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFlowDirectionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFlowDirectionEnum.SOURCE = "SOURCE";
  IfcFlowDirectionEnum.SINK = "SINK";
  IfcFlowDirectionEnum.SOURCEANDSINK = "SOURCEANDSINK";
  IfcFlowDirectionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFlowInstrumentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFlowInstrumentTypeEnum.PRESSUREGAUGE = "PRESSUREGAUGE";
  IfcFlowInstrumentTypeEnum.THERMOMETER = "THERMOMETER";
  IfcFlowInstrumentTypeEnum.AMMETER = "AMMETER";
  IfcFlowInstrumentTypeEnum.FREQUENCYMETER = "FREQUENCYMETER";
  IfcFlowInstrumentTypeEnum.POWERFACTORMETER = "POWERFACTORMETER";
  IfcFlowInstrumentTypeEnum.PHASEANGLEMETER = "PHASEANGLEMETER";
  IfcFlowInstrumentTypeEnum.VOLTMETER_PEAK = "VOLTMETER_PEAK";
  IfcFlowInstrumentTypeEnum.VOLTMETER_RMS = "VOLTMETER_RMS";
  IfcFlowInstrumentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFlowInstrumentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFlowMeterTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFlowMeterTypeEnum.ENERGYMETER = "ENERGYMETER";
  IfcFlowMeterTypeEnum.GASMETER = "GASMETER";
  IfcFlowMeterTypeEnum.OILMETER = "OILMETER";
  IfcFlowMeterTypeEnum.WATERMETER = "WATERMETER";
  IfcFlowMeterTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFlowMeterTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFootingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFootingTypeEnum.CAISSON_FOUNDATION = "CAISSON_FOUNDATION";
  IfcFootingTypeEnum.FOOTING_BEAM = "FOOTING_BEAM";
  IfcFootingTypeEnum.PAD_FOOTING = "PAD_FOOTING";
  IfcFootingTypeEnum.PILE_CAP = "PILE_CAP";
  IfcFootingTypeEnum.STRIP_FOOTING = "STRIP_FOOTING";
  IfcFootingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFootingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcFurnitureTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcFurnitureTypeEnum.CHAIR = "CHAIR";
  IfcFurnitureTypeEnum.TABLE = "TABLE";
  IfcFurnitureTypeEnum.DESK = "DESK";
  IfcFurnitureTypeEnum.BED = "BED";
  IfcFurnitureTypeEnum.FILECABINET = "FILECABINET";
  IfcFurnitureTypeEnum.SHELF = "SHELF";
  IfcFurnitureTypeEnum.SOFA = "SOFA";
  IfcFurnitureTypeEnum.USERDEFINED = "USERDEFINED";
  IfcFurnitureTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcGeographicElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcGeographicElementTypeEnum.TERRAIN = "TERRAIN";
  IfcGeographicElementTypeEnum.SOIL_BORING_POINT = "SOIL_BORING_POINT";
  IfcGeographicElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcGeographicElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcGeometricProjectionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcGeometricProjectionEnum.GRAPH_VIEW = "GRAPH_VIEW";
  IfcGeometricProjectionEnum.SKETCH_VIEW = "SKETCH_VIEW";
  IfcGeometricProjectionEnum.MODEL_VIEW = "MODEL_VIEW";
  IfcGeometricProjectionEnum.PLAN_VIEW = "PLAN_VIEW";
  IfcGeometricProjectionEnum.REFLECTED_PLAN_VIEW = "REFLECTED_PLAN_VIEW";
  IfcGeometricProjectionEnum.SECTION_VIEW = "SECTION_VIEW";
  IfcGeometricProjectionEnum.ELEVATION_VIEW = "ELEVATION_VIEW";
  IfcGeometricProjectionEnum.USERDEFINED = "USERDEFINED";
  IfcGeometricProjectionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcGlobalOrLocalEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcGlobalOrLocalEnum.GLOBAL_COORDS = "GLOBAL_COORDS";
  IfcGlobalOrLocalEnum.LOCAL_COORDS = "LOCAL_COORDS";
  var IfcGridTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcGridTypeEnum.RECTANGULAR = "RECTANGULAR";
  IfcGridTypeEnum.RADIAL = "RADIAL";
  IfcGridTypeEnum.TRIANGULAR = "TRIANGULAR";
  IfcGridTypeEnum.IRREGULAR = "IRREGULAR";
  IfcGridTypeEnum.USERDEFINED = "USERDEFINED";
  IfcGridTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcHeatExchangerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcHeatExchangerTypeEnum.PLATE = "PLATE";
  IfcHeatExchangerTypeEnum.SHELLANDTUBE = "SHELLANDTUBE";
  IfcHeatExchangerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcHeatExchangerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcHumidifierTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcHumidifierTypeEnum.STEAMINJECTION = "STEAMINJECTION";
  IfcHumidifierTypeEnum.ADIABATICAIRWASHER = "ADIABATICAIRWASHER";
  IfcHumidifierTypeEnum.ADIABATICPAN = "ADIABATICPAN";
  IfcHumidifierTypeEnum.ADIABATICWETTEDELEMENT = "ADIABATICWETTEDELEMENT";
  IfcHumidifierTypeEnum.ADIABATICATOMIZING = "ADIABATICATOMIZING";
  IfcHumidifierTypeEnum.ADIABATICULTRASONIC = "ADIABATICULTRASONIC";
  IfcHumidifierTypeEnum.ADIABATICRIGIDMEDIA = "ADIABATICRIGIDMEDIA";
  IfcHumidifierTypeEnum.ADIABATICCOMPRESSEDAIRNOZZLE = "ADIABATICCOMPRESSEDAIRNOZZLE";
  IfcHumidifierTypeEnum.ASSISTEDELECTRIC = "ASSISTEDELECTRIC";
  IfcHumidifierTypeEnum.ASSISTEDNATURALGAS = "ASSISTEDNATURALGAS";
  IfcHumidifierTypeEnum.ASSISTEDPROPANE = "ASSISTEDPROPANE";
  IfcHumidifierTypeEnum.ASSISTEDBUTANE = "ASSISTEDBUTANE";
  IfcHumidifierTypeEnum.ASSISTEDSTEAM = "ASSISTEDSTEAM";
  IfcHumidifierTypeEnum.USERDEFINED = "USERDEFINED";
  IfcHumidifierTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcInterceptorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcInterceptorTypeEnum.CYCLONIC = "CYCLONIC";
  IfcInterceptorTypeEnum.GREASE = "GREASE";
  IfcInterceptorTypeEnum.OIL = "OIL";
  IfcInterceptorTypeEnum.PETROL = "PETROL";
  IfcInterceptorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcInterceptorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcInternalOrExternalEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcInternalOrExternalEnum.INTERNAL = "INTERNAL";
  IfcInternalOrExternalEnum.EXTERNAL = "EXTERNAL";
  IfcInternalOrExternalEnum.EXTERNAL_EARTH = "EXTERNAL_EARTH";
  IfcInternalOrExternalEnum.EXTERNAL_WATER = "EXTERNAL_WATER";
  IfcInternalOrExternalEnum.EXTERNAL_FIRE = "EXTERNAL_FIRE";
  IfcInternalOrExternalEnum.NOTDEFINED = "NOTDEFINED";
  var IfcInventoryTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcInventoryTypeEnum.ASSETINVENTORY = "ASSETINVENTORY";
  IfcInventoryTypeEnum.SPACEINVENTORY = "SPACEINVENTORY";
  IfcInventoryTypeEnum.FURNITUREINVENTORY = "FURNITUREINVENTORY";
  IfcInventoryTypeEnum.USERDEFINED = "USERDEFINED";
  IfcInventoryTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcJunctionBoxTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcJunctionBoxTypeEnum.DATA = "DATA";
  IfcJunctionBoxTypeEnum.POWER = "POWER";
  IfcJunctionBoxTypeEnum.USERDEFINED = "USERDEFINED";
  IfcJunctionBoxTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcKnotType = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcKnotType.UNIFORM_KNOTS = "UNIFORM_KNOTS";
  IfcKnotType.QUASI_UNIFORM_KNOTS = "QUASI_UNIFORM_KNOTS";
  IfcKnotType.PIECEWISE_BEZIER_KNOTS = "PIECEWISE_BEZIER_KNOTS";
  IfcKnotType.UNSPECIFIED = "UNSPECIFIED";
  var IfcLaborResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLaborResourceTypeEnum.ADMINISTRATION = "ADMINISTRATION";
  IfcLaborResourceTypeEnum.CARPENTRY = "CARPENTRY";
  IfcLaborResourceTypeEnum.CLEANING = "CLEANING";
  IfcLaborResourceTypeEnum.CONCRETE = "CONCRETE";
  IfcLaborResourceTypeEnum.DRYWALL = "DRYWALL";
  IfcLaborResourceTypeEnum.ELECTRIC = "ELECTRIC";
  IfcLaborResourceTypeEnum.FINISHING = "FINISHING";
  IfcLaborResourceTypeEnum.FLOORING = "FLOORING";
  IfcLaborResourceTypeEnum.GENERAL = "GENERAL";
  IfcLaborResourceTypeEnum.HVAC = "HVAC";
  IfcLaborResourceTypeEnum.LANDSCAPING = "LANDSCAPING";
  IfcLaborResourceTypeEnum.MASONRY = "MASONRY";
  IfcLaborResourceTypeEnum.PAINTING = "PAINTING";
  IfcLaborResourceTypeEnum.PAVING = "PAVING";
  IfcLaborResourceTypeEnum.PLUMBING = "PLUMBING";
  IfcLaborResourceTypeEnum.ROOFING = "ROOFING";
  IfcLaborResourceTypeEnum.SITEGRADING = "SITEGRADING";
  IfcLaborResourceTypeEnum.STEELWORK = "STEELWORK";
  IfcLaborResourceTypeEnum.SURVEYING = "SURVEYING";
  IfcLaborResourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcLaborResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLampTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLampTypeEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
  IfcLampTypeEnum.FLUORESCENT = "FLUORESCENT";
  IfcLampTypeEnum.HALOGEN = "HALOGEN";
  IfcLampTypeEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
  IfcLampTypeEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
  IfcLampTypeEnum.LED = "LED";
  IfcLampTypeEnum.METALHALIDE = "METALHALIDE";
  IfcLampTypeEnum.OLED = "OLED";
  IfcLampTypeEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
  IfcLampTypeEnum.USERDEFINED = "USERDEFINED";
  IfcLampTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLayerSetDirectionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLayerSetDirectionEnum.AXIS1 = "AXIS1";
  IfcLayerSetDirectionEnum.AXIS2 = "AXIS2";
  IfcLayerSetDirectionEnum.AXIS3 = "AXIS3";
  var IfcLightDistributionCurveEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLightDistributionCurveEnum.TYPE_A = "TYPE_A";
  IfcLightDistributionCurveEnum.TYPE_B = "TYPE_B";
  IfcLightDistributionCurveEnum.TYPE_C = "TYPE_C";
  IfcLightDistributionCurveEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLightEmissionSourceEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLightEmissionSourceEnum.COMPACTFLUORESCENT = "COMPACTFLUORESCENT";
  IfcLightEmissionSourceEnum.FLUORESCENT = "FLUORESCENT";
  IfcLightEmissionSourceEnum.HIGHPRESSUREMERCURY = "HIGHPRESSUREMERCURY";
  IfcLightEmissionSourceEnum.HIGHPRESSURESODIUM = "HIGHPRESSURESODIUM";
  IfcLightEmissionSourceEnum.LIGHTEMITTINGDIODE = "LIGHTEMITTINGDIODE";
  IfcLightEmissionSourceEnum.LOWPRESSURESODIUM = "LOWPRESSURESODIUM";
  IfcLightEmissionSourceEnum.LOWVOLTAGEHALOGEN = "LOWVOLTAGEHALOGEN";
  IfcLightEmissionSourceEnum.MAINVOLTAGEHALOGEN = "MAINVOLTAGEHALOGEN";
  IfcLightEmissionSourceEnum.METALHALIDE = "METALHALIDE";
  IfcLightEmissionSourceEnum.TUNGSTENFILAMENT = "TUNGSTENFILAMENT";
  IfcLightEmissionSourceEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLightFixtureTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLightFixtureTypeEnum.POINTSOURCE = "POINTSOURCE";
  IfcLightFixtureTypeEnum.DIRECTIONSOURCE = "DIRECTIONSOURCE";
  IfcLightFixtureTypeEnum.SECURITYLIGHTING = "SECURITYLIGHTING";
  IfcLightFixtureTypeEnum.USERDEFINED = "USERDEFINED";
  IfcLightFixtureTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLoadGroupTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLoadGroupTypeEnum.LOAD_GROUP = "LOAD_GROUP";
  IfcLoadGroupTypeEnum.LOAD_CASE = "LOAD_CASE";
  IfcLoadGroupTypeEnum.LOAD_COMBINATION = "LOAD_COMBINATION";
  IfcLoadGroupTypeEnum.USERDEFINED = "USERDEFINED";
  IfcLoadGroupTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcLogicalOperatorEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcLogicalOperatorEnum.LOGICALAND = "LOGICALAND";
  IfcLogicalOperatorEnum.LOGICALOR = "LOGICALOR";
  IfcLogicalOperatorEnum.LOGICALXOR = "LOGICALXOR";
  IfcLogicalOperatorEnum.LOGICALNOTAND = "LOGICALNOTAND";
  IfcLogicalOperatorEnum.LOGICALNOTOR = "LOGICALNOTOR";
  var IfcMechanicalFastenerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcMechanicalFastenerTypeEnum.ANCHORBOLT = "ANCHORBOLT";
  IfcMechanicalFastenerTypeEnum.BOLT = "BOLT";
  IfcMechanicalFastenerTypeEnum.DOWEL = "DOWEL";
  IfcMechanicalFastenerTypeEnum.NAIL = "NAIL";
  IfcMechanicalFastenerTypeEnum.NAILPLATE = "NAILPLATE";
  IfcMechanicalFastenerTypeEnum.RIVET = "RIVET";
  IfcMechanicalFastenerTypeEnum.SCREW = "SCREW";
  IfcMechanicalFastenerTypeEnum.SHEARCONNECTOR = "SHEARCONNECTOR";
  IfcMechanicalFastenerTypeEnum.STAPLE = "STAPLE";
  IfcMechanicalFastenerTypeEnum.STUDSHEARCONNECTOR = "STUDSHEARCONNECTOR";
  IfcMechanicalFastenerTypeEnum.COUPLER = "COUPLER";
  IfcMechanicalFastenerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcMechanicalFastenerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcMedicalDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcMedicalDeviceTypeEnum.AIRSTATION = "AIRSTATION";
  IfcMedicalDeviceTypeEnum.FEEDAIRUNIT = "FEEDAIRUNIT";
  IfcMedicalDeviceTypeEnum.OXYGENGENERATOR = "OXYGENGENERATOR";
  IfcMedicalDeviceTypeEnum.OXYGENPLANT = "OXYGENPLANT";
  IfcMedicalDeviceTypeEnum.VACUUMSTATION = "VACUUMSTATION";
  IfcMedicalDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcMedicalDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcMemberTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcMemberTypeEnum.BRACE = "BRACE";
  IfcMemberTypeEnum.CHORD = "CHORD";
  IfcMemberTypeEnum.COLLAR = "COLLAR";
  IfcMemberTypeEnum.MEMBER = "MEMBER";
  IfcMemberTypeEnum.MULLION = "MULLION";
  IfcMemberTypeEnum.PLATE = "PLATE";
  IfcMemberTypeEnum.POST = "POST";
  IfcMemberTypeEnum.PURLIN = "PURLIN";
  IfcMemberTypeEnum.RAFTER = "RAFTER";
  IfcMemberTypeEnum.STRINGER = "STRINGER";
  IfcMemberTypeEnum.STRUT = "STRUT";
  IfcMemberTypeEnum.STUD = "STUD";
  IfcMemberTypeEnum.STIFFENING_RIB = "STIFFENING_RIB";
  IfcMemberTypeEnum.ARCH_SEGMENT = "ARCH_SEGMENT";
  IfcMemberTypeEnum.SUSPENSION_CABLE = "SUSPENSION_CABLE";
  IfcMemberTypeEnum.SUSPENDER = "SUSPENDER";
  IfcMemberTypeEnum.STAY_CABLE = "STAY_CABLE";
  IfcMemberTypeEnum.USERDEFINED = "USERDEFINED";
  IfcMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcMotorConnectionTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcMotorConnectionTypeEnum.BELTDRIVE = "BELTDRIVE";
  IfcMotorConnectionTypeEnum.COUPLING = "COUPLING";
  IfcMotorConnectionTypeEnum.DIRECTDRIVE = "DIRECTDRIVE";
  IfcMotorConnectionTypeEnum.USERDEFINED = "USERDEFINED";
  IfcMotorConnectionTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcNullStyle = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcNullStyle.NULL = "NULL";
  var IfcObjectTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcObjectTypeEnum.PRODUCT = "PRODUCT";
  IfcObjectTypeEnum.PROCESS = "PROCESS";
  IfcObjectTypeEnum.CONTROL = "CONTROL";
  IfcObjectTypeEnum.RESOURCE = "RESOURCE";
  IfcObjectTypeEnum.ACTOR = "ACTOR";
  IfcObjectTypeEnum.GROUP = "GROUP";
  IfcObjectTypeEnum.PROJECT = "PROJECT";
  IfcObjectTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcObjectiveEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcObjectiveEnum.CODECOMPLIANCE = "CODECOMPLIANCE";
  IfcObjectiveEnum.CODEWAIVER = "CODEWAIVER";
  IfcObjectiveEnum.DESIGNINTENT = "DESIGNINTENT";
  IfcObjectiveEnum.EXTERNAL = "EXTERNAL";
  IfcObjectiveEnum.HEALTHANDSAFETY = "HEALTHANDSAFETY";
  IfcObjectiveEnum.MERGECONFLICT = "MERGECONFLICT";
  IfcObjectiveEnum.MODELVIEW = "MODELVIEW";
  IfcObjectiveEnum.PARAMETER = "PARAMETER";
  IfcObjectiveEnum.REQUIREMENT = "REQUIREMENT";
  IfcObjectiveEnum.SPECIFICATION = "SPECIFICATION";
  IfcObjectiveEnum.TRIGGERCONDITION = "TRIGGERCONDITION";
  IfcObjectiveEnum.USERDEFINED = "USERDEFINED";
  IfcObjectiveEnum.NOTDEFINED = "NOTDEFINED";
  var IfcOccupantTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcOccupantTypeEnum.ASSIGNEE = "ASSIGNEE";
  IfcOccupantTypeEnum.ASSIGNOR = "ASSIGNOR";
  IfcOccupantTypeEnum.LESSEE = "LESSEE";
  IfcOccupantTypeEnum.LESSOR = "LESSOR";
  IfcOccupantTypeEnum.LETTINGAGENT = "LETTINGAGENT";
  IfcOccupantTypeEnum.OWNER = "OWNER";
  IfcOccupantTypeEnum.TENANT = "TENANT";
  IfcOccupantTypeEnum.USERDEFINED = "USERDEFINED";
  IfcOccupantTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcOpeningElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcOpeningElementTypeEnum.OPENING = "OPENING";
  IfcOpeningElementTypeEnum.RECESS = "RECESS";
  IfcOpeningElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcOpeningElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcOutletTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcOutletTypeEnum.AUDIOVISUALOUTLET = "AUDIOVISUALOUTLET";
  IfcOutletTypeEnum.COMMUNICATIONSOUTLET = "COMMUNICATIONSOUTLET";
  IfcOutletTypeEnum.POWEROUTLET = "POWEROUTLET";
  IfcOutletTypeEnum.DATAOUTLET = "DATAOUTLET";
  IfcOutletTypeEnum.TELEPHONEOUTLET = "TELEPHONEOUTLET";
  IfcOutletTypeEnum.USERDEFINED = "USERDEFINED";
  IfcOutletTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPerformanceHistoryTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPerformanceHistoryTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPerformanceHistoryTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPermeableCoveringOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPermeableCoveringOperationEnum.GRILL = "GRILL";
  IfcPermeableCoveringOperationEnum.LOUVER = "LOUVER";
  IfcPermeableCoveringOperationEnum.SCREEN = "SCREEN";
  IfcPermeableCoveringOperationEnum.USERDEFINED = "USERDEFINED";
  IfcPermeableCoveringOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPermitTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPermitTypeEnum.ACCESS = "ACCESS";
  IfcPermitTypeEnum.BUILDING = "BUILDING";
  IfcPermitTypeEnum.WORK = "WORK";
  IfcPermitTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPermitTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPhysicalOrVirtualEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPhysicalOrVirtualEnum.PHYSICAL = "PHYSICAL";
  IfcPhysicalOrVirtualEnum.VIRTUAL = "VIRTUAL";
  IfcPhysicalOrVirtualEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPileConstructionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPileConstructionEnum.CAST_IN_PLACE = "CAST_IN_PLACE";
  IfcPileConstructionEnum.COMPOSITE = "COMPOSITE";
  IfcPileConstructionEnum.PRECAST_CONCRETE = "PRECAST_CONCRETE";
  IfcPileConstructionEnum.PREFAB_STEEL = "PREFAB_STEEL";
  IfcPileConstructionEnum.USERDEFINED = "USERDEFINED";
  IfcPileConstructionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPileTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPileTypeEnum.BORED = "BORED";
  IfcPileTypeEnum.DRIVEN = "DRIVEN";
  IfcPileTypeEnum.JETGROUTING = "JETGROUTING";
  IfcPileTypeEnum.COHESION = "COHESION";
  IfcPileTypeEnum.FRICTION = "FRICTION";
  IfcPileTypeEnum.SUPPORT = "SUPPORT";
  IfcPileTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPileTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPipeFittingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPipeFittingTypeEnum.BEND = "BEND";
  IfcPipeFittingTypeEnum.CONNECTOR = "CONNECTOR";
  IfcPipeFittingTypeEnum.ENTRY = "ENTRY";
  IfcPipeFittingTypeEnum.EXIT = "EXIT";
  IfcPipeFittingTypeEnum.JUNCTION = "JUNCTION";
  IfcPipeFittingTypeEnum.OBSTRUCTION = "OBSTRUCTION";
  IfcPipeFittingTypeEnum.TRANSITION = "TRANSITION";
  IfcPipeFittingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPipeFittingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPipeSegmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPipeSegmentTypeEnum.CULVERT = "CULVERT";
  IfcPipeSegmentTypeEnum.FLEXIBLESEGMENT = "FLEXIBLESEGMENT";
  IfcPipeSegmentTypeEnum.RIGIDSEGMENT = "RIGIDSEGMENT";
  IfcPipeSegmentTypeEnum.GUTTER = "GUTTER";
  IfcPipeSegmentTypeEnum.SPOOL = "SPOOL";
  IfcPipeSegmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPipeSegmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPlateTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPlateTypeEnum.CURTAIN_PANEL = "CURTAIN_PANEL";
  IfcPlateTypeEnum.SHEET = "SHEET";
  IfcPlateTypeEnum.FLANGE_PLATE = "FLANGE_PLATE";
  IfcPlateTypeEnum.WEB_PLATE = "WEB_PLATE";
  IfcPlateTypeEnum.STIFFENER_PLATE = "STIFFENER_PLATE";
  IfcPlateTypeEnum.GUSSET_PLATE = "GUSSET_PLATE";
  IfcPlateTypeEnum.COVER_PLATE = "COVER_PLATE";
  IfcPlateTypeEnum.SPLICE_PLATE = "SPLICE_PLATE";
  IfcPlateTypeEnum.BASE_PLATE = "BASE_PLATE";
  IfcPlateTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPlateTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPreferredSurfaceCurveRepresentation = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPreferredSurfaceCurveRepresentation.CURVE3D = "CURVE3D";
  IfcPreferredSurfaceCurveRepresentation.PCURVE_S1 = "PCURVE_S1";
  IfcPreferredSurfaceCurveRepresentation.PCURVE_S2 = "PCURVE_S2";
  var IfcProcedureTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProcedureTypeEnum.ADVICE_CAUTION = "ADVICE_CAUTION";
  IfcProcedureTypeEnum.ADVICE_NOTE = "ADVICE_NOTE";
  IfcProcedureTypeEnum.ADVICE_WARNING = "ADVICE_WARNING";
  IfcProcedureTypeEnum.CALIBRATION = "CALIBRATION";
  IfcProcedureTypeEnum.DIAGNOSTIC = "DIAGNOSTIC";
  IfcProcedureTypeEnum.SHUTDOWN = "SHUTDOWN";
  IfcProcedureTypeEnum.STARTUP = "STARTUP";
  IfcProcedureTypeEnum.USERDEFINED = "USERDEFINED";
  IfcProcedureTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcProfileTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProfileTypeEnum.CURVE = "CURVE";
  IfcProfileTypeEnum.AREA = "AREA";
  var IfcProjectOrderTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProjectOrderTypeEnum.CHANGEORDER = "CHANGEORDER";
  IfcProjectOrderTypeEnum.MAINTENANCEWORKORDER = "MAINTENANCEWORKORDER";
  IfcProjectOrderTypeEnum.MOVEORDER = "MOVEORDER";
  IfcProjectOrderTypeEnum.PURCHASEORDER = "PURCHASEORDER";
  IfcProjectOrderTypeEnum.WORKORDER = "WORKORDER";
  IfcProjectOrderTypeEnum.USERDEFINED = "USERDEFINED";
  IfcProjectOrderTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcProjectedOrTrueLengthEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProjectedOrTrueLengthEnum.PROJECTED_LENGTH = "PROJECTED_LENGTH";
  IfcProjectedOrTrueLengthEnum.TRUE_LENGTH = "TRUE_LENGTH";
  var IfcProjectionElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProjectionElementTypeEnum.BLISTER = "BLISTER";
  IfcProjectionElementTypeEnum.DEVIATOR = "DEVIATOR";
  IfcProjectionElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcProjectionElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPropertySetTemplateTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENONLY = "PSET_TYPEDRIVENONLY";
  IfcPropertySetTemplateTypeEnum.PSET_TYPEDRIVENOVERRIDE = "PSET_TYPEDRIVENOVERRIDE";
  IfcPropertySetTemplateTypeEnum.PSET_OCCURRENCEDRIVEN = "PSET_OCCURRENCEDRIVEN";
  IfcPropertySetTemplateTypeEnum.PSET_PERFORMANCEDRIVEN = "PSET_PERFORMANCEDRIVEN";
  IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENONLY = "QTO_TYPEDRIVENONLY";
  IfcPropertySetTemplateTypeEnum.QTO_TYPEDRIVENOVERRIDE = "QTO_TYPEDRIVENOVERRIDE";
  IfcPropertySetTemplateTypeEnum.QTO_OCCURRENCEDRIVEN = "QTO_OCCURRENCEDRIVEN";
  IfcPropertySetTemplateTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcProtectiveDeviceTrippingUnitTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTRONIC = "ELECTRONIC";
  IfcProtectiveDeviceTrippingUnitTypeEnum.ELECTROMAGNETIC = "ELECTROMAGNETIC";
  IfcProtectiveDeviceTrippingUnitTypeEnum.RESIDUALCURRENT = "RESIDUALCURRENT";
  IfcProtectiveDeviceTrippingUnitTypeEnum.THERMAL = "THERMAL";
  IfcProtectiveDeviceTrippingUnitTypeEnum.USERDEFINED = "USERDEFINED";
  IfcProtectiveDeviceTrippingUnitTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcProtectiveDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcProtectiveDeviceTypeEnum.CIRCUITBREAKER = "CIRCUITBREAKER";
  IfcProtectiveDeviceTypeEnum.EARTHLEAKAGECIRCUITBREAKER = "EARTHLEAKAGECIRCUITBREAKER";
  IfcProtectiveDeviceTypeEnum.EARTHINGSWITCH = "EARTHINGSWITCH";
  IfcProtectiveDeviceTypeEnum.FUSEDISCONNECTOR = "FUSEDISCONNECTOR";
  IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTCIRCUITBREAKER = "RESIDUALCURRENTCIRCUITBREAKER";
  IfcProtectiveDeviceTypeEnum.RESIDUALCURRENTSWITCH = "RESIDUALCURRENTSWITCH";
  IfcProtectiveDeviceTypeEnum.VARISTOR = "VARISTOR";
  IfcProtectiveDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcProtectiveDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcPumpTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcPumpTypeEnum.CIRCULATOR = "CIRCULATOR";
  IfcPumpTypeEnum.ENDSUCTION = "ENDSUCTION";
  IfcPumpTypeEnum.SPLITCASE = "SPLITCASE";
  IfcPumpTypeEnum.SUBMERSIBLEPUMP = "SUBMERSIBLEPUMP";
  IfcPumpTypeEnum.SUMPPUMP = "SUMPPUMP";
  IfcPumpTypeEnum.VERTICALINLINE = "VERTICALINLINE";
  IfcPumpTypeEnum.VERTICALTURBINE = "VERTICALTURBINE";
  IfcPumpTypeEnum.USERDEFINED = "USERDEFINED";
  IfcPumpTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcRailingTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRailingTypeEnum.HANDRAIL = "HANDRAIL";
  IfcRailingTypeEnum.GUARDRAIL = "GUARDRAIL";
  IfcRailingTypeEnum.BALUSTRADE = "BALUSTRADE";
  IfcRailingTypeEnum.USERDEFINED = "USERDEFINED";
  IfcRailingTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcRampFlightTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRampFlightTypeEnum.STRAIGHT = "STRAIGHT";
  IfcRampFlightTypeEnum.SPIRAL = "SPIRAL";
  IfcRampFlightTypeEnum.USERDEFINED = "USERDEFINED";
  IfcRampFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcRampTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRampTypeEnum.STRAIGHT_RUN_RAMP = "STRAIGHT_RUN_RAMP";
  IfcRampTypeEnum.TWO_STRAIGHT_RUN_RAMP = "TWO_STRAIGHT_RUN_RAMP";
  IfcRampTypeEnum.QUARTER_TURN_RAMP = "QUARTER_TURN_RAMP";
  IfcRampTypeEnum.TWO_QUARTER_TURN_RAMP = "TWO_QUARTER_TURN_RAMP";
  IfcRampTypeEnum.HALF_TURN_RAMP = "HALF_TURN_RAMP";
  IfcRampTypeEnum.SPIRAL_RAMP = "SPIRAL_RAMP";
  IfcRampTypeEnum.USERDEFINED = "USERDEFINED";
  IfcRampTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcRecurrenceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRecurrenceTypeEnum.DAILY = "DAILY";
  IfcRecurrenceTypeEnum.WEEKLY = "WEEKLY";
  IfcRecurrenceTypeEnum.MONTHLY_BY_DAY_OF_MONTH = "MONTHLY_BY_DAY_OF_MONTH";
  IfcRecurrenceTypeEnum.MONTHLY_BY_POSITION = "MONTHLY_BY_POSITION";
  IfcRecurrenceTypeEnum.BY_DAY_COUNT = "BY_DAY_COUNT";
  IfcRecurrenceTypeEnum.BY_WEEKDAY_COUNT = "BY_WEEKDAY_COUNT";
  IfcRecurrenceTypeEnum.YEARLY_BY_DAY_OF_MONTH = "YEARLY_BY_DAY_OF_MONTH";
  IfcRecurrenceTypeEnum.YEARLY_BY_POSITION = "YEARLY_BY_POSITION";
  var IfcReferentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReferentTypeEnum.KILOPOINT = "KILOPOINT";
  IfcReferentTypeEnum.MILEPOINT = "MILEPOINT";
  IfcReferentTypeEnum.STATION = "STATION";
  IfcReferentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcReferentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcReflectanceMethodEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReflectanceMethodEnum.BLINN = "BLINN";
  IfcReflectanceMethodEnum.FLAT = "FLAT";
  IfcReflectanceMethodEnum.GLASS = "GLASS";
  IfcReflectanceMethodEnum.MATT = "MATT";
  IfcReflectanceMethodEnum.METAL = "METAL";
  IfcReflectanceMethodEnum.MIRROR = "MIRROR";
  IfcReflectanceMethodEnum.PHONG = "PHONG";
  IfcReflectanceMethodEnum.PLASTIC = "PLASTIC";
  IfcReflectanceMethodEnum.STRAUSS = "STRAUSS";
  IfcReflectanceMethodEnum.NOTDEFINED = "NOTDEFINED";
  var IfcReinforcingBarRoleEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReinforcingBarRoleEnum.MAIN = "MAIN";
  IfcReinforcingBarRoleEnum.SHEAR = "SHEAR";
  IfcReinforcingBarRoleEnum.LIGATURE = "LIGATURE";
  IfcReinforcingBarRoleEnum.STUD = "STUD";
  IfcReinforcingBarRoleEnum.PUNCHING = "PUNCHING";
  IfcReinforcingBarRoleEnum.EDGE = "EDGE";
  IfcReinforcingBarRoleEnum.RING = "RING";
  IfcReinforcingBarRoleEnum.ANCHORING = "ANCHORING";
  IfcReinforcingBarRoleEnum.USERDEFINED = "USERDEFINED";
  IfcReinforcingBarRoleEnum.NOTDEFINED = "NOTDEFINED";
  var IfcReinforcingBarSurfaceEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReinforcingBarSurfaceEnum.PLAIN = "PLAIN";
  IfcReinforcingBarSurfaceEnum.TEXTURED = "TEXTURED";
  var IfcReinforcingBarTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReinforcingBarTypeEnum.ANCHORING = "ANCHORING";
  IfcReinforcingBarTypeEnum.EDGE = "EDGE";
  IfcReinforcingBarTypeEnum.LIGATURE = "LIGATURE";
  IfcReinforcingBarTypeEnum.MAIN = "MAIN";
  IfcReinforcingBarTypeEnum.PUNCHING = "PUNCHING";
  IfcReinforcingBarTypeEnum.RING = "RING";
  IfcReinforcingBarTypeEnum.SHEAR = "SHEAR";
  IfcReinforcingBarTypeEnum.STUD = "STUD";
  IfcReinforcingBarTypeEnum.SPACEBAR = "SPACEBAR";
  IfcReinforcingBarTypeEnum.USERDEFINED = "USERDEFINED";
  IfcReinforcingBarTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcReinforcingMeshTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcReinforcingMeshTypeEnum.USERDEFINED = "USERDEFINED";
  IfcReinforcingMeshTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcRoleEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRoleEnum.SUPPLIER = "SUPPLIER";
  IfcRoleEnum.MANUFACTURER = "MANUFACTURER";
  IfcRoleEnum.CONTRACTOR = "CONTRACTOR";
  IfcRoleEnum.SUBCONTRACTOR = "SUBCONTRACTOR";
  IfcRoleEnum.ARCHITECT = "ARCHITECT";
  IfcRoleEnum.STRUCTURALENGINEER = "STRUCTURALENGINEER";
  IfcRoleEnum.COSTENGINEER = "COSTENGINEER";
  IfcRoleEnum.CLIENT = "CLIENT";
  IfcRoleEnum.BUILDINGOWNER = "BUILDINGOWNER";
  IfcRoleEnum.BUILDINGOPERATOR = "BUILDINGOPERATOR";
  IfcRoleEnum.MECHANICALENGINEER = "MECHANICALENGINEER";
  IfcRoleEnum.ELECTRICALENGINEER = "ELECTRICALENGINEER";
  IfcRoleEnum.PROJECTMANAGER = "PROJECTMANAGER";
  IfcRoleEnum.FACILITIESMANAGER = "FACILITIESMANAGER";
  IfcRoleEnum.CIVILENGINEER = "CIVILENGINEER";
  IfcRoleEnum.COMMISSIONINGENGINEER = "COMMISSIONINGENGINEER";
  IfcRoleEnum.ENGINEER = "ENGINEER";
  IfcRoleEnum.OWNER = "OWNER";
  IfcRoleEnum.CONSULTANT = "CONSULTANT";
  IfcRoleEnum.CONSTRUCTIONMANAGER = "CONSTRUCTIONMANAGER";
  IfcRoleEnum.FIELDCONSTRUCTIONMANAGER = "FIELDCONSTRUCTIONMANAGER";
  IfcRoleEnum.RESELLER = "RESELLER";
  IfcRoleEnum.USERDEFINED = "USERDEFINED";
  var IfcRoofTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcRoofTypeEnum.FLAT_ROOF = "FLAT_ROOF";
  IfcRoofTypeEnum.SHED_ROOF = "SHED_ROOF";
  IfcRoofTypeEnum.GABLE_ROOF = "GABLE_ROOF";
  IfcRoofTypeEnum.HIP_ROOF = "HIP_ROOF";
  IfcRoofTypeEnum.HIPPED_GABLE_ROOF = "HIPPED_GABLE_ROOF";
  IfcRoofTypeEnum.GAMBREL_ROOF = "GAMBREL_ROOF";
  IfcRoofTypeEnum.MANSARD_ROOF = "MANSARD_ROOF";
  IfcRoofTypeEnum.BARREL_ROOF = "BARREL_ROOF";
  IfcRoofTypeEnum.RAINBOW_ROOF = "RAINBOW_ROOF";
  IfcRoofTypeEnum.BUTTERFLY_ROOF = "BUTTERFLY_ROOF";
  IfcRoofTypeEnum.PAVILION_ROOF = "PAVILION_ROOF";
  IfcRoofTypeEnum.DOME_ROOF = "DOME_ROOF";
  IfcRoofTypeEnum.FREEFORM = "FREEFORM";
  IfcRoofTypeEnum.USERDEFINED = "USERDEFINED";
  IfcRoofTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSIPrefix = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSIPrefix.EXA = "EXA";
  IfcSIPrefix.PETA = "PETA";
  IfcSIPrefix.TERA = "TERA";
  IfcSIPrefix.GIGA = "GIGA";
  IfcSIPrefix.MEGA = "MEGA";
  IfcSIPrefix.KILO = "KILO";
  IfcSIPrefix.HECTO = "HECTO";
  IfcSIPrefix.DECA = "DECA";
  IfcSIPrefix.DECI = "DECI";
  IfcSIPrefix.CENTI = "CENTI";
  IfcSIPrefix.MILLI = "MILLI";
  IfcSIPrefix.MICRO = "MICRO";
  IfcSIPrefix.NANO = "NANO";
  IfcSIPrefix.PICO = "PICO";
  IfcSIPrefix.FEMTO = "FEMTO";
  IfcSIPrefix.ATTO = "ATTO";
  var IfcSIUnitName = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSIUnitName.AMPERE = "AMPERE";
  IfcSIUnitName.BECQUEREL = "BECQUEREL";
  IfcSIUnitName.CANDELA = "CANDELA";
  IfcSIUnitName.COULOMB = "COULOMB";
  IfcSIUnitName.CUBIC_METRE = "CUBIC_METRE";
  IfcSIUnitName.DEGREE_CELSIUS = "DEGREE_CELSIUS";
  IfcSIUnitName.FARAD = "FARAD";
  IfcSIUnitName.GRAM = "GRAM";
  IfcSIUnitName.GRAY = "GRAY";
  IfcSIUnitName.HENRY = "HENRY";
  IfcSIUnitName.HERTZ = "HERTZ";
  IfcSIUnitName.JOULE = "JOULE";
  IfcSIUnitName.KELVIN = "KELVIN";
  IfcSIUnitName.LUMEN = "LUMEN";
  IfcSIUnitName.LUX = "LUX";
  IfcSIUnitName.METRE = "METRE";
  IfcSIUnitName.MOLE = "MOLE";
  IfcSIUnitName.NEWTON = "NEWTON";
  IfcSIUnitName.OHM = "OHM";
  IfcSIUnitName.PASCAL = "PASCAL";
  IfcSIUnitName.RADIAN = "RADIAN";
  IfcSIUnitName.SECOND = "SECOND";
  IfcSIUnitName.SIEMENS = "SIEMENS";
  IfcSIUnitName.SIEVERT = "SIEVERT";
  IfcSIUnitName.SQUARE_METRE = "SQUARE_METRE";
  IfcSIUnitName.STERADIAN = "STERADIAN";
  IfcSIUnitName.TESLA = "TESLA";
  IfcSIUnitName.VOLT = "VOLT";
  IfcSIUnitName.WATT = "WATT";
  IfcSIUnitName.WEBER = "WEBER";
  var IfcSanitaryTerminalTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSanitaryTerminalTypeEnum.BATH = "BATH";
  IfcSanitaryTerminalTypeEnum.BIDET = "BIDET";
  IfcSanitaryTerminalTypeEnum.CISTERN = "CISTERN";
  IfcSanitaryTerminalTypeEnum.SHOWER = "SHOWER";
  IfcSanitaryTerminalTypeEnum.SINK = "SINK";
  IfcSanitaryTerminalTypeEnum.SANITARYFOUNTAIN = "SANITARYFOUNTAIN";
  IfcSanitaryTerminalTypeEnum.TOILETPAN = "TOILETPAN";
  IfcSanitaryTerminalTypeEnum.URINAL = "URINAL";
  IfcSanitaryTerminalTypeEnum.WASHHANDBASIN = "WASHHANDBASIN";
  IfcSanitaryTerminalTypeEnum.WCSEAT = "WCSEAT";
  IfcSanitaryTerminalTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSanitaryTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSectionTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSectionTypeEnum.UNIFORM = "UNIFORM";
  IfcSectionTypeEnum.TAPERED = "TAPERED";
  var IfcSensorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSensorTypeEnum.COSENSOR = "COSENSOR";
  IfcSensorTypeEnum.CO2SENSOR = "CO2SENSOR";
  IfcSensorTypeEnum.CONDUCTANCESENSOR = "CONDUCTANCESENSOR";
  IfcSensorTypeEnum.CONTACTSENSOR = "CONTACTSENSOR";
  IfcSensorTypeEnum.FIRESENSOR = "FIRESENSOR";
  IfcSensorTypeEnum.FLOWSENSOR = "FLOWSENSOR";
  IfcSensorTypeEnum.FROSTSENSOR = "FROSTSENSOR";
  IfcSensorTypeEnum.GASSENSOR = "GASSENSOR";
  IfcSensorTypeEnum.HEATSENSOR = "HEATSENSOR";
  IfcSensorTypeEnum.HUMIDITYSENSOR = "HUMIDITYSENSOR";
  IfcSensorTypeEnum.IDENTIFIERSENSOR = "IDENTIFIERSENSOR";
  IfcSensorTypeEnum.IONCONCENTRATIONSENSOR = "IONCONCENTRATIONSENSOR";
  IfcSensorTypeEnum.LEVELSENSOR = "LEVELSENSOR";
  IfcSensorTypeEnum.LIGHTSENSOR = "LIGHTSENSOR";
  IfcSensorTypeEnum.MOISTURESENSOR = "MOISTURESENSOR";
  IfcSensorTypeEnum.MOVEMENTSENSOR = "MOVEMENTSENSOR";
  IfcSensorTypeEnum.PHSENSOR = "PHSENSOR";
  IfcSensorTypeEnum.PRESSURESENSOR = "PRESSURESENSOR";
  IfcSensorTypeEnum.RADIATIONSENSOR = "RADIATIONSENSOR";
  IfcSensorTypeEnum.RADIOACTIVITYSENSOR = "RADIOACTIVITYSENSOR";
  IfcSensorTypeEnum.SMOKESENSOR = "SMOKESENSOR";
  IfcSensorTypeEnum.SOUNDSENSOR = "SOUNDSENSOR";
  IfcSensorTypeEnum.TEMPERATURESENSOR = "TEMPERATURESENSOR";
  IfcSensorTypeEnum.WINDSENSOR = "WINDSENSOR";
  IfcSensorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSensorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSequenceEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSequenceEnum.START_START = "START_START";
  IfcSequenceEnum.START_FINISH = "START_FINISH";
  IfcSequenceEnum.FINISH_START = "FINISH_START";
  IfcSequenceEnum.FINISH_FINISH = "FINISH_FINISH";
  IfcSequenceEnum.USERDEFINED = "USERDEFINED";
  IfcSequenceEnum.NOTDEFINED = "NOTDEFINED";
  var IfcShadingDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcShadingDeviceTypeEnum.JALOUSIE = "JALOUSIE";
  IfcShadingDeviceTypeEnum.SHUTTER = "SHUTTER";
  IfcShadingDeviceTypeEnum.AWNING = "AWNING";
  IfcShadingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcShadingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSimplePropertyTemplateTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSimplePropertyTemplateTypeEnum.P_SINGLEVALUE = "P_SINGLEVALUE";
  IfcSimplePropertyTemplateTypeEnum.P_ENUMERATEDVALUE = "P_ENUMERATEDVALUE";
  IfcSimplePropertyTemplateTypeEnum.P_BOUNDEDVALUE = "P_BOUNDEDVALUE";
  IfcSimplePropertyTemplateTypeEnum.P_LISTVALUE = "P_LISTVALUE";
  IfcSimplePropertyTemplateTypeEnum.P_TABLEVALUE = "P_TABLEVALUE";
  IfcSimplePropertyTemplateTypeEnum.P_REFERENCEVALUE = "P_REFERENCEVALUE";
  IfcSimplePropertyTemplateTypeEnum.Q_LENGTH = "Q_LENGTH";
  IfcSimplePropertyTemplateTypeEnum.Q_AREA = "Q_AREA";
  IfcSimplePropertyTemplateTypeEnum.Q_VOLUME = "Q_VOLUME";
  IfcSimplePropertyTemplateTypeEnum.Q_COUNT = "Q_COUNT";
  IfcSimplePropertyTemplateTypeEnum.Q_WEIGHT = "Q_WEIGHT";
  IfcSimplePropertyTemplateTypeEnum.Q_TIME = "Q_TIME";
  var IfcSlabTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSlabTypeEnum.FLOOR = "FLOOR";
  IfcSlabTypeEnum.ROOF = "ROOF";
  IfcSlabTypeEnum.LANDING = "LANDING";
  IfcSlabTypeEnum.BASESLAB = "BASESLAB";
  IfcSlabTypeEnum.APPROACH_SLAB = "APPROACH_SLAB";
  IfcSlabTypeEnum.PAVING = "PAVING";
  IfcSlabTypeEnum.WEARING = "WEARING";
  IfcSlabTypeEnum.SIDEWALK = "SIDEWALK";
  IfcSlabTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSlabTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSolarDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSolarDeviceTypeEnum.SOLARCOLLECTOR = "SOLARCOLLECTOR";
  IfcSolarDeviceTypeEnum.SOLARPANEL = "SOLARPANEL";
  IfcSolarDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSolarDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSpaceHeaterTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSpaceHeaterTypeEnum.CONVECTOR = "CONVECTOR";
  IfcSpaceHeaterTypeEnum.RADIATOR = "RADIATOR";
  IfcSpaceHeaterTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSpaceHeaterTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSpaceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSpaceTypeEnum.SPACE = "SPACE";
  IfcSpaceTypeEnum.PARKING = "PARKING";
  IfcSpaceTypeEnum.GFA = "GFA";
  IfcSpaceTypeEnum.INTERNAL = "INTERNAL";
  IfcSpaceTypeEnum.EXTERNAL = "EXTERNAL";
  IfcSpaceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSpaceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSpatialZoneTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSpatialZoneTypeEnum.CONSTRUCTION = "CONSTRUCTION";
  IfcSpatialZoneTypeEnum.FIRESAFETY = "FIRESAFETY";
  IfcSpatialZoneTypeEnum.LIGHTING = "LIGHTING";
  IfcSpatialZoneTypeEnum.OCCUPANCY = "OCCUPANCY";
  IfcSpatialZoneTypeEnum.SECURITY = "SECURITY";
  IfcSpatialZoneTypeEnum.THERMAL = "THERMAL";
  IfcSpatialZoneTypeEnum.TRANSPORT = "TRANSPORT";
  IfcSpatialZoneTypeEnum.VENTILATION = "VENTILATION";
  IfcSpatialZoneTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSpatialZoneTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStackTerminalTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStackTerminalTypeEnum.BIRDCAGE = "BIRDCAGE";
  IfcStackTerminalTypeEnum.COWL = "COWL";
  IfcStackTerminalTypeEnum.RAINWATERHOPPER = "RAINWATERHOPPER";
  IfcStackTerminalTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStackTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStairFlightTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStairFlightTypeEnum.STRAIGHT = "STRAIGHT";
  IfcStairFlightTypeEnum.WINDER = "WINDER";
  IfcStairFlightTypeEnum.SPIRAL = "SPIRAL";
  IfcStairFlightTypeEnum.CURVED = "CURVED";
  IfcStairFlightTypeEnum.FREEFORM = "FREEFORM";
  IfcStairFlightTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStairFlightTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStairTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStairTypeEnum.STRAIGHT_RUN_STAIR = "STRAIGHT_RUN_STAIR";
  IfcStairTypeEnum.TWO_STRAIGHT_RUN_STAIR = "TWO_STRAIGHT_RUN_STAIR";
  IfcStairTypeEnum.QUARTER_WINDING_STAIR = "QUARTER_WINDING_STAIR";
  IfcStairTypeEnum.QUARTER_TURN_STAIR = "QUARTER_TURN_STAIR";
  IfcStairTypeEnum.HALF_WINDING_STAIR = "HALF_WINDING_STAIR";
  IfcStairTypeEnum.HALF_TURN_STAIR = "HALF_TURN_STAIR";
  IfcStairTypeEnum.TWO_QUARTER_WINDING_STAIR = "TWO_QUARTER_WINDING_STAIR";
  IfcStairTypeEnum.TWO_QUARTER_TURN_STAIR = "TWO_QUARTER_TURN_STAIR";
  IfcStairTypeEnum.THREE_QUARTER_WINDING_STAIR = "THREE_QUARTER_WINDING_STAIR";
  IfcStairTypeEnum.THREE_QUARTER_TURN_STAIR = "THREE_QUARTER_TURN_STAIR";
  IfcStairTypeEnum.SPIRAL_STAIR = "SPIRAL_STAIR";
  IfcStairTypeEnum.DOUBLE_RETURN_STAIR = "DOUBLE_RETURN_STAIR";
  IfcStairTypeEnum.CURVED_RUN_STAIR = "CURVED_RUN_STAIR";
  IfcStairTypeEnum.TWO_CURVED_RUN_STAIR = "TWO_CURVED_RUN_STAIR";
  IfcStairTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStairTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStateEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStateEnum.READWRITE = "READWRITE";
  IfcStateEnum.READONLY = "READONLY";
  IfcStateEnum.LOCKED = "LOCKED";
  IfcStateEnum.READWRITELOCKED = "READWRITELOCKED";
  IfcStateEnum.READONLYLOCKED = "READONLYLOCKED";
  var IfcStructuralCurveActivityTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStructuralCurveActivityTypeEnum.CONST = "CONST";
  IfcStructuralCurveActivityTypeEnum.LINEAR = "LINEAR";
  IfcStructuralCurveActivityTypeEnum.POLYGONAL = "POLYGONAL";
  IfcStructuralCurveActivityTypeEnum.EQUIDISTANT = "EQUIDISTANT";
  IfcStructuralCurveActivityTypeEnum.SINUS = "SINUS";
  IfcStructuralCurveActivityTypeEnum.PARABOLA = "PARABOLA";
  IfcStructuralCurveActivityTypeEnum.DISCRETE = "DISCRETE";
  IfcStructuralCurveActivityTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStructuralCurveActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStructuralCurveMemberTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStructuralCurveMemberTypeEnum.RIGID_JOINED_MEMBER = "RIGID_JOINED_MEMBER";
  IfcStructuralCurveMemberTypeEnum.PIN_JOINED_MEMBER = "PIN_JOINED_MEMBER";
  IfcStructuralCurveMemberTypeEnum.CABLE = "CABLE";
  IfcStructuralCurveMemberTypeEnum.TENSION_MEMBER = "TENSION_MEMBER";
  IfcStructuralCurveMemberTypeEnum.COMPRESSION_MEMBER = "COMPRESSION_MEMBER";
  IfcStructuralCurveMemberTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStructuralCurveMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStructuralSurfaceActivityTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStructuralSurfaceActivityTypeEnum.CONST = "CONST";
  IfcStructuralSurfaceActivityTypeEnum.BILINEAR = "BILINEAR";
  IfcStructuralSurfaceActivityTypeEnum.DISCRETE = "DISCRETE";
  IfcStructuralSurfaceActivityTypeEnum.ISOCONTOUR = "ISOCONTOUR";
  IfcStructuralSurfaceActivityTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStructuralSurfaceActivityTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcStructuralSurfaceMemberTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcStructuralSurfaceMemberTypeEnum.BENDING_ELEMENT = "BENDING_ELEMENT";
  IfcStructuralSurfaceMemberTypeEnum.MEMBRANE_ELEMENT = "MEMBRANE_ELEMENT";
  IfcStructuralSurfaceMemberTypeEnum.SHELL = "SHELL";
  IfcStructuralSurfaceMemberTypeEnum.USERDEFINED = "USERDEFINED";
  IfcStructuralSurfaceMemberTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSubContractResourceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSubContractResourceTypeEnum.PURCHASE = "PURCHASE";
  IfcSubContractResourceTypeEnum.WORK = "WORK";
  IfcSubContractResourceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSubContractResourceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSurfaceFeatureTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSurfaceFeatureTypeEnum.MARK = "MARK";
  IfcSurfaceFeatureTypeEnum.TAG = "TAG";
  IfcSurfaceFeatureTypeEnum.TREATMENT = "TREATMENT";
  IfcSurfaceFeatureTypeEnum.DEFECT = "DEFECT";
  IfcSurfaceFeatureTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSurfaceFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSurfaceSide = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSurfaceSide.POSITIVE = "POSITIVE";
  IfcSurfaceSide.NEGATIVE = "NEGATIVE";
  IfcSurfaceSide.BOTH = "BOTH";
  var IfcSwitchingDeviceTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSwitchingDeviceTypeEnum.CONTACTOR = "CONTACTOR";
  IfcSwitchingDeviceTypeEnum.DIMMERSWITCH = "DIMMERSWITCH";
  IfcSwitchingDeviceTypeEnum.EMERGENCYSTOP = "EMERGENCYSTOP";
  IfcSwitchingDeviceTypeEnum.KEYPAD = "KEYPAD";
  IfcSwitchingDeviceTypeEnum.MOMENTARYSWITCH = "MOMENTARYSWITCH";
  IfcSwitchingDeviceTypeEnum.SELECTORSWITCH = "SELECTORSWITCH";
  IfcSwitchingDeviceTypeEnum.STARTER = "STARTER";
  IfcSwitchingDeviceTypeEnum.SWITCHDISCONNECTOR = "SWITCHDISCONNECTOR";
  IfcSwitchingDeviceTypeEnum.TOGGLESWITCH = "TOGGLESWITCH";
  IfcSwitchingDeviceTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSwitchingDeviceTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcSystemFurnitureElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcSystemFurnitureElementTypeEnum.PANEL = "PANEL";
  IfcSystemFurnitureElementTypeEnum.WORKSURFACE = "WORKSURFACE";
  IfcSystemFurnitureElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcSystemFurnitureElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTankTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTankTypeEnum.BASIN = "BASIN";
  IfcTankTypeEnum.BREAKPRESSURE = "BREAKPRESSURE";
  IfcTankTypeEnum.EXPANSION = "EXPANSION";
  IfcTankTypeEnum.FEEDANDEXPANSION = "FEEDANDEXPANSION";
  IfcTankTypeEnum.PRESSUREVESSEL = "PRESSUREVESSEL";
  IfcTankTypeEnum.STORAGE = "STORAGE";
  IfcTankTypeEnum.VESSEL = "VESSEL";
  IfcTankTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTankTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTaskDurationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTaskDurationEnum.ELAPSEDTIME = "ELAPSEDTIME";
  IfcTaskDurationEnum.WORKTIME = "WORKTIME";
  IfcTaskDurationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTaskTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTaskTypeEnum.ATTENDANCE = "ATTENDANCE";
  IfcTaskTypeEnum.CONSTRUCTION = "CONSTRUCTION";
  IfcTaskTypeEnum.DEMOLITION = "DEMOLITION";
  IfcTaskTypeEnum.DISMANTLE = "DISMANTLE";
  IfcTaskTypeEnum.DISPOSAL = "DISPOSAL";
  IfcTaskTypeEnum.INSTALLATION = "INSTALLATION";
  IfcTaskTypeEnum.LOGISTIC = "LOGISTIC";
  IfcTaskTypeEnum.MAINTENANCE = "MAINTENANCE";
  IfcTaskTypeEnum.MOVE = "MOVE";
  IfcTaskTypeEnum.OPERATION = "OPERATION";
  IfcTaskTypeEnum.REMOVAL = "REMOVAL";
  IfcTaskTypeEnum.RENOVATION = "RENOVATION";
  IfcTaskTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTaskTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTendonAnchorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTendonAnchorTypeEnum.COUPLER = "COUPLER";
  IfcTendonAnchorTypeEnum.FIXED_END = "FIXED_END";
  IfcTendonAnchorTypeEnum.TENSIONING_END = "TENSIONING_END";
  IfcTendonAnchorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTendonAnchorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTendonConduitTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTendonConduitTypeEnum.DUCT = "DUCT";
  IfcTendonConduitTypeEnum.COUPLER = "COUPLER";
  IfcTendonConduitTypeEnum.GROUTING_DUCT = "GROUTING_DUCT";
  IfcTendonConduitTypeEnum.TRUMPET = "TRUMPET";
  IfcTendonConduitTypeEnum.DIABOLO = "DIABOLO";
  IfcTendonConduitTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTendonConduitTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTendonTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTendonTypeEnum.BAR = "BAR";
  IfcTendonTypeEnum.COATED = "COATED";
  IfcTendonTypeEnum.STRAND = "STRAND";
  IfcTendonTypeEnum.WIRE = "WIRE";
  IfcTendonTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTendonTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTextPath = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTextPath.LEFT = "LEFT";
  IfcTextPath.RIGHT = "RIGHT";
  IfcTextPath.UP = "UP";
  IfcTextPath.DOWN = "DOWN";
  var IfcTimeSeriesDataTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTimeSeriesDataTypeEnum.CONTINUOUS = "CONTINUOUS";
  IfcTimeSeriesDataTypeEnum.DISCRETE = "DISCRETE";
  IfcTimeSeriesDataTypeEnum.DISCRETEBINARY = "DISCRETEBINARY";
  IfcTimeSeriesDataTypeEnum.PIECEWISEBINARY = "PIECEWISEBINARY";
  IfcTimeSeriesDataTypeEnum.PIECEWISECONSTANT = "PIECEWISECONSTANT";
  IfcTimeSeriesDataTypeEnum.PIECEWISECONTINUOUS = "PIECEWISECONTINUOUS";
  IfcTimeSeriesDataTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTransformerTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTransformerTypeEnum.CURRENT = "CURRENT";
  IfcTransformerTypeEnum.FREQUENCY = "FREQUENCY";
  IfcTransformerTypeEnum.INVERTER = "INVERTER";
  IfcTransformerTypeEnum.RECTIFIER = "RECTIFIER";
  IfcTransformerTypeEnum.VOLTAGE = "VOLTAGE";
  IfcTransformerTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTransformerTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTransitionCode = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTransitionCode.DISCONTINUOUS = "DISCONTINUOUS";
  IfcTransitionCode.CONTINUOUS = "CONTINUOUS";
  IfcTransitionCode.CONTSAMEGRADIENT = "CONTSAMEGRADIENT";
  IfcTransitionCode.CONTSAMEGRADIENTSAMECURVATURE = "CONTSAMEGRADIENTSAMECURVATURE";
  var IfcTransitionCurveType = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTransitionCurveType.BIQUADRATICPARABOLA = "BIQUADRATICPARABOLA";
  IfcTransitionCurveType.BLOSSCURVE = "BLOSSCURVE";
  IfcTransitionCurveType.CLOTHOIDCURVE = "CLOTHOIDCURVE";
  IfcTransitionCurveType.COSINECURVE = "COSINECURVE";
  IfcTransitionCurveType.CUBICPARABOLA = "CUBICPARABOLA";
  IfcTransitionCurveType.SINECURVE = "SINECURVE";
  var IfcTransportElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTransportElementTypeEnum.ELEVATOR = "ELEVATOR";
  IfcTransportElementTypeEnum.ESCALATOR = "ESCALATOR";
  IfcTransportElementTypeEnum.MOVINGWALKWAY = "MOVINGWALKWAY";
  IfcTransportElementTypeEnum.CRANEWAY = "CRANEWAY";
  IfcTransportElementTypeEnum.LIFTINGGEAR = "LIFTINGGEAR";
  IfcTransportElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTransportElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcTrimmingPreference = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTrimmingPreference.CARTESIAN = "CARTESIAN";
  IfcTrimmingPreference.PARAMETER = "PARAMETER";
  IfcTrimmingPreference.UNSPECIFIED = "UNSPECIFIED";
  var IfcTubeBundleTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcTubeBundleTypeEnum.FINNED = "FINNED";
  IfcTubeBundleTypeEnum.USERDEFINED = "USERDEFINED";
  IfcTubeBundleTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcUnitEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcUnitEnum.ABSORBEDDOSEUNIT = "ABSORBEDDOSEUNIT";
  IfcUnitEnum.AMOUNTOFSUBSTANCEUNIT = "AMOUNTOFSUBSTANCEUNIT";
  IfcUnitEnum.AREAUNIT = "AREAUNIT";
  IfcUnitEnum.DOSEEQUIVALENTUNIT = "DOSEEQUIVALENTUNIT";
  IfcUnitEnum.ELECTRICCAPACITANCEUNIT = "ELECTRICCAPACITANCEUNIT";
  IfcUnitEnum.ELECTRICCHARGEUNIT = "ELECTRICCHARGEUNIT";
  IfcUnitEnum.ELECTRICCONDUCTANCEUNIT = "ELECTRICCONDUCTANCEUNIT";
  IfcUnitEnum.ELECTRICCURRENTUNIT = "ELECTRICCURRENTUNIT";
  IfcUnitEnum.ELECTRICRESISTANCEUNIT = "ELECTRICRESISTANCEUNIT";
  IfcUnitEnum.ELECTRICVOLTAGEUNIT = "ELECTRICVOLTAGEUNIT";
  IfcUnitEnum.ENERGYUNIT = "ENERGYUNIT";
  IfcUnitEnum.FORCEUNIT = "FORCEUNIT";
  IfcUnitEnum.FREQUENCYUNIT = "FREQUENCYUNIT";
  IfcUnitEnum.ILLUMINANCEUNIT = "ILLUMINANCEUNIT";
  IfcUnitEnum.INDUCTANCEUNIT = "INDUCTANCEUNIT";
  IfcUnitEnum.LENGTHUNIT = "LENGTHUNIT";
  IfcUnitEnum.LUMINOUSFLUXUNIT = "LUMINOUSFLUXUNIT";
  IfcUnitEnum.LUMINOUSINTENSITYUNIT = "LUMINOUSINTENSITYUNIT";
  IfcUnitEnum.MAGNETICFLUXDENSITYUNIT = "MAGNETICFLUXDENSITYUNIT";
  IfcUnitEnum.MAGNETICFLUXUNIT = "MAGNETICFLUXUNIT";
  IfcUnitEnum.MASSUNIT = "MASSUNIT";
  IfcUnitEnum.PLANEANGLEUNIT = "PLANEANGLEUNIT";
  IfcUnitEnum.POWERUNIT = "POWERUNIT";
  IfcUnitEnum.PRESSUREUNIT = "PRESSUREUNIT";
  IfcUnitEnum.RADIOACTIVITYUNIT = "RADIOACTIVITYUNIT";
  IfcUnitEnum.SOLIDANGLEUNIT = "SOLIDANGLEUNIT";
  IfcUnitEnum.THERMODYNAMICTEMPERATUREUNIT = "THERMODYNAMICTEMPERATUREUNIT";
  IfcUnitEnum.TIMEUNIT = "TIMEUNIT";
  IfcUnitEnum.VOLUMEUNIT = "VOLUMEUNIT";
  IfcUnitEnum.USERDEFINED = "USERDEFINED";
  var IfcUnitaryControlElementTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcUnitaryControlElementTypeEnum.ALARMPANEL = "ALARMPANEL";
  IfcUnitaryControlElementTypeEnum.CONTROLPANEL = "CONTROLPANEL";
  IfcUnitaryControlElementTypeEnum.GASDETECTIONPANEL = "GASDETECTIONPANEL";
  IfcUnitaryControlElementTypeEnum.INDICATORPANEL = "INDICATORPANEL";
  IfcUnitaryControlElementTypeEnum.MIMICPANEL = "MIMICPANEL";
  IfcUnitaryControlElementTypeEnum.HUMIDISTAT = "HUMIDISTAT";
  IfcUnitaryControlElementTypeEnum.THERMOSTAT = "THERMOSTAT";
  IfcUnitaryControlElementTypeEnum.WEATHERSTATION = "WEATHERSTATION";
  IfcUnitaryControlElementTypeEnum.USERDEFINED = "USERDEFINED";
  IfcUnitaryControlElementTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcUnitaryEquipmentTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcUnitaryEquipmentTypeEnum.AIRHANDLER = "AIRHANDLER";
  IfcUnitaryEquipmentTypeEnum.AIRCONDITIONINGUNIT = "AIRCONDITIONINGUNIT";
  IfcUnitaryEquipmentTypeEnum.DEHUMIDIFIER = "DEHUMIDIFIER";
  IfcUnitaryEquipmentTypeEnum.SPLITSYSTEM = "SPLITSYSTEM";
  IfcUnitaryEquipmentTypeEnum.ROOFTOPUNIT = "ROOFTOPUNIT";
  IfcUnitaryEquipmentTypeEnum.USERDEFINED = "USERDEFINED";
  IfcUnitaryEquipmentTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcValveTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcValveTypeEnum.AIRRELEASE = "AIRRELEASE";
  IfcValveTypeEnum.ANTIVACUUM = "ANTIVACUUM";
  IfcValveTypeEnum.CHANGEOVER = "CHANGEOVER";
  IfcValveTypeEnum.CHECK = "CHECK";
  IfcValveTypeEnum.COMMISSIONING = "COMMISSIONING";
  IfcValveTypeEnum.DIVERTING = "DIVERTING";
  IfcValveTypeEnum.DRAWOFFCOCK = "DRAWOFFCOCK";
  IfcValveTypeEnum.DOUBLECHECK = "DOUBLECHECK";
  IfcValveTypeEnum.DOUBLEREGULATING = "DOUBLEREGULATING";
  IfcValveTypeEnum.FAUCET = "FAUCET";
  IfcValveTypeEnum.FLUSHING = "FLUSHING";
  IfcValveTypeEnum.GASCOCK = "GASCOCK";
  IfcValveTypeEnum.GASTAP = "GASTAP";
  IfcValveTypeEnum.ISOLATING = "ISOLATING";
  IfcValveTypeEnum.MIXING = "MIXING";
  IfcValveTypeEnum.PRESSUREREDUCING = "PRESSUREREDUCING";
  IfcValveTypeEnum.PRESSURERELIEF = "PRESSURERELIEF";
  IfcValveTypeEnum.REGULATING = "REGULATING";
  IfcValveTypeEnum.SAFETYCUTOFF = "SAFETYCUTOFF";
  IfcValveTypeEnum.STEAMTRAP = "STEAMTRAP";
  IfcValveTypeEnum.STOPCOCK = "STOPCOCK";
  IfcValveTypeEnum.USERDEFINED = "USERDEFINED";
  IfcValveTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcVibrationDamperTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcVibrationDamperTypeEnum.BENDING_YIELD = "BENDING_YIELD";
  IfcVibrationDamperTypeEnum.SHEAR_YIELD = "SHEAR_YIELD";
  IfcVibrationDamperTypeEnum.AXIAL_YIELD = "AXIAL_YIELD";
  IfcVibrationDamperTypeEnum.FRICTION = "FRICTION";
  IfcVibrationDamperTypeEnum.VISCOUS = "VISCOUS";
  IfcVibrationDamperTypeEnum.RUBBER = "RUBBER";
  IfcVibrationDamperTypeEnum.USERDEFINED = "USERDEFINED";
  IfcVibrationDamperTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcVibrationIsolatorTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcVibrationIsolatorTypeEnum.COMPRESSION = "COMPRESSION";
  IfcVibrationIsolatorTypeEnum.SPRING = "SPRING";
  IfcVibrationIsolatorTypeEnum.BASE = "BASE";
  IfcVibrationIsolatorTypeEnum.USERDEFINED = "USERDEFINED";
  IfcVibrationIsolatorTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcVoidingFeatureTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcVoidingFeatureTypeEnum.CUTOUT = "CUTOUT";
  IfcVoidingFeatureTypeEnum.NOTCH = "NOTCH";
  IfcVoidingFeatureTypeEnum.HOLE = "HOLE";
  IfcVoidingFeatureTypeEnum.MITER = "MITER";
  IfcVoidingFeatureTypeEnum.CHAMFER = "CHAMFER";
  IfcVoidingFeatureTypeEnum.EDGE = "EDGE";
  IfcVoidingFeatureTypeEnum.USERDEFINED = "USERDEFINED";
  IfcVoidingFeatureTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWallTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWallTypeEnum.MOVABLE = "MOVABLE";
  IfcWallTypeEnum.PARAPET = "PARAPET";
  IfcWallTypeEnum.PARTITIONING = "PARTITIONING";
  IfcWallTypeEnum.PLUMBINGWALL = "PLUMBINGWALL";
  IfcWallTypeEnum.SHEAR = "SHEAR";
  IfcWallTypeEnum.SOLIDWALL = "SOLIDWALL";
  IfcWallTypeEnum.STANDARD = "STANDARD";
  IfcWallTypeEnum.POLYGONAL = "POLYGONAL";
  IfcWallTypeEnum.ELEMENTEDWALL = "ELEMENTEDWALL";
  IfcWallTypeEnum.RETAININGWALL = "RETAININGWALL";
  IfcWallTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWallTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWasteTerminalTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWasteTerminalTypeEnum.FLOORTRAP = "FLOORTRAP";
  IfcWasteTerminalTypeEnum.FLOORWASTE = "FLOORWASTE";
  IfcWasteTerminalTypeEnum.GULLYSUMP = "GULLYSUMP";
  IfcWasteTerminalTypeEnum.GULLYTRAP = "GULLYTRAP";
  IfcWasteTerminalTypeEnum.ROOFDRAIN = "ROOFDRAIN";
  IfcWasteTerminalTypeEnum.WASTEDISPOSALUNIT = "WASTEDISPOSALUNIT";
  IfcWasteTerminalTypeEnum.WASTETRAP = "WASTETRAP";
  IfcWasteTerminalTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWasteTerminalTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowPanelOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowPanelOperationEnum.SIDEHUNGRIGHTHAND = "SIDEHUNGRIGHTHAND";
  IfcWindowPanelOperationEnum.SIDEHUNGLEFTHAND = "SIDEHUNGLEFTHAND";
  IfcWindowPanelOperationEnum.TILTANDTURNRIGHTHAND = "TILTANDTURNRIGHTHAND";
  IfcWindowPanelOperationEnum.TILTANDTURNLEFTHAND = "TILTANDTURNLEFTHAND";
  IfcWindowPanelOperationEnum.TOPHUNG = "TOPHUNG";
  IfcWindowPanelOperationEnum.BOTTOMHUNG = "BOTTOMHUNG";
  IfcWindowPanelOperationEnum.PIVOTHORIZONTAL = "PIVOTHORIZONTAL";
  IfcWindowPanelOperationEnum.PIVOTVERTICAL = "PIVOTVERTICAL";
  IfcWindowPanelOperationEnum.SLIDINGHORIZONTAL = "SLIDINGHORIZONTAL";
  IfcWindowPanelOperationEnum.SLIDINGVERTICAL = "SLIDINGVERTICAL";
  IfcWindowPanelOperationEnum.REMOVABLECASEMENT = "REMOVABLECASEMENT";
  IfcWindowPanelOperationEnum.FIXEDCASEMENT = "FIXEDCASEMENT";
  IfcWindowPanelOperationEnum.OTHEROPERATION = "OTHEROPERATION";
  IfcWindowPanelOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowPanelPositionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowPanelPositionEnum.LEFT = "LEFT";
  IfcWindowPanelPositionEnum.MIDDLE = "MIDDLE";
  IfcWindowPanelPositionEnum.RIGHT = "RIGHT";
  IfcWindowPanelPositionEnum.BOTTOM = "BOTTOM";
  IfcWindowPanelPositionEnum.TOP = "TOP";
  IfcWindowPanelPositionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowStyleConstructionEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowStyleConstructionEnum.ALUMINIUM = "ALUMINIUM";
  IfcWindowStyleConstructionEnum.HIGH_GRADE_STEEL = "HIGH_GRADE_STEEL";
  IfcWindowStyleConstructionEnum.STEEL = "STEEL";
  IfcWindowStyleConstructionEnum.WOOD = "WOOD";
  IfcWindowStyleConstructionEnum.ALUMINIUM_WOOD = "ALUMINIUM_WOOD";
  IfcWindowStyleConstructionEnum.PLASTIC = "PLASTIC";
  IfcWindowStyleConstructionEnum.OTHER_CONSTRUCTION = "OTHER_CONSTRUCTION";
  IfcWindowStyleConstructionEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowStyleOperationEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowStyleOperationEnum.SINGLE_PANEL = "SINGLE_PANEL";
  IfcWindowStyleOperationEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
  IfcWindowStyleOperationEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
  IfcWindowStyleOperationEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
  IfcWindowStyleOperationEnum.USERDEFINED = "USERDEFINED";
  IfcWindowStyleOperationEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowTypeEnum.WINDOW = "WINDOW";
  IfcWindowTypeEnum.SKYLIGHT = "SKYLIGHT";
  IfcWindowTypeEnum.LIGHTDOME = "LIGHTDOME";
  IfcWindowTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWindowTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWindowTypePartitioningEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWindowTypePartitioningEnum.SINGLE_PANEL = "SINGLE_PANEL";
  IfcWindowTypePartitioningEnum.DOUBLE_PANEL_VERTICAL = "DOUBLE_PANEL_VERTICAL";
  IfcWindowTypePartitioningEnum.DOUBLE_PANEL_HORIZONTAL = "DOUBLE_PANEL_HORIZONTAL";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_VERTICAL = "TRIPLE_PANEL_VERTICAL";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_BOTTOM = "TRIPLE_PANEL_BOTTOM";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_TOP = "TRIPLE_PANEL_TOP";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_LEFT = "TRIPLE_PANEL_LEFT";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_RIGHT = "TRIPLE_PANEL_RIGHT";
  IfcWindowTypePartitioningEnum.TRIPLE_PANEL_HORIZONTAL = "TRIPLE_PANEL_HORIZONTAL";
  IfcWindowTypePartitioningEnum.USERDEFINED = "USERDEFINED";
  IfcWindowTypePartitioningEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWorkCalendarTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWorkCalendarTypeEnum.FIRSTSHIFT = "FIRSTSHIFT";
  IfcWorkCalendarTypeEnum.SECONDSHIFT = "SECONDSHIFT";
  IfcWorkCalendarTypeEnum.THIRDSHIFT = "THIRDSHIFT";
  IfcWorkCalendarTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWorkCalendarTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWorkPlanTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWorkPlanTypeEnum.ACTUAL = "ACTUAL";
  IfcWorkPlanTypeEnum.BASELINE = "BASELINE";
  IfcWorkPlanTypeEnum.PLANNED = "PLANNED";
  IfcWorkPlanTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWorkPlanTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcWorkScheduleTypeEnum = class {
    constructor(v) {
      this.value = v;
    }
  };
  IfcWorkScheduleTypeEnum.ACTUAL = "ACTUAL";
  IfcWorkScheduleTypeEnum.BASELINE = "BASELINE";
  IfcWorkScheduleTypeEnum.PLANNED = "PLANNED";
  IfcWorkScheduleTypeEnum.USERDEFINED = "USERDEFINED";
  IfcWorkScheduleTypeEnum.NOTDEFINED = "NOTDEFINED";
  var IfcActionRequest = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Status);
      ;
      args.push(this.LongDescription);
      ;
      return args;
    }
  };
  var IfcActor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheActor = TheActor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheActor = tape[ptr++];
      return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.TheActor);
      ;
      return args;
    }
  };
  var IfcActorRole = class {
    constructor(expressID, type, Role, UserDefinedRole, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Role = Role;
      this.UserDefinedRole = UserDefinedRole;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Role = tape[ptr++];
      let UserDefinedRole = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Role);
      ;
      args.push(this.UserDefinedRole);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcActuator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcActuatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      ;
      args.push(this.Description);
      ;
      args.push(this.UserDefinedPurpose);
      ;
      return args;
    }
  };
  var IfcAdvancedBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcAdvancedBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      ;
      return args;
    }
  };
  var IfcAdvancedBrepWithVoids = class {
    constructor(expressID, type, Outer, Voids) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
      this.Voids = Voids;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      let Voids = tape[ptr++];
      return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      ;
      args.push(this.Voids);
      ;
      return args;
    }
  };
  var IfcAdvancedFace = class {
    constructor(expressID, type, Bounds, FaceSurface, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
      this.FaceSurface = FaceSurface;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      let FaceSurface = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      ;
      args.push(this.FaceSurface);
      ;
      args.push(this.SameSense);
      ;
      return args;
    }
  };
  var IfcAirTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAirTerminalBox = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAirTerminalBoxType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAirTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAirToAirHeatRecovery = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAirToAirHeatRecoveryType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAlarm = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAlarmType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAlignment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Axis = Axis;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Axis = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Axis);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAlignment2DHorizontal = class {
    constructor(expressID, type, StartDistAlong, Segments) {
      this.expressID = expressID;
      this.type = type;
      this.StartDistAlong = StartDistAlong;
      this.Segments = Segments;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartDistAlong = tape[ptr++];
      let Segments = tape[ptr++];
      return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
    }
    ToTape() {
      let args = [];
      args.push(this.StartDistAlong);
      ;
      args.push(this.Segments);
      ;
      return args;
    }
  };
  var IfcAlignment2DHorizontalSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.CurveGeometry = CurveGeometry;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let CurveGeometry = tape[ptr++];
      return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      args.push(this.CurveGeometry);
      ;
      return args;
    }
  };
  var IfcAlignment2DSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      return args;
    }
  };
  var IfcAlignment2DVerSegCircularArc = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
      this.Radius = Radius;
      this.IsConvex = IsConvex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      let Radius = tape[ptr++];
      let IsConvex = tape[ptr++];
      return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      args.push(this.StartDistAlong);
      ;
      args.push(this.HorizontalLength);
      ;
      args.push(this.StartHeight);
      ;
      args.push(this.StartGradient);
      ;
      args.push(this.Radius);
      ;
      args.push(this.IsConvex);
      ;
      return args;
    }
  };
  var IfcAlignment2DVerSegLine = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      args.push(this.StartDistAlong);
      ;
      args.push(this.HorizontalLength);
      ;
      args.push(this.StartHeight);
      ;
      args.push(this.StartGradient);
      ;
      return args;
    }
  };
  var IfcAlignment2DVerSegParabolicArc = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
      this.ParabolaConstant = ParabolaConstant;
      this.IsConvex = IsConvex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      let ParabolaConstant = tape[ptr++];
      let IsConvex = tape[ptr++];
      return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      args.push(this.StartDistAlong);
      ;
      args.push(this.HorizontalLength);
      ;
      args.push(this.StartHeight);
      ;
      args.push(this.StartGradient);
      ;
      args.push(this.ParabolaConstant);
      ;
      args.push(this.IsConvex);
      ;
      return args;
    }
  };
  var IfcAlignment2DVertical = class {
    constructor(expressID, type, Segments) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      return new IfcAlignment2DVertical(expressID, type, Segments);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      ;
      return args;
    }
  };
  var IfcAlignment2DVerticalSegment = class {
    constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
      this.expressID = expressID;
      this.type = type;
      this.TangentialContinuity = TangentialContinuity;
      this.StartTag = StartTag;
      this.EndTag = EndTag;
      this.StartDistAlong = StartDistAlong;
      this.HorizontalLength = HorizontalLength;
      this.StartHeight = StartHeight;
      this.StartGradient = StartGradient;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TangentialContinuity = tape[ptr++];
      let StartTag = tape[ptr++];
      let EndTag = tape[ptr++];
      let StartDistAlong = tape[ptr++];
      let HorizontalLength = tape[ptr++];
      let StartHeight = tape[ptr++];
      let StartGradient = tape[ptr++];
      return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
    }
    ToTape() {
      let args = [];
      args.push(this.TangentialContinuity);
      ;
      args.push(this.StartTag);
      ;
      args.push(this.EndTag);
      ;
      args.push(this.StartDistAlong);
      ;
      args.push(this.HorizontalLength);
      ;
      args.push(this.StartHeight);
      ;
      args.push(this.StartGradient);
      ;
      return args;
    }
  };
  var IfcAlignmentCurve = class {
    constructor(expressID, type, Horizontal, Vertical, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.Horizontal = Horizontal;
      this.Vertical = Vertical;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Horizontal = tape[ptr++];
      let Vertical = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.Horizontal);
      ;
      args.push(this.Vertical);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcAnnotation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcAnnotationFillArea = class {
    constructor(expressID, type, OuterBoundary, InnerBoundaries) {
      this.expressID = expressID;
      this.type = type;
      this.OuterBoundary = OuterBoundary;
      this.InnerBoundaries = InnerBoundaries;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let OuterBoundary = tape[ptr++];
      let InnerBoundaries = tape[ptr++];
      return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
    }
    ToTape() {
      let args = [];
      args.push(this.OuterBoundary);
      ;
      args.push(this.InnerBoundaries);
      ;
      return args;
    }
  };
  var IfcApplication = class {
    constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
      this.expressID = expressID;
      this.type = type;
      this.ApplicationDeveloper = ApplicationDeveloper;
      this.Version = Version;
      this.ApplicationFullName = ApplicationFullName;
      this.ApplicationIdentifier = ApplicationIdentifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ApplicationDeveloper = tape[ptr++];
      let Version = tape[ptr++];
      let ApplicationFullName = tape[ptr++];
      let ApplicationIdentifier = tape[ptr++];
      return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
    }
    ToTape() {
      let args = [];
      args.push(this.ApplicationDeveloper);
      ;
      args.push(this.Version);
      ;
      args.push(this.ApplicationFullName);
      ;
      args.push(this.ApplicationIdentifier);
      ;
      return args;
    }
  };
  var IfcAppliedValue = class {
    constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AppliedValue = AppliedValue;
      this.UnitBasis = UnitBasis;
      this.ApplicableDate = ApplicableDate;
      this.FixedUntilDate = FixedUntilDate;
      this.Category = Category;
      this.Condition = Condition;
      this.ArithmeticOperator = ArithmeticOperator;
      this.Components = Components;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AppliedValue = tape[ptr++];
      let UnitBasis = tape[ptr++];
      let ApplicableDate = tape[ptr++];
      let FixedUntilDate = tape[ptr++];
      let Category = tape[ptr++];
      let Condition = tape[ptr++];
      let ArithmeticOperator = tape[ptr++];
      let Components = tape[ptr++];
      return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.AppliedValue);
      ;
      args.push(this.UnitBasis);
      ;
      args.push(this.ApplicableDate);
      ;
      args.push(this.FixedUntilDate);
      ;
      args.push(this.Category);
      ;
      args.push(this.Condition);
      ;
      args.push(this.ArithmeticOperator);
      ;
      args.push(this.Components);
      ;
      return args;
    }
  };
  var IfcApproval = class {
    constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.Identifier = Identifier;
      this.Name = Name;
      this.Description = Description;
      this.TimeOfApproval = TimeOfApproval;
      this.Status = Status;
      this.Level = Level;
      this.Qualifier = Qualifier;
      this.RequestingApproval = RequestingApproval;
      this.GivingApproval = GivingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identifier = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TimeOfApproval = tape[ptr++];
      let Status = tape[ptr++];
      let Level = tape[ptr++];
      let Qualifier = tape[ptr++];
      let RequestingApproval = tape[ptr++];
      let GivingApproval = tape[ptr++];
      return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.Identifier);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.TimeOfApproval);
      ;
      args.push(this.Status);
      ;
      args.push(this.Level);
      ;
      args.push(this.Qualifier);
      ;
      args.push(this.RequestingApproval);
      ;
      args.push(this.GivingApproval);
      ;
      return args;
    }
  };
  var IfcApprovalRelationship = class {
    constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingApproval = RelatingApproval;
      this.RelatedApprovals = RelatedApprovals;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      let RelatedApprovals = tape[ptr++];
      return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingApproval);
      ;
      args.push(this.RelatedApprovals);
      ;
      return args;
    }
  };
  var IfcArbitraryClosedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.OuterCurve = OuterCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let OuterCurve = tape[ptr++];
      return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.OuterCurve);
      ;
      return args;
    }
  };
  var IfcArbitraryOpenProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Curve) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Curve = Curve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Curve = tape[ptr++];
      return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Curve);
      ;
      return args;
    }
  };
  var IfcArbitraryProfileDefWithVoids = class {
    constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.OuterCurve = OuterCurve;
      this.InnerCurves = InnerCurves;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let OuterCurve = tape[ptr++];
      let InnerCurves = tape[ptr++];
      return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.OuterCurve);
      ;
      args.push(this.InnerCurves);
      ;
      return args;
    }
  };
  var IfcAsset = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.OriginalValue = OriginalValue;
      this.CurrentValue = CurrentValue;
      this.TotalReplacementCost = TotalReplacementCost;
      this.Owner = Owner;
      this.User = User;
      this.ResponsiblePerson = ResponsiblePerson;
      this.IncorporationDate = IncorporationDate;
      this.DepreciatedValue = DepreciatedValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let OriginalValue = tape[ptr++];
      let CurrentValue = tape[ptr++];
      let TotalReplacementCost = tape[ptr++];
      let Owner = tape[ptr++];
      let User = tape[ptr++];
      let ResponsiblePerson = tape[ptr++];
      let IncorporationDate = tape[ptr++];
      let DepreciatedValue = tape[ptr++];
      return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.OriginalValue);
      ;
      args.push(this.CurrentValue);
      ;
      args.push(this.TotalReplacementCost);
      ;
      args.push(this.Owner);
      ;
      args.push(this.User);
      ;
      args.push(this.ResponsiblePerson);
      ;
      args.push(this.IncorporationDate);
      ;
      args.push(this.DepreciatedValue);
      ;
      return args;
    }
  };
  var IfcAsymmetricIShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.BottomFlangeWidth = BottomFlangeWidth;
      this.OverallDepth = OverallDepth;
      this.WebThickness = WebThickness;
      this.BottomFlangeThickness = BottomFlangeThickness;
      this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
      this.TopFlangeWidth = TopFlangeWidth;
      this.TopFlangeThickness = TopFlangeThickness;
      this.TopFlangeFilletRadius = TopFlangeFilletRadius;
      this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
      this.BottomFlangeSlope = BottomFlangeSlope;
      this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
      this.TopFlangeSlope = TopFlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let BottomFlangeWidth = tape[ptr++];
      let OverallDepth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let BottomFlangeThickness = tape[ptr++];
      let BottomFlangeFilletRadius = tape[ptr++];
      let TopFlangeWidth = tape[ptr++];
      let TopFlangeThickness = tape[ptr++];
      let TopFlangeFilletRadius = tape[ptr++];
      let BottomFlangeEdgeRadius = tape[ptr++];
      let BottomFlangeSlope = tape[ptr++];
      let TopFlangeEdgeRadius = tape[ptr++];
      let TopFlangeSlope = tape[ptr++];
      return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.BottomFlangeWidth);
      ;
      args.push(this.OverallDepth);
      ;
      args.push(this.WebThickness);
      ;
      args.push(this.BottomFlangeThickness);
      ;
      args.push(this.BottomFlangeFilletRadius);
      ;
      args.push(this.TopFlangeWidth);
      ;
      args.push(this.TopFlangeThickness);
      ;
      args.push(this.TopFlangeFilletRadius);
      ;
      args.push(this.BottomFlangeEdgeRadius);
      ;
      args.push(this.BottomFlangeSlope);
      ;
      args.push(this.TopFlangeEdgeRadius);
      ;
      args.push(this.TopFlangeSlope);
      ;
      return args;
    }
  };
  var IfcAudioVisualAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAudioVisualApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcAxis1Placement = class {
    constructor(expressID, type, Location, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcAxis1Placement(expressID, type, Location, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Axis);
      ;
      return args;
    }
  };
  var IfcAxis2Placement2D = class {
    constructor(expressID, type, Location, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.RefDirection);
      ;
      return args;
    }
  };
  var IfcAxis2Placement3D = class {
    constructor(expressID, type, Location, Axis, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Axis = Axis;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Axis = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Axis);
      ;
      args.push(this.RefDirection);
      ;
      return args;
    }
  };
  var IfcBSplineCurve = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.CurveForm);
      ;
      args.push(this.ClosedCurve);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcBSplineCurveWithKnots = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
      this.KnotMultiplicities = KnotMultiplicities;
      this.Knots = Knots;
      this.KnotSpec = KnotSpec;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let KnotMultiplicities = tape[ptr++];
      let Knots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.CurveForm);
      ;
      args.push(this.ClosedCurve);
      ;
      args.push(this.SelfIntersect);
      ;
      args.push(this.KnotMultiplicities);
      ;
      args.push(this.Knots);
      ;
      args.push(this.KnotSpec);
      ;
      return args;
    }
  };
  var IfcBSplineSurface = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      ;
      args.push(this.VDegree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.SurfaceForm);
      ;
      args.push(this.UClosed);
      ;
      args.push(this.VClosed);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcBSplineSurfaceWithKnots = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
      this.UMultiplicities = UMultiplicities;
      this.VMultiplicities = VMultiplicities;
      this.UKnots = UKnots;
      this.VKnots = VKnots;
      this.KnotSpec = KnotSpec;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let UMultiplicities = tape[ptr++];
      let VMultiplicities = tape[ptr++];
      let UKnots = tape[ptr++];
      let VKnots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      ;
      args.push(this.VDegree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.SurfaceForm);
      ;
      args.push(this.UClosed);
      ;
      args.push(this.VClosed);
      ;
      args.push(this.SelfIntersect);
      ;
      args.push(this.UMultiplicities);
      ;
      args.push(this.VMultiplicities);
      ;
      args.push(this.UKnots);
      ;
      args.push(this.VKnots);
      ;
      args.push(this.KnotSpec);
      ;
      return args;
    }
  };
  var IfcBeam = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBeamStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBeamType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBearing = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBearingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBlobTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.RasterFormat = RasterFormat;
      this.RasterCode = RasterCode;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let RasterFormat = tape[ptr++];
      let RasterCode = tape[ptr++];
      return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      ;
      args.push(this.RepeatT);
      ;
      args.push(this.Mode);
      ;
      args.push(this.TextureTransform);
      ;
      args.push(this.Parameter);
      ;
      args.push(this.RasterFormat);
      ;
      args.push(this.RasterCode);
      ;
      return args;
    }
  };
  var IfcBlock = class {
    constructor(expressID, type, Position, XLength, YLength, ZLength) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.XLength = XLength;
      this.YLength = YLength;
      this.ZLength = ZLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let XLength = tape[ptr++];
      let YLength = tape[ptr++];
      let ZLength = tape[ptr++];
      return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.XLength);
      ;
      args.push(this.YLength);
      ;
      args.push(this.ZLength);
      ;
      return args;
    }
  };
  var IfcBoiler = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBoilerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBooleanClippingResult = class {
    constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
      this.expressID = expressID;
      this.type = type;
      this.Operator = Operator;
      this.FirstOperand = FirstOperand;
      this.SecondOperand = SecondOperand;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Operator = tape[ptr++];
      let FirstOperand = tape[ptr++];
      let SecondOperand = tape[ptr++];
      return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
    }
    ToTape() {
      let args = [];
      args.push(this.Operator);
      ;
      args.push(this.FirstOperand);
      ;
      args.push(this.SecondOperand);
      ;
      return args;
    }
  };
  var IfcBooleanResult = class {
    constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
      this.expressID = expressID;
      this.type = type;
      this.Operator = Operator;
      this.FirstOperand = FirstOperand;
      this.SecondOperand = SecondOperand;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Operator = tape[ptr++];
      let FirstOperand = tape[ptr++];
      let SecondOperand = tape[ptr++];
      return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
    }
    ToTape() {
      let args = [];
      args.push(this.Operator);
      ;
      args.push(this.FirstOperand);
      ;
      args.push(this.SecondOperand);
      ;
      return args;
    }
  };
  var IfcBoundaryCondition = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcBoundaryCondition(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcBoundaryCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcBoundaryEdgeCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
      this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
      this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
      this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
      this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
      this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessByLengthX = tape[ptr++];
      let TranslationalStiffnessByLengthY = tape[ptr++];
      let TranslationalStiffnessByLengthZ = tape[ptr++];
      let RotationalStiffnessByLengthX = tape[ptr++];
      let RotationalStiffnessByLengthY = tape[ptr++];
      let RotationalStiffnessByLengthZ = tape[ptr++];
      return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TranslationalStiffnessByLengthX);
      ;
      args.push(this.TranslationalStiffnessByLengthY);
      ;
      args.push(this.TranslationalStiffnessByLengthZ);
      ;
      args.push(this.RotationalStiffnessByLengthX);
      ;
      args.push(this.RotationalStiffnessByLengthY);
      ;
      args.push(this.RotationalStiffnessByLengthZ);
      ;
      return args;
    }
  };
  var IfcBoundaryFaceCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
      this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
      this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessByAreaX = tape[ptr++];
      let TranslationalStiffnessByAreaY = tape[ptr++];
      let TranslationalStiffnessByAreaZ = tape[ptr++];
      return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TranslationalStiffnessByAreaX);
      ;
      args.push(this.TranslationalStiffnessByAreaY);
      ;
      args.push(this.TranslationalStiffnessByAreaZ);
      ;
      return args;
    }
  };
  var IfcBoundaryNodeCondition = class {
    constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessX = TranslationalStiffnessX;
      this.TranslationalStiffnessY = TranslationalStiffnessY;
      this.TranslationalStiffnessZ = TranslationalStiffnessZ;
      this.RotationalStiffnessX = RotationalStiffnessX;
      this.RotationalStiffnessY = RotationalStiffnessY;
      this.RotationalStiffnessZ = RotationalStiffnessZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessX = tape[ptr++];
      let TranslationalStiffnessY = tape[ptr++];
      let TranslationalStiffnessZ = tape[ptr++];
      let RotationalStiffnessX = tape[ptr++];
      let RotationalStiffnessY = tape[ptr++];
      let RotationalStiffnessZ = tape[ptr++];
      return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TranslationalStiffnessX);
      ;
      args.push(this.TranslationalStiffnessY);
      ;
      args.push(this.TranslationalStiffnessZ);
      ;
      args.push(this.RotationalStiffnessX);
      ;
      args.push(this.RotationalStiffnessY);
      ;
      args.push(this.RotationalStiffnessZ);
      ;
      return args;
    }
  };
  var IfcBoundaryNodeConditionWarping = class {
    constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TranslationalStiffnessX = TranslationalStiffnessX;
      this.TranslationalStiffnessY = TranslationalStiffnessY;
      this.TranslationalStiffnessZ = TranslationalStiffnessZ;
      this.RotationalStiffnessX = RotationalStiffnessX;
      this.RotationalStiffnessY = RotationalStiffnessY;
      this.RotationalStiffnessZ = RotationalStiffnessZ;
      this.WarpingStiffness = WarpingStiffness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TranslationalStiffnessX = tape[ptr++];
      let TranslationalStiffnessY = tape[ptr++];
      let TranslationalStiffnessZ = tape[ptr++];
      let RotationalStiffnessX = tape[ptr++];
      let RotationalStiffnessY = tape[ptr++];
      let RotationalStiffnessZ = tape[ptr++];
      let WarpingStiffness = tape[ptr++];
      return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TranslationalStiffnessX);
      ;
      args.push(this.TranslationalStiffnessY);
      ;
      args.push(this.TranslationalStiffnessZ);
      ;
      args.push(this.RotationalStiffnessX);
      ;
      args.push(this.RotationalStiffnessY);
      ;
      args.push(this.RotationalStiffnessZ);
      ;
      args.push(this.WarpingStiffness);
      ;
      return args;
    }
  };
  var IfcBoundedCurve = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcBoundedCurve(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcBoundedSurface = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcBoundedSurface(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcBoundingBox = class {
    constructor(expressID, type, Corner, XDim, YDim, ZDim) {
      this.expressID = expressID;
      this.type = type;
      this.Corner = Corner;
      this.XDim = XDim;
      this.YDim = YDim;
      this.ZDim = ZDim;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Corner = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let ZDim = tape[ptr++];
      return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
    }
    ToTape() {
      let args = [];
      args.push(this.Corner);
      ;
      args.push(this.XDim);
      ;
      args.push(this.YDim);
      ;
      args.push(this.ZDim);
      ;
      return args;
    }
  };
  var IfcBoxedHalfSpace = class {
    constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
      this.Enclosure = Enclosure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      let Enclosure = tape[ptr++];
      return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      ;
      args.push(this.AgreementFlag);
      ;
      args.push(this.Enclosure);
      ;
      return args;
    }
  };
  var IfcBridge = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBridgePart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBuilding = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.ElevationOfRefHeight = ElevationOfRefHeight;
      this.ElevationOfTerrain = ElevationOfTerrain;
      this.BuildingAddress = BuildingAddress;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let ElevationOfRefHeight = tape[ptr++];
      let ElevationOfTerrain = tape[ptr++];
      let BuildingAddress = tape[ptr++];
      return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.ElevationOfRefHeight);
      ;
      args.push(this.ElevationOfTerrain);
      ;
      args.push(this.BuildingAddress);
      ;
      return args;
    }
  };
  var IfcBuildingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcBuildingElementPart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBuildingElementPartType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBuildingElementProxy = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBuildingElementProxyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBuildingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcBuildingStorey = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.Elevation = Elevation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let Elevation = tape[ptr++];
      return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.Elevation);
      ;
      return args;
    }
  };
  var IfcBuildingSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };
  var IfcBurner = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcBurnerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.Width = Width;
      this.WallThickness = WallThickness;
      this.Girth = Girth;
      this.InternalFilletRadius = InternalFilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let Width = tape[ptr++];
      let WallThickness = tape[ptr++];
      let Girth = tape[ptr++];
      let InternalFilletRadius = tape[ptr++];
      return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Depth);
      ;
      args.push(this.Width);
      ;
      args.push(this.WallThickness);
      ;
      args.push(this.Girth);
      ;
      args.push(this.InternalFilletRadius);
      ;
      return args;
    }
  };
  var IfcCableCarrierFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableCarrierFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableCarrierSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableCarrierSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCableSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCaissonFoundation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCaissonFoundationType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCartesianPoint = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcCartesianPoint(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      return args;
    }
  };
  var IfcCartesianPointList = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcCartesianPointList(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcCartesianPointList2D = class {
    constructor(expressID, type, CoordList, TagList) {
      this.expressID = expressID;
      this.type = type;
      this.CoordList = CoordList;
      this.TagList = TagList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordList = tape[ptr++];
      let TagList = tape[ptr++];
      return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordList);
      ;
      args.push(this.TagList);
      ;
      return args;
    }
  };
  var IfcCartesianPointList3D = class {
    constructor(expressID, type, CoordList, TagList) {
      this.expressID = expressID;
      this.type = type;
      this.CoordList = CoordList;
      this.TagList = TagList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordList = tape[ptr++];
      let TagList = tape[ptr++];
      return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordList);
      ;
      args.push(this.TagList);
      ;
      return args;
    }
  };
  var IfcCartesianTransformationOperator = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      ;
      args.push(this.Axis2);
      ;
      args.push(this.LocalOrigin);
      ;
      args.push(this.Scale);
      ;
      return args;
    }
  };
  var IfcCartesianTransformationOperator2D = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      ;
      args.push(this.Axis2);
      ;
      args.push(this.LocalOrigin);
      ;
      args.push(this.Scale);
      ;
      return args;
    }
  };
  var IfcCartesianTransformationOperator2DnonUniform = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Scale2 = Scale2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Scale2 = tape[ptr++];
      return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      ;
      args.push(this.Axis2);
      ;
      args.push(this.LocalOrigin);
      ;
      args.push(this.Scale);
      ;
      args.push(this.Scale2);
      ;
      return args;
    }
  };
  var IfcCartesianTransformationOperator3D = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Axis3 = Axis3;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Axis3 = tape[ptr++];
      return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      ;
      args.push(this.Axis2);
      ;
      args.push(this.LocalOrigin);
      ;
      args.push(this.Scale);
      ;
      args.push(this.Axis3);
      ;
      return args;
    }
  };
  var IfcCartesianTransformationOperator3DnonUniform = class {
    constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
      this.expressID = expressID;
      this.type = type;
      this.Axis1 = Axis1;
      this.Axis2 = Axis2;
      this.LocalOrigin = LocalOrigin;
      this.Scale = Scale;
      this.Axis3 = Axis3;
      this.Scale2 = Scale2;
      this.Scale3 = Scale3;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Axis1 = tape[ptr++];
      let Axis2 = tape[ptr++];
      let LocalOrigin = tape[ptr++];
      let Scale = tape[ptr++];
      let Axis3 = tape[ptr++];
      let Scale2 = tape[ptr++];
      let Scale3 = tape[ptr++];
      return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
    }
    ToTape() {
      let args = [];
      args.push(this.Axis1);
      ;
      args.push(this.Axis2);
      ;
      args.push(this.LocalOrigin);
      ;
      args.push(this.Scale);
      ;
      args.push(this.Axis3);
      ;
      args.push(this.Scale2);
      ;
      args.push(this.Scale3);
      ;
      return args;
    }
  };
  var IfcCenterLineProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Curve = Curve;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Curve = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Curve);
      ;
      args.push(this.Thickness);
      ;
      return args;
    }
  };
  var IfcChiller = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcChillerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcChimney = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcChimneyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCircle = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCircle(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcCircleHollowProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Radius = Radius;
      this.WallThickness = WallThickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let WallThickness = tape[ptr++];
      return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      args.push(this.WallThickness);
      ;
      return args;
    }
  };
  var IfcCircleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcCircularArcSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
      this.Radius = Radius;
      this.IsCCW = IsCCW;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      let Radius = tape[ptr++];
      let IsCCW = tape[ptr++];
      return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      ;
      args.push(this.StartDirection);
      ;
      args.push(this.SegmentLength);
      ;
      args.push(this.Radius);
      ;
      args.push(this.IsCCW);
      ;
      return args;
    }
  };
  var IfcCivilElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcCivilElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcClassification = class {
    constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
      this.expressID = expressID;
      this.type = type;
      this.Source = Source;
      this.Edition = Edition;
      this.EditionDate = EditionDate;
      this.Name = Name;
      this.Description = Description;
      this.Location = Location;
      this.ReferenceTokens = ReferenceTokens;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Source = tape[ptr++];
      let Edition = tape[ptr++];
      let EditionDate = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Location = tape[ptr++];
      let ReferenceTokens = tape[ptr++];
      return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
    }
    ToTape() {
      let args = [];
      args.push(this.Source);
      ;
      args.push(this.Edition);
      ;
      args.push(this.EditionDate);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Location);
      ;
      args.push(this.ReferenceTokens);
      ;
      return args;
    }
  };
  var IfcClassificationReference = class {
    constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.ReferencedSource = ReferencedSource;
      this.Description = Description;
      this.Sort = Sort;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let ReferencedSource = tape[ptr++];
      let Description = tape[ptr++];
      let Sort = tape[ptr++];
      return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      args.push(this.ReferencedSource);
      ;
      args.push(this.Description);
      ;
      args.push(this.Sort);
      ;
      return args;
    }
  };
  var IfcClosedShell = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcClosedShell(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      ;
      return args;
    }
  };
  var IfcCoil = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCoilType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcColourRgb = class {
    constructor(expressID, type, Name, Red, Green, Blue) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Red = Red;
      this.Green = Green;
      this.Blue = Blue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Red = tape[ptr++];
      let Green = tape[ptr++];
      let Blue = tape[ptr++];
      return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Red);
      ;
      args.push(this.Green);
      ;
      args.push(this.Blue);
      ;
      return args;
    }
  };
  var IfcColourRgbList = class {
    constructor(expressID, type, ColourList) {
      this.expressID = expressID;
      this.type = type;
      this.ColourList = ColourList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ColourList = tape[ptr++];
      return new IfcColourRgbList(expressID, type, ColourList);
    }
    ToTape() {
      let args = [];
      args.push(this.ColourList);
      ;
      return args;
    }
  };
  var IfcColourSpecification = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcColourSpecification(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcColumn = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcColumnStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcColumnType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCommunicationsAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCommunicationsApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcComplexProperty = class {
    constructor(expressID, type, Name, Description, UsageName, HasProperties) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.HasProperties = HasProperties;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let HasProperties = tape[ptr++];
      return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.UsageName);
      ;
      args.push(this.HasProperties);
      ;
      return args;
    }
  };
  var IfcComplexPropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.TemplateType = TemplateType;
      this.HasPropertyTemplates = HasPropertyTemplates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let TemplateType = tape[ptr++];
      let HasPropertyTemplates = tape[ptr++];
      return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.UsageName);
      ;
      args.push(this.TemplateType);
      ;
      args.push(this.HasPropertyTemplates);
      ;
      return args;
    }
  };
  var IfcCompositeCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcCompositeCurveOnSurface = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcCompositeCurveSegment = class {
    constructor(expressID, type, Transition, SameSense, ParentCurve) {
      this.expressID = expressID;
      this.type = type;
      this.Transition = Transition;
      this.SameSense = SameSense;
      this.ParentCurve = ParentCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Transition = tape[ptr++];
      let SameSense = tape[ptr++];
      let ParentCurve = tape[ptr++];
      return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.Transition);
      ;
      args.push(this.SameSense);
      ;
      args.push(this.ParentCurve);
      ;
      return args;
    }
  };
  var IfcCompositeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Profiles = Profiles;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Profiles = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Profiles);
      ;
      args.push(this.Label);
      ;
      return args;
    }
  };
  var IfcCompressor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCompressorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCondenser = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCondenserType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConic = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcConic(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcConnectedFaceSet = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcConnectedFaceSet(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      ;
      return args;
    }
  };
  var IfcConnectionCurveGeometry = class {
    constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.CurveOnRelatingElement = CurveOnRelatingElement;
      this.CurveOnRelatedElement = CurveOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CurveOnRelatingElement = tape[ptr++];
      let CurveOnRelatedElement = tape[ptr++];
      return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.CurveOnRelatingElement);
      ;
      args.push(this.CurveOnRelatedElement);
      ;
      return args;
    }
  };
  var IfcConnectionGeometry = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcConnectionGeometry(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcConnectionPointEccentricity = class {
    constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
      this.expressID = expressID;
      this.type = type;
      this.PointOnRelatingElement = PointOnRelatingElement;
      this.PointOnRelatedElement = PointOnRelatedElement;
      this.EccentricityInX = EccentricityInX;
      this.EccentricityInY = EccentricityInY;
      this.EccentricityInZ = EccentricityInZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PointOnRelatingElement = tape[ptr++];
      let PointOnRelatedElement = tape[ptr++];
      let EccentricityInX = tape[ptr++];
      let EccentricityInY = tape[ptr++];
      let EccentricityInZ = tape[ptr++];
      return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
    }
    ToTape() {
      let args = [];
      args.push(this.PointOnRelatingElement);
      ;
      args.push(this.PointOnRelatedElement);
      ;
      args.push(this.EccentricityInX);
      ;
      args.push(this.EccentricityInY);
      ;
      args.push(this.EccentricityInZ);
      ;
      return args;
    }
  };
  var IfcConnectionPointGeometry = class {
    constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.PointOnRelatingElement = PointOnRelatingElement;
      this.PointOnRelatedElement = PointOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PointOnRelatingElement = tape[ptr++];
      let PointOnRelatedElement = tape[ptr++];
      return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.PointOnRelatingElement);
      ;
      args.push(this.PointOnRelatedElement);
      ;
      return args;
    }
  };
  var IfcConnectionSurfaceGeometry = class {
    constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
      this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceOnRelatingElement = tape[ptr++];
      let SurfaceOnRelatedElement = tape[ptr++];
      return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceOnRelatingElement);
      ;
      args.push(this.SurfaceOnRelatedElement);
      ;
      return args;
    }
  };
  var IfcConnectionVolumeGeometry = class {
    constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.VolumeOnRelatingElement = VolumeOnRelatingElement;
      this.VolumeOnRelatedElement = VolumeOnRelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VolumeOnRelatingElement = tape[ptr++];
      let VolumeOnRelatedElement = tape[ptr++];
      return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.VolumeOnRelatingElement);
      ;
      args.push(this.VolumeOnRelatedElement);
      ;
      return args;
    }
  };
  var IfcConstraint = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConstraintGrade);
      ;
      args.push(this.ConstraintSource);
      ;
      args.push(this.CreatingActor);
      ;
      args.push(this.CreationTime);
      ;
      args.push(this.UserDefinedGrade);
      ;
      return args;
    }
  };
  var IfcConstructionEquipmentResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionEquipmentResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionMaterialResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionMaterialResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionProductResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionProductResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConstructionResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      return args;
    }
  };
  var IfcConstructionResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      return args;
    }
  };
  var IfcContext = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      args.push(this.Phase);
      ;
      args.push(this.RepresentationContexts);
      ;
      args.push(this.UnitsInContext);
      ;
      return args;
    }
  };
  var IfcContextDependentUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      ;
      args.push(this.UnitType);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      return args;
    }
  };
  var IfcController = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcControllerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcConversionBasedUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
      this.ConversionFactor = ConversionFactor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      let ConversionFactor = tape[ptr++];
      return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      ;
      args.push(this.UnitType);
      ;
      args.push(this.Name);
      ;
      args.push(this.ConversionFactor);
      ;
      return args;
    }
  };
  var IfcConversionBasedUnitWithOffset = class {
    constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Name = Name;
      this.ConversionFactor = ConversionFactor;
      this.ConversionOffset = ConversionOffset;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Name = tape[ptr++];
      let ConversionFactor = tape[ptr++];
      let ConversionOffset = tape[ptr++];
      return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      ;
      args.push(this.UnitType);
      ;
      args.push(this.Name);
      ;
      args.push(this.ConversionFactor);
      ;
      args.push(this.ConversionOffset);
      ;
      return args;
    }
  };
  var IfcCooledBeam = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCooledBeamType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCoolingTower = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCoolingTowerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCoordinateOperation = class {
    constructor(expressID, type, SourceCRS, TargetCRS) {
      this.expressID = expressID;
      this.type = type;
      this.SourceCRS = SourceCRS;
      this.TargetCRS = TargetCRS;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SourceCRS = tape[ptr++];
      let TargetCRS = tape[ptr++];
      return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
    }
    ToTape() {
      let args = [];
      args.push(this.SourceCRS);
      ;
      args.push(this.TargetCRS);
      ;
      return args;
    }
  };
  var IfcCoordinateReferenceSystem = class {
    constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.GeodeticDatum = GeodeticDatum;
      this.VerticalDatum = VerticalDatum;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let GeodeticDatum = tape[ptr++];
      let VerticalDatum = tape[ptr++];
      return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.GeodeticDatum);
      ;
      args.push(this.VerticalDatum);
      ;
      return args;
    }
  };
  var IfcCostItem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.CostValues = CostValues;
      this.CostQuantities = CostQuantities;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let CostValues = tape[ptr++];
      let CostQuantities = tape[ptr++];
      return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.CostValues);
      ;
      args.push(this.CostQuantities);
      ;
      return args;
    }
  };
  var IfcCostSchedule = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.SubmittedOn = SubmittedOn;
      this.UpdateDate = UpdateDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let SubmittedOn = tape[ptr++];
      let UpdateDate = tape[ptr++];
      return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Status);
      ;
      args.push(this.SubmittedOn);
      ;
      args.push(this.UpdateDate);
      ;
      return args;
    }
  };
  var IfcCostValue = class {
    constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AppliedValue = AppliedValue;
      this.UnitBasis = UnitBasis;
      this.ApplicableDate = ApplicableDate;
      this.FixedUntilDate = FixedUntilDate;
      this.Category = Category;
      this.Condition = Condition;
      this.ArithmeticOperator = ArithmeticOperator;
      this.Components = Components;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AppliedValue = tape[ptr++];
      let UnitBasis = tape[ptr++];
      let ApplicableDate = tape[ptr++];
      let FixedUntilDate = tape[ptr++];
      let Category = tape[ptr++];
      let Condition = tape[ptr++];
      let ArithmeticOperator = tape[ptr++];
      let Components = tape[ptr++];
      return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.AppliedValue);
      ;
      args.push(this.UnitBasis);
      ;
      args.push(this.ApplicableDate);
      ;
      args.push(this.FixedUntilDate);
      ;
      args.push(this.Category);
      ;
      args.push(this.Condition);
      ;
      args.push(this.ArithmeticOperator);
      ;
      args.push(this.Components);
      ;
      return args;
    }
  };
  var IfcCovering = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCoveringType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCrewResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCrewResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCsgPrimitive3D = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcCsgPrimitive3D(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcCsgSolid = class {
    constructor(expressID, type, TreeRootExpression) {
      this.expressID = expressID;
      this.type = type;
      this.TreeRootExpression = TreeRootExpression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TreeRootExpression = tape[ptr++];
      return new IfcCsgSolid(expressID, type, TreeRootExpression);
    }
    ToTape() {
      let args = [];
      args.push(this.TreeRootExpression);
      ;
      return args;
    }
  };
  var IfcCurrencyRelationship = class {
    constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingMonetaryUnit = RelatingMonetaryUnit;
      this.RelatedMonetaryUnit = RelatedMonetaryUnit;
      this.ExchangeRate = ExchangeRate;
      this.RateDateTime = RateDateTime;
      this.RateSource = RateSource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingMonetaryUnit = tape[ptr++];
      let RelatedMonetaryUnit = tape[ptr++];
      let ExchangeRate = tape[ptr++];
      let RateDateTime = tape[ptr++];
      let RateSource = tape[ptr++];
      return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingMonetaryUnit);
      ;
      args.push(this.RelatedMonetaryUnit);
      ;
      args.push(this.ExchangeRate);
      ;
      args.push(this.RateDateTime);
      ;
      args.push(this.RateSource);
      ;
      return args;
    }
  };
  var IfcCurtainWall = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCurtainWallType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcCurve = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcCurve(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcCurveBoundedPlane = class {
    constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.OuterBoundary = OuterBoundary;
      this.InnerBoundaries = InnerBoundaries;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let OuterBoundary = tape[ptr++];
      let InnerBoundaries = tape[ptr++];
      return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      ;
      args.push(this.OuterBoundary);
      ;
      args.push(this.InnerBoundaries);
      ;
      return args;
    }
  };
  var IfcCurveBoundedSurface = class {
    constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.Boundaries = Boundaries;
      this.ImplicitOuter = ImplicitOuter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let Boundaries = tape[ptr++];
      let ImplicitOuter = tape[ptr++];
      return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      ;
      args.push(this.Boundaries);
      ;
      args.push(this.ImplicitOuter);
      ;
      return args;
    }
  };
  var IfcCurveSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      ;
      args.push(this.StartDirection);
      ;
      args.push(this.SegmentLength);
      ;
      return args;
    }
  };
  var IfcCurveStyle = class {
    constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.CurveFont = CurveFont;
      this.CurveWidth = CurveWidth;
      this.CurveColour = CurveColour;
      this.ModelOrDraughting = ModelOrDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let CurveFont = tape[ptr++];
      let CurveWidth = tape[ptr++];
      let CurveColour = tape[ptr++];
      let ModelOrDraughting = tape[ptr++];
      return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.CurveFont);
      ;
      args.push(this.CurveWidth);
      ;
      args.push(this.CurveColour);
      ;
      args.push(this.ModelOrDraughting);
      ;
      return args;
    }
  };
  var IfcCurveStyleFont = class {
    constructor(expressID, type, Name, PatternList) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.PatternList = PatternList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let PatternList = tape[ptr++];
      return new IfcCurveStyleFont(expressID, type, Name, PatternList);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.PatternList);
      ;
      return args;
    }
  };
  var IfcCurveStyleFontAndScaling = class {
    constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.CurveFont = CurveFont;
      this.CurveFontScaling = CurveFontScaling;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let CurveFont = tape[ptr++];
      let CurveFontScaling = tape[ptr++];
      return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.CurveFont);
      ;
      args.push(this.CurveFontScaling);
      ;
      return args;
    }
  };
  var IfcCurveStyleFontPattern = class {
    constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.VisibleSegmentLength = VisibleSegmentLength;
      this.InvisibleSegmentLength = InvisibleSegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VisibleSegmentLength = tape[ptr++];
      let InvisibleSegmentLength = tape[ptr++];
      return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.VisibleSegmentLength);
      ;
      args.push(this.InvisibleSegmentLength);
      ;
      return args;
    }
  };
  var IfcCylindricalSurface = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcCylindricalSurface(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcDamper = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDamperType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDeepFoundation = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcDeepFoundationType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcDerivedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.ParentProfile = ParentProfile;
      this.Operator = Operator;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let ParentProfile = tape[ptr++];
      let Operator = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.ParentProfile);
      ;
      args.push(this.Operator);
      ;
      args.push(this.Label);
      ;
      return args;
    }
  };
  var IfcDerivedUnit = class {
    constructor(expressID, type, Elements, UnitType, UserDefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
      this.UnitType = UnitType;
      this.UserDefinedType = UserDefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      let UnitType = tape[ptr++];
      let UserDefinedType = tape[ptr++];
      return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      ;
      args.push(this.UnitType);
      ;
      args.push(this.UserDefinedType);
      ;
      return args;
    }
  };
  var IfcDerivedUnitElement = class {
    constructor(expressID, type, Unit, Exponent) {
      this.expressID = expressID;
      this.type = type;
      this.Unit = Unit;
      this.Exponent = Exponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Unit = tape[ptr++];
      let Exponent = tape[ptr++];
      return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
    }
    ToTape() {
      let args = [];
      args.push(this.Unit);
      ;
      args.push(this.Exponent);
      ;
      return args;
    }
  };
  var IfcDimensionalExponents = class {
    constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
      this.expressID = expressID;
      this.type = type;
      this.LengthExponent = LengthExponent;
      this.MassExponent = MassExponent;
      this.TimeExponent = TimeExponent;
      this.ElectricCurrentExponent = ElectricCurrentExponent;
      this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
      this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
      this.LuminousIntensityExponent = LuminousIntensityExponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LengthExponent = tape[ptr++];
      let MassExponent = tape[ptr++];
      let TimeExponent = tape[ptr++];
      let ElectricCurrentExponent = tape[ptr++];
      let ThermodynamicTemperatureExponent = tape[ptr++];
      let AmountOfSubstanceExponent = tape[ptr++];
      let LuminousIntensityExponent = tape[ptr++];
      return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
    }
    ToTape() {
      let args = [];
      args.push(this.LengthExponent);
      ;
      args.push(this.MassExponent);
      ;
      args.push(this.TimeExponent);
      ;
      args.push(this.ElectricCurrentExponent);
      ;
      args.push(this.ThermodynamicTemperatureExponent);
      ;
      args.push(this.AmountOfSubstanceExponent);
      ;
      args.push(this.LuminousIntensityExponent);
      ;
      return args;
    }
  };
  var IfcDirection = class {
    constructor(expressID, type, DirectionRatios) {
      this.expressID = expressID;
      this.type = type;
      this.DirectionRatios = DirectionRatios;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DirectionRatios = tape[ptr++];
      return new IfcDirection(expressID, type, DirectionRatios);
    }
    ToTape() {
      let args = [];
      args.push(this.DirectionRatios);
      ;
      return args;
    }
  };
  var IfcDiscreteAccessory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDiscreteAccessoryType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDistanceExpression = class {
    constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
      this.expressID = expressID;
      this.type = type;
      this.DistanceAlong = DistanceAlong;
      this.OffsetLateral = OffsetLateral;
      this.OffsetVertical = OffsetVertical;
      this.OffsetLongitudinal = OffsetLongitudinal;
      this.AlongHorizontal = AlongHorizontal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DistanceAlong = tape[ptr++];
      let OffsetLateral = tape[ptr++];
      let OffsetVertical = tape[ptr++];
      let OffsetLongitudinal = tape[ptr++];
      let AlongHorizontal = tape[ptr++];
      return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
    }
    ToTape() {
      let args = [];
      args.push(this.DistanceAlong);
      ;
      args.push(this.OffsetLateral);
      ;
      args.push(this.OffsetVertical);
      ;
      args.push(this.OffsetLongitudinal);
      ;
      args.push(this.AlongHorizontal);
      ;
      return args;
    }
  };
  var IfcDistributionChamberElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDistributionChamberElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDistributionCircuit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDistributionControlElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcDistributionControlElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcDistributionElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcDistributionElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcDistributionFlowElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcDistributionFlowElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcDistributionPort = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.FlowDirection = FlowDirection;
      this.PredefinedType = PredefinedType;
      this.SystemType = SystemType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let FlowDirection = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let SystemType = tape[ptr++];
      return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.FlowDirection);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.SystemType);
      ;
      return args;
    }
  };
  var IfcDistributionSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDocumentInformation = class {
    constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Location = Location;
      this.Purpose = Purpose;
      this.IntendedUse = IntendedUse;
      this.Scope = Scope;
      this.Revision = Revision;
      this.DocumentOwner = DocumentOwner;
      this.Editors = Editors;
      this.CreationTime = CreationTime;
      this.LastRevisionTime = LastRevisionTime;
      this.ElectronicFormat = ElectronicFormat;
      this.ValidFrom = ValidFrom;
      this.ValidUntil = ValidUntil;
      this.Confidentiality = Confidentiality;
      this.Status = Status;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Location = tape[ptr++];
      let Purpose = tape[ptr++];
      let IntendedUse = tape[ptr++];
      let Scope = tape[ptr++];
      let Revision = tape[ptr++];
      let DocumentOwner = tape[ptr++];
      let Editors = tape[ptr++];
      let CreationTime = tape[ptr++];
      let LastRevisionTime = tape[ptr++];
      let ElectronicFormat = tape[ptr++];
      let ValidFrom = tape[ptr++];
      let ValidUntil = tape[ptr++];
      let Confidentiality = tape[ptr++];
      let Status = tape[ptr++];
      return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Location);
      ;
      args.push(this.Purpose);
      ;
      args.push(this.IntendedUse);
      ;
      args.push(this.Scope);
      ;
      args.push(this.Revision);
      ;
      args.push(this.DocumentOwner);
      ;
      args.push(this.Editors);
      ;
      args.push(this.CreationTime);
      ;
      args.push(this.LastRevisionTime);
      ;
      args.push(this.ElectronicFormat);
      ;
      args.push(this.ValidFrom);
      ;
      args.push(this.ValidUntil);
      ;
      args.push(this.Confidentiality);
      ;
      args.push(this.Status);
      ;
      return args;
    }
  };
  var IfcDocumentInformationRelationship = class {
    constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingDocument = RelatingDocument;
      this.RelatedDocuments = RelatedDocuments;
      this.RelationshipType = RelationshipType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingDocument = tape[ptr++];
      let RelatedDocuments = tape[ptr++];
      let RelationshipType = tape[ptr++];
      return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingDocument);
      ;
      args.push(this.RelatedDocuments);
      ;
      args.push(this.RelationshipType);
      ;
      return args;
    }
  };
  var IfcDocumentReference = class {
    constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.ReferencedDocument = ReferencedDocument;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ReferencedDocument = tape[ptr++];
      return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ReferencedDocument);
      ;
      return args;
    }
  };
  var IfcDoor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.OverallHeight);
      ;
      args.push(this.OverallWidth);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.UserDefinedOperationType);
      ;
      return args;
    }
  };
  var IfcDoorLiningProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.LiningDepth = LiningDepth;
      this.LiningThickness = LiningThickness;
      this.ThresholdDepth = ThresholdDepth;
      this.ThresholdThickness = ThresholdThickness;
      this.TransomThickness = TransomThickness;
      this.TransomOffset = TransomOffset;
      this.LiningOffset = LiningOffset;
      this.ThresholdOffset = ThresholdOffset;
      this.CasingThickness = CasingThickness;
      this.CasingDepth = CasingDepth;
      this.ShapeAspectStyle = ShapeAspectStyle;
      this.LiningToPanelOffsetX = LiningToPanelOffsetX;
      this.LiningToPanelOffsetY = LiningToPanelOffsetY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let LiningDepth = tape[ptr++];
      let LiningThickness = tape[ptr++];
      let ThresholdDepth = tape[ptr++];
      let ThresholdThickness = tape[ptr++];
      let TransomThickness = tape[ptr++];
      let TransomOffset = tape[ptr++];
      let LiningOffset = tape[ptr++];
      let ThresholdOffset = tape[ptr++];
      let CasingThickness = tape[ptr++];
      let CasingDepth = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      let LiningToPanelOffsetX = tape[ptr++];
      let LiningToPanelOffsetY = tape[ptr++];
      return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.LiningDepth);
      ;
      args.push(this.LiningThickness);
      ;
      args.push(this.ThresholdDepth);
      ;
      args.push(this.ThresholdThickness);
      ;
      args.push(this.TransomThickness);
      ;
      args.push(this.TransomOffset);
      ;
      args.push(this.LiningOffset);
      ;
      args.push(this.ThresholdOffset);
      ;
      args.push(this.CasingThickness);
      ;
      args.push(this.CasingDepth);
      ;
      args.push(this.ShapeAspectStyle);
      ;
      args.push(this.LiningToPanelOffsetX);
      ;
      args.push(this.LiningToPanelOffsetY);
      ;
      return args;
    }
  };
  var IfcDoorPanelProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.PanelDepth = PanelDepth;
      this.PanelOperation = PanelOperation;
      this.PanelWidth = PanelWidth;
      this.PanelPosition = PanelPosition;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let PanelDepth = tape[ptr++];
      let PanelOperation = tape[ptr++];
      let PanelWidth = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.PanelDepth);
      ;
      args.push(this.PanelOperation);
      ;
      args.push(this.PanelWidth);
      ;
      args.push(this.PanelPosition);
      ;
      args.push(this.ShapeAspectStyle);
      ;
      return args;
    }
  };
  var IfcDoorStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.OverallHeight);
      ;
      args.push(this.OverallWidth);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.UserDefinedOperationType);
      ;
      return args;
    }
  };
  var IfcDoorStyle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.OperationType = OperationType;
      this.ConstructionType = ConstructionType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.Sizeable = Sizeable;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let OperationType = tape[ptr++];
      let ConstructionType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let Sizeable = tape[ptr++];
      return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.ConstructionType);
      ;
      args.push(this.ParameterTakesPrecedence);
      ;
      args.push(this.Sizeable);
      ;
      return args;
    }
  };
  var IfcDoorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.OperationType = OperationType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.UserDefinedOperationType = UserDefinedOperationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OperationType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let UserDefinedOperationType = tape[ptr++];
      return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.ParameterTakesPrecedence);
      ;
      args.push(this.UserDefinedOperationType);
      ;
      return args;
    }
  };
  var IfcDraughtingPreDefinedColour = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcDraughtingPreDefinedColour(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcDraughtingPreDefinedCurveFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcDuctFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDuctFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDuctSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDuctSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDuctSilencer = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcDuctSilencerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEdge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      ;
      args.push(this.EdgeEnd);
      ;
      return args;
    }
  };
  var IfcEdgeCurve = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.EdgeGeometry = EdgeGeometry;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let EdgeGeometry = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      ;
      args.push(this.EdgeEnd);
      ;
      args.push(this.EdgeGeometry);
      ;
      args.push(this.SameSense);
      ;
      return args;
    }
  };
  var IfcEdgeLoop = class {
    constructor(expressID, type, EdgeList) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeList = EdgeList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeList = tape[ptr++];
      return new IfcEdgeLoop(expressID, type, EdgeList);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeList);
      ;
      return args;
    }
  };
  var IfcElectricAppliance = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricApplianceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricDistributionBoard = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricDistributionBoardType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricFlowStorageDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricFlowStorageDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricGenerator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricGeneratorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricMotor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricMotorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricTimeControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElectricTimeControlType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcElementAssembly = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.AssemblyPlace = AssemblyPlace;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let AssemblyPlace = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.AssemblyPlace);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElementAssemblyType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcElementComponent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcElementComponentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcElementQuantity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.MethodOfMeasurement = MethodOfMeasurement;
      this.Quantities = Quantities;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MethodOfMeasurement = tape[ptr++];
      let Quantities = tape[ptr++];
      return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.MethodOfMeasurement);
      ;
      args.push(this.Quantities);
      ;
      return args;
    }
  };
  var IfcElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcElementarySurface = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcElementarySurface(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcEllipse = class {
    constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.SemiAxis1 = SemiAxis1;
      this.SemiAxis2 = SemiAxis2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let SemiAxis1 = tape[ptr++];
      let SemiAxis2 = tape[ptr++];
      return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.SemiAxis1);
      ;
      args.push(this.SemiAxis2);
      ;
      return args;
    }
  };
  var IfcEllipseProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.SemiAxis1 = SemiAxis1;
      this.SemiAxis2 = SemiAxis2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let SemiAxis1 = tape[ptr++];
      let SemiAxis2 = tape[ptr++];
      return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.SemiAxis1);
      ;
      args.push(this.SemiAxis2);
      ;
      return args;
    }
  };
  var IfcEnergyConversionDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcEnergyConversionDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcEngine = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEngineType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEvaporativeCooler = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEvaporativeCoolerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEvaporator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEvaporatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcEvent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.PredefinedType = PredefinedType;
      this.EventTriggerType = EventTriggerType;
      this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
      this.EventOccurenceTime = EventOccurenceTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let EventTriggerType = tape[ptr++];
      let UserDefinedEventTriggerType = tape[ptr++];
      let EventOccurenceTime = tape[ptr++];
      return new IfcEvent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.EventTriggerType);
      ;
      args.push(this.UserDefinedEventTriggerType);
      ;
      args.push(this.EventOccurenceTime);
      ;
      return args;
    }
  };
  var IfcEventTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.ActualDate = ActualDate;
      this.EarlyDate = EarlyDate;
      this.LateDate = LateDate;
      this.ScheduleDate = ScheduleDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let ActualDate = tape[ptr++];
      let EarlyDate = tape[ptr++];
      let LateDate = tape[ptr++];
      let ScheduleDate = tape[ptr++];
      return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.ActualDate);
      ;
      args.push(this.EarlyDate);
      ;
      args.push(this.LateDate);
      ;
      args.push(this.ScheduleDate);
      ;
      return args;
    }
  };
  var IfcEventType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
      this.EventTriggerType = EventTriggerType;
      this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let EventTriggerType = tape[ptr++];
      let UserDefinedEventTriggerType = tape[ptr++];
      return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ProcessType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.EventTriggerType);
      ;
      args.push(this.UserDefinedEventTriggerType);
      ;
      return args;
    }
  };
  var IfcExtendedProperties = class {
    constructor(expressID, type, Name, Description, Properties2) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      return new IfcExtendedProperties(expressID, type, Name, Description, Properties2);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Properties);
      ;
      return args;
    }
  };
  var IfcExternalInformation = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcExternalInformation(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcExternalReference = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternalReference(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcExternalReferenceRelationship = class {
    constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingReference = RelatingReference;
      this.RelatedResourceObjects = RelatedResourceObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingReference = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingReference);
      ;
      args.push(this.RelatedResourceObjects);
      ;
      return args;
    }
  };
  var IfcExternalSpatialElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcExternalSpatialStructureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };
  var IfcExternallyDefinedHatchStyle = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcExternallyDefinedSurfaceStyle = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcExternallyDefinedTextFont = class {
    constructor(expressID, type, Location, Identification, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcExtrudedAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.ExtrudedDirection);
      ;
      args.push(this.Depth);
      ;
      return args;
    }
  };
  var IfcExtrudedAreaSolidTapered = class {
    constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
      this.EndSweptArea = EndSweptArea;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      let EndSweptArea = tape[ptr++];
      return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.ExtrudedDirection);
      ;
      args.push(this.Depth);
      ;
      args.push(this.EndSweptArea);
      ;
      return args;
    }
  };
  var IfcFace = class {
    constructor(expressID, type, Bounds) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      return new IfcFace(expressID, type, Bounds);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      ;
      return args;
    }
  };
  var IfcFaceBasedSurfaceModel = class {
    constructor(expressID, type, FbsmFaces) {
      this.expressID = expressID;
      this.type = type;
      this.FbsmFaces = FbsmFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let FbsmFaces = tape[ptr++];
      return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.FbsmFaces);
      ;
      return args;
    }
  };
  var IfcFaceBound = class {
    constructor(expressID, type, Bound, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Bound = Bound;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bound = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcFaceBound(expressID, type, Bound, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Bound);
      ;
      args.push(this.Orientation);
      ;
      return args;
    }
  };
  var IfcFaceOuterBound = class {
    constructor(expressID, type, Bound, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Bound = Bound;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bound = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Bound);
      ;
      args.push(this.Orientation);
      ;
      return args;
    }
  };
  var IfcFaceSurface = class {
    constructor(expressID, type, Bounds, FaceSurface, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.Bounds = Bounds;
      this.FaceSurface = FaceSurface;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Bounds = tape[ptr++];
      let FaceSurface = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.Bounds);
      ;
      args.push(this.FaceSurface);
      ;
      args.push(this.SameSense);
      ;
      return args;
    }
  };
  var IfcFacetedBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcFacetedBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      ;
      return args;
    }
  };
  var IfcFacetedBrepWithVoids = class {
    constructor(expressID, type, Outer, Voids) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
      this.Voids = Voids;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      let Voids = tape[ptr++];
      return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      ;
      args.push(this.Voids);
      ;
      return args;
    }
  };
  var IfcFacility = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      return args;
    }
  };
  var IfcFacilityPart = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      return args;
    }
  };
  var IfcFailureConnectionCondition = class {
    constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TensionFailureX = TensionFailureX;
      this.TensionFailureY = TensionFailureY;
      this.TensionFailureZ = TensionFailureZ;
      this.CompressionFailureX = CompressionFailureX;
      this.CompressionFailureY = CompressionFailureY;
      this.CompressionFailureZ = CompressionFailureZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TensionFailureX = tape[ptr++];
      let TensionFailureY = tape[ptr++];
      let TensionFailureZ = tape[ptr++];
      let CompressionFailureX = tape[ptr++];
      let CompressionFailureY = tape[ptr++];
      let CompressionFailureZ = tape[ptr++];
      return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TensionFailureX);
      ;
      args.push(this.TensionFailureY);
      ;
      args.push(this.TensionFailureZ);
      ;
      args.push(this.CompressionFailureX);
      ;
      args.push(this.CompressionFailureY);
      ;
      args.push(this.CompressionFailureZ);
      ;
      return args;
    }
  };
  var IfcFan = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFanType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFastener = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFastenerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFeatureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFeatureElementAddition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFeatureElementSubtraction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFillAreaStyle = class {
    constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.FillStyles = FillStyles;
      this.ModelorDraughting = ModelorDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let FillStyles = tape[ptr++];
      let ModelorDraughting = tape[ptr++];
      return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.FillStyles);
      ;
      args.push(this.ModelorDraughting);
      ;
      return args;
    }
  };
  var IfcFillAreaStyleHatching = class {
    constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
      this.expressID = expressID;
      this.type = type;
      this.HatchLineAppearance = HatchLineAppearance;
      this.StartOfNextHatchLine = StartOfNextHatchLine;
      this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
      this.PatternStart = PatternStart;
      this.HatchLineAngle = HatchLineAngle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let HatchLineAppearance = tape[ptr++];
      let StartOfNextHatchLine = tape[ptr++];
      let PointOfReferenceHatchLine = tape[ptr++];
      let PatternStart = tape[ptr++];
      let HatchLineAngle = tape[ptr++];
      return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
    }
    ToTape() {
      let args = [];
      args.push(this.HatchLineAppearance);
      ;
      args.push(this.StartOfNextHatchLine);
      ;
      args.push(this.PointOfReferenceHatchLine);
      ;
      args.push(this.PatternStart);
      ;
      args.push(this.HatchLineAngle);
      ;
      return args;
    }
  };
  var IfcFillAreaStyleTiles = class {
    constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
      this.expressID = expressID;
      this.type = type;
      this.TilingPattern = TilingPattern;
      this.Tiles = Tiles;
      this.TilingScale = TilingScale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TilingPattern = tape[ptr++];
      let Tiles = tape[ptr++];
      let TilingScale = tape[ptr++];
      return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
    }
    ToTape() {
      let args = [];
      args.push(this.TilingPattern);
      ;
      args.push(this.Tiles);
      ;
      args.push(this.TilingScale);
      ;
      return args;
    }
  };
  var IfcFilter = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFilterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFireSuppressionTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFireSuppressionTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFixedReferenceSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Directrix = Directrix;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.FixedReference = FixedReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Directrix = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let FixedReference = tape[ptr++];
      return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.Directrix);
      ;
      args.push(this.StartParam);
      ;
      args.push(this.EndParam);
      ;
      args.push(this.FixedReference);
      ;
      return args;
    }
  };
  var IfcFlowController = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowControllerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowInstrument = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFlowInstrumentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFlowMeter = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFlowMeterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFlowMovingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowMovingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowStorageDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowStorageDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFlowTreatmentDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFlowTreatmentDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFooting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFootingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFurnishingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcFurnishingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcFurniture = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcFurnitureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.AssemblyPlace = AssemblyPlace;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let AssemblyPlace = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.AssemblyPlace);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcGeographicElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcGeographicElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcGeometricCurveSet = class {
    constructor(expressID, type, Elements) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      return new IfcGeometricCurveSet(expressID, type, Elements);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      ;
      return args;
    }
  };
  var IfcGeometricRepresentationContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
      this.CoordinateSpaceDimension = CoordinateSpaceDimension;
      this.Precision = Precision;
      this.WorldCoordinateSystem = WorldCoordinateSystem;
      this.TrueNorth = TrueNorth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      let CoordinateSpaceDimension = tape[ptr++];
      let Precision = tape[ptr++];
      let WorldCoordinateSystem = tape[ptr++];
      let TrueNorth = tape[ptr++];
      return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      ;
      args.push(this.ContextType);
      ;
      args.push(this.CoordinateSpaceDimension);
      ;
      args.push(this.Precision);
      ;
      args.push(this.WorldCoordinateSystem);
      ;
      args.push(this.TrueNorth);
      ;
      return args;
    }
  };
  var IfcGeometricRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcGeometricRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcGeometricRepresentationSubContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
      this.CoordinateSpaceDimension = CoordinateSpaceDimension;
      this.Precision = Precision;
      this.WorldCoordinateSystem = WorldCoordinateSystem;
      this.TrueNorth = TrueNorth;
      this.ParentContext = ParentContext;
      this.TargetScale = TargetScale;
      this.TargetView = TargetView;
      this.UserDefinedTargetView = UserDefinedTargetView;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      let CoordinateSpaceDimension = tape[ptr++];
      let Precision = tape[ptr++];
      let WorldCoordinateSystem = tape[ptr++];
      let TrueNorth = tape[ptr++];
      let ParentContext = tape[ptr++];
      let TargetScale = tape[ptr++];
      let TargetView = tape[ptr++];
      let UserDefinedTargetView = tape[ptr++];
      return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      ;
      args.push(this.ContextType);
      ;
      args.push(this.CoordinateSpaceDimension);
      ;
      args.push(this.Precision);
      ;
      args.push(this.WorldCoordinateSystem);
      ;
      args.push(this.TrueNorth);
      ;
      args.push(this.ParentContext);
      ;
      args.push(this.TargetScale);
      ;
      args.push(this.TargetView);
      ;
      args.push(this.UserDefinedTargetView);
      ;
      return args;
    }
  };
  var IfcGeometricSet = class {
    constructor(expressID, type, Elements) {
      this.expressID = expressID;
      this.type = type;
      this.Elements = Elements;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Elements = tape[ptr++];
      return new IfcGeometricSet(expressID, type, Elements);
    }
    ToTape() {
      let args = [];
      args.push(this.Elements);
      ;
      return args;
    }
  };
  var IfcGrid = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.UAxes = UAxes;
      this.VAxes = VAxes;
      this.WAxes = WAxes;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let UAxes = tape[ptr++];
      let VAxes = tape[ptr++];
      let WAxes = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.UAxes);
      ;
      args.push(this.VAxes);
      ;
      args.push(this.WAxes);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcGridAxis = class {
    constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
      this.expressID = expressID;
      this.type = type;
      this.AxisTag = AxisTag;
      this.AxisCurve = AxisCurve;
      this.SameSense = SameSense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let AxisTag = tape[ptr++];
      let AxisCurve = tape[ptr++];
      let SameSense = tape[ptr++];
      return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
    }
    ToTape() {
      let args = [];
      args.push(this.AxisTag);
      ;
      args.push(this.AxisCurve);
      ;
      args.push(this.SameSense);
      ;
      return args;
    }
  };
  var IfcGridPlacement = class {
    constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.PlacementLocation = PlacementLocation;
      this.PlacementRefDirection = PlacementRefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let PlacementLocation = tape[ptr++];
      let PlacementRefDirection = tape[ptr++];
      return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      ;
      args.push(this.PlacementLocation);
      ;
      args.push(this.PlacementRefDirection);
      ;
      return args;
    }
  };
  var IfcGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      return args;
    }
  };
  var IfcHalfSpaceSolid = class {
    constructor(expressID, type, BaseSurface, AgreementFlag) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      ;
      args.push(this.AgreementFlag);
      ;
      return args;
    }
  };
  var IfcHeatExchanger = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcHeatExchangerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcHumidifier = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcHumidifierType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcIShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.OverallWidth = OverallWidth;
      this.OverallDepth = OverallDepth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.FlangeEdgeRadius = FlangeEdgeRadius;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let OverallDepth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let FlangeEdgeRadius = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.OverallWidth);
      ;
      args.push(this.OverallDepth);
      ;
      args.push(this.WebThickness);
      ;
      args.push(this.FlangeThickness);
      ;
      args.push(this.FilletRadius);
      ;
      args.push(this.FlangeEdgeRadius);
      ;
      args.push(this.FlangeSlope);
      ;
      return args;
    }
  };
  var IfcImageTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.URLReference = URLReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let URLReference = tape[ptr++];
      return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      ;
      args.push(this.RepeatT);
      ;
      args.push(this.Mode);
      ;
      args.push(this.TextureTransform);
      ;
      args.push(this.Parameter);
      ;
      args.push(this.URLReference);
      ;
      return args;
    }
  };
  var IfcIndexedColourMap = class {
    constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
      this.expressID = expressID;
      this.type = type;
      this.MappedTo = MappedTo;
      this.Opacity = Opacity;
      this.Colours = Colours;
      this.ColourIndex = ColourIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappedTo = tape[ptr++];
      let Opacity = tape[ptr++];
      let Colours = tape[ptr++];
      let ColourIndex = tape[ptr++];
      return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.MappedTo);
      ;
      args.push(this.Opacity);
      ;
      args.push(this.Colours);
      ;
      args.push(this.ColourIndex);
      ;
      return args;
    }
  };
  var IfcIndexedPolyCurve = class {
    constructor(expressID, type, Points, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Points = Points;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Points = tape[ptr++];
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Points);
      ;
      args.push(this.Segments);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcIndexedPolygonalFace = class {
    constructor(expressID, type, CoordIndex) {
      this.expressID = expressID;
      this.type = type;
      this.CoordIndex = CoordIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordIndex = tape[ptr++];
      return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordIndex);
      ;
      return args;
    }
  };
  var IfcIndexedPolygonalFaceWithVoids = class {
    constructor(expressID, type, CoordIndex, InnerCoordIndices) {
      this.expressID = expressID;
      this.type = type;
      this.CoordIndex = CoordIndex;
      this.InnerCoordIndices = InnerCoordIndices;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CoordIndex = tape[ptr++];
      let InnerCoordIndices = tape[ptr++];
      return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
    }
    ToTape() {
      let args = [];
      args.push(this.CoordIndex);
      ;
      args.push(this.InnerCoordIndices);
      ;
      return args;
    }
  };
  var IfcIndexedTextureMap = class {
    constructor(expressID, type, Maps, MappedTo, TexCoords) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.MappedTo = MappedTo;
      this.TexCoords = TexCoords;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let MappedTo = tape[ptr++];
      let TexCoords = tape[ptr++];
      return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      ;
      args.push(this.MappedTo);
      ;
      args.push(this.TexCoords);
      ;
      return args;
    }
  };
  var IfcIndexedTriangleTextureMap = class {
    constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.MappedTo = MappedTo;
      this.TexCoords = TexCoords;
      this.TexCoordIndex = TexCoordIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let MappedTo = tape[ptr++];
      let TexCoords = tape[ptr++];
      let TexCoordIndex = tape[ptr++];
      return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      ;
      args.push(this.MappedTo);
      ;
      args.push(this.TexCoords);
      ;
      args.push(this.TexCoordIndex);
      ;
      return args;
    }
  };
  var IfcInterceptor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcInterceptorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcIntersectionCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      ;
      args.push(this.AssociatedGeometry);
      ;
      args.push(this.MasterRepresentation);
      ;
      return args;
    }
  };
  var IfcInventory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.Jurisdiction = Jurisdiction;
      this.ResponsiblePersons = ResponsiblePersons;
      this.LastUpdateDate = LastUpdateDate;
      this.CurrentValue = CurrentValue;
      this.OriginalValue = OriginalValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Jurisdiction = tape[ptr++];
      let ResponsiblePersons = tape[ptr++];
      let LastUpdateDate = tape[ptr++];
      let CurrentValue = tape[ptr++];
      let OriginalValue = tape[ptr++];
      return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Jurisdiction);
      ;
      args.push(this.ResponsiblePersons);
      ;
      args.push(this.LastUpdateDate);
      ;
      args.push(this.CurrentValue);
      ;
      args.push(this.OriginalValue);
      ;
      return args;
    }
  };
  var IfcIrregularTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
      this.Values = Values;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      let Values = tape[ptr++];
      return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.EndTime);
      ;
      args.push(this.TimeSeriesDataType);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.Unit);
      ;
      args.push(this.Values);
      ;
      return args;
    }
  };
  var IfcIrregularTimeSeriesValue = class {
    constructor(expressID, type, TimeStamp, ListValues) {
      this.expressID = expressID;
      this.type = type;
      this.TimeStamp = TimeStamp;
      this.ListValues = ListValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TimeStamp = tape[ptr++];
      let ListValues = tape[ptr++];
      return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
    }
    ToTape() {
      let args = [];
      args.push(this.TimeStamp);
      ;
      args.push(this.ListValues);
      ;
      return args;
    }
  };
  var IfcJunctionBox = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcJunctionBoxType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.Width = Width;
      this.Thickness = Thickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
      this.LegSlope = LegSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let Width = tape[ptr++];
      let Thickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      let LegSlope = tape[ptr++];
      return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Depth);
      ;
      args.push(this.Width);
      ;
      args.push(this.Thickness);
      ;
      args.push(this.FilletRadius);
      ;
      args.push(this.EdgeRadius);
      ;
      args.push(this.LegSlope);
      ;
      return args;
    }
  };
  var IfcLaborResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLaborResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLagTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.LagValue = LagValue;
      this.DurationType = DurationType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let LagValue = tape[ptr++];
      let DurationType = tape[ptr++];
      return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.LagValue);
      ;
      args.push(this.DurationType);
      ;
      return args;
    }
  };
  var IfcLamp = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLampType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLibraryInformation = class {
    constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Version = Version;
      this.Publisher = Publisher;
      this.VersionDate = VersionDate;
      this.Location = Location;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Version = tape[ptr++];
      let Publisher = tape[ptr++];
      let VersionDate = tape[ptr++];
      let Location = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Version);
      ;
      args.push(this.Publisher);
      ;
      args.push(this.VersionDate);
      ;
      args.push(this.Location);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcLibraryReference = class {
    constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Language = Language;
      this.ReferencedLibrary = ReferencedLibrary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Language = tape[ptr++];
      let ReferencedLibrary = tape[ptr++];
      return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Language);
      ;
      args.push(this.ReferencedLibrary);
      ;
      return args;
    }
  };
  var IfcLightDistributionData = class {
    constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
      this.expressID = expressID;
      this.type = type;
      this.MainPlaneAngle = MainPlaneAngle;
      this.SecondaryPlaneAngle = SecondaryPlaneAngle;
      this.LuminousIntensity = LuminousIntensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MainPlaneAngle = tape[ptr++];
      let SecondaryPlaneAngle = tape[ptr++];
      let LuminousIntensity = tape[ptr++];
      return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
    }
    ToTape() {
      let args = [];
      args.push(this.MainPlaneAngle);
      ;
      args.push(this.SecondaryPlaneAngle);
      ;
      args.push(this.LuminousIntensity);
      ;
      return args;
    }
  };
  var IfcLightFixture = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLightFixtureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcLightIntensityDistribution = class {
    constructor(expressID, type, LightDistributionCurve, DistributionData) {
      this.expressID = expressID;
      this.type = type;
      this.LightDistributionCurve = LightDistributionCurve;
      this.DistributionData = DistributionData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LightDistributionCurve = tape[ptr++];
      let DistributionData = tape[ptr++];
      return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
    }
    ToTape() {
      let args = [];
      args.push(this.LightDistributionCurve);
      ;
      args.push(this.DistributionData);
      ;
      return args;
    }
  };
  var IfcLightSource = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      return args;
    }
  };
  var IfcLightSourceAmbient = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      return args;
    }
  };
  var IfcLightSourceDirectional = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      args.push(this.Orientation);
      ;
      return args;
    }
  };
  var IfcLightSourceGoniometric = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.ColourAppearance = ColourAppearance;
      this.ColourTemperature = ColourTemperature;
      this.LuminousFlux = LuminousFlux;
      this.LightEmissionSource = LightEmissionSource;
      this.LightDistributionDataSource = LightDistributionDataSource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let ColourAppearance = tape[ptr++];
      let ColourTemperature = tape[ptr++];
      let LuminousFlux = tape[ptr++];
      let LightEmissionSource = tape[ptr++];
      let LightDistributionDataSource = tape[ptr++];
      return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      args.push(this.Position);
      ;
      args.push(this.ColourAppearance);
      ;
      args.push(this.ColourTemperature);
      ;
      args.push(this.LuminousFlux);
      ;
      args.push(this.LightEmissionSource);
      ;
      args.push(this.LightDistributionDataSource);
      ;
      return args;
    }
  };
  var IfcLightSourcePositional = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.Radius = Radius;
      this.ConstantAttenuation = ConstantAttenuation;
      this.DistanceAttenuation = DistanceAttenuation;
      this.QuadricAttenuation = QuadricAttenuation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let ConstantAttenuation = tape[ptr++];
      let DistanceAttenuation = tape[ptr++];
      let QuadricAttenuation = tape[ptr++];
      return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      args.push(this.ConstantAttenuation);
      ;
      args.push(this.DistanceAttenuation);
      ;
      args.push(this.QuadricAttenuation);
      ;
      return args;
    }
  };
  var IfcLightSourceSpot = class {
    constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LightColour = LightColour;
      this.AmbientIntensity = AmbientIntensity;
      this.Intensity = Intensity;
      this.Position = Position;
      this.Radius = Radius;
      this.ConstantAttenuation = ConstantAttenuation;
      this.DistanceAttenuation = DistanceAttenuation;
      this.QuadricAttenuation = QuadricAttenuation;
      this.Orientation = Orientation;
      this.ConcentrationExponent = ConcentrationExponent;
      this.SpreadAngle = SpreadAngle;
      this.BeamWidthAngle = BeamWidthAngle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LightColour = tape[ptr++];
      let AmbientIntensity = tape[ptr++];
      let Intensity = tape[ptr++];
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      let ConstantAttenuation = tape[ptr++];
      let DistanceAttenuation = tape[ptr++];
      let QuadricAttenuation = tape[ptr++];
      let Orientation = tape[ptr++];
      let ConcentrationExponent = tape[ptr++];
      let SpreadAngle = tape[ptr++];
      let BeamWidthAngle = tape[ptr++];
      return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LightColour);
      ;
      args.push(this.AmbientIntensity);
      ;
      args.push(this.Intensity);
      ;
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      args.push(this.ConstantAttenuation);
      ;
      args.push(this.DistanceAttenuation);
      ;
      args.push(this.QuadricAttenuation);
      ;
      args.push(this.Orientation);
      ;
      args.push(this.ConcentrationExponent);
      ;
      args.push(this.SpreadAngle);
      ;
      args.push(this.BeamWidthAngle);
      ;
      return args;
    }
  };
  var IfcLine = class {
    constructor(expressID, type, Pnt, Dir) {
      this.expressID = expressID;
      this.type = type;
      this.Pnt = Pnt;
      this.Dir = Dir;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Pnt = tape[ptr++];
      let Dir = tape[ptr++];
      return new IfcLine(expressID, type, Pnt, Dir);
    }
    ToTape() {
      let args = [];
      args.push(this.Pnt);
      ;
      args.push(this.Dir);
      ;
      return args;
    }
  };
  var IfcLineSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      ;
      args.push(this.StartDirection);
      ;
      args.push(this.SegmentLength);
      ;
      return args;
    }
  };
  var IfcLinearPlacement = class {
    constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.PlacementMeasuredAlong = PlacementMeasuredAlong;
      this.Distance = Distance;
      this.Orientation = Orientation;
      this.CartesianPosition = CartesianPosition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let PlacementMeasuredAlong = tape[ptr++];
      let Distance = tape[ptr++];
      let Orientation = tape[ptr++];
      let CartesianPosition = tape[ptr++];
      return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      ;
      args.push(this.PlacementMeasuredAlong);
      ;
      args.push(this.Distance);
      ;
      args.push(this.Orientation);
      ;
      args.push(this.CartesianPosition);
      ;
      return args;
    }
  };
  var IfcLinearPositioningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Axis);
      ;
      return args;
    }
  };
  var IfcLocalPlacement = class {
    constructor(expressID, type, PlacementRelTo, RelativePlacement) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
      this.RelativePlacement = RelativePlacement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      let RelativePlacement = tape[ptr++];
      return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      ;
      args.push(this.RelativePlacement);
      ;
      return args;
    }
  };
  var IfcLoop = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcLoop(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcManifoldSolidBrep = class {
    constructor(expressID, type, Outer) {
      this.expressID = expressID;
      this.type = type;
      this.Outer = Outer;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Outer = tape[ptr++];
      return new IfcManifoldSolidBrep(expressID, type, Outer);
    }
    ToTape() {
      let args = [];
      args.push(this.Outer);
      ;
      return args;
    }
  };
  var IfcMapConversion = class {
    constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
      this.expressID = expressID;
      this.type = type;
      this.SourceCRS = SourceCRS;
      this.TargetCRS = TargetCRS;
      this.Eastings = Eastings;
      this.Northings = Northings;
      this.OrthogonalHeight = OrthogonalHeight;
      this.XAxisAbscissa = XAxisAbscissa;
      this.XAxisOrdinate = XAxisOrdinate;
      this.Scale = Scale;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SourceCRS = tape[ptr++];
      let TargetCRS = tape[ptr++];
      let Eastings = tape[ptr++];
      let Northings = tape[ptr++];
      let OrthogonalHeight = tape[ptr++];
      let XAxisAbscissa = tape[ptr++];
      let XAxisOrdinate = tape[ptr++];
      let Scale = tape[ptr++];
      return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
    }
    ToTape() {
      let args = [];
      args.push(this.SourceCRS);
      ;
      args.push(this.TargetCRS);
      ;
      args.push(this.Eastings);
      ;
      args.push(this.Northings);
      ;
      args.push(this.OrthogonalHeight);
      ;
      args.push(this.XAxisAbscissa);
      ;
      args.push(this.XAxisOrdinate);
      ;
      args.push(this.Scale);
      ;
      return args;
    }
  };
  var IfcMappedItem = class {
    constructor(expressID, type, MappingSource, MappingTarget) {
      this.expressID = expressID;
      this.type = type;
      this.MappingSource = MappingSource;
      this.MappingTarget = MappingTarget;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappingSource = tape[ptr++];
      let MappingTarget = tape[ptr++];
      return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
    }
    ToTape() {
      let args = [];
      args.push(this.MappingSource);
      ;
      args.push(this.MappingTarget);
      ;
      return args;
    }
  };
  var IfcMaterial = class {
    constructor(expressID, type, Name, Description, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterial(expressID, type, Name, Description, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Category);
      ;
      return args;
    }
  };
  var IfcMaterialClassificationRelationship = class {
    constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.MaterialClassifications = MaterialClassifications;
      this.ClassifiedMaterial = ClassifiedMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MaterialClassifications = tape[ptr++];
      let ClassifiedMaterial = tape[ptr++];
      return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.MaterialClassifications);
      ;
      args.push(this.ClassifiedMaterial);
      ;
      return args;
    }
  };
  var IfcMaterialConstituent = class {
    constructor(expressID, type, Name, Description, Material, Fraction, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Fraction = Fraction;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Fraction = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Material);
      ;
      args.push(this.Fraction);
      ;
      args.push(this.Category);
      ;
      return args;
    }
  };
  var IfcMaterialConstituentSet = class {
    constructor(expressID, type, Name, Description, MaterialConstituents) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.MaterialConstituents = MaterialConstituents;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MaterialConstituents = tape[ptr++];
      return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.MaterialConstituents);
      ;
      return args;
    }
  };
  var IfcMaterialDefinition = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcMaterialDefinition(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcMaterialDefinitionRepresentation = class {
    constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
      this.RepresentedMaterial = RepresentedMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      let RepresentedMaterial = tape[ptr++];
      return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Representations);
      ;
      args.push(this.RepresentedMaterial);
      ;
      return args;
    }
  };
  var IfcMaterialLayer = class {
    constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
      this.expressID = expressID;
      this.type = type;
      this.Material = Material;
      this.LayerThickness = LayerThickness;
      this.IsVentilated = IsVentilated;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
      this.Priority = Priority;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Material = tape[ptr++];
      let LayerThickness = tape[ptr++];
      let IsVentilated = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      let Priority = tape[ptr++];
      return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
    }
    ToTape() {
      let args = [];
      args.push(this.Material);
      ;
      args.push(this.LayerThickness);
      ;
      args.push(this.IsVentilated);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Category);
      ;
      args.push(this.Priority);
      ;
      return args;
    }
  };
  var IfcMaterialLayerSet = class {
    constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
      this.expressID = expressID;
      this.type = type;
      this.MaterialLayers = MaterialLayers;
      this.LayerSetName = LayerSetName;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MaterialLayers = tape[ptr++];
      let LayerSetName = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.MaterialLayers);
      ;
      args.push(this.LayerSetName);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcMaterialLayerSetUsage = class {
    constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
      this.expressID = expressID;
      this.type = type;
      this.ForLayerSet = ForLayerSet;
      this.LayerSetDirection = LayerSetDirection;
      this.DirectionSense = DirectionSense;
      this.OffsetFromReferenceLine = OffsetFromReferenceLine;
      this.ReferenceExtent = ReferenceExtent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForLayerSet = tape[ptr++];
      let LayerSetDirection = tape[ptr++];
      let DirectionSense = tape[ptr++];
      let OffsetFromReferenceLine = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
    }
    ToTape() {
      let args = [];
      args.push(this.ForLayerSet);
      ;
      args.push(this.LayerSetDirection);
      ;
      args.push(this.DirectionSense);
      ;
      args.push(this.OffsetFromReferenceLine);
      ;
      args.push(this.ReferenceExtent);
      ;
      return args;
    }
  };
  var IfcMaterialLayerWithOffsets = class {
    constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
      this.expressID = expressID;
      this.type = type;
      this.Material = Material;
      this.LayerThickness = LayerThickness;
      this.IsVentilated = IsVentilated;
      this.Name = Name;
      this.Description = Description;
      this.Category = Category;
      this.Priority = Priority;
      this.OffsetDirection = OffsetDirection;
      this.OffsetValues = OffsetValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Material = tape[ptr++];
      let LayerThickness = tape[ptr++];
      let IsVentilated = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Category = tape[ptr++];
      let Priority = tape[ptr++];
      let OffsetDirection = tape[ptr++];
      let OffsetValues = tape[ptr++];
      return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
    }
    ToTape() {
      let args = [];
      args.push(this.Material);
      ;
      args.push(this.LayerThickness);
      ;
      args.push(this.IsVentilated);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Category);
      ;
      args.push(this.Priority);
      ;
      args.push(this.OffsetDirection);
      ;
      args.push(this.OffsetValues);
      ;
      return args;
    }
  };
  var IfcMaterialList = class {
    constructor(expressID, type, Materials) {
      this.expressID = expressID;
      this.type = type;
      this.Materials = Materials;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Materials = tape[ptr++];
      return new IfcMaterialList(expressID, type, Materials);
    }
    ToTape() {
      let args = [];
      args.push(this.Materials);
      ;
      return args;
    }
  };
  var IfcMaterialProfile = class {
    constructor(expressID, type, Name, Description, Material, Profile, Priority, Category) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Profile = Profile;
      this.Priority = Priority;
      this.Category = Category;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Profile = tape[ptr++];
      let Priority = tape[ptr++];
      let Category = tape[ptr++];
      return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Material);
      ;
      args.push(this.Profile);
      ;
      args.push(this.Priority);
      ;
      args.push(this.Category);
      ;
      return args;
    }
  };
  var IfcMaterialProfileSet = class {
    constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.MaterialProfiles = MaterialProfiles;
      this.CompositeProfile = CompositeProfile;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let MaterialProfiles = tape[ptr++];
      let CompositeProfile = tape[ptr++];
      return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.MaterialProfiles);
      ;
      args.push(this.CompositeProfile);
      ;
      return args;
    }
  };
  var IfcMaterialProfileSetUsage = class {
    constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
      this.expressID = expressID;
      this.type = type;
      this.ForProfileSet = ForProfileSet;
      this.CardinalPoint = CardinalPoint;
      this.ReferenceExtent = ReferenceExtent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForProfileSet = tape[ptr++];
      let CardinalPoint = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
    }
    ToTape() {
      let args = [];
      args.push(this.ForProfileSet);
      ;
      args.push(this.CardinalPoint);
      ;
      args.push(this.ReferenceExtent);
      ;
      return args;
    }
  };
  var IfcMaterialProfileSetUsageTapering = class {
    constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
      this.expressID = expressID;
      this.type = type;
      this.ForProfileSet = ForProfileSet;
      this.CardinalPoint = CardinalPoint;
      this.ReferenceExtent = ReferenceExtent;
      this.ForProfileEndSet = ForProfileEndSet;
      this.CardinalEndPoint = CardinalEndPoint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ForProfileSet = tape[ptr++];
      let CardinalPoint = tape[ptr++];
      let ReferenceExtent = tape[ptr++];
      let ForProfileEndSet = tape[ptr++];
      let CardinalEndPoint = tape[ptr++];
      return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
    }
    ToTape() {
      let args = [];
      args.push(this.ForProfileSet);
      ;
      args.push(this.CardinalPoint);
      ;
      args.push(this.ReferenceExtent);
      ;
      args.push(this.ForProfileEndSet);
      ;
      args.push(this.CardinalEndPoint);
      ;
      return args;
    }
  };
  var IfcMaterialProfileWithOffsets = class {
    constructor(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Material = Material;
      this.Profile = Profile;
      this.Priority = Priority;
      this.Category = Category;
      this.OffsetValues = OffsetValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Material = tape[ptr++];
      let Profile = tape[ptr++];
      let Priority = tape[ptr++];
      let Category = tape[ptr++];
      let OffsetValues = tape[ptr++];
      return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Material);
      ;
      args.push(this.Profile);
      ;
      args.push(this.Priority);
      ;
      args.push(this.Category);
      ;
      args.push(this.OffsetValues);
      ;
      return args;
    }
  };
  var IfcMaterialProperties = class {
    constructor(expressID, type, Name, Description, Properties2, Material) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
      this.Material = Material;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      let Material = tape[ptr++];
      return new IfcMaterialProperties(expressID, type, Name, Description, Properties2, Material);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Properties);
      ;
      args.push(this.Material);
      ;
      return args;
    }
  };
  var IfcMaterialRelationship = class {
    constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingMaterial = RelatingMaterial;
      this.RelatedMaterials = RelatedMaterials;
      this.Expression = Expression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingMaterial = tape[ptr++];
      let RelatedMaterials = tape[ptr++];
      let Expression = tape[ptr++];
      return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingMaterial);
      ;
      args.push(this.RelatedMaterials);
      ;
      args.push(this.Expression);
      ;
      return args;
    }
  };
  var IfcMaterialUsageDefinition = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcMaterialUsageDefinition(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcMeasureWithUnit = class {
    constructor(expressID, type, ValueComponent, UnitComponent) {
      this.expressID = expressID;
      this.type = type;
      this.ValueComponent = ValueComponent;
      this.UnitComponent = UnitComponent;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ValueComponent = tape[ptr++];
      let UnitComponent = tape[ptr++];
      return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
    }
    ToTape() {
      let args = [];
      args.push(this.ValueComponent);
      ;
      args.push(this.UnitComponent);
      ;
      return args;
    }
  };
  var IfcMechanicalFastener = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.NominalDiameter = NominalDiameter;
      this.NominalLength = NominalLength;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let NominalLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.NominalLength);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMechanicalFastenerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.NominalLength = NominalLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let NominalLength = tape[ptr++];
      return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.NominalLength);
      ;
      return args;
    }
  };
  var IfcMedicalDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMedicalDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMemberStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMemberType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMetric = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
      this.Benchmark = Benchmark;
      this.ValueSource = ValueSource;
      this.DataValue = DataValue;
      this.ReferencePath = ReferencePath;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      let Benchmark = tape[ptr++];
      let ValueSource = tape[ptr++];
      let DataValue = tape[ptr++];
      let ReferencePath = tape[ptr++];
      return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConstraintGrade);
      ;
      args.push(this.ConstraintSource);
      ;
      args.push(this.CreatingActor);
      ;
      args.push(this.CreationTime);
      ;
      args.push(this.UserDefinedGrade);
      ;
      args.push(this.Benchmark);
      ;
      args.push(this.ValueSource);
      ;
      args.push(this.DataValue);
      ;
      args.push(this.ReferencePath);
      ;
      return args;
    }
  };
  var IfcMirroredProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.ParentProfile = ParentProfile;
      this.Operator = Operator;
      this.Label = Label;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let ParentProfile = tape[ptr++];
      let Operator = tape[ptr++];
      let Label = tape[ptr++];
      return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.ParentProfile);
      ;
      args.push(this.Operator);
      ;
      args.push(this.Label);
      ;
      return args;
    }
  };
  var IfcMonetaryUnit = class {
    constructor(expressID, type, Currency) {
      this.expressID = expressID;
      this.type = type;
      this.Currency = Currency;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Currency = tape[ptr++];
      return new IfcMonetaryUnit(expressID, type, Currency);
    }
    ToTape() {
      let args = [];
      args.push(this.Currency);
      ;
      return args;
    }
  };
  var IfcMotorConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcMotorConnectionType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcNamedUnit = class {
    constructor(expressID, type, Dimensions, UnitType) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      ;
      args.push(this.UnitType);
      ;
      return args;
    }
  };
  var IfcObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      return args;
    }
  };
  var IfcObjectDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcObjectPlacement = class {
    constructor(expressID, type, PlacementRelTo) {
      this.expressID = expressID;
      this.type = type;
      this.PlacementRelTo = PlacementRelTo;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let PlacementRelTo = tape[ptr++];
      return new IfcObjectPlacement(expressID, type, PlacementRelTo);
    }
    ToTape() {
      let args = [];
      args.push(this.PlacementRelTo);
      ;
      return args;
    }
  };
  var IfcObjective = class {
    constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ConstraintGrade = ConstraintGrade;
      this.ConstraintSource = ConstraintSource;
      this.CreatingActor = CreatingActor;
      this.CreationTime = CreationTime;
      this.UserDefinedGrade = UserDefinedGrade;
      this.BenchmarkValues = BenchmarkValues;
      this.LogicalAggregator = LogicalAggregator;
      this.ObjectiveQualifier = ObjectiveQualifier;
      this.UserDefinedQualifier = UserDefinedQualifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConstraintGrade = tape[ptr++];
      let ConstraintSource = tape[ptr++];
      let CreatingActor = tape[ptr++];
      let CreationTime = tape[ptr++];
      let UserDefinedGrade = tape[ptr++];
      let BenchmarkValues = tape[ptr++];
      let LogicalAggregator = tape[ptr++];
      let ObjectiveQualifier = tape[ptr++];
      let UserDefinedQualifier = tape[ptr++];
      return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConstraintGrade);
      ;
      args.push(this.ConstraintSource);
      ;
      args.push(this.CreatingActor);
      ;
      args.push(this.CreationTime);
      ;
      args.push(this.UserDefinedGrade);
      ;
      args.push(this.BenchmarkValues);
      ;
      args.push(this.LogicalAggregator);
      ;
      args.push(this.ObjectiveQualifier);
      ;
      args.push(this.UserDefinedQualifier);
      ;
      return args;
    }
  };
  var IfcOccupant = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheActor = TheActor;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheActor = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.TheActor);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcOffsetCurve = class {
    constructor(expressID, type, BasisCurve) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      return new IfcOffsetCurve(expressID, type, BasisCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      return args;
    }
  };
  var IfcOffsetCurve2D = class {
    constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Distance = Distance;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Distance = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      args.push(this.Distance);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcOffsetCurve3D = class {
    constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Distance = Distance;
      this.SelfIntersect = SelfIntersect;
      this.RefDirection = RefDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Distance = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let RefDirection = tape[ptr++];
      return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      args.push(this.Distance);
      ;
      args.push(this.SelfIntersect);
      ;
      args.push(this.RefDirection);
      ;
      return args;
    }
  };
  var IfcOffsetCurveByDistances = class {
    constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.OffsetValues = OffsetValues;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let OffsetValues = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      args.push(this.OffsetValues);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcOpenShell = class {
    constructor(expressID, type, CfsFaces) {
      this.expressID = expressID;
      this.type = type;
      this.CfsFaces = CfsFaces;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let CfsFaces = tape[ptr++];
      return new IfcOpenShell(expressID, type, CfsFaces);
    }
    ToTape() {
      let args = [];
      args.push(this.CfsFaces);
      ;
      return args;
    }
  };
  var IfcOpeningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcOpeningStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcOrganization = class {
    constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.Name = Name;
      this.Description = Description;
      this.Roles = Roles;
      this.Addresses = Addresses;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Roles = tape[ptr++];
      let Addresses = tape[ptr++];
      return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Roles);
      ;
      args.push(this.Addresses);
      ;
      return args;
    }
  };
  var IfcOrganizationRelationship = class {
    constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingOrganization = RelatingOrganization;
      this.RelatedOrganizations = RelatedOrganizations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingOrganization = tape[ptr++];
      let RelatedOrganizations = tape[ptr++];
      return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingOrganization);
      ;
      args.push(this.RelatedOrganizations);
      ;
      return args;
    }
  };
  var IfcOrientationExpression = class {
    constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
      this.expressID = expressID;
      this.type = type;
      this.LateralAxisDirection = LateralAxisDirection;
      this.VerticalAxisDirection = VerticalAxisDirection;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LateralAxisDirection = tape[ptr++];
      let VerticalAxisDirection = tape[ptr++];
      return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
    }
    ToTape() {
      let args = [];
      args.push(this.LateralAxisDirection);
      ;
      args.push(this.VerticalAxisDirection);
      ;
      return args;
    }
  };
  var IfcOrientedEdge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.EdgeElement = EdgeElement;
      this.Orientation = Orientation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let EdgeElement = tape[ptr++];
      let Orientation = tape[ptr++];
      return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      ;
      args.push(this.EdgeEnd);
      ;
      args.push(this.EdgeElement);
      ;
      args.push(this.Orientation);
      ;
      return args;
    }
  };
  var IfcOuterBoundaryCurve = class {
    constructor(expressID, type, Segments, SelfIntersect) {
      this.expressID = expressID;
      this.type = type;
      this.Segments = Segments;
      this.SelfIntersect = SelfIntersect;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Segments = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
    }
    ToTape() {
      let args = [];
      args.push(this.Segments);
      ;
      args.push(this.SelfIntersect);
      ;
      return args;
    }
  };
  var IfcOutlet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcOutletType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcOwnerHistory = class {
    constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
      this.expressID = expressID;
      this.type = type;
      this.OwningUser = OwningUser;
      this.OwningApplication = OwningApplication;
      this.State = State;
      this.ChangeAction = ChangeAction;
      this.LastModifiedDate = LastModifiedDate;
      this.LastModifyingUser = LastModifyingUser;
      this.LastModifyingApplication = LastModifyingApplication;
      this.CreationDate = CreationDate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let OwningUser = tape[ptr++];
      let OwningApplication = tape[ptr++];
      let State = tape[ptr++];
      let ChangeAction = tape[ptr++];
      let LastModifiedDate = tape[ptr++];
      let LastModifyingUser = tape[ptr++];
      let LastModifyingApplication = tape[ptr++];
      let CreationDate = tape[ptr++];
      return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
    }
    ToTape() {
      let args = [];
      args.push(this.OwningUser);
      ;
      args.push(this.OwningApplication);
      ;
      args.push(this.State);
      ;
      args.push(this.ChangeAction);
      ;
      args.push(this.LastModifiedDate);
      ;
      args.push(this.LastModifyingUser);
      ;
      args.push(this.LastModifyingApplication);
      ;
      args.push(this.CreationDate);
      ;
      return args;
    }
  };
  var IfcParameterizedProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcPath = class {
    constructor(expressID, type, EdgeList) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeList = EdgeList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeList = tape[ptr++];
      return new IfcPath(expressID, type, EdgeList);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeList);
      ;
      return args;
    }
  };
  var IfcPcurve = class {
    constructor(expressID, type, BasisSurface, ReferenceCurve) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.ReferenceCurve = ReferenceCurve;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let ReferenceCurve = tape[ptr++];
      return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      ;
      args.push(this.ReferenceCurve);
      ;
      return args;
    }
  };
  var IfcPerformanceHistory = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LifeCyclePhase = LifeCyclePhase;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LifeCyclePhase = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LifeCyclePhase);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPermeableCoveringProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.OperationType = OperationType;
      this.PanelPosition = PanelPosition;
      this.FrameDepth = FrameDepth;
      this.FrameThickness = FrameThickness;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let OperationType = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let FrameDepth = tape[ptr++];
      let FrameThickness = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.PanelPosition);
      ;
      args.push(this.FrameDepth);
      ;
      args.push(this.FrameThickness);
      ;
      args.push(this.ShapeAspectStyle);
      ;
      return args;
    }
  };
  var IfcPermit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Status);
      ;
      args.push(this.LongDescription);
      ;
      return args;
    }
  };
  var IfcPerson = class {
    constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
      this.expressID = expressID;
      this.type = type;
      this.Identification = Identification;
      this.FamilyName = FamilyName;
      this.GivenName = GivenName;
      this.MiddleNames = MiddleNames;
      this.PrefixTitles = PrefixTitles;
      this.SuffixTitles = SuffixTitles;
      this.Roles = Roles;
      this.Addresses = Addresses;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identification = tape[ptr++];
      let FamilyName = tape[ptr++];
      let GivenName = tape[ptr++];
      let MiddleNames = tape[ptr++];
      let PrefixTitles = tape[ptr++];
      let SuffixTitles = tape[ptr++];
      let Roles = tape[ptr++];
      let Addresses = tape[ptr++];
      return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
    }
    ToTape() {
      let args = [];
      args.push(this.Identification);
      ;
      args.push(this.FamilyName);
      ;
      args.push(this.GivenName);
      ;
      args.push(this.MiddleNames);
      ;
      args.push(this.PrefixTitles);
      ;
      args.push(this.SuffixTitles);
      ;
      args.push(this.Roles);
      ;
      args.push(this.Addresses);
      ;
      return args;
    }
  };
  var IfcPersonAndOrganization = class {
    constructor(expressID, type, ThePerson, TheOrganization, Roles) {
      this.expressID = expressID;
      this.type = type;
      this.ThePerson = ThePerson;
      this.TheOrganization = TheOrganization;
      this.Roles = Roles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ThePerson = tape[ptr++];
      let TheOrganization = tape[ptr++];
      let Roles = tape[ptr++];
      return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
    }
    ToTape() {
      let args = [];
      args.push(this.ThePerson);
      ;
      args.push(this.TheOrganization);
      ;
      args.push(this.Roles);
      ;
      return args;
    }
  };
  var IfcPhysicalComplexQuantity = class {
    constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.HasQuantities = HasQuantities;
      this.Discrimination = Discrimination;
      this.Quality = Quality;
      this.Usage = Usage;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let HasQuantities = tape[ptr++];
      let Discrimination = tape[ptr++];
      let Quality = tape[ptr++];
      let Usage = tape[ptr++];
      return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.HasQuantities);
      ;
      args.push(this.Discrimination);
      ;
      args.push(this.Quality);
      ;
      args.push(this.Usage);
      ;
      return args;
    }
  };
  var IfcPhysicalQuantity = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPhysicalQuantity(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPhysicalSimpleQuantity = class {
    constructor(expressID, type, Name, Description, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      return args;
    }
  };
  var IfcPile = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
      this.ConstructionType = ConstructionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ConstructionType = tape[ptr++];
      return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.ConstructionType);
      ;
      return args;
    }
  };
  var IfcPileType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPipeFitting = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPipeFittingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPipeSegment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPipeSegmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPixelTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
      this.Width = Width;
      this.Height = Height;
      this.ColourComponents = ColourComponents;
      this.Pixel = Pixel;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      let Width = tape[ptr++];
      let Height = tape[ptr++];
      let ColourComponents = tape[ptr++];
      let Pixel = tape[ptr++];
      return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      ;
      args.push(this.RepeatT);
      ;
      args.push(this.Mode);
      ;
      args.push(this.TextureTransform);
      ;
      args.push(this.Parameter);
      ;
      args.push(this.Width);
      ;
      args.push(this.Height);
      ;
      args.push(this.ColourComponents);
      ;
      args.push(this.Pixel);
      ;
      return args;
    }
  };
  var IfcPlacement = class {
    constructor(expressID, type, Location) {
      this.expressID = expressID;
      this.type = type;
      this.Location = Location;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Location = tape[ptr++];
      return new IfcPlacement(expressID, type, Location);
    }
    ToTape() {
      let args = [];
      args.push(this.Location);
      ;
      return args;
    }
  };
  var IfcPlanarBox = class {
    constructor(expressID, type, SizeInX, SizeInY, Placement) {
      this.expressID = expressID;
      this.type = type;
      this.SizeInX = SizeInX;
      this.SizeInY = SizeInY;
      this.Placement = Placement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SizeInX = tape[ptr++];
      let SizeInY = tape[ptr++];
      let Placement = tape[ptr++];
      return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
    }
    ToTape() {
      let args = [];
      args.push(this.SizeInX);
      ;
      args.push(this.SizeInY);
      ;
      args.push(this.Placement);
      ;
      return args;
    }
  };
  var IfcPlanarExtent = class {
    constructor(expressID, type, SizeInX, SizeInY) {
      this.expressID = expressID;
      this.type = type;
      this.SizeInX = SizeInX;
      this.SizeInY = SizeInY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SizeInX = tape[ptr++];
      let SizeInY = tape[ptr++];
      return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
    }
    ToTape() {
      let args = [];
      args.push(this.SizeInX);
      ;
      args.push(this.SizeInY);
      ;
      return args;
    }
  };
  var IfcPlane = class {
    constructor(expressID, type, Position) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      return new IfcPlane(expressID, type, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcPlate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPlateStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPlateType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPoint = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcPoint(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPointOnCurve = class {
    constructor(expressID, type, BasisCurve, PointParameter) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.PointParameter = PointParameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let PointParameter = tape[ptr++];
      return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      args.push(this.PointParameter);
      ;
      return args;
    }
  };
  var IfcPointOnSurface = class {
    constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.PointParameterU = PointParameterU;
      this.PointParameterV = PointParameterV;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let PointParameterU = tape[ptr++];
      let PointParameterV = tape[ptr++];
      return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      ;
      args.push(this.PointParameterU);
      ;
      args.push(this.PointParameterV);
      ;
      return args;
    }
  };
  var IfcPolyLoop = class {
    constructor(expressID, type, Polygon) {
      this.expressID = expressID;
      this.type = type;
      this.Polygon = Polygon;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Polygon = tape[ptr++];
      return new IfcPolyLoop(expressID, type, Polygon);
    }
    ToTape() {
      let args = [];
      args.push(this.Polygon);
      ;
      return args;
    }
  };
  var IfcPolygonalBoundedHalfSpace = class {
    constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.BaseSurface = BaseSurface;
      this.AgreementFlag = AgreementFlag;
      this.Position = Position;
      this.PolygonalBoundary = PolygonalBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BaseSurface = tape[ptr++];
      let AgreementFlag = tape[ptr++];
      let Position = tape[ptr++];
      let PolygonalBoundary = tape[ptr++];
      return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.BaseSurface);
      ;
      args.push(this.AgreementFlag);
      ;
      args.push(this.Position);
      ;
      args.push(this.PolygonalBoundary);
      ;
      return args;
    }
  };
  var IfcPolygonalFaceSet = class {
    constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Closed = Closed;
      this.Faces = Faces;
      this.PnIndex = PnIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Closed = tape[ptr++];
      let Faces = tape[ptr++];
      let PnIndex = tape[ptr++];
      return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      args.push(this.Closed);
      ;
      args.push(this.Faces);
      ;
      args.push(this.PnIndex);
      ;
      return args;
    }
  };
  var IfcPolyline = class {
    constructor(expressID, type, Points) {
      this.expressID = expressID;
      this.type = type;
      this.Points = Points;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Points = tape[ptr++];
      return new IfcPolyline(expressID, type, Points);
    }
    ToTape() {
      let args = [];
      args.push(this.Points);
      ;
      return args;
    }
  };
  var IfcPort = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcPositioningElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcPostalAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
      this.InternalLocation = InternalLocation;
      this.AddressLines = AddressLines;
      this.PostalBox = PostalBox;
      this.Town = Town;
      this.Region = Region;
      this.PostalCode = PostalCode;
      this.Country = Country;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      let InternalLocation = tape[ptr++];
      let AddressLines = tape[ptr++];
      let PostalBox = tape[ptr++];
      let Town = tape[ptr++];
      let Region = tape[ptr++];
      let PostalCode = tape[ptr++];
      let Country = tape[ptr++];
      return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      ;
      args.push(this.Description);
      ;
      args.push(this.UserDefinedPurpose);
      ;
      args.push(this.InternalLocation);
      ;
      args.push(this.AddressLines);
      ;
      args.push(this.PostalBox);
      ;
      args.push(this.Town);
      ;
      args.push(this.Region);
      ;
      args.push(this.PostalCode);
      ;
      args.push(this.Country);
      ;
      return args;
    }
  };
  var IfcPreDefinedColour = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedColour(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcPreDefinedCurveFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedCurveFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcPreDefinedItem = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedItem(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcPreDefinedProperties = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcPreDefinedProperties(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPreDefinedPropertySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPreDefinedTextFont = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPreDefinedTextFont(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcPresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcPresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPresentationLayerAssignment = class {
    constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AssignedItems = AssignedItems;
      this.Identifier = Identifier;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AssignedItems = tape[ptr++];
      let Identifier = tape[ptr++];
      return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.AssignedItems);
      ;
      args.push(this.Identifier);
      ;
      return args;
    }
  };
  var IfcPresentationLayerWithStyle = class {
    constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.AssignedItems = AssignedItems;
      this.Identifier = Identifier;
      this.LayerOn = LayerOn;
      this.LayerFrozen = LayerFrozen;
      this.LayerBlocked = LayerBlocked;
      this.LayerStyles = LayerStyles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let AssignedItems = tape[ptr++];
      let Identifier = tape[ptr++];
      let LayerOn = tape[ptr++];
      let LayerFrozen = tape[ptr++];
      let LayerBlocked = tape[ptr++];
      let LayerStyles = tape[ptr++];
      return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.AssignedItems);
      ;
      args.push(this.Identifier);
      ;
      args.push(this.LayerOn);
      ;
      args.push(this.LayerFrozen);
      ;
      args.push(this.LayerBlocked);
      ;
      args.push(this.LayerStyles);
      ;
      return args;
    }
  };
  var IfcPresentationStyle = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcPresentationStyle(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcPresentationStyleAssignment = class {
    constructor(expressID, type, Styles) {
      this.expressID = expressID;
      this.type = type;
      this.Styles = Styles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Styles = tape[ptr++];
      return new IfcPresentationStyleAssignment(expressID, type, Styles);
    }
    ToTape() {
      let args = [];
      args.push(this.Styles);
      ;
      return args;
    }
  };
  var IfcProcedure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProcedureType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ProcessType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      return args;
    }
  };
  var IfcProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcProductDefinitionShape = class {
    constructor(expressID, type, Name, Description, Representations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Representations);
      ;
      return args;
    }
  };
  var IfcProductRepresentation = class {
    constructor(expressID, type, Name, Description, Representations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Representations = Representations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Representations = tape[ptr++];
      return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Representations);
      ;
      return args;
    }
  };
  var IfcProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      return args;
    }
  };
  var IfcProfileProperties = class {
    constructor(expressID, type, Name, Description, Properties2, ProfileDefinition) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Properties = Properties2;
      this.ProfileDefinition = ProfileDefinition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Properties2 = tape[ptr++];
      let ProfileDefinition = tape[ptr++];
      return new IfcProfileProperties(expressID, type, Name, Description, Properties2, ProfileDefinition);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Properties);
      ;
      args.push(this.ProfileDefinition);
      ;
      return args;
    }
  };
  var IfcProject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      args.push(this.Phase);
      ;
      args.push(this.RepresentationContexts);
      ;
      args.push(this.UnitsInContext);
      ;
      return args;
    }
  };
  var IfcProjectLibrary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
      this.Phase = Phase;
      this.RepresentationContexts = RepresentationContexts;
      this.UnitsInContext = UnitsInContext;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      let Phase = tape[ptr++];
      let RepresentationContexts = tape[ptr++];
      let UnitsInContext = tape[ptr++];
      return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      args.push(this.Phase);
      ;
      args.push(this.RepresentationContexts);
      ;
      args.push(this.UnitsInContext);
      ;
      return args;
    }
  };
  var IfcProjectOrder = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.PredefinedType = PredefinedType;
      this.Status = Status;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Status = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Status);
      ;
      args.push(this.LongDescription);
      ;
      return args;
    }
  };
  var IfcProjectedCRS = class {
    constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.GeodeticDatum = GeodeticDatum;
      this.VerticalDatum = VerticalDatum;
      this.MapProjection = MapProjection;
      this.MapZone = MapZone;
      this.MapUnit = MapUnit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let GeodeticDatum = tape[ptr++];
      let VerticalDatum = tape[ptr++];
      let MapProjection = tape[ptr++];
      let MapZone = tape[ptr++];
      let MapUnit = tape[ptr++];
      return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.GeodeticDatum);
      ;
      args.push(this.VerticalDatum);
      ;
      args.push(this.MapProjection);
      ;
      args.push(this.MapZone);
      ;
      args.push(this.MapUnit);
      ;
      return args;
    }
  };
  var IfcProjectionElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProperty = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcProperty(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPropertyAbstraction = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcPropertyAbstraction(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcPropertyBoundedValue = class {
    constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UpperBoundValue = UpperBoundValue;
      this.LowerBoundValue = LowerBoundValue;
      this.Unit = Unit;
      this.SetPointValue = SetPointValue;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UpperBoundValue = tape[ptr++];
      let LowerBoundValue = tape[ptr++];
      let Unit = tape[ptr++];
      let SetPointValue = tape[ptr++];
      return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.UpperBoundValue);
      ;
      args.push(this.LowerBoundValue);
      ;
      args.push(this.Unit);
      ;
      args.push(this.SetPointValue);
      ;
      return args;
    }
  };
  var IfcPropertyDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPropertyDependencyRelationship = class {
    constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.DependingProperty = DependingProperty;
      this.DependantProperty = DependantProperty;
      this.Expression = Expression;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DependingProperty = tape[ptr++];
      let DependantProperty = tape[ptr++];
      let Expression = tape[ptr++];
      return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.DependingProperty);
      ;
      args.push(this.DependantProperty);
      ;
      args.push(this.Expression);
      ;
      return args;
    }
  };
  var IfcPropertyEnumeratedValue = class {
    constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.EnumerationValues = EnumerationValues;
      this.EnumerationReference = EnumerationReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let EnumerationValues = tape[ptr++];
      let EnumerationReference = tape[ptr++];
      return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.EnumerationValues);
      ;
      args.push(this.EnumerationReference);
      ;
      return args;
    }
  };
  var IfcPropertyEnumeration = class {
    constructor(expressID, type, Name, EnumerationValues, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.EnumerationValues = EnumerationValues;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let EnumerationValues = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.EnumerationValues);
      ;
      args.push(this.Unit);
      ;
      return args;
    }
  };
  var IfcPropertyListValue = class {
    constructor(expressID, type, Name, Description, ListValues, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.ListValues = ListValues;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ListValues = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ListValues);
      ;
      args.push(this.Unit);
      ;
      return args;
    }
  };
  var IfcPropertyReferenceValue = class {
    constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.UsageName = UsageName;
      this.PropertyReference = PropertyReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let UsageName = tape[ptr++];
      let PropertyReference = tape[ptr++];
      return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.UsageName);
      ;
      args.push(this.PropertyReference);
      ;
      return args;
    }
  };
  var IfcPropertySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.HasProperties = HasProperties;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let HasProperties = tape[ptr++];
      return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.HasProperties);
      ;
      return args;
    }
  };
  var IfcPropertySetDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPropertySetTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.TemplateType = TemplateType;
      this.ApplicableEntity = ApplicableEntity;
      this.HasPropertyTemplates = HasPropertyTemplates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TemplateType = tape[ptr++];
      let ApplicableEntity = tape[ptr++];
      let HasPropertyTemplates = tape[ptr++];
      return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.TemplateType);
      ;
      args.push(this.ApplicableEntity);
      ;
      args.push(this.HasPropertyTemplates);
      ;
      return args;
    }
  };
  var IfcPropertySingleValue = class {
    constructor(expressID, type, Name, Description, NominalValue, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.NominalValue = NominalValue;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let NominalValue = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.NominalValue);
      ;
      args.push(this.Unit);
      ;
      return args;
    }
  };
  var IfcPropertyTableValue = class {
    constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.DefiningValues = DefiningValues;
      this.DefinedValues = DefinedValues;
      this.Expression = Expression;
      this.DefiningUnit = DefiningUnit;
      this.DefinedUnit = DefinedUnit;
      this.CurveInterpolation = CurveInterpolation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DefiningValues = tape[ptr++];
      let DefinedValues = tape[ptr++];
      let Expression = tape[ptr++];
      let DefiningUnit = tape[ptr++];
      let DefinedUnit = tape[ptr++];
      let CurveInterpolation = tape[ptr++];
      return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.DefiningValues);
      ;
      args.push(this.DefinedValues);
      ;
      args.push(this.Expression);
      ;
      args.push(this.DefiningUnit);
      ;
      args.push(this.DefinedUnit);
      ;
      args.push(this.CurveInterpolation);
      ;
      return args;
    }
  };
  var IfcPropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcPropertyTemplateDefinition = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcProtectiveDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProtectiveDeviceTrippingUnit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProtectiveDeviceTrippingUnitType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProtectiveDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcProxy = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.ProxyType = ProxyType;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let ProxyType = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.ProxyType);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcPump = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcPumpType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcQuantityArea = class {
    constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.AreaValue = AreaValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let AreaValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.AreaValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcQuantityCount = class {
    constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.CountValue = CountValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let CountValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.CountValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcQuantityLength = class {
    constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.LengthValue = LengthValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let LengthValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.LengthValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcQuantitySet = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcQuantityTime = class {
    constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.TimeValue = TimeValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let TimeValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.TimeValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcQuantityVolume = class {
    constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.VolumeValue = VolumeValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let VolumeValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.VolumeValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcQuantityWeight = class {
    constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.WeightValue = WeightValue;
      this.Formula = Formula;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let WeightValue = tape[ptr++];
      let Formula = tape[ptr++];
      return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.WeightValue);
      ;
      args.push(this.Formula);
      ;
      return args;
    }
  };
  var IfcRailing = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRailingType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRamp = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRampFlight = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRampFlightType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRampType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRationalBSplineCurveWithKnots = class {
    constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
      this.expressID = expressID;
      this.type = type;
      this.Degree = Degree;
      this.ControlPointsList = ControlPointsList;
      this.CurveForm = CurveForm;
      this.ClosedCurve = ClosedCurve;
      this.SelfIntersect = SelfIntersect;
      this.KnotMultiplicities = KnotMultiplicities;
      this.Knots = Knots;
      this.KnotSpec = KnotSpec;
      this.WeightsData = WeightsData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Degree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let CurveForm = tape[ptr++];
      let ClosedCurve = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let KnotMultiplicities = tape[ptr++];
      let Knots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      let WeightsData = tape[ptr++];
      return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
    }
    ToTape() {
      let args = [];
      args.push(this.Degree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.CurveForm);
      ;
      args.push(this.ClosedCurve);
      ;
      args.push(this.SelfIntersect);
      ;
      args.push(this.KnotMultiplicities);
      ;
      args.push(this.Knots);
      ;
      args.push(this.KnotSpec);
      ;
      args.push(this.WeightsData);
      ;
      return args;
    }
  };
  var IfcRationalBSplineSurfaceWithKnots = class {
    constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
      this.expressID = expressID;
      this.type = type;
      this.UDegree = UDegree;
      this.VDegree = VDegree;
      this.ControlPointsList = ControlPointsList;
      this.SurfaceForm = SurfaceForm;
      this.UClosed = UClosed;
      this.VClosed = VClosed;
      this.SelfIntersect = SelfIntersect;
      this.UMultiplicities = UMultiplicities;
      this.VMultiplicities = VMultiplicities;
      this.UKnots = UKnots;
      this.VKnots = VKnots;
      this.KnotSpec = KnotSpec;
      this.WeightsData = WeightsData;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let UDegree = tape[ptr++];
      let VDegree = tape[ptr++];
      let ControlPointsList = tape[ptr++];
      let SurfaceForm = tape[ptr++];
      let UClosed = tape[ptr++];
      let VClosed = tape[ptr++];
      let SelfIntersect = tape[ptr++];
      let UMultiplicities = tape[ptr++];
      let VMultiplicities = tape[ptr++];
      let UKnots = tape[ptr++];
      let VKnots = tape[ptr++];
      let KnotSpec = tape[ptr++];
      let WeightsData = tape[ptr++];
      return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
    }
    ToTape() {
      let args = [];
      args.push(this.UDegree);
      ;
      args.push(this.VDegree);
      ;
      args.push(this.ControlPointsList);
      ;
      args.push(this.SurfaceForm);
      ;
      args.push(this.UClosed);
      ;
      args.push(this.VClosed);
      ;
      args.push(this.SelfIntersect);
      ;
      args.push(this.UMultiplicities);
      ;
      args.push(this.VMultiplicities);
      ;
      args.push(this.UKnots);
      ;
      args.push(this.VKnots);
      ;
      args.push(this.KnotSpec);
      ;
      args.push(this.WeightsData);
      ;
      return args;
    }
  };
  var IfcRectangleHollowProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
      this.WallThickness = WallThickness;
      this.InnerFilletRadius = InnerFilletRadius;
      this.OuterFilletRadius = OuterFilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let WallThickness = tape[ptr++];
      let InnerFilletRadius = tape[ptr++];
      let OuterFilletRadius = tape[ptr++];
      return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.XDim);
      ;
      args.push(this.YDim);
      ;
      args.push(this.WallThickness);
      ;
      args.push(this.InnerFilletRadius);
      ;
      args.push(this.OuterFilletRadius);
      ;
      return args;
    }
  };
  var IfcRectangleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.XDim);
      ;
      args.push(this.YDim);
      ;
      return args;
    }
  };
  var IfcRectangularPyramid = class {
    constructor(expressID, type, Position, XLength, YLength, Height) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.XLength = XLength;
      this.YLength = YLength;
      this.Height = Height;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let XLength = tape[ptr++];
      let YLength = tape[ptr++];
      let Height = tape[ptr++];
      return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.XLength);
      ;
      args.push(this.YLength);
      ;
      args.push(this.Height);
      ;
      return args;
    }
  };
  var IfcRectangularTrimmedSurface = class {
    constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
      this.expressID = expressID;
      this.type = type;
      this.BasisSurface = BasisSurface;
      this.U1 = U1;
      this.V1 = V1;
      this.U2 = U2;
      this.V2 = V2;
      this.Usense = Usense;
      this.Vsense = Vsense;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisSurface = tape[ptr++];
      let U1 = tape[ptr++];
      let V1 = tape[ptr++];
      let U2 = tape[ptr++];
      let V2 = tape[ptr++];
      let Usense = tape[ptr++];
      let Vsense = tape[ptr++];
      return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisSurface);
      ;
      args.push(this.U1);
      ;
      args.push(this.V1);
      ;
      args.push(this.U2);
      ;
      args.push(this.V2);
      ;
      args.push(this.Usense);
      ;
      args.push(this.Vsense);
      ;
      return args;
    }
  };
  var IfcRecurrencePattern = class {
    constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
      this.expressID = expressID;
      this.type = type;
      this.RecurrenceType = RecurrenceType;
      this.DayComponent = DayComponent;
      this.WeekdayComponent = WeekdayComponent;
      this.MonthComponent = MonthComponent;
      this.Position = Position;
      this.Interval = Interval;
      this.Occurrences = Occurrences;
      this.TimePeriods = TimePeriods;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RecurrenceType = tape[ptr++];
      let DayComponent = tape[ptr++];
      let WeekdayComponent = tape[ptr++];
      let MonthComponent = tape[ptr++];
      let Position = tape[ptr++];
      let Interval = tape[ptr++];
      let Occurrences = tape[ptr++];
      let TimePeriods = tape[ptr++];
      return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
    }
    ToTape() {
      let args = [];
      args.push(this.RecurrenceType);
      ;
      args.push(this.DayComponent);
      ;
      args.push(this.WeekdayComponent);
      ;
      args.push(this.MonthComponent);
      ;
      args.push(this.Position);
      ;
      args.push(this.Interval);
      ;
      args.push(this.Occurrences);
      ;
      args.push(this.TimePeriods);
      ;
      return args;
    }
  };
  var IfcReference = class {
    constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
      this.expressID = expressID;
      this.type = type;
      this.TypeIdentifier = TypeIdentifier;
      this.AttributeIdentifier = AttributeIdentifier;
      this.InstanceName = InstanceName;
      this.ListPositions = ListPositions;
      this.InnerReference = InnerReference;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TypeIdentifier = tape[ptr++];
      let AttributeIdentifier = tape[ptr++];
      let InstanceName = tape[ptr++];
      let ListPositions = tape[ptr++];
      let InnerReference = tape[ptr++];
      return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
    }
    ToTape() {
      let args = [];
      args.push(this.TypeIdentifier);
      ;
      args.push(this.AttributeIdentifier);
      ;
      args.push(this.InstanceName);
      ;
      args.push(this.ListPositions);
      ;
      args.push(this.InnerReference);
      ;
      return args;
    }
  };
  var IfcReferent = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.RestartDistance = RestartDistance;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let RestartDistance = tape[ptr++];
      return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.RestartDistance);
      ;
      return args;
    }
  };
  var IfcRegularTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
      this.TimeStep = TimeStep;
      this.Values = Values;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      let TimeStep = tape[ptr++];
      let Values = tape[ptr++];
      return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.EndTime);
      ;
      args.push(this.TimeSeriesDataType);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.Unit);
      ;
      args.push(this.TimeStep);
      ;
      args.push(this.Values);
      ;
      return args;
    }
  };
  var IfcReinforcementBarProperties = class {
    constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
      this.expressID = expressID;
      this.type = type;
      this.TotalCrossSectionArea = TotalCrossSectionArea;
      this.SteelGrade = SteelGrade;
      this.BarSurface = BarSurface;
      this.EffectiveDepth = EffectiveDepth;
      this.NominalBarDiameter = NominalBarDiameter;
      this.BarCount = BarCount;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TotalCrossSectionArea = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let BarSurface = tape[ptr++];
      let EffectiveDepth = tape[ptr++];
      let NominalBarDiameter = tape[ptr++];
      let BarCount = tape[ptr++];
      return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
    }
    ToTape() {
      let args = [];
      args.push(this.TotalCrossSectionArea);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.BarSurface);
      ;
      args.push(this.EffectiveDepth);
      ;
      args.push(this.NominalBarDiameter);
      ;
      args.push(this.BarCount);
      ;
      return args;
    }
  };
  var IfcReinforcementDefinitionProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.DefinitionType = DefinitionType;
      this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let DefinitionType = tape[ptr++];
      let ReinforcementSectionDefinitions = tape[ptr++];
      return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.DefinitionType);
      ;
      args.push(this.ReinforcementSectionDefinitions);
      ;
      return args;
    }
  };
  var IfcReinforcingBar = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.BarLength = BarLength;
      this.PredefinedType = PredefinedType;
      this.BarSurface = BarSurface;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let BarLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let BarSurface = tape[ptr++];
      return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.CrossSectionArea);
      ;
      args.push(this.BarLength);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.BarSurface);
      ;
      return args;
    }
  };
  var IfcReinforcingBarType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.BarLength = BarLength;
      this.BarSurface = BarSurface;
      this.BendingShapeCode = BendingShapeCode;
      this.BendingParameters = BendingParameters;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let BarLength = tape[ptr++];
      let BarSurface = tape[ptr++];
      let BendingShapeCode = tape[ptr++];
      let BendingParameters = tape[ptr++];
      return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.CrossSectionArea);
      ;
      args.push(this.BarLength);
      ;
      args.push(this.BarSurface);
      ;
      args.push(this.BendingShapeCode);
      ;
      args.push(this.BendingParameters);
      ;
      return args;
    }
  };
  var IfcReinforcingElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      return args;
    }
  };
  var IfcReinforcingElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcReinforcingMesh = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.MeshLength = MeshLength;
      this.MeshWidth = MeshWidth;
      this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
      this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
      this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
      this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
      this.LongitudinalBarSpacing = LongitudinalBarSpacing;
      this.TransverseBarSpacing = TransverseBarSpacing;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let MeshLength = tape[ptr++];
      let MeshWidth = tape[ptr++];
      let LongitudinalBarNominalDiameter = tape[ptr++];
      let TransverseBarNominalDiameter = tape[ptr++];
      let LongitudinalBarCrossSectionArea = tape[ptr++];
      let TransverseBarCrossSectionArea = tape[ptr++];
      let LongitudinalBarSpacing = tape[ptr++];
      let TransverseBarSpacing = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.MeshLength);
      ;
      args.push(this.MeshWidth);
      ;
      args.push(this.LongitudinalBarNominalDiameter);
      ;
      args.push(this.TransverseBarNominalDiameter);
      ;
      args.push(this.LongitudinalBarCrossSectionArea);
      ;
      args.push(this.TransverseBarCrossSectionArea);
      ;
      args.push(this.LongitudinalBarSpacing);
      ;
      args.push(this.TransverseBarSpacing);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcReinforcingMeshType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.MeshLength = MeshLength;
      this.MeshWidth = MeshWidth;
      this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
      this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
      this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
      this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
      this.LongitudinalBarSpacing = LongitudinalBarSpacing;
      this.TransverseBarSpacing = TransverseBarSpacing;
      this.BendingShapeCode = BendingShapeCode;
      this.BendingParameters = BendingParameters;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let MeshLength = tape[ptr++];
      let MeshWidth = tape[ptr++];
      let LongitudinalBarNominalDiameter = tape[ptr++];
      let TransverseBarNominalDiameter = tape[ptr++];
      let LongitudinalBarCrossSectionArea = tape[ptr++];
      let TransverseBarCrossSectionArea = tape[ptr++];
      let LongitudinalBarSpacing = tape[ptr++];
      let TransverseBarSpacing = tape[ptr++];
      let BendingShapeCode = tape[ptr++];
      let BendingParameters = tape[ptr++];
      return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.MeshLength);
      ;
      args.push(this.MeshWidth);
      ;
      args.push(this.LongitudinalBarNominalDiameter);
      ;
      args.push(this.TransverseBarNominalDiameter);
      ;
      args.push(this.LongitudinalBarCrossSectionArea);
      ;
      args.push(this.TransverseBarCrossSectionArea);
      ;
      args.push(this.LongitudinalBarSpacing);
      ;
      args.push(this.TransverseBarSpacing);
      ;
      args.push(this.BendingShapeCode);
      ;
      args.push(this.BendingParameters);
      ;
      return args;
    }
  };
  var IfcRelAggregates = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingObject = RelatingObject;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingObject = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingObject);
      ;
      args.push(this.RelatedObjects);
      ;
      return args;
    }
  };
  var IfcRelAssigns = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      return args;
    }
  };
  var IfcRelAssignsToActor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingActor = RelatingActor;
      this.ActingRole = ActingRole;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingActor = tape[ptr++];
      let ActingRole = tape[ptr++];
      return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingActor);
      ;
      args.push(this.ActingRole);
      ;
      return args;
    }
  };
  var IfcRelAssignsToControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingControl = RelatingControl;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingControl = tape[ptr++];
      return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingControl);
      ;
      return args;
    }
  };
  var IfcRelAssignsToGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingGroup = RelatingGroup;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingGroup = tape[ptr++];
      return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingGroup);
      ;
      return args;
    }
  };
  var IfcRelAssignsToGroupByFactor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingGroup = RelatingGroup;
      this.Factor = Factor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingGroup = tape[ptr++];
      let Factor = tape[ptr++];
      return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingGroup);
      ;
      args.push(this.Factor);
      ;
      return args;
    }
  };
  var IfcRelAssignsToProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingProcess = RelatingProcess;
      this.QuantityInProcess = QuantityInProcess;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingProcess = tape[ptr++];
      let QuantityInProcess = tape[ptr++];
      return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingProcess);
      ;
      args.push(this.QuantityInProcess);
      ;
      return args;
    }
  };
  var IfcRelAssignsToProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingProduct = RelatingProduct;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingProduct = tape[ptr++];
      return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingProduct);
      ;
      return args;
    }
  };
  var IfcRelAssignsToResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatedObjectsType = RelatedObjectsType;
      this.RelatingResource = RelatingResource;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatedObjectsType = tape[ptr++];
      let RelatingResource = tape[ptr++];
      return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatedObjectsType);
      ;
      args.push(this.RelatingResource);
      ;
      return args;
    }
  };
  var IfcRelAssociates = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      return args;
    }
  };
  var IfcRelAssociatesApproval = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingApproval = RelatingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingApproval);
      ;
      return args;
    }
  };
  var IfcRelAssociatesClassification = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingClassification = RelatingClassification;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingClassification = tape[ptr++];
      return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingClassification);
      ;
      return args;
    }
  };
  var IfcRelAssociatesConstraint = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.Intent = Intent;
      this.RelatingConstraint = RelatingConstraint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let Intent = tape[ptr++];
      let RelatingConstraint = tape[ptr++];
      return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.Intent);
      ;
      args.push(this.RelatingConstraint);
      ;
      return args;
    }
  };
  var IfcRelAssociatesDocument = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingDocument = RelatingDocument;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingDocument = tape[ptr++];
      return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingDocument);
      ;
      return args;
    }
  };
  var IfcRelAssociatesLibrary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingLibrary = RelatingLibrary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingLibrary = tape[ptr++];
      return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingLibrary);
      ;
      return args;
    }
  };
  var IfcRelAssociatesMaterial = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingMaterial = RelatingMaterial;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingMaterial = tape[ptr++];
      return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingMaterial);
      ;
      return args;
    }
  };
  var IfcRelConnects = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcRelConnectsElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedElement);
      ;
      return args;
    }
  };
  var IfcRelConnectsPathElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.RelatingPriorities = RelatingPriorities;
      this.RelatedPriorities = RelatedPriorities;
      this.RelatedConnectionType = RelatedConnectionType;
      this.RelatingConnectionType = RelatingConnectionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let RelatingPriorities = tape[ptr++];
      let RelatedPriorities = tape[ptr++];
      let RelatedConnectionType = tape[ptr++];
      let RelatingConnectionType = tape[ptr++];
      return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedElement);
      ;
      args.push(this.RelatingPriorities);
      ;
      args.push(this.RelatedPriorities);
      ;
      args.push(this.RelatedConnectionType);
      ;
      args.push(this.RelatingConnectionType);
      ;
      return args;
    }
  };
  var IfcRelConnectsPortToElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPort = RelatingPort;
      this.RelatedElement = RelatedElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPort = tape[ptr++];
      let RelatedElement = tape[ptr++];
      return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingPort);
      ;
      args.push(this.RelatedElement);
      ;
      return args;
    }
  };
  var IfcRelConnectsPorts = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPort = RelatingPort;
      this.RelatedPort = RelatedPort;
      this.RealizingElement = RealizingElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPort = tape[ptr++];
      let RelatedPort = tape[ptr++];
      let RealizingElement = tape[ptr++];
      return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingPort);
      ;
      args.push(this.RelatedPort);
      ;
      args.push(this.RealizingElement);
      ;
      return args;
    }
  };
  var IfcRelConnectsStructuralActivity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedStructuralActivity = RelatedStructuralActivity;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedStructuralActivity = tape[ptr++];
      return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedStructuralActivity);
      ;
      return args;
    }
  };
  var IfcRelConnectsStructuralMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingStructuralMember = RelatingStructuralMember;
      this.RelatedStructuralConnection = RelatedStructuralConnection;
      this.AppliedCondition = AppliedCondition;
      this.AdditionalConditions = AdditionalConditions;
      this.SupportedLength = SupportedLength;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingStructuralMember = tape[ptr++];
      let RelatedStructuralConnection = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let AdditionalConditions = tape[ptr++];
      let SupportedLength = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingStructuralMember);
      ;
      args.push(this.RelatedStructuralConnection);
      ;
      args.push(this.AppliedCondition);
      ;
      args.push(this.AdditionalConditions);
      ;
      args.push(this.SupportedLength);
      ;
      args.push(this.ConditionCoordinateSystem);
      ;
      return args;
    }
  };
  var IfcRelConnectsWithEccentricity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingStructuralMember = RelatingStructuralMember;
      this.RelatedStructuralConnection = RelatedStructuralConnection;
      this.AppliedCondition = AppliedCondition;
      this.AdditionalConditions = AdditionalConditions;
      this.SupportedLength = SupportedLength;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
      this.ConnectionConstraint = ConnectionConstraint;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingStructuralMember = tape[ptr++];
      let RelatedStructuralConnection = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let AdditionalConditions = tape[ptr++];
      let SupportedLength = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      let ConnectionConstraint = tape[ptr++];
      return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingStructuralMember);
      ;
      args.push(this.RelatedStructuralConnection);
      ;
      args.push(this.AppliedCondition);
      ;
      args.push(this.AdditionalConditions);
      ;
      args.push(this.SupportedLength);
      ;
      args.push(this.ConditionCoordinateSystem);
      ;
      args.push(this.ConnectionConstraint);
      ;
      return args;
    }
  };
  var IfcRelConnectsWithRealizingElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ConnectionGeometry = ConnectionGeometry;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.RealizingElements = RealizingElements;
      this.ConnectionType = ConnectionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let RealizingElements = tape[ptr++];
      let ConnectionType = tape[ptr++];
      return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedElement);
      ;
      args.push(this.RealizingElements);
      ;
      args.push(this.ConnectionType);
      ;
      return args;
    }
  };
  var IfcRelContainedInSpatialStructure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedElements = RelatedElements;
      this.RelatingStructure = RelatingStructure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedElements = tape[ptr++];
      let RelatingStructure = tape[ptr++];
      return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedElements);
      ;
      args.push(this.RelatingStructure);
      ;
      return args;
    }
  };
  var IfcRelCoversBldgElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingBuildingElement = RelatingBuildingElement;
      this.RelatedCoverings = RelatedCoverings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingBuildingElement = tape[ptr++];
      let RelatedCoverings = tape[ptr++];
      return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingBuildingElement);
      ;
      args.push(this.RelatedCoverings);
      ;
      return args;
    }
  };
  var IfcRelCoversSpaces = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedCoverings = RelatedCoverings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedCoverings = tape[ptr++];
      return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingSpace);
      ;
      args.push(this.RelatedCoverings);
      ;
      return args;
    }
  };
  var IfcRelDeclares = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingContext = RelatingContext;
      this.RelatedDefinitions = RelatedDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingContext = tape[ptr++];
      let RelatedDefinitions = tape[ptr++];
      return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingContext);
      ;
      args.push(this.RelatedDefinitions);
      ;
      return args;
    }
  };
  var IfcRelDecomposes = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcRelDefines = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcRelDefinesByObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingObject = RelatingObject;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingObject = tape[ptr++];
      return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingObject);
      ;
      return args;
    }
  };
  var IfcRelDefinesByProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingPropertyDefinition = RelatingPropertyDefinition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingPropertyDefinition = tape[ptr++];
      return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingPropertyDefinition);
      ;
      return args;
    }
  };
  var IfcRelDefinesByTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedPropertySets = RelatedPropertySets;
      this.RelatingTemplate = RelatingTemplate;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedPropertySets = tape[ptr++];
      let RelatingTemplate = tape[ptr++];
      return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedPropertySets);
      ;
      args.push(this.RelatingTemplate);
      ;
      return args;
    }
  };
  var IfcRelDefinesByType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedObjects = RelatedObjects;
      this.RelatingType = RelatingType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      let RelatingType = tape[ptr++];
      return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedObjects);
      ;
      args.push(this.RelatingType);
      ;
      return args;
    }
  };
  var IfcRelFillsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingOpeningElement = RelatingOpeningElement;
      this.RelatedBuildingElement = RelatedBuildingElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingOpeningElement = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingOpeningElement);
      ;
      args.push(this.RelatedBuildingElement);
      ;
      return args;
    }
  };
  var IfcRelFlowControlElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedControlElements = RelatedControlElements;
      this.RelatingFlowElement = RelatingFlowElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedControlElements = tape[ptr++];
      let RelatingFlowElement = tape[ptr++];
      return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedControlElements);
      ;
      args.push(this.RelatingFlowElement);
      ;
      return args;
    }
  };
  var IfcRelInterferesElements = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedElement = RelatedElement;
      this.InterferenceGeometry = InterferenceGeometry;
      this.InterferenceType = InterferenceType;
      this.ImpliedOrder = ImpliedOrder;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedElement = tape[ptr++];
      let InterferenceGeometry = tape[ptr++];
      let InterferenceType = tape[ptr++];
      let ImpliedOrder = tape[ptr++];
      return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedElement);
      ;
      args.push(this.InterferenceGeometry);
      ;
      args.push(this.InterferenceType);
      ;
      args.push(this.ImpliedOrder);
      ;
      return args;
    }
  };
  var IfcRelNests = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingObject = RelatingObject;
      this.RelatedObjects = RelatedObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingObject = tape[ptr++];
      let RelatedObjects = tape[ptr++];
      return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingObject);
      ;
      args.push(this.RelatedObjects);
      ;
      return args;
    }
  };
  var IfcRelPositions = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingPositioningElement = RelatingPositioningElement;
      this.RelatedProducts = RelatedProducts;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingPositioningElement = tape[ptr++];
      let RelatedProducts = tape[ptr++];
      return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingPositioningElement);
      ;
      args.push(this.RelatedProducts);
      ;
      return args;
    }
  };
  var IfcRelProjectsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingElement = RelatingElement;
      this.RelatedFeatureElement = RelatedFeatureElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingElement = tape[ptr++];
      let RelatedFeatureElement = tape[ptr++];
      return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingElement);
      ;
      args.push(this.RelatedFeatureElement);
      ;
      return args;
    }
  };
  var IfcRelReferencedInSpatialStructure = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatedElements = RelatedElements;
      this.RelatingStructure = RelatingStructure;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedElements = tape[ptr++];
      let RelatingStructure = tape[ptr++];
      return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedElements);
      ;
      args.push(this.RelatingStructure);
      ;
      return args;
    }
  };
  var IfcRelSequence = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingProcess = RelatingProcess;
      this.RelatedProcess = RelatedProcess;
      this.TimeLag = TimeLag;
      this.SequenceType = SequenceType;
      this.UserDefinedSequenceType = UserDefinedSequenceType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingProcess = tape[ptr++];
      let RelatedProcess = tape[ptr++];
      let TimeLag = tape[ptr++];
      let SequenceType = tape[ptr++];
      let UserDefinedSequenceType = tape[ptr++];
      return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingProcess);
      ;
      args.push(this.RelatedProcess);
      ;
      args.push(this.TimeLag);
      ;
      args.push(this.SequenceType);
      ;
      args.push(this.UserDefinedSequenceType);
      ;
      return args;
    }
  };
  var IfcRelServicesBuildings = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSystem = RelatingSystem;
      this.RelatedBuildings = RelatedBuildings;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSystem = tape[ptr++];
      let RelatedBuildings = tape[ptr++];
      return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingSystem);
      ;
      args.push(this.RelatedBuildings);
      ;
      return args;
    }
  };
  var IfcRelSpaceBoundary = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingSpace);
      ;
      args.push(this.RelatedBuildingElement);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.PhysicalOrVirtualBoundary);
      ;
      args.push(this.InternalOrExternalBoundary);
      ;
      return args;
    }
  };
  var IfcRelSpaceBoundary1stLevel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
      this.ParentBoundary = ParentBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      let ParentBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingSpace);
      ;
      args.push(this.RelatedBuildingElement);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.PhysicalOrVirtualBoundary);
      ;
      args.push(this.InternalOrExternalBoundary);
      ;
      args.push(this.ParentBoundary);
      ;
      return args;
    }
  };
  var IfcRelSpaceBoundary2ndLevel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingSpace = RelatingSpace;
      this.RelatedBuildingElement = RelatedBuildingElement;
      this.ConnectionGeometry = ConnectionGeometry;
      this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
      this.InternalOrExternalBoundary = InternalOrExternalBoundary;
      this.ParentBoundary = ParentBoundary;
      this.CorrespondingBoundary = CorrespondingBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingSpace = tape[ptr++];
      let RelatedBuildingElement = tape[ptr++];
      let ConnectionGeometry = tape[ptr++];
      let PhysicalOrVirtualBoundary = tape[ptr++];
      let InternalOrExternalBoundary = tape[ptr++];
      let ParentBoundary = tape[ptr++];
      let CorrespondingBoundary = tape[ptr++];
      return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingSpace);
      ;
      args.push(this.RelatedBuildingElement);
      ;
      args.push(this.ConnectionGeometry);
      ;
      args.push(this.PhysicalOrVirtualBoundary);
      ;
      args.push(this.InternalOrExternalBoundary);
      ;
      args.push(this.ParentBoundary);
      ;
      args.push(this.CorrespondingBoundary);
      ;
      return args;
    }
  };
  var IfcRelVoidsElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.RelatingBuildingElement = RelatingBuildingElement;
      this.RelatedOpeningElement = RelatedOpeningElement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingBuildingElement = tape[ptr++];
      let RelatedOpeningElement = tape[ptr++];
      return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingBuildingElement);
      ;
      args.push(this.RelatedOpeningElement);
      ;
      return args;
    }
  };
  var IfcRelationship = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcReparametrisedCompositeCurveSegment = class {
    constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
      this.expressID = expressID;
      this.type = type;
      this.Transition = Transition;
      this.SameSense = SameSense;
      this.ParentCurve = ParentCurve;
      this.ParamLength = ParamLength;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Transition = tape[ptr++];
      let SameSense = tape[ptr++];
      let ParentCurve = tape[ptr++];
      let ParamLength = tape[ptr++];
      return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
    }
    ToTape() {
      let args = [];
      args.push(this.Transition);
      ;
      args.push(this.SameSense);
      ;
      args.push(this.ParentCurve);
      ;
      args.push(this.ParamLength);
      ;
      return args;
    }
  };
  var IfcRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcRepresentationContext = class {
    constructor(expressID, type, ContextIdentifier, ContextType) {
      this.expressID = expressID;
      this.type = type;
      this.ContextIdentifier = ContextIdentifier;
      this.ContextType = ContextType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextIdentifier = tape[ptr++];
      let ContextType = tape[ptr++];
      return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextIdentifier);
      ;
      args.push(this.ContextType);
      ;
      return args;
    }
  };
  var IfcRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcRepresentationMap = class {
    constructor(expressID, type, MappingOrigin, MappedRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.MappingOrigin = MappingOrigin;
      this.MappedRepresentation = MappedRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let MappingOrigin = tape[ptr++];
      let MappedRepresentation = tape[ptr++];
      return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.MappingOrigin);
      ;
      args.push(this.MappedRepresentation);
      ;
      return args;
    }
  };
  var IfcResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      return args;
    }
  };
  var IfcResourceApprovalRelationship = class {
    constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatedResourceObjects = RelatedResourceObjects;
      this.RelatingApproval = RelatingApproval;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      let RelatingApproval = tape[ptr++];
      return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatedResourceObjects);
      ;
      args.push(this.RelatingApproval);
      ;
      return args;
    }
  };
  var IfcResourceConstraintRelationship = class {
    constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.RelatingConstraint = RelatingConstraint;
      this.RelatedResourceObjects = RelatedResourceObjects;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let RelatingConstraint = tape[ptr++];
      let RelatedResourceObjects = tape[ptr++];
      return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.RelatingConstraint);
      ;
      args.push(this.RelatedResourceObjects);
      ;
      return args;
    }
  };
  var IfcResourceLevelRelationship = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcResourceLevelRelationship(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcResourceTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.ScheduleWork = ScheduleWork;
      this.ScheduleUsage = ScheduleUsage;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.ScheduleContour = ScheduleContour;
      this.LevelingDelay = LevelingDelay;
      this.IsOverAllocated = IsOverAllocated;
      this.StatusTime = StatusTime;
      this.ActualWork = ActualWork;
      this.ActualUsage = ActualUsage;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingWork = RemainingWork;
      this.RemainingUsage = RemainingUsage;
      this.Completion = Completion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let ScheduleWork = tape[ptr++];
      let ScheduleUsage = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let ScheduleContour = tape[ptr++];
      let LevelingDelay = tape[ptr++];
      let IsOverAllocated = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualWork = tape[ptr++];
      let ActualUsage = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingWork = tape[ptr++];
      let RemainingUsage = tape[ptr++];
      let Completion = tape[ptr++];
      return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.ScheduleWork);
      ;
      args.push(this.ScheduleUsage);
      ;
      args.push(this.ScheduleStart);
      ;
      args.push(this.ScheduleFinish);
      ;
      args.push(this.ScheduleContour);
      ;
      args.push(this.LevelingDelay);
      ;
      args.push(this.IsOverAllocated);
      ;
      args.push(this.StatusTime);
      ;
      args.push(this.ActualWork);
      ;
      args.push(this.ActualUsage);
      ;
      args.push(this.ActualStart);
      ;
      args.push(this.ActualFinish);
      ;
      args.push(this.RemainingWork);
      ;
      args.push(this.RemainingUsage);
      ;
      args.push(this.Completion);
      ;
      return args;
    }
  };
  var IfcRevolvedAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Axis, Angle) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Axis = Axis;
      this.Angle = Angle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Axis = tape[ptr++];
      let Angle = tape[ptr++];
      return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.Axis);
      ;
      args.push(this.Angle);
      ;
      return args;
    }
  };
  var IfcRevolvedAreaSolidTapered = class {
    constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Axis = Axis;
      this.Angle = Angle;
      this.EndSweptArea = EndSweptArea;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Axis = tape[ptr++];
      let Angle = tape[ptr++];
      let EndSweptArea = tape[ptr++];
      return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.Axis);
      ;
      args.push(this.Angle);
      ;
      args.push(this.EndSweptArea);
      ;
      return args;
    }
  };
  var IfcRightCircularCone = class {
    constructor(expressID, type, Position, Height, BottomRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Height = Height;
      this.BottomRadius = BottomRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Height = tape[ptr++];
      let BottomRadius = tape[ptr++];
      return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Height);
      ;
      args.push(this.BottomRadius);
      ;
      return args;
    }
  };
  var IfcRightCircularCylinder = class {
    constructor(expressID, type, Position, Height, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Height = Height;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Height = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Height);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcRoof = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRoofType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcRoot = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcRoundedRectangleProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.XDim = XDim;
      this.YDim = YDim;
      this.RoundingRadius = RoundingRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let XDim = tape[ptr++];
      let YDim = tape[ptr++];
      let RoundingRadius = tape[ptr++];
      return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.XDim);
      ;
      args.push(this.YDim);
      ;
      args.push(this.RoundingRadius);
      ;
      return args;
    }
  };
  var IfcSIUnit = class {
    constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Dimensions = Dimensions;
      this.UnitType = UnitType;
      this.Prefix = Prefix;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Dimensions = tape[ptr++];
      let UnitType = tape[ptr++];
      let Prefix = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Dimensions);
      ;
      args.push(this.UnitType);
      ;
      args.push(this.Prefix);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcSanitaryTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSanitaryTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSchedulingTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      return args;
    }
  };
  var IfcSeamCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      ;
      args.push(this.AssociatedGeometry);
      ;
      args.push(this.MasterRepresentation);
      ;
      return args;
    }
  };
  var IfcSectionProperties = class {
    constructor(expressID, type, SectionType, StartProfile, EndProfile) {
      this.expressID = expressID;
      this.type = type;
      this.SectionType = SectionType;
      this.StartProfile = StartProfile;
      this.EndProfile = EndProfile;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SectionType = tape[ptr++];
      let StartProfile = tape[ptr++];
      let EndProfile = tape[ptr++];
      return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
    }
    ToTape() {
      let args = [];
      args.push(this.SectionType);
      ;
      args.push(this.StartProfile);
      ;
      args.push(this.EndProfile);
      ;
      return args;
    }
  };
  var IfcSectionReinforcementProperties = class {
    constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
      this.expressID = expressID;
      this.type = type;
      this.LongitudinalStartPosition = LongitudinalStartPosition;
      this.LongitudinalEndPosition = LongitudinalEndPosition;
      this.TransversePosition = TransversePosition;
      this.ReinforcementRole = ReinforcementRole;
      this.SectionDefinition = SectionDefinition;
      this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LongitudinalStartPosition = tape[ptr++];
      let LongitudinalEndPosition = tape[ptr++];
      let TransversePosition = tape[ptr++];
      let ReinforcementRole = tape[ptr++];
      let SectionDefinition = tape[ptr++];
      let CrossSectionReinforcementDefinitions = tape[ptr++];
      return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
    }
    ToTape() {
      let args = [];
      args.push(this.LongitudinalStartPosition);
      ;
      args.push(this.LongitudinalEndPosition);
      ;
      args.push(this.TransversePosition);
      ;
      args.push(this.ReinforcementRole);
      ;
      args.push(this.SectionDefinition);
      ;
      args.push(this.CrossSectionReinforcementDefinitions);
      ;
      return args;
    }
  };
  var IfcSectionedSolid = class {
    constructor(expressID, type, Directrix, CrossSections) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.CrossSections = CrossSections;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let CrossSections = tape[ptr++];
      return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      ;
      args.push(this.CrossSections);
      ;
      return args;
    }
  };
  var IfcSectionedSolidHorizontal = class {
    constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.CrossSections = CrossSections;
      this.CrossSectionPositions = CrossSectionPositions;
      this.FixedAxisVertical = FixedAxisVertical;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let CrossSections = tape[ptr++];
      let CrossSectionPositions = tape[ptr++];
      let FixedAxisVertical = tape[ptr++];
      return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      ;
      args.push(this.CrossSections);
      ;
      args.push(this.CrossSectionPositions);
      ;
      args.push(this.FixedAxisVertical);
      ;
      return args;
    }
  };
  var IfcSectionedSpine = class {
    constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
      this.expressID = expressID;
      this.type = type;
      this.SpineCurve = SpineCurve;
      this.CrossSections = CrossSections;
      this.CrossSectionPositions = CrossSectionPositions;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SpineCurve = tape[ptr++];
      let CrossSections = tape[ptr++];
      let CrossSectionPositions = tape[ptr++];
      return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
    }
    ToTape() {
      let args = [];
      args.push(this.SpineCurve);
      ;
      args.push(this.CrossSections);
      ;
      args.push(this.CrossSectionPositions);
      ;
      return args;
    }
  };
  var IfcSensor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSensorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcShadingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcShadingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcShapeAspect = class {
    constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
      this.expressID = expressID;
      this.type = type;
      this.ShapeRepresentations = ShapeRepresentations;
      this.Name = Name;
      this.Description = Description;
      this.ProductDefinitional = ProductDefinitional;
      this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ShapeRepresentations = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ProductDefinitional = tape[ptr++];
      let PartOfProductDefinitionShape = tape[ptr++];
      return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
    }
    ToTape() {
      let args = [];
      args.push(this.ShapeRepresentations);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ProductDefinitional);
      ;
      args.push(this.PartOfProductDefinitionShape);
      ;
      return args;
    }
  };
  var IfcShapeModel = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcShapeRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcShellBasedSurfaceModel = class {
    constructor(expressID, type, SbsmBoundary) {
      this.expressID = expressID;
      this.type = type;
      this.SbsmBoundary = SbsmBoundary;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SbsmBoundary = tape[ptr++];
      return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
    }
    ToTape() {
      let args = [];
      args.push(this.SbsmBoundary);
      ;
      return args;
    }
  };
  var IfcSimpleProperty = class {
    constructor(expressID, type, Name, Description) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      return new IfcSimpleProperty(expressID, type, Name, Description);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      return args;
    }
  };
  var IfcSimplePropertyTemplate = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.TemplateType = TemplateType;
      this.PrimaryMeasureType = PrimaryMeasureType;
      this.SecondaryMeasureType = SecondaryMeasureType;
      this.Enumerators = Enumerators;
      this.PrimaryUnit = PrimaryUnit;
      this.SecondaryUnit = SecondaryUnit;
      this.Expression = Expression;
      this.AccessState = AccessState;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let TemplateType = tape[ptr++];
      let PrimaryMeasureType = tape[ptr++];
      let SecondaryMeasureType = tape[ptr++];
      let Enumerators = tape[ptr++];
      let PrimaryUnit = tape[ptr++];
      let SecondaryUnit = tape[ptr++];
      let Expression = tape[ptr++];
      let AccessState = tape[ptr++];
      return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.TemplateType);
      ;
      args.push(this.PrimaryMeasureType);
      ;
      args.push(this.SecondaryMeasureType);
      ;
      args.push(this.Enumerators);
      ;
      args.push(this.PrimaryUnit);
      ;
      args.push(this.SecondaryUnit);
      ;
      args.push(this.Expression);
      ;
      args.push(this.AccessState);
      ;
      return args;
    }
  };
  var IfcSite = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.RefLatitude = RefLatitude;
      this.RefLongitude = RefLongitude;
      this.RefElevation = RefElevation;
      this.LandTitleNumber = LandTitleNumber;
      this.SiteAddress = SiteAddress;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let RefLatitude = tape[ptr++];
      let RefLongitude = tape[ptr++];
      let RefElevation = tape[ptr++];
      let LandTitleNumber = tape[ptr++];
      let SiteAddress = tape[ptr++];
      return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.RefLatitude);
      ;
      args.push(this.RefLongitude);
      ;
      args.push(this.RefElevation);
      ;
      args.push(this.LandTitleNumber);
      ;
      args.push(this.SiteAddress);
      ;
      return args;
    }
  };
  var IfcSlab = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSlabElementedCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSlabStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSlabType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSlippageConnectionCondition = class {
    constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.SlippageX = SlippageX;
      this.SlippageY = SlippageY;
      this.SlippageZ = SlippageZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let SlippageX = tape[ptr++];
      let SlippageY = tape[ptr++];
      let SlippageZ = tape[ptr++];
      return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.SlippageX);
      ;
      args.push(this.SlippageY);
      ;
      args.push(this.SlippageZ);
      ;
      return args;
    }
  };
  var IfcSolarDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSolarDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSolidModel = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcSolidModel(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcSpace = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
      this.PredefinedType = PredefinedType;
      this.ElevationWithFlooring = ElevationWithFlooring;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ElevationWithFlooring = tape[ptr++];
      return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.ElevationWithFlooring);
      ;
      return args;
    }
  };
  var IfcSpaceHeater = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSpaceHeaterType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSpaceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };
  var IfcSpatialElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };
  var IfcSpatialElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcSpatialStructureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.CompositionType = CompositionType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let CompositionType = tape[ptr++];
      return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.CompositionType);
      ;
      return args;
    }
  };
  var IfcSpatialStructureElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      return args;
    }
  };
  var IfcSpatialZone = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.LongName = LongName;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let LongName = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.LongName);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSpatialZoneType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };
  var IfcSphere = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcSphere(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcSphericalSurface = class {
    constructor(expressID, type, Position, Radius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.Radius = Radius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let Radius = tape[ptr++];
      return new IfcSphericalSurface(expressID, type, Position, Radius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.Radius);
      ;
      return args;
    }
  };
  var IfcStackTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStackTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStair = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStairFlight = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.NumberOfRisers = NumberOfRisers;
      this.NumberOfTreads = NumberOfTreads;
      this.RiserHeight = RiserHeight;
      this.TreadLength = TreadLength;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let NumberOfRisers = tape[ptr++];
      let NumberOfTreads = tape[ptr++];
      let RiserHeight = tape[ptr++];
      let TreadLength = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.NumberOfRisers);
      ;
      args.push(this.NumberOfTreads);
      ;
      args.push(this.RiserHeight);
      ;
      args.push(this.TreadLength);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStairFlightType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStairType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      return args;
    }
  };
  var IfcStructuralActivity = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      return args;
    }
  };
  var IfcStructuralAnalysisModel = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.OrientationOf2DPlane = OrientationOf2DPlane;
      this.LoadedBy = LoadedBy;
      this.HasResults = HasResults;
      this.SharedPlacement = SharedPlacement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let OrientationOf2DPlane = tape[ptr++];
      let LoadedBy = tape[ptr++];
      let HasResults = tape[ptr++];
      let SharedPlacement = tape[ptr++];
      return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.OrientationOf2DPlane);
      ;
      args.push(this.LoadedBy);
      ;
      args.push(this.HasResults);
      ;
      args.push(this.SharedPlacement);
      ;
      return args;
    }
  };
  var IfcStructuralConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedCondition);
      ;
      return args;
    }
  };
  var IfcStructuralConnectionCondition = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralConnectionCondition(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcStructuralCurveAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      args.push(this.ProjectedOrTrue);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralCurveConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedCondition);
      ;
      args.push(this.Axis);
      ;
      return args;
    }
  };
  var IfcStructuralCurveMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Axis);
      ;
      return args;
    }
  };
  var IfcStructuralCurveMemberVarying = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Axis = Axis;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Axis = tape[ptr++];
      return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Axis);
      ;
      return args;
    }
  };
  var IfcStructuralCurveReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralItem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcStructuralLinearAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      args.push(this.ProjectedOrTrue);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralLoad = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoad(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcStructuralLoadCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.ActionType = ActionType;
      this.ActionSource = ActionSource;
      this.Coefficient = Coefficient;
      this.Purpose = Purpose;
      this.SelfWeightCoefficients = SelfWeightCoefficients;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ActionType = tape[ptr++];
      let ActionSource = tape[ptr++];
      let Coefficient = tape[ptr++];
      let Purpose = tape[ptr++];
      let SelfWeightCoefficients = tape[ptr++];
      return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.ActionType);
      ;
      args.push(this.ActionSource);
      ;
      args.push(this.Coefficient);
      ;
      args.push(this.Purpose);
      ;
      args.push(this.SelfWeightCoefficients);
      ;
      return args;
    }
  };
  var IfcStructuralLoadConfiguration = class {
    constructor(expressID, type, Name, Values, Locations) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Values = Values;
      this.Locations = Locations;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Values = tape[ptr++];
      let Locations = tape[ptr++];
      return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Values);
      ;
      args.push(this.Locations);
      ;
      return args;
    }
  };
  var IfcStructuralLoadGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.PredefinedType = PredefinedType;
      this.ActionType = ActionType;
      this.ActionSource = ActionSource;
      this.Coefficient = Coefficient;
      this.Purpose = Purpose;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let ActionType = tape[ptr++];
      let ActionSource = tape[ptr++];
      let Coefficient = tape[ptr++];
      let Purpose = tape[ptr++];
      return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.ActionType);
      ;
      args.push(this.ActionSource);
      ;
      args.push(this.Coefficient);
      ;
      args.push(this.Purpose);
      ;
      return args;
    }
  };
  var IfcStructuralLoadLinearForce = class {
    constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.LinearForceX = LinearForceX;
      this.LinearForceY = LinearForceY;
      this.LinearForceZ = LinearForceZ;
      this.LinearMomentX = LinearMomentX;
      this.LinearMomentY = LinearMomentY;
      this.LinearMomentZ = LinearMomentZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let LinearForceX = tape[ptr++];
      let LinearForceY = tape[ptr++];
      let LinearForceZ = tape[ptr++];
      let LinearMomentX = tape[ptr++];
      let LinearMomentY = tape[ptr++];
      let LinearMomentZ = tape[ptr++];
      return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.LinearForceX);
      ;
      args.push(this.LinearForceY);
      ;
      args.push(this.LinearForceZ);
      ;
      args.push(this.LinearMomentX);
      ;
      args.push(this.LinearMomentY);
      ;
      args.push(this.LinearMomentZ);
      ;
      return args;
    }
  };
  var IfcStructuralLoadOrResult = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoadOrResult(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcStructuralLoadPlanarForce = class {
    constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.PlanarForceX = PlanarForceX;
      this.PlanarForceY = PlanarForceY;
      this.PlanarForceZ = PlanarForceZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let PlanarForceX = tape[ptr++];
      let PlanarForceY = tape[ptr++];
      let PlanarForceZ = tape[ptr++];
      return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.PlanarForceX);
      ;
      args.push(this.PlanarForceY);
      ;
      args.push(this.PlanarForceZ);
      ;
      return args;
    }
  };
  var IfcStructuralLoadSingleDisplacement = class {
    constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DisplacementX = DisplacementX;
      this.DisplacementY = DisplacementY;
      this.DisplacementZ = DisplacementZ;
      this.RotationalDisplacementRX = RotationalDisplacementRX;
      this.RotationalDisplacementRY = RotationalDisplacementRY;
      this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DisplacementX = tape[ptr++];
      let DisplacementY = tape[ptr++];
      let DisplacementZ = tape[ptr++];
      let RotationalDisplacementRX = tape[ptr++];
      let RotationalDisplacementRY = tape[ptr++];
      let RotationalDisplacementRZ = tape[ptr++];
      return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DisplacementX);
      ;
      args.push(this.DisplacementY);
      ;
      args.push(this.DisplacementZ);
      ;
      args.push(this.RotationalDisplacementRX);
      ;
      args.push(this.RotationalDisplacementRY);
      ;
      args.push(this.RotationalDisplacementRZ);
      ;
      return args;
    }
  };
  var IfcStructuralLoadSingleDisplacementDistortion = class {
    constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DisplacementX = DisplacementX;
      this.DisplacementY = DisplacementY;
      this.DisplacementZ = DisplacementZ;
      this.RotationalDisplacementRX = RotationalDisplacementRX;
      this.RotationalDisplacementRY = RotationalDisplacementRY;
      this.RotationalDisplacementRZ = RotationalDisplacementRZ;
      this.Distortion = Distortion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DisplacementX = tape[ptr++];
      let DisplacementY = tape[ptr++];
      let DisplacementZ = tape[ptr++];
      let RotationalDisplacementRX = tape[ptr++];
      let RotationalDisplacementRY = tape[ptr++];
      let RotationalDisplacementRZ = tape[ptr++];
      let Distortion = tape[ptr++];
      return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DisplacementX);
      ;
      args.push(this.DisplacementY);
      ;
      args.push(this.DisplacementZ);
      ;
      args.push(this.RotationalDisplacementRX);
      ;
      args.push(this.RotationalDisplacementRY);
      ;
      args.push(this.RotationalDisplacementRZ);
      ;
      args.push(this.Distortion);
      ;
      return args;
    }
  };
  var IfcStructuralLoadSingleForce = class {
    constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.ForceX = ForceX;
      this.ForceY = ForceY;
      this.ForceZ = ForceZ;
      this.MomentX = MomentX;
      this.MomentY = MomentY;
      this.MomentZ = MomentZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let ForceX = tape[ptr++];
      let ForceY = tape[ptr++];
      let ForceZ = tape[ptr++];
      let MomentX = tape[ptr++];
      let MomentY = tape[ptr++];
      let MomentZ = tape[ptr++];
      return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.ForceX);
      ;
      args.push(this.ForceY);
      ;
      args.push(this.ForceZ);
      ;
      args.push(this.MomentX);
      ;
      args.push(this.MomentY);
      ;
      args.push(this.MomentZ);
      ;
      return args;
    }
  };
  var IfcStructuralLoadSingleForceWarping = class {
    constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.ForceX = ForceX;
      this.ForceY = ForceY;
      this.ForceZ = ForceZ;
      this.MomentX = MomentX;
      this.MomentY = MomentY;
      this.MomentZ = MomentZ;
      this.WarpingMoment = WarpingMoment;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let ForceX = tape[ptr++];
      let ForceY = tape[ptr++];
      let ForceZ = tape[ptr++];
      let MomentX = tape[ptr++];
      let MomentY = tape[ptr++];
      let MomentZ = tape[ptr++];
      let WarpingMoment = tape[ptr++];
      return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.ForceX);
      ;
      args.push(this.ForceY);
      ;
      args.push(this.ForceZ);
      ;
      args.push(this.MomentX);
      ;
      args.push(this.MomentY);
      ;
      args.push(this.MomentZ);
      ;
      args.push(this.WarpingMoment);
      ;
      return args;
    }
  };
  var IfcStructuralLoadStatic = class {
    constructor(expressID, type, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      return new IfcStructuralLoadStatic(expressID, type, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcStructuralLoadTemperature = class {
    constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DeltaTConstant = DeltaTConstant;
      this.DeltaTY = DeltaTY;
      this.DeltaTZ = DeltaTZ;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DeltaTConstant = tape[ptr++];
      let DeltaTY = tape[ptr++];
      let DeltaTZ = tape[ptr++];
      return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DeltaTConstant);
      ;
      args.push(this.DeltaTY);
      ;
      args.push(this.DeltaTZ);
      ;
      return args;
    }
  };
  var IfcStructuralMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      return args;
    }
  };
  var IfcStructuralPlanarAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      args.push(this.ProjectedOrTrue);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralPointAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      return args;
    }
  };
  var IfcStructuralPointConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
      this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      let ConditionCoordinateSystem = tape[ptr++];
      return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedCondition);
      ;
      args.push(this.ConditionCoordinateSystem);
      ;
      return args;
    }
  };
  var IfcStructuralPointReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      return args;
    }
  };
  var IfcStructuralReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      return args;
    }
  };
  var IfcStructuralResultGroup = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.TheoryType = TheoryType;
      this.ResultForLoadGroup = ResultForLoadGroup;
      this.IsLinear = IsLinear;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let TheoryType = tape[ptr++];
      let ResultForLoadGroup = tape[ptr++];
      let IsLinear = tape[ptr++];
      return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.TheoryType);
      ;
      args.push(this.ResultForLoadGroup);
      ;
      args.push(this.IsLinear);
      ;
      return args;
    }
  };
  var IfcStructuralSurfaceAction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.DestabilizingLoad = DestabilizingLoad;
      this.ProjectedOrTrue = ProjectedOrTrue;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let DestabilizingLoad = tape[ptr++];
      let ProjectedOrTrue = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.DestabilizingLoad);
      ;
      args.push(this.ProjectedOrTrue);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStructuralSurfaceConnection = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedCondition = AppliedCondition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedCondition = tape[ptr++];
      return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedCondition);
      ;
      return args;
    }
  };
  var IfcStructuralSurfaceMember = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Thickness);
      ;
      return args;
    }
  };
  var IfcStructuralSurfaceMemberVarying = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.PredefinedType = PredefinedType;
      this.Thickness = Thickness;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let Thickness = tape[ptr++];
      return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.Thickness);
      ;
      return args;
    }
  };
  var IfcStructuralSurfaceReaction = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.AppliedLoad = AppliedLoad;
      this.GlobalOrLocal = GlobalOrLocal;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let AppliedLoad = tape[ptr++];
      let GlobalOrLocal = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.AppliedLoad);
      ;
      args.push(this.GlobalOrLocal);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcStyleModel = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcStyledItem = class {
    constructor(expressID, type, Item, Styles, Name) {
      this.expressID = expressID;
      this.type = type;
      this.Item = Item;
      this.Styles = Styles;
      this.Name = Name;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Item = tape[ptr++];
      let Styles = tape[ptr++];
      let Name = tape[ptr++];
      return new IfcStyledItem(expressID, type, Item, Styles, Name);
    }
    ToTape() {
      let args = [];
      args.push(this.Item);
      ;
      args.push(this.Styles);
      ;
      args.push(this.Name);
      ;
      return args;
    }
  };
  var IfcStyledRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcSubContractResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Usage = Usage;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Usage = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Usage);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSubContractResourceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
      this.BaseCosts = BaseCosts;
      this.BaseQuantity = BaseQuantity;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      let BaseCosts = tape[ptr++];
      let BaseQuantity = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      args.push(this.BaseCosts);
      ;
      args.push(this.BaseQuantity);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSubedge = class {
    constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
      this.expressID = expressID;
      this.type = type;
      this.EdgeStart = EdgeStart;
      this.EdgeEnd = EdgeEnd;
      this.ParentEdge = ParentEdge;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let EdgeStart = tape[ptr++];
      let EdgeEnd = tape[ptr++];
      let ParentEdge = tape[ptr++];
      return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
    }
    ToTape() {
      let args = [];
      args.push(this.EdgeStart);
      ;
      args.push(this.EdgeEnd);
      ;
      args.push(this.ParentEdge);
      ;
      return args;
    }
  };
  var IfcSurface = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcSurface(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcSurfaceCurve = class {
    constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.Curve3D = Curve3D;
      this.AssociatedGeometry = AssociatedGeometry;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Curve3D = tape[ptr++];
      let AssociatedGeometry = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.Curve3D);
      ;
      args.push(this.AssociatedGeometry);
      ;
      args.push(this.MasterRepresentation);
      ;
      return args;
    }
  };
  var IfcSurfaceCurveSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
      this.Directrix = Directrix;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.ReferenceSurface = ReferenceSurface;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      let Directrix = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let ReferenceSurface = tape[ptr++];
      return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      args.push(this.Directrix);
      ;
      args.push(this.StartParam);
      ;
      args.push(this.EndParam);
      ;
      args.push(this.ReferenceSurface);
      ;
      return args;
    }
  };
  var IfcSurfaceFeature = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSurfaceOfLinearExtrusion = class {
    constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
      this.ExtrudedDirection = ExtrudedDirection;
      this.Depth = Depth;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      let ExtrudedDirection = tape[ptr++];
      let Depth = tape[ptr++];
      return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      ;
      args.push(this.Position);
      ;
      args.push(this.ExtrudedDirection);
      ;
      args.push(this.Depth);
      ;
      return args;
    }
  };
  var IfcSurfaceOfRevolution = class {
    constructor(expressID, type, SweptCurve, Position, AxisPosition) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
      this.AxisPosition = AxisPosition;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      let AxisPosition = tape[ptr++];
      return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      ;
      args.push(this.Position);
      ;
      args.push(this.AxisPosition);
      ;
      return args;
    }
  };
  var IfcSurfaceReinforcementArea = class {
    constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.SurfaceReinforcement1 = SurfaceReinforcement1;
      this.SurfaceReinforcement2 = SurfaceReinforcement2;
      this.ShearReinforcement = ShearReinforcement;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let SurfaceReinforcement1 = tape[ptr++];
      let SurfaceReinforcement2 = tape[ptr++];
      let ShearReinforcement = tape[ptr++];
      return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.SurfaceReinforcement1);
      ;
      args.push(this.SurfaceReinforcement2);
      ;
      args.push(this.ShearReinforcement);
      ;
      return args;
    }
  };
  var IfcSurfaceStyle = class {
    constructor(expressID, type, Name, Side, Styles) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Side = Side;
      this.Styles = Styles;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Side = tape[ptr++];
      let Styles = tape[ptr++];
      return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Side);
      ;
      args.push(this.Styles);
      ;
      return args;
    }
  };
  var IfcSurfaceStyleLighting = class {
    constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
      this.expressID = expressID;
      this.type = type;
      this.DiffuseTransmissionColour = DiffuseTransmissionColour;
      this.DiffuseReflectionColour = DiffuseReflectionColour;
      this.TransmissionColour = TransmissionColour;
      this.ReflectanceColour = ReflectanceColour;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let DiffuseTransmissionColour = tape[ptr++];
      let DiffuseReflectionColour = tape[ptr++];
      let TransmissionColour = tape[ptr++];
      let ReflectanceColour = tape[ptr++];
      return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
    }
    ToTape() {
      let args = [];
      args.push(this.DiffuseTransmissionColour);
      ;
      args.push(this.DiffuseReflectionColour);
      ;
      args.push(this.TransmissionColour);
      ;
      args.push(this.ReflectanceColour);
      ;
      return args;
    }
  };
  var IfcSurfaceStyleRefraction = class {
    constructor(expressID, type, RefractionIndex, DispersionFactor) {
      this.expressID = expressID;
      this.type = type;
      this.RefractionIndex = RefractionIndex;
      this.DispersionFactor = DispersionFactor;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RefractionIndex = tape[ptr++];
      let DispersionFactor = tape[ptr++];
      return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
    }
    ToTape() {
      let args = [];
      args.push(this.RefractionIndex);
      ;
      args.push(this.DispersionFactor);
      ;
      return args;
    }
  };
  var IfcSurfaceStyleRendering = class {
    constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceColour = SurfaceColour;
      this.Transparency = Transparency;
      this.DiffuseColour = DiffuseColour;
      this.TransmissionColour = TransmissionColour;
      this.DiffuseTransmissionColour = DiffuseTransmissionColour;
      this.ReflectionColour = ReflectionColour;
      this.SpecularColour = SpecularColour;
      this.SpecularHighlight = SpecularHighlight;
      this.ReflectanceMethod = ReflectanceMethod;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceColour = tape[ptr++];
      let Transparency = tape[ptr++];
      let DiffuseColour = tape[ptr++];
      let TransmissionColour = tape[ptr++];
      let DiffuseTransmissionColour = tape[ptr++];
      let ReflectionColour = tape[ptr++];
      let SpecularColour = tape[ptr++];
      let SpecularHighlight = tape[ptr++];
      let ReflectanceMethod = tape[ptr++];
      return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceColour);
      ;
      args.push(this.Transparency);
      ;
      args.push(this.DiffuseColour);
      ;
      args.push(this.TransmissionColour);
      ;
      args.push(this.DiffuseTransmissionColour);
      ;
      args.push(this.ReflectionColour);
      ;
      args.push(this.SpecularColour);
      ;
      args.push(this.SpecularHighlight);
      ;
      args.push(this.ReflectanceMethod);
      ;
      return args;
    }
  };
  var IfcSurfaceStyleShading = class {
    constructor(expressID, type, SurfaceColour, Transparency) {
      this.expressID = expressID;
      this.type = type;
      this.SurfaceColour = SurfaceColour;
      this.Transparency = Transparency;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SurfaceColour = tape[ptr++];
      let Transparency = tape[ptr++];
      return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
    }
    ToTape() {
      let args = [];
      args.push(this.SurfaceColour);
      ;
      args.push(this.Transparency);
      ;
      return args;
    }
  };
  var IfcSurfaceStyleWithTextures = class {
    constructor(expressID, type, Textures) {
      this.expressID = expressID;
      this.type = type;
      this.Textures = Textures;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Textures = tape[ptr++];
      return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
    }
    ToTape() {
      let args = [];
      args.push(this.Textures);
      ;
      return args;
    }
  };
  var IfcSurfaceTexture = class {
    constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
      this.expressID = expressID;
      this.type = type;
      this.RepeatS = RepeatS;
      this.RepeatT = RepeatT;
      this.Mode = Mode;
      this.TextureTransform = TextureTransform;
      this.Parameter = Parameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RepeatS = tape[ptr++];
      let RepeatT = tape[ptr++];
      let Mode = tape[ptr++];
      let TextureTransform = tape[ptr++];
      let Parameter = tape[ptr++];
      return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
    }
    ToTape() {
      let args = [];
      args.push(this.RepeatS);
      ;
      args.push(this.RepeatT);
      ;
      args.push(this.Mode);
      ;
      args.push(this.TextureTransform);
      ;
      args.push(this.Parameter);
      ;
      return args;
    }
  };
  var IfcSweptAreaSolid = class {
    constructor(expressID, type, SweptArea, Position) {
      this.expressID = expressID;
      this.type = type;
      this.SweptArea = SweptArea;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptArea = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptArea);
      ;
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcSweptDiskSolid = class {
    constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.Radius = Radius;
      this.InnerRadius = InnerRadius;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let Radius = tape[ptr++];
      let InnerRadius = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      ;
      args.push(this.Radius);
      ;
      args.push(this.InnerRadius);
      ;
      args.push(this.StartParam);
      ;
      args.push(this.EndParam);
      ;
      return args;
    }
  };
  var IfcSweptDiskSolidPolygonal = class {
    constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Directrix = Directrix;
      this.Radius = Radius;
      this.InnerRadius = InnerRadius;
      this.StartParam = StartParam;
      this.EndParam = EndParam;
      this.FilletRadius = FilletRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Directrix = tape[ptr++];
      let Radius = tape[ptr++];
      let InnerRadius = tape[ptr++];
      let StartParam = tape[ptr++];
      let EndParam = tape[ptr++];
      let FilletRadius = tape[ptr++];
      return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Directrix);
      ;
      args.push(this.Radius);
      ;
      args.push(this.InnerRadius);
      ;
      args.push(this.StartParam);
      ;
      args.push(this.EndParam);
      ;
      args.push(this.FilletRadius);
      ;
      return args;
    }
  };
  var IfcSweptSurface = class {
    constructor(expressID, type, SweptCurve, Position) {
      this.expressID = expressID;
      this.type = type;
      this.SweptCurve = SweptCurve;
      this.Position = Position;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let SweptCurve = tape[ptr++];
      let Position = tape[ptr++];
      return new IfcSweptSurface(expressID, type, SweptCurve, Position);
    }
    ToTape() {
      let args = [];
      args.push(this.SweptCurve);
      ;
      args.push(this.Position);
      ;
      return args;
    }
  };
  var IfcSwitchingDevice = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSwitchingDeviceType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSystem = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      return args;
    }
  };
  var IfcSystemFurnitureElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcSystemFurnitureElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.FlangeEdgeRadius = FlangeEdgeRadius;
      this.WebEdgeRadius = WebEdgeRadius;
      this.WebSlope = WebSlope;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let FlangeEdgeRadius = tape[ptr++];
      let WebEdgeRadius = tape[ptr++];
      let WebSlope = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Depth);
      ;
      args.push(this.FlangeWidth);
      ;
      args.push(this.WebThickness);
      ;
      args.push(this.FlangeThickness);
      ;
      args.push(this.FilletRadius);
      ;
      args.push(this.FlangeEdgeRadius);
      ;
      args.push(this.WebEdgeRadius);
      ;
      args.push(this.WebSlope);
      ;
      args.push(this.FlangeSlope);
      ;
      return args;
    }
  };
  var IfcTable = class {
    constructor(expressID, type, Name, Rows, Columns) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Rows = Rows;
      this.Columns = Columns;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Rows = tape[ptr++];
      let Columns = tape[ptr++];
      return new IfcTable(expressID, type, Name, Rows, Columns);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Rows);
      ;
      args.push(this.Columns);
      ;
      return args;
    }
  };
  var IfcTableColumn = class {
    constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
      this.expressID = expressID;
      this.type = type;
      this.Identifier = Identifier;
      this.Name = Name;
      this.Description = Description;
      this.Unit = Unit;
      this.ReferencePath = ReferencePath;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Identifier = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let Unit = tape[ptr++];
      let ReferencePath = tape[ptr++];
      return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
    }
    ToTape() {
      let args = [];
      args.push(this.Identifier);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.Unit);
      ;
      args.push(this.ReferencePath);
      ;
      return args;
    }
  };
  var IfcTableRow = class {
    constructor(expressID, type, RowCells, IsHeading) {
      this.expressID = expressID;
      this.type = type;
      this.RowCells = RowCells;
      this.IsHeading = IsHeading;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let RowCells = tape[ptr++];
      let IsHeading = tape[ptr++];
      return new IfcTableRow(expressID, type, RowCells, IsHeading);
    }
    ToTape() {
      let args = [];
      args.push(this.RowCells);
      ;
      args.push(this.IsHeading);
      ;
      return args;
    }
  };
  var IfcTank = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTankType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTask = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.Status = Status;
      this.WorkMethod = WorkMethod;
      this.IsMilestone = IsMilestone;
      this.Priority = Priority;
      this.TaskTime = TaskTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let Status = tape[ptr++];
      let WorkMethod = tape[ptr++];
      let IsMilestone = tape[ptr++];
      let Priority = tape[ptr++];
      let TaskTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.Status);
      ;
      args.push(this.WorkMethod);
      ;
      args.push(this.IsMilestone);
      ;
      args.push(this.Priority);
      ;
      args.push(this.TaskTime);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTaskTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.DurationType = DurationType;
      this.ScheduleDuration = ScheduleDuration;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.EarlyStart = EarlyStart;
      this.EarlyFinish = EarlyFinish;
      this.LateStart = LateStart;
      this.LateFinish = LateFinish;
      this.FreeFloat = FreeFloat;
      this.TotalFloat = TotalFloat;
      this.IsCritical = IsCritical;
      this.StatusTime = StatusTime;
      this.ActualDuration = ActualDuration;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingTime = RemainingTime;
      this.Completion = Completion;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let DurationType = tape[ptr++];
      let ScheduleDuration = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let EarlyStart = tape[ptr++];
      let EarlyFinish = tape[ptr++];
      let LateStart = tape[ptr++];
      let LateFinish = tape[ptr++];
      let FreeFloat = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let IsCritical = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualDuration = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingTime = tape[ptr++];
      let Completion = tape[ptr++];
      return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.DurationType);
      ;
      args.push(this.ScheduleDuration);
      ;
      args.push(this.ScheduleStart);
      ;
      args.push(this.ScheduleFinish);
      ;
      args.push(this.EarlyStart);
      ;
      args.push(this.EarlyFinish);
      ;
      args.push(this.LateStart);
      ;
      args.push(this.LateFinish);
      ;
      args.push(this.FreeFloat);
      ;
      args.push(this.TotalFloat);
      ;
      args.push(this.IsCritical);
      ;
      args.push(this.StatusTime);
      ;
      args.push(this.ActualDuration);
      ;
      args.push(this.ActualStart);
      ;
      args.push(this.ActualFinish);
      ;
      args.push(this.RemainingTime);
      ;
      args.push(this.Completion);
      ;
      return args;
    }
  };
  var IfcTaskTimeRecurring = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.DurationType = DurationType;
      this.ScheduleDuration = ScheduleDuration;
      this.ScheduleStart = ScheduleStart;
      this.ScheduleFinish = ScheduleFinish;
      this.EarlyStart = EarlyStart;
      this.EarlyFinish = EarlyFinish;
      this.LateStart = LateStart;
      this.LateFinish = LateFinish;
      this.FreeFloat = FreeFloat;
      this.TotalFloat = TotalFloat;
      this.IsCritical = IsCritical;
      this.StatusTime = StatusTime;
      this.ActualDuration = ActualDuration;
      this.ActualStart = ActualStart;
      this.ActualFinish = ActualFinish;
      this.RemainingTime = RemainingTime;
      this.Completion = Completion;
      this.Recurrence = Recurrence;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let DurationType = tape[ptr++];
      let ScheduleDuration = tape[ptr++];
      let ScheduleStart = tape[ptr++];
      let ScheduleFinish = tape[ptr++];
      let EarlyStart = tape[ptr++];
      let EarlyFinish = tape[ptr++];
      let LateStart = tape[ptr++];
      let LateFinish = tape[ptr++];
      let FreeFloat = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let IsCritical = tape[ptr++];
      let StatusTime = tape[ptr++];
      let ActualDuration = tape[ptr++];
      let ActualStart = tape[ptr++];
      let ActualFinish = tape[ptr++];
      let RemainingTime = tape[ptr++];
      let Completion = tape[ptr++];
      let Recurrence = tape[ptr++];
      return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.DurationType);
      ;
      args.push(this.ScheduleDuration);
      ;
      args.push(this.ScheduleStart);
      ;
      args.push(this.ScheduleFinish);
      ;
      args.push(this.EarlyStart);
      ;
      args.push(this.EarlyFinish);
      ;
      args.push(this.LateStart);
      ;
      args.push(this.LateFinish);
      ;
      args.push(this.FreeFloat);
      ;
      args.push(this.TotalFloat);
      ;
      args.push(this.IsCritical);
      ;
      args.push(this.StatusTime);
      ;
      args.push(this.ActualDuration);
      ;
      args.push(this.ActualStart);
      ;
      args.push(this.ActualFinish);
      ;
      args.push(this.RemainingTime);
      ;
      args.push(this.Completion);
      ;
      args.push(this.Recurrence);
      ;
      return args;
    }
  };
  var IfcTaskType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
      this.PredefinedType = PredefinedType;
      this.WorkMethod = WorkMethod;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let WorkMethod = tape[ptr++];
      return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ProcessType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.WorkMethod);
      ;
      return args;
    }
  };
  var IfcTelecomAddress = class {
    constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
      this.expressID = expressID;
      this.type = type;
      this.Purpose = Purpose;
      this.Description = Description;
      this.UserDefinedPurpose = UserDefinedPurpose;
      this.TelephoneNumbers = TelephoneNumbers;
      this.FacsimileNumbers = FacsimileNumbers;
      this.PagerNumber = PagerNumber;
      this.ElectronicMailAddresses = ElectronicMailAddresses;
      this.WWWHomePageURL = WWWHomePageURL;
      this.MessagingIDs = MessagingIDs;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Purpose = tape[ptr++];
      let Description = tape[ptr++];
      let UserDefinedPurpose = tape[ptr++];
      let TelephoneNumbers = tape[ptr++];
      let FacsimileNumbers = tape[ptr++];
      let PagerNumber = tape[ptr++];
      let ElectronicMailAddresses = tape[ptr++];
      let WWWHomePageURL = tape[ptr++];
      let MessagingIDs = tape[ptr++];
      return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
    }
    ToTape() {
      let args = [];
      args.push(this.Purpose);
      ;
      args.push(this.Description);
      ;
      args.push(this.UserDefinedPurpose);
      ;
      args.push(this.TelephoneNumbers);
      ;
      args.push(this.FacsimileNumbers);
      ;
      args.push(this.PagerNumber);
      ;
      args.push(this.ElectronicMailAddresses);
      ;
      args.push(this.WWWHomePageURL);
      ;
      args.push(this.MessagingIDs);
      ;
      return args;
    }
  };
  var IfcTendon = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.TensionForce = TensionForce;
      this.PreStress = PreStress;
      this.FrictionCoefficient = FrictionCoefficient;
      this.AnchorageSlip = AnchorageSlip;
      this.MinCurvatureRadius = MinCurvatureRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let TensionForce = tape[ptr++];
      let PreStress = tape[ptr++];
      let FrictionCoefficient = tape[ptr++];
      let AnchorageSlip = tape[ptr++];
      let MinCurvatureRadius = tape[ptr++];
      return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.CrossSectionArea);
      ;
      args.push(this.TensionForce);
      ;
      args.push(this.PreStress);
      ;
      args.push(this.FrictionCoefficient);
      ;
      args.push(this.AnchorageSlip);
      ;
      args.push(this.MinCurvatureRadius);
      ;
      return args;
    }
  };
  var IfcTendonAnchor = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTendonAnchorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTendonConduit = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.SteelGrade = SteelGrade;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let SteelGrade = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.SteelGrade);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTendonConduitType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTendonType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.NominalDiameter = NominalDiameter;
      this.CrossSectionArea = CrossSectionArea;
      this.SheathDiameter = SheathDiameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let NominalDiameter = tape[ptr++];
      let CrossSectionArea = tape[ptr++];
      let SheathDiameter = tape[ptr++];
      return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.NominalDiameter);
      ;
      args.push(this.CrossSectionArea);
      ;
      args.push(this.SheathDiameter);
      ;
      return args;
    }
  };
  var IfcTessellatedFaceSet = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcTessellatedFaceSet(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      return args;
    }
  };
  var IfcTessellatedItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcTessellatedItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcTextLiteral = class {
    constructor(expressID, type, Literal, Placement, Path) {
      this.expressID = expressID;
      this.type = type;
      this.Literal = Literal;
      this.Placement = Placement;
      this.Path = Path;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Literal = tape[ptr++];
      let Placement = tape[ptr++];
      let Path = tape[ptr++];
      return new IfcTextLiteral(expressID, type, Literal, Placement, Path);
    }
    ToTape() {
      let args = [];
      args.push(this.Literal);
      ;
      args.push(this.Placement);
      ;
      args.push(this.Path);
      ;
      return args;
    }
  };
  var IfcTextLiteralWithExtent = class {
    constructor(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
      this.expressID = expressID;
      this.type = type;
      this.Literal = Literal;
      this.Placement = Placement;
      this.Path = Path;
      this.Extent = Extent;
      this.BoxAlignment = BoxAlignment;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Literal = tape[ptr++];
      let Placement = tape[ptr++];
      let Path = tape[ptr++];
      let Extent = tape[ptr++];
      let BoxAlignment = tape[ptr++];
      return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment);
    }
    ToTape() {
      let args = [];
      args.push(this.Literal);
      ;
      args.push(this.Placement);
      ;
      args.push(this.Path);
      ;
      args.push(this.Extent);
      ;
      args.push(this.BoxAlignment);
      ;
      return args;
    }
  };
  var IfcTextStyle = class {
    constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.TextCharacterAppearance = TextCharacterAppearance;
      this.TextStyle = TextStyle;
      this.TextFontStyle = TextFontStyle;
      this.ModelOrDraughting = ModelOrDraughting;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let TextCharacterAppearance = tape[ptr++];
      let TextStyle = tape[ptr++];
      let TextFontStyle = tape[ptr++];
      let ModelOrDraughting = tape[ptr++];
      return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.TextCharacterAppearance);
      ;
      args.push(this.TextStyle);
      ;
      args.push(this.TextFontStyle);
      ;
      args.push(this.ModelOrDraughting);
      ;
      return args;
    }
  };
  var IfcTextStyleFontModel = class {
    constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.FontFamily = FontFamily;
      this.FontStyle = FontStyle;
      this.FontVariant = FontVariant;
      this.FontWeight = FontWeight;
      this.FontSize = FontSize;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let FontFamily = tape[ptr++];
      let FontStyle = tape[ptr++];
      let FontVariant = tape[ptr++];
      let FontWeight = tape[ptr++];
      let FontSize = tape[ptr++];
      return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.FontFamily);
      ;
      args.push(this.FontStyle);
      ;
      args.push(this.FontVariant);
      ;
      args.push(this.FontWeight);
      ;
      args.push(this.FontSize);
      ;
      return args;
    }
  };
  var IfcTextStyleForDefinedFont = class {
    constructor(expressID, type, Colour, BackgroundColour) {
      this.expressID = expressID;
      this.type = type;
      this.Colour = Colour;
      this.BackgroundColour = BackgroundColour;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Colour = tape[ptr++];
      let BackgroundColour = tape[ptr++];
      return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
    }
    ToTape() {
      let args = [];
      args.push(this.Colour);
      ;
      args.push(this.BackgroundColour);
      ;
      return args;
    }
  };
  var IfcTextStyleTextModel = class {
    constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
      this.expressID = expressID;
      this.type = type;
      this.TextIndent = TextIndent;
      this.TextAlign = TextAlign;
      this.TextDecoration = TextDecoration;
      this.LetterSpacing = LetterSpacing;
      this.WordSpacing = WordSpacing;
      this.TextTransform = TextTransform;
      this.LineHeight = LineHeight;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TextIndent = tape[ptr++];
      let TextAlign = tape[ptr++];
      let TextDecoration = tape[ptr++];
      let LetterSpacing = tape[ptr++];
      let WordSpacing = tape[ptr++];
      let TextTransform = tape[ptr++];
      let LineHeight = tape[ptr++];
      return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
    }
    ToTape() {
      let args = [];
      args.push(this.TextIndent);
      ;
      args.push(this.TextAlign);
      ;
      args.push(this.TextDecoration);
      ;
      args.push(this.LetterSpacing);
      ;
      args.push(this.WordSpacing);
      ;
      args.push(this.TextTransform);
      ;
      args.push(this.LineHeight);
      ;
      return args;
    }
  };
  var IfcTextureCoordinate = class {
    constructor(expressID, type, Maps) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      return new IfcTextureCoordinate(expressID, type, Maps);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      ;
      return args;
    }
  };
  var IfcTextureCoordinateGenerator = class {
    constructor(expressID, type, Maps, Mode, Parameter) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.Mode = Mode;
      this.Parameter = Parameter;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let Mode = tape[ptr++];
      let Parameter = tape[ptr++];
      return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      ;
      args.push(this.Mode);
      ;
      args.push(this.Parameter);
      ;
      return args;
    }
  };
  var IfcTextureMap = class {
    constructor(expressID, type, Maps, Vertices, MappedTo) {
      this.expressID = expressID;
      this.type = type;
      this.Maps = Maps;
      this.Vertices = Vertices;
      this.MappedTo = MappedTo;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Maps = tape[ptr++];
      let Vertices = tape[ptr++];
      let MappedTo = tape[ptr++];
      return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
    }
    ToTape() {
      let args = [];
      args.push(this.Maps);
      ;
      args.push(this.Vertices);
      ;
      args.push(this.MappedTo);
      ;
      return args;
    }
  };
  var IfcTextureVertex = class {
    constructor(expressID, type, Coordinates) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      return new IfcTextureVertex(expressID, type, Coordinates);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      return args;
    }
  };
  var IfcTextureVertexList = class {
    constructor(expressID, type, TexCoordsList) {
      this.expressID = expressID;
      this.type = type;
      this.TexCoordsList = TexCoordsList;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let TexCoordsList = tape[ptr++];
      return new IfcTextureVertexList(expressID, type, TexCoordsList);
    }
    ToTape() {
      let args = [];
      args.push(this.TexCoordsList);
      ;
      return args;
    }
  };
  var IfcTimePeriod = class {
    constructor(expressID, type, StartTime, EndTime) {
      this.expressID = expressID;
      this.type = type;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      return new IfcTimePeriod(expressID, type, StartTime, EndTime);
    }
    ToTape() {
      let args = [];
      args.push(this.StartTime);
      ;
      args.push(this.EndTime);
      ;
      return args;
    }
  };
  var IfcTimeSeries = class {
    constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.Description = Description;
      this.StartTime = StartTime;
      this.EndTime = EndTime;
      this.TimeSeriesDataType = TimeSeriesDataType;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.Unit = Unit;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let StartTime = tape[ptr++];
      let EndTime = tape[ptr++];
      let TimeSeriesDataType = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let Unit = tape[ptr++];
      return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.EndTime);
      ;
      args.push(this.TimeSeriesDataType);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.Unit);
      ;
      return args;
    }
  };
  var IfcTimeSeriesValue = class {
    constructor(expressID, type, ListValues) {
      this.expressID = expressID;
      this.type = type;
      this.ListValues = ListValues;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ListValues = tape[ptr++];
      return new IfcTimeSeriesValue(expressID, type, ListValues);
    }
    ToTape() {
      let args = [];
      args.push(this.ListValues);
      ;
      return args;
    }
  };
  var IfcTopologicalRepresentationItem = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcTopologicalRepresentationItem(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcTopologyRepresentation = class {
    constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
      this.expressID = expressID;
      this.type = type;
      this.ContextOfItems = ContextOfItems;
      this.RepresentationIdentifier = RepresentationIdentifier;
      this.RepresentationType = RepresentationType;
      this.Items = Items;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ContextOfItems = tape[ptr++];
      let RepresentationIdentifier = tape[ptr++];
      let RepresentationType = tape[ptr++];
      let Items = tape[ptr++];
      return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
    }
    ToTape() {
      let args = [];
      args.push(this.ContextOfItems);
      ;
      args.push(this.RepresentationIdentifier);
      ;
      args.push(this.RepresentationType);
      ;
      args.push(this.Items);
      ;
      return args;
    }
  };
  var IfcToroidalSurface = class {
    constructor(expressID, type, Position, MajorRadius, MinorRadius) {
      this.expressID = expressID;
      this.type = type;
      this.Position = Position;
      this.MajorRadius = MajorRadius;
      this.MinorRadius = MinorRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Position = tape[ptr++];
      let MajorRadius = tape[ptr++];
      let MinorRadius = tape[ptr++];
      return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.Position);
      ;
      args.push(this.MajorRadius);
      ;
      args.push(this.MinorRadius);
      ;
      return args;
    }
  };
  var IfcTransformer = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTransformerType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTransitionCurveSegment2D = class {
    constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
      this.expressID = expressID;
      this.type = type;
      this.StartPoint = StartPoint;
      this.StartDirection = StartDirection;
      this.SegmentLength = SegmentLength;
      this.StartRadius = StartRadius;
      this.EndRadius = EndRadius;
      this.IsStartRadiusCCW = IsStartRadiusCCW;
      this.IsEndRadiusCCW = IsEndRadiusCCW;
      this.TransitionCurveType = TransitionCurveType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let StartPoint = tape[ptr++];
      let StartDirection = tape[ptr++];
      let SegmentLength = tape[ptr++];
      let StartRadius = tape[ptr++];
      let EndRadius = tape[ptr++];
      let IsStartRadiusCCW = tape[ptr++];
      let IsEndRadiusCCW = tape[ptr++];
      let TransitionCurveType = tape[ptr++];
      return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
    }
    ToTape() {
      let args = [];
      args.push(this.StartPoint);
      ;
      args.push(this.StartDirection);
      ;
      args.push(this.SegmentLength);
      ;
      args.push(this.StartRadius);
      ;
      args.push(this.EndRadius);
      ;
      args.push(this.IsStartRadiusCCW);
      ;
      args.push(this.IsEndRadiusCCW);
      ;
      args.push(this.TransitionCurveType);
      ;
      return args;
    }
  };
  var IfcTransportElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTransportElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTrapeziumProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.BottomXDim = BottomXDim;
      this.TopXDim = TopXDim;
      this.YDim = YDim;
      this.TopXOffset = TopXOffset;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let BottomXDim = tape[ptr++];
      let TopXDim = tape[ptr++];
      let YDim = tape[ptr++];
      let TopXOffset = tape[ptr++];
      return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.BottomXDim);
      ;
      args.push(this.TopXDim);
      ;
      args.push(this.YDim);
      ;
      args.push(this.TopXOffset);
      ;
      return args;
    }
  };
  var IfcTriangulatedFaceSet = class {
    constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Normals = Normals;
      this.Closed = Closed;
      this.CoordIndex = CoordIndex;
      this.PnIndex = PnIndex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Normals = tape[ptr++];
      let Closed = tape[ptr++];
      let CoordIndex = tape[ptr++];
      let PnIndex = tape[ptr++];
      return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      args.push(this.Normals);
      ;
      args.push(this.Closed);
      ;
      args.push(this.CoordIndex);
      ;
      args.push(this.PnIndex);
      ;
      return args;
    }
  };
  var IfcTriangulatedIrregularNetwork = class {
    constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
      this.expressID = expressID;
      this.type = type;
      this.Coordinates = Coordinates;
      this.Normals = Normals;
      this.Closed = Closed;
      this.CoordIndex = CoordIndex;
      this.PnIndex = PnIndex;
      this.Flags = Flags;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Coordinates = tape[ptr++];
      let Normals = tape[ptr++];
      let Closed = tape[ptr++];
      let CoordIndex = tape[ptr++];
      let PnIndex = tape[ptr++];
      let Flags = tape[ptr++];
      return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
    }
    ToTape() {
      let args = [];
      args.push(this.Coordinates);
      ;
      args.push(this.Normals);
      ;
      args.push(this.Closed);
      ;
      args.push(this.CoordIndex);
      ;
      args.push(this.PnIndex);
      ;
      args.push(this.Flags);
      ;
      return args;
    }
  };
  var IfcTrimmedCurve = class {
    constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
      this.expressID = expressID;
      this.type = type;
      this.BasisCurve = BasisCurve;
      this.Trim1 = Trim1;
      this.Trim2 = Trim2;
      this.SenseAgreement = SenseAgreement;
      this.MasterRepresentation = MasterRepresentation;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let BasisCurve = tape[ptr++];
      let Trim1 = tape[ptr++];
      let Trim2 = tape[ptr++];
      let SenseAgreement = tape[ptr++];
      let MasterRepresentation = tape[ptr++];
      return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
    }
    ToTape() {
      let args = [];
      args.push(this.BasisCurve);
      ;
      args.push(this.Trim1);
      ;
      args.push(this.Trim2);
      ;
      args.push(this.SenseAgreement);
      ;
      args.push(this.MasterRepresentation);
      ;
      return args;
    }
  };
  var IfcTubeBundle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTubeBundleType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcTypeObject = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      return args;
    }
  };
  var IfcTypeProcess = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ProcessType = ProcessType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ProcessType = tape[ptr++];
      return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ProcessType);
      ;
      return args;
    }
  };
  var IfcTypeProduct = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcTypeResource = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.Identification = Identification;
      this.LongDescription = LongDescription;
      this.ResourceType = ResourceType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let Identification = tape[ptr++];
      let LongDescription = tape[ptr++];
      let ResourceType = tape[ptr++];
      return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.Identification);
      ;
      args.push(this.LongDescription);
      ;
      args.push(this.ResourceType);
      ;
      return args;
    }
  };
  var IfcUShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
      this.FlangeSlope = FlangeSlope;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      let FlangeSlope = tape[ptr++];
      return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Depth);
      ;
      args.push(this.FlangeWidth);
      ;
      args.push(this.WebThickness);
      ;
      args.push(this.FlangeThickness);
      ;
      args.push(this.FilletRadius);
      ;
      args.push(this.EdgeRadius);
      ;
      args.push(this.FlangeSlope);
      ;
      return args;
    }
  };
  var IfcUnitAssignment = class {
    constructor(expressID, type, Units) {
      this.expressID = expressID;
      this.type = type;
      this.Units = Units;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Units = tape[ptr++];
      return new IfcUnitAssignment(expressID, type, Units);
    }
    ToTape() {
      let args = [];
      args.push(this.Units);
      ;
      return args;
    }
  };
  var IfcUnitaryControlElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcUnitaryControlElementType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcUnitaryEquipment = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcUnitaryEquipmentType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcValve = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcValveType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcVector = class {
    constructor(expressID, type, Orientation, Magnitude) {
      this.expressID = expressID;
      this.type = type;
      this.Orientation = Orientation;
      this.Magnitude = Magnitude;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Orientation = tape[ptr++];
      let Magnitude = tape[ptr++];
      return new IfcVector(expressID, type, Orientation, Magnitude);
    }
    ToTape() {
      let args = [];
      args.push(this.Orientation);
      ;
      args.push(this.Magnitude);
      ;
      return args;
    }
  };
  var IfcVertex = class {
    constructor(expressID, type) {
      this.expressID = expressID;
      this.type = type;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      return new IfcVertex(expressID, type);
    }
    ToTape() {
      let args = [];
      return args;
    }
  };
  var IfcVertexLoop = class {
    constructor(expressID, type, LoopVertex) {
      this.expressID = expressID;
      this.type = type;
      this.LoopVertex = LoopVertex;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let LoopVertex = tape[ptr++];
      return new IfcVertexLoop(expressID, type, LoopVertex);
    }
    ToTape() {
      let args = [];
      args.push(this.LoopVertex);
      ;
      return args;
    }
  };
  var IfcVertexPoint = class {
    constructor(expressID, type, VertexGeometry) {
      this.expressID = expressID;
      this.type = type;
      this.VertexGeometry = VertexGeometry;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let VertexGeometry = tape[ptr++];
      return new IfcVertexPoint(expressID, type, VertexGeometry);
    }
    ToTape() {
      let args = [];
      args.push(this.VertexGeometry);
      ;
      return args;
    }
  };
  var IfcVibrationDamper = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcVibrationDamperType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcVibrationIsolator = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcVibrationIsolatorType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcVirtualElement = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      return args;
    }
  };
  var IfcVirtualGridIntersection = class {
    constructor(expressID, type, IntersectingAxes, OffsetDistances) {
      this.expressID = expressID;
      this.type = type;
      this.IntersectingAxes = IntersectingAxes;
      this.OffsetDistances = OffsetDistances;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let IntersectingAxes = tape[ptr++];
      let OffsetDistances = tape[ptr++];
      return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
    }
    ToTape() {
      let args = [];
      args.push(this.IntersectingAxes);
      ;
      args.push(this.OffsetDistances);
      ;
      return args;
    }
  };
  var IfcVoidingFeature = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWall = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWallElementedCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWallStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWallType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWasteTerminal = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWasteTerminalType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWindow = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.OverallHeight);
      ;
      args.push(this.OverallWidth);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.PartitioningType);
      ;
      args.push(this.UserDefinedPartitioningType);
      ;
      return args;
    }
  };
  var IfcWindowLiningProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.LiningDepth = LiningDepth;
      this.LiningThickness = LiningThickness;
      this.TransomThickness = TransomThickness;
      this.MullionThickness = MullionThickness;
      this.FirstTransomOffset = FirstTransomOffset;
      this.SecondTransomOffset = SecondTransomOffset;
      this.FirstMullionOffset = FirstMullionOffset;
      this.SecondMullionOffset = SecondMullionOffset;
      this.ShapeAspectStyle = ShapeAspectStyle;
      this.LiningOffset = LiningOffset;
      this.LiningToPanelOffsetX = LiningToPanelOffsetX;
      this.LiningToPanelOffsetY = LiningToPanelOffsetY;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let LiningDepth = tape[ptr++];
      let LiningThickness = tape[ptr++];
      let TransomThickness = tape[ptr++];
      let MullionThickness = tape[ptr++];
      let FirstTransomOffset = tape[ptr++];
      let SecondTransomOffset = tape[ptr++];
      let FirstMullionOffset = tape[ptr++];
      let SecondMullionOffset = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      let LiningOffset = tape[ptr++];
      let LiningToPanelOffsetX = tape[ptr++];
      let LiningToPanelOffsetY = tape[ptr++];
      return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.LiningDepth);
      ;
      args.push(this.LiningThickness);
      ;
      args.push(this.TransomThickness);
      ;
      args.push(this.MullionThickness);
      ;
      args.push(this.FirstTransomOffset);
      ;
      args.push(this.SecondTransomOffset);
      ;
      args.push(this.FirstMullionOffset);
      ;
      args.push(this.SecondMullionOffset);
      ;
      args.push(this.ShapeAspectStyle);
      ;
      args.push(this.LiningOffset);
      ;
      args.push(this.LiningToPanelOffsetX);
      ;
      args.push(this.LiningToPanelOffsetY);
      ;
      return args;
    }
  };
  var IfcWindowPanelProperties = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.OperationType = OperationType;
      this.PanelPosition = PanelPosition;
      this.FrameDepth = FrameDepth;
      this.FrameThickness = FrameThickness;
      this.ShapeAspectStyle = ShapeAspectStyle;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let OperationType = tape[ptr++];
      let PanelPosition = tape[ptr++];
      let FrameDepth = tape[ptr++];
      let FrameThickness = tape[ptr++];
      let ShapeAspectStyle = tape[ptr++];
      return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.PanelPosition);
      ;
      args.push(this.FrameDepth);
      ;
      args.push(this.FrameThickness);
      ;
      args.push(this.ShapeAspectStyle);
      ;
      return args;
    }
  };
  var IfcWindowStandardCase = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.ObjectPlacement = ObjectPlacement;
      this.Representation = Representation;
      this.Tag = Tag;
      this.OverallHeight = OverallHeight;
      this.OverallWidth = OverallWidth;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let ObjectPlacement = tape[ptr++];
      let Representation = tape[ptr++];
      let Tag = tape[ptr++];
      let OverallHeight = tape[ptr++];
      let OverallWidth = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.ObjectPlacement);
      ;
      args.push(this.Representation);
      ;
      args.push(this.Tag);
      ;
      args.push(this.OverallHeight);
      ;
      args.push(this.OverallWidth);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.PartitioningType);
      ;
      args.push(this.UserDefinedPartitioningType);
      ;
      return args;
    }
  };
  var IfcWindowStyle = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ConstructionType = ConstructionType;
      this.OperationType = OperationType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.Sizeable = Sizeable;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ConstructionType = tape[ptr++];
      let OperationType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let Sizeable = tape[ptr++];
      return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ConstructionType);
      ;
      args.push(this.OperationType);
      ;
      args.push(this.ParameterTakesPrecedence);
      ;
      args.push(this.Sizeable);
      ;
      return args;
    }
  };
  var IfcWindowType = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ApplicableOccurrence = ApplicableOccurrence;
      this.HasPropertySets = HasPropertySets;
      this.RepresentationMaps = RepresentationMaps;
      this.Tag = Tag;
      this.ElementType = ElementType;
      this.PredefinedType = PredefinedType;
      this.PartitioningType = PartitioningType;
      this.ParameterTakesPrecedence = ParameterTakesPrecedence;
      this.UserDefinedPartitioningType = UserDefinedPartitioningType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ApplicableOccurrence = tape[ptr++];
      let HasPropertySets = tape[ptr++];
      let RepresentationMaps = tape[ptr++];
      let Tag = tape[ptr++];
      let ElementType = tape[ptr++];
      let PredefinedType = tape[ptr++];
      let PartitioningType = tape[ptr++];
      let ParameterTakesPrecedence = tape[ptr++];
      let UserDefinedPartitioningType = tape[ptr++];
      return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ApplicableOccurrence);
      ;
      args.push(this.HasPropertySets);
      ;
      args.push(this.RepresentationMaps);
      ;
      args.push(this.Tag);
      ;
      args.push(this.ElementType);
      ;
      args.push(this.PredefinedType);
      ;
      args.push(this.PartitioningType);
      ;
      args.push(this.ParameterTakesPrecedence);
      ;
      args.push(this.UserDefinedPartitioningType);
      ;
      return args;
    }
  };
  var IfcWorkCalendar = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.WorkingTimes = WorkingTimes;
      this.ExceptionTimes = ExceptionTimes;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let WorkingTimes = tape[ptr++];
      let ExceptionTimes = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.WorkingTimes);
      ;
      args.push(this.ExceptionTimes);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWorkControl = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.CreationDate);
      ;
      args.push(this.Creators);
      ;
      args.push(this.Purpose);
      ;
      args.push(this.Duration);
      ;
      args.push(this.TotalFloat);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.FinishTime);
      ;
      return args;
    }
  };
  var IfcWorkPlan = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.CreationDate);
      ;
      args.push(this.Creators);
      ;
      args.push(this.Purpose);
      ;
      args.push(this.Duration);
      ;
      args.push(this.TotalFloat);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.FinishTime);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWorkSchedule = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.Identification = Identification;
      this.CreationDate = CreationDate;
      this.Creators = Creators;
      this.Purpose = Purpose;
      this.Duration = Duration;
      this.TotalFloat = TotalFloat;
      this.StartTime = StartTime;
      this.FinishTime = FinishTime;
      this.PredefinedType = PredefinedType;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let Identification = tape[ptr++];
      let CreationDate = tape[ptr++];
      let Creators = tape[ptr++];
      let Purpose = tape[ptr++];
      let Duration = tape[ptr++];
      let TotalFloat = tape[ptr++];
      let StartTime = tape[ptr++];
      let FinishTime = tape[ptr++];
      let PredefinedType = tape[ptr++];
      return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.Identification);
      ;
      args.push(this.CreationDate);
      ;
      args.push(this.Creators);
      ;
      args.push(this.Purpose);
      ;
      args.push(this.Duration);
      ;
      args.push(this.TotalFloat);
      ;
      args.push(this.StartTime);
      ;
      args.push(this.FinishTime);
      ;
      args.push(this.PredefinedType);
      ;
      return args;
    }
  };
  var IfcWorkTime = class {
    constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
      this.expressID = expressID;
      this.type = type;
      this.Name = Name;
      this.DataOrigin = DataOrigin;
      this.UserDefinedDataOrigin = UserDefinedDataOrigin;
      this.RecurrencePattern = RecurrencePattern;
      this.Start = Start;
      this.Finish = Finish;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let Name = tape[ptr++];
      let DataOrigin = tape[ptr++];
      let UserDefinedDataOrigin = tape[ptr++];
      let RecurrencePattern = tape[ptr++];
      let Start = tape[ptr++];
      let Finish = tape[ptr++];
      return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
    }
    ToTape() {
      let args = [];
      args.push(this.Name);
      ;
      args.push(this.DataOrigin);
      ;
      args.push(this.UserDefinedDataOrigin);
      ;
      args.push(this.RecurrencePattern);
      ;
      args.push(this.Start);
      ;
      args.push(this.Finish);
      ;
      return args;
    }
  };
  var IfcZShapeProfileDef = class {
    constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
      this.expressID = expressID;
      this.type = type;
      this.ProfileType = ProfileType;
      this.ProfileName = ProfileName;
      this.Position = Position;
      this.Depth = Depth;
      this.FlangeWidth = FlangeWidth;
      this.WebThickness = WebThickness;
      this.FlangeThickness = FlangeThickness;
      this.FilletRadius = FilletRadius;
      this.EdgeRadius = EdgeRadius;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let ProfileType = tape[ptr++];
      let ProfileName = tape[ptr++];
      let Position = tape[ptr++];
      let Depth = tape[ptr++];
      let FlangeWidth = tape[ptr++];
      let WebThickness = tape[ptr++];
      let FlangeThickness = tape[ptr++];
      let FilletRadius = tape[ptr++];
      let EdgeRadius = tape[ptr++];
      return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
    }
    ToTape() {
      let args = [];
      args.push(this.ProfileType);
      ;
      args.push(this.ProfileName);
      ;
      args.push(this.Position);
      ;
      args.push(this.Depth);
      ;
      args.push(this.FlangeWidth);
      ;
      args.push(this.WebThickness);
      ;
      args.push(this.FlangeThickness);
      ;
      args.push(this.FilletRadius);
      ;
      args.push(this.EdgeRadius);
      ;
      return args;
    }
  };
  var IfcZone = class {
    constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
      this.expressID = expressID;
      this.type = type;
      this.GlobalId = GlobalId;
      this.OwnerHistory = OwnerHistory;
      this.Name = Name;
      this.Description = Description;
      this.ObjectType = ObjectType;
      this.LongName = LongName;
    }
    static FromTape(expressID, type, tape) {
      let ptr = 0;
      let GlobalId = tape[ptr++];
      let OwnerHistory = tape[ptr++];
      let Name = tape[ptr++];
      let Description = tape[ptr++];
      let ObjectType = tape[ptr++];
      let LongName = tape[ptr++];
      return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
    }
    ToTape() {
      let args = [];
      args.push(this.GlobalId);
      ;
      args.push(this.OwnerHistory);
      ;
      args.push(this.Name);
      ;
      args.push(this.Description);
      ;
      args.push(this.ObjectType);
      ;
      args.push(this.LongName);
      ;
      return args;
    }
  };

  // dist/helpers/ifc-elements.ts
  var IfcElements2 = {
    103090709: "IFCPROJECT",
    4097777520: "IFCSITE",
    4031249490: "IFCBUILDING",
    3124254112: "IFCBUILDINGSTOREY",
    3856911033: "IFCSPACE",
    1674181508: "IFCANNOTATION",
    25142252: "IFCCONTROLLER",
    32344328: "IFCBOILER",
    76236018: "IFCLAMP",
    90941305: "IFCPUMP",
    177149247: "IFCAIRTERMINALBOX",
    182646315: "IFCFLOWINSTRUMENT",
    263784265: "IFCFURNISHINGELEMENT",
    264262732: "IFCELECTRICGENERATOR",
    277319702: "IFCAUDIOVISUALAPPLIANCE",
    310824031: "IFCPIPEFITTING",
    331165859: "IFCSTAIR",
    342316401: "IFCDUCTFITTING",
    377706215: "IFCMECHANICALFASTENER",
    395920057: "IFCDOOR",
    402227799: "IFCELECTRICMOTOR",
    413509423: "IFCSYSTEMFURNITUREELEMENT",
    484807127: "IFCEVAPORATOR",
    486154966: "IFCWINDOWSTANDARDCASE",
    629592764: "IFCLIGHTFIXTURE",
    630975310: "IFCUNITARYCONTROLELEMENT",
    635142910: "IFCCABLECARRIERFITTING",
    639361253: "IFCCOIL",
    647756555: "IFCFASTENER",
    707683696: "IFCFLOWSTORAGEDEVICE",
    738039164: "IFCPROTECTIVEDEVICE",
    753842376: "IFCBEAM",
    812556717: "IFCTANK",
    819412036: "IFCFILTER",
    843113511: "IFCCOLUMN",
    862014818: "IFCELECTRICDISTRIBUTIONBOARD",
    900683007: "IFCFOOTING",
    905975707: "IFCCOLUMNSTANDARDCASE",
    926996030: "IFCVOIDINGFEATURE",
    979691226: "IFCREINFORCINGBAR",
    987401354: "IFCFLOWSEGMENT",
    1003880860: "IFCELECTRICTIMECONTROL",
    1051757585: "IFCCABLEFITTING",
    1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
    1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
    1073191201: "IFCMEMBER",
    1095909175: "IFCBUILDINGELEMENTPROXY",
    1156407060: "IFCPLATESTANDARDCASE",
    1162798199: "IFCSWITCHINGDEVICE",
    1329646415: "IFCSHADINGDEVICE",
    1335981549: "IFCDISCRETEACCESSORY",
    1360408905: "IFCDUCTSILENCER",
    1404847402: "IFCSTACKTERMINAL",
    1426591983: "IFCFIRESUPPRESSIONTERMINAL",
    1437502449: "IFCMEDICALDEVICE",
    1509553395: "IFCFURNITURE",
    1529196076: "IFCSLAB",
    1620046519: "IFCTRANSPORTELEMENT",
    1634111441: "IFCAIRTERMINAL",
    1658829314: "IFCENERGYCONVERSIONDEVICE",
    1677625105: "IFCCIVILELEMENT",
    1687234759: "IFCPILE",
    1904799276: "IFCELECTRICAPPLIANCE",
    1911478936: "IFCMEMBERSTANDARDCASE",
    1945004755: "IFCDISTRIBUTIONELEMENT",
    1973544240: "IFCCOVERING",
    1999602285: "IFCSPACEHEATER",
    2016517767: "IFCROOF",
    2056796094: "IFCAIRTOAIRHEATRECOVERY",
    2058353004: "IFCFLOWCONTROLLER",
    2068733104: "IFCHUMIDIFIER",
    2176052936: "IFCJUNCTIONBOX",
    2188021234: "IFCFLOWMETER",
    2223149337: "IFCFLOWTERMINAL",
    2262370178: "IFCRAILING",
    2272882330: "IFCCONDENSER",
    2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
    2320036040: "IFCREINFORCINGMESH",
    2347447852: "IFCTENDONANCHOR",
    2391383451: "IFCVIBRATIONISOLATOR",
    2391406946: "IFCWALL",
    2474470126: "IFCMOTORCONNECTION",
    2769231204: "IFCVIRTUALELEMENT",
    2814081492: "IFCENGINE",
    2906023776: "IFCBEAMSTANDARDCASE",
    2938176219: "IFCBURNER",
    2979338954: "IFCBUILDINGELEMENTPART",
    3024970846: "IFCRAMP",
    3026737570: "IFCTUBEBUNDLE",
    3027962421: "IFCSLABSTANDARDCASE",
    3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
    3053780830: "IFCSANITARYTERMINAL",
    3079942009: "IFCOPENINGSTANDARDCASE",
    3087945054: "IFCALARM",
    3101698114: "IFCSURFACEFEATURE",
    3127900445: "IFCSLABELEMENTEDCASE",
    3132237377: "IFCFLOWMOVINGDEVICE",
    3171933400: "IFCPLATE",
    3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
    3242481149: "IFCDOORSTANDARDCASE",
    3283111854: "IFCRAMPFLIGHT",
    3296154744: "IFCCHIMNEY",
    3304561284: "IFCWINDOW",
    3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
    3319311131: "IFCHEATEXCHANGER",
    3415622556: "IFCFAN",
    3420628829: "IFCSOLARDEVICE",
    3493046030: "IFCGEOGRAPHICELEMENT",
    3495092785: "IFCCURTAINWALL",
    3508470533: "IFCFLOWTREATMENTDEVICE",
    3512223829: "IFCWALLSTANDARDCASE",
    3518393246: "IFCDUCTSEGMENT",
    3571504051: "IFCCOMPRESSOR",
    3588315303: "IFCOPENINGELEMENT",
    3612865200: "IFCPIPESEGMENT",
    3640358203: "IFCCOOLINGTOWER",
    3651124850: "IFCPROJECTIONELEMENT",
    3694346114: "IFCOUTLET",
    3747195512: "IFCEVAPORATIVECOOLER",
    3758799889: "IFCCABLECARRIERSEGMENT",
    3824725483: "IFCTENDON",
    3825984169: "IFCTRANSFORMER",
    3902619387: "IFCCHILLER",
    4074379575: "IFCDAMPER",
    4086658281: "IFCSENSOR",
    4123344466: "IFCELEMENTASSEMBLY",
    4136498852: "IFCCOOLEDBEAM",
    4156078855: "IFCWALLELEMENTEDCASE",
    4175244083: "IFCINTERCEPTOR",
    4207607924: "IFCVALVE",
    4217484030: "IFCCABLESEGMENT",
    4237592921: "IFCWASTETERMINAL",
    4252922144: "IFCSTAIRFLIGHT",
    4278956645: "IFCFLOWFITTING",
    4288193352: "IFCACTUATOR",
    4292641817: "IFCUNITARYEQUIPMENT",
    3009204131: "IFCGRID"
  };

  // dist/helpers/types-map.ts
  var IfcTypesMap = {
    3821786052: "IFCACTIONREQUEST",
    2296667514: "IFCACTOR",
    3630933823: "IFCACTORROLE",
    4288193352: "IFCACTUATOR",
    2874132201: "IFCACTUATORTYPE",
    618182010: "IFCADDRESS",
    1635779807: "IFCADVANCEDBREP",
    2603310189: "IFCADVANCEDBREPWITHVOIDS",
    3406155212: "IFCADVANCEDFACE",
    1634111441: "IFCAIRTERMINAL",
    177149247: "IFCAIRTERMINALBOX",
    1411407467: "IFCAIRTERMINALBOXTYPE",
    3352864051: "IFCAIRTERMINALTYPE",
    2056796094: "IFCAIRTOAIRHEATRECOVERY",
    1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
    3087945054: "IFCALARM",
    3001207471: "IFCALARMTYPE",
    325726236: "IFCALIGNMENT",
    749761778: "IFCALIGNMENT2DHORIZONTAL",
    3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
    2483840362: "IFCALIGNMENT2DSEGMENT",
    3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
    3239324667: "IFCALIGNMENT2DVERSEGLINE",
    4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
    53199957: "IFCALIGNMENT2DVERTICAL",
    2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
    3512275521: "IFCALIGNMENTCURVE",
    1674181508: "IFCANNOTATION",
    669184980: "IFCANNOTATIONFILLAREA",
    639542469: "IFCAPPLICATION",
    411424972: "IFCAPPLIEDVALUE",
    130549933: "IFCAPPROVAL",
    3869604511: "IFCAPPROVALRELATIONSHIP",
    3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
    1310608509: "IFCARBITRARYOPENPROFILEDEF",
    2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
    3460190687: "IFCASSET",
    3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
    277319702: "IFCAUDIOVISUALAPPLIANCE",
    1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
    4261334040: "IFCAXIS1PLACEMENT",
    3125803723: "IFCAXIS2PLACEMENT2D",
    2740243338: "IFCAXIS2PLACEMENT3D",
    1967976161: "IFCBSPLINECURVE",
    2461110595: "IFCBSPLINECURVEWITHKNOTS",
    2887950389: "IFCBSPLINESURFACE",
    167062518: "IFCBSPLINESURFACEWITHKNOTS",
    753842376: "IFCBEAM",
    2906023776: "IFCBEAMSTANDARDCASE",
    819618141: "IFCBEAMTYPE",
    4196446775: "IFCBEARING",
    3649138523: "IFCBEARINGTYPE",
    616511568: "IFCBLOBTEXTURE",
    1334484129: "IFCBLOCK",
    32344328: "IFCBOILER",
    231477066: "IFCBOILERTYPE",
    3649129432: "IFCBOOLEANCLIPPINGRESULT",
    2736907675: "IFCBOOLEANRESULT",
    4037036970: "IFCBOUNDARYCONDITION",
    1136057603: "IFCBOUNDARYCURVE",
    1560379544: "IFCBOUNDARYEDGECONDITION",
    3367102660: "IFCBOUNDARYFACECONDITION",
    1387855156: "IFCBOUNDARYNODECONDITION",
    2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
    1260505505: "IFCBOUNDEDCURVE",
    4182860854: "IFCBOUNDEDSURFACE",
    2581212453: "IFCBOUNDINGBOX",
    2713105998: "IFCBOXEDHALFSPACE",
    644574406: "IFCBRIDGE",
    963979645: "IFCBRIDGEPART",
    4031249490: "IFCBUILDING",
    3299480353: "IFCBUILDINGELEMENT",
    2979338954: "IFCBUILDINGELEMENTPART",
    39481116: "IFCBUILDINGELEMENTPARTTYPE",
    1095909175: "IFCBUILDINGELEMENTPROXY",
    1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
    1950629157: "IFCBUILDINGELEMENTTYPE",
    3124254112: "IFCBUILDINGSTOREY",
    1177604601: "IFCBUILDINGSYSTEM",
    2938176219: "IFCBURNER",
    2188180465: "IFCBURNERTYPE",
    2898889636: "IFCCSHAPEPROFILEDEF",
    635142910: "IFCCABLECARRIERFITTING",
    395041908: "IFCCABLECARRIERFITTINGTYPE",
    3758799889: "IFCCABLECARRIERSEGMENT",
    3293546465: "IFCCABLECARRIERSEGMENTTYPE",
    1051757585: "IFCCABLEFITTING",
    2674252688: "IFCCABLEFITTINGTYPE",
    4217484030: "IFCCABLESEGMENT",
    1285652485: "IFCCABLESEGMENTTYPE",
    3999819293: "IFCCAISSONFOUNDATION",
    3203706013: "IFCCAISSONFOUNDATIONTYPE",
    1123145078: "IFCCARTESIANPOINT",
    574549367: "IFCCARTESIANPOINTLIST",
    1675464909: "IFCCARTESIANPOINTLIST2D",
    2059837836: "IFCCARTESIANPOINTLIST3D",
    59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
    3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
    3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
    3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
    1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
    3150382593: "IFCCENTERLINEPROFILEDEF",
    3902619387: "IFCCHILLER",
    2951183804: "IFCCHILLERTYPE",
    3296154744: "IFCCHIMNEY",
    2197970202: "IFCCHIMNEYTYPE",
    2611217952: "IFCCIRCLE",
    2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
    1383045692: "IFCCIRCLEPROFILEDEF",
    1062206242: "IFCCIRCULARARCSEGMENT2D",
    1677625105: "IFCCIVILELEMENT",
    3893394355: "IFCCIVILELEMENTTYPE",
    747523909: "IFCCLASSIFICATION",
    647927063: "IFCCLASSIFICATIONREFERENCE",
    2205249479: "IFCCLOSEDSHELL",
    639361253: "IFCCOIL",
    2301859152: "IFCCOILTYPE",
    776857604: "IFCCOLOURRGB",
    3285139300: "IFCCOLOURRGBLIST",
    3264961684: "IFCCOLOURSPECIFICATION",
    843113511: "IFCCOLUMN",
    905975707: "IFCCOLUMNSTANDARDCASE",
    300633059: "IFCCOLUMNTYPE",
    3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
    400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
    2542286263: "IFCCOMPLEXPROPERTY",
    3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
    3732776249: "IFCCOMPOSITECURVE",
    15328376: "IFCCOMPOSITECURVEONSURFACE",
    2485617015: "IFCCOMPOSITECURVESEGMENT",
    1485152156: "IFCCOMPOSITEPROFILEDEF",
    3571504051: "IFCCOMPRESSOR",
    3850581409: "IFCCOMPRESSORTYPE",
    2272882330: "IFCCONDENSER",
    2816379211: "IFCCONDENSERTYPE",
    2510884976: "IFCCONIC",
    370225590: "IFCCONNECTEDFACESET",
    1981873012: "IFCCONNECTIONCURVEGEOMETRY",
    2859738748: "IFCCONNECTIONGEOMETRY",
    45288368: "IFCCONNECTIONPOINTECCENTRICITY",
    2614616156: "IFCCONNECTIONPOINTGEOMETRY",
    2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
    775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
    1959218052: "IFCCONSTRAINT",
    3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
    2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
    1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
    4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
    488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
    1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
    2559216714: "IFCCONSTRUCTIONRESOURCE",
    2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
    3419103109: "IFCCONTEXT",
    3050246964: "IFCCONTEXTDEPENDENTUNIT",
    3293443760: "IFCCONTROL",
    25142252: "IFCCONTROLLER",
    578613899: "IFCCONTROLLERTYPE",
    2889183280: "IFCCONVERSIONBASEDUNIT",
    2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
    4136498852: "IFCCOOLEDBEAM",
    335055490: "IFCCOOLEDBEAMTYPE",
    3640358203: "IFCCOOLINGTOWER",
    2954562838: "IFCCOOLINGTOWERTYPE",
    1785450214: "IFCCOORDINATEOPERATION",
    1466758467: "IFCCOORDINATEREFERENCESYSTEM",
    3895139033: "IFCCOSTITEM",
    1419761937: "IFCCOSTSCHEDULE",
    602808272: "IFCCOSTVALUE",
    1973544240: "IFCCOVERING",
    1916426348: "IFCCOVERINGTYPE",
    3295246426: "IFCCREWRESOURCE",
    1815067380: "IFCCREWRESOURCETYPE",
    2506170314: "IFCCSGPRIMITIVE3D",
    2147822146: "IFCCSGSOLID",
    539742890: "IFCCURRENCYRELATIONSHIP",
    3495092785: "IFCCURTAINWALL",
    1457835157: "IFCCURTAINWALLTYPE",
    2601014836: "IFCCURVE",
    2827736869: "IFCCURVEBOUNDEDPLANE",
    2629017746: "IFCCURVEBOUNDEDSURFACE",
    1186437898: "IFCCURVESEGMENT2D",
    3800577675: "IFCCURVESTYLE",
    1105321065: "IFCCURVESTYLEFONT",
    2367409068: "IFCCURVESTYLEFONTANDSCALING",
    3510044353: "IFCCURVESTYLEFONTPATTERN",
    1213902940: "IFCCYLINDRICALSURFACE",
    4074379575: "IFCDAMPER",
    3961806047: "IFCDAMPERTYPE",
    3426335179: "IFCDEEPFOUNDATION",
    1306400036: "IFCDEEPFOUNDATIONTYPE",
    3632507154: "IFCDERIVEDPROFILEDEF",
    1765591967: "IFCDERIVEDUNIT",
    1045800335: "IFCDERIVEDUNITELEMENT",
    2949456006: "IFCDIMENSIONALEXPONENTS",
    32440307: "IFCDIRECTION",
    1335981549: "IFCDISCRETEACCESSORY",
    2635815018: "IFCDISCRETEACCESSORYTYPE",
    1945343521: "IFCDISTANCEEXPRESSION",
    1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
    1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
    562808652: "IFCDISTRIBUTIONCIRCUIT",
    1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
    2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
    1945004755: "IFCDISTRIBUTIONELEMENT",
    3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
    3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
    3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
    3041715199: "IFCDISTRIBUTIONPORT",
    3205830791: "IFCDISTRIBUTIONSYSTEM",
    1154170062: "IFCDOCUMENTINFORMATION",
    770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
    3732053477: "IFCDOCUMENTREFERENCE",
    395920057: "IFCDOOR",
    2963535650: "IFCDOORLININGPROPERTIES",
    1714330368: "IFCDOORPANELPROPERTIES",
    3242481149: "IFCDOORSTANDARDCASE",
    526551008: "IFCDOORSTYLE",
    2323601079: "IFCDOORTYPE",
    445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
    4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
    342316401: "IFCDUCTFITTING",
    869906466: "IFCDUCTFITTINGTYPE",
    3518393246: "IFCDUCTSEGMENT",
    3760055223: "IFCDUCTSEGMENTTYPE",
    1360408905: "IFCDUCTSILENCER",
    2030761528: "IFCDUCTSILENCERTYPE",
    3900360178: "IFCEDGE",
    476780140: "IFCEDGECURVE",
    1472233963: "IFCEDGELOOP",
    1904799276: "IFCELECTRICAPPLIANCE",
    663422040: "IFCELECTRICAPPLIANCETYPE",
    862014818: "IFCELECTRICDISTRIBUTIONBOARD",
    2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
    3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
    3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
    264262732: "IFCELECTRICGENERATOR",
    1534661035: "IFCELECTRICGENERATORTYPE",
    402227799: "IFCELECTRICMOTOR",
    1217240411: "IFCELECTRICMOTORTYPE",
    1003880860: "IFCELECTRICTIMECONTROL",
    712377611: "IFCELECTRICTIMECONTROLTYPE",
    1758889154: "IFCELEMENT",
    4123344466: "IFCELEMENTASSEMBLY",
    2397081782: "IFCELEMENTASSEMBLYTYPE",
    1623761950: "IFCELEMENTCOMPONENT",
    2590856083: "IFCELEMENTCOMPONENTTYPE",
    1883228015: "IFCELEMENTQUANTITY",
    339256511: "IFCELEMENTTYPE",
    2777663545: "IFCELEMENTARYSURFACE",
    1704287377: "IFCELLIPSE",
    2835456948: "IFCELLIPSEPROFILEDEF",
    1658829314: "IFCENERGYCONVERSIONDEVICE",
    2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
    2814081492: "IFCENGINE",
    132023988: "IFCENGINETYPE",
    3747195512: "IFCEVAPORATIVECOOLER",
    3174744832: "IFCEVAPORATIVECOOLERTYPE",
    484807127: "IFCEVAPORATOR",
    3390157468: "IFCEVAPORATORTYPE",
    4148101412: "IFCEVENT",
    211053100: "IFCEVENTTIME",
    4024345920: "IFCEVENTTYPE",
    297599258: "IFCEXTENDEDPROPERTIES",
    4294318154: "IFCEXTERNALINFORMATION",
    3200245327: "IFCEXTERNALREFERENCE",
    1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
    1209101575: "IFCEXTERNALSPATIALELEMENT",
    2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
    2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
    1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
    3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
    477187591: "IFCEXTRUDEDAREASOLID",
    2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
    2556980723: "IFCFACE",
    2047409740: "IFCFACEBASEDSURFACEMODEL",
    1809719519: "IFCFACEBOUND",
    803316827: "IFCFACEOUTERBOUND",
    3008276851: "IFCFACESURFACE",
    807026263: "IFCFACETEDBREP",
    3737207727: "IFCFACETEDBREPWITHVOIDS",
    24185140: "IFCFACILITY",
    1310830890: "IFCFACILITYPART",
    4219587988: "IFCFAILURECONNECTIONCONDITION",
    3415622556: "IFCFAN",
    346874300: "IFCFANTYPE",
    647756555: "IFCFASTENER",
    2489546625: "IFCFASTENERTYPE",
    2827207264: "IFCFEATUREELEMENT",
    2143335405: "IFCFEATUREELEMENTADDITION",
    1287392070: "IFCFEATUREELEMENTSUBTRACTION",
    738692330: "IFCFILLAREASTYLE",
    374418227: "IFCFILLAREASTYLEHATCHING",
    315944413: "IFCFILLAREASTYLETILES",
    819412036: "IFCFILTER",
    1810631287: "IFCFILTERTYPE",
    1426591983: "IFCFIRESUPPRESSIONTERMINAL",
    4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
    2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
    2058353004: "IFCFLOWCONTROLLER",
    3907093117: "IFCFLOWCONTROLLERTYPE",
    4278956645: "IFCFLOWFITTING",
    3198132628: "IFCFLOWFITTINGTYPE",
    182646315: "IFCFLOWINSTRUMENT",
    4037862832: "IFCFLOWINSTRUMENTTYPE",
    2188021234: "IFCFLOWMETER",
    3815607619: "IFCFLOWMETERTYPE",
    3132237377: "IFCFLOWMOVINGDEVICE",
    1482959167: "IFCFLOWMOVINGDEVICETYPE",
    987401354: "IFCFLOWSEGMENT",
    1834744321: "IFCFLOWSEGMENTTYPE",
    707683696: "IFCFLOWSTORAGEDEVICE",
    1339347760: "IFCFLOWSTORAGEDEVICETYPE",
    2223149337: "IFCFLOWTERMINAL",
    2297155007: "IFCFLOWTERMINALTYPE",
    3508470533: "IFCFLOWTREATMENTDEVICE",
    3009222698: "IFCFLOWTREATMENTDEVICETYPE",
    900683007: "IFCFOOTING",
    1893162501: "IFCFOOTINGTYPE",
    263784265: "IFCFURNISHINGELEMENT",
    4238390223: "IFCFURNISHINGELEMENTTYPE",
    1509553395: "IFCFURNITURE",
    1268542332: "IFCFURNITURETYPE",
    3493046030: "IFCGEOGRAPHICELEMENT",
    4095422895: "IFCGEOGRAPHICELEMENTTYPE",
    987898635: "IFCGEOMETRICCURVESET",
    3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
    2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
    4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
    3590301190: "IFCGEOMETRICSET",
    3009204131: "IFCGRID",
    852622518: "IFCGRIDAXIS",
    178086475: "IFCGRIDPLACEMENT",
    2706460486: "IFCGROUP",
    812098782: "IFCHALFSPACESOLID",
    3319311131: "IFCHEATEXCHANGER",
    1251058090: "IFCHEATEXCHANGERTYPE",
    2068733104: "IFCHUMIDIFIER",
    1806887404: "IFCHUMIDIFIERTYPE",
    1484403080: "IFCISHAPEPROFILEDEF",
    3905492369: "IFCIMAGETEXTURE",
    3570813810: "IFCINDEXEDCOLOURMAP",
    2571569899: "IFCINDEXEDPOLYCURVE",
    178912537: "IFCINDEXEDPOLYGONALFACE",
    2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
    1437953363: "IFCINDEXEDTEXTUREMAP",
    2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
    4175244083: "IFCINTERCEPTOR",
    3946677679: "IFCINTERCEPTORTYPE",
    3113134337: "IFCINTERSECTIONCURVE",
    2391368822: "IFCINVENTORY",
    3741457305: "IFCIRREGULARTIMESERIES",
    3020489413: "IFCIRREGULARTIMESERIESVALUE",
    2176052936: "IFCJUNCTIONBOX",
    4288270099: "IFCJUNCTIONBOXTYPE",
    572779678: "IFCLSHAPEPROFILEDEF",
    3827777499: "IFCLABORRESOURCE",
    428585644: "IFCLABORRESOURCETYPE",
    1585845231: "IFCLAGTIME",
    76236018: "IFCLAMP",
    1051575348: "IFCLAMPTYPE",
    2655187982: "IFCLIBRARYINFORMATION",
    3452421091: "IFCLIBRARYREFERENCE",
    4162380809: "IFCLIGHTDISTRIBUTIONDATA",
    629592764: "IFCLIGHTFIXTURE",
    1161773419: "IFCLIGHTFIXTURETYPE",
    1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
    1402838566: "IFCLIGHTSOURCE",
    125510826: "IFCLIGHTSOURCEAMBIENT",
    2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
    4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
    1520743889: "IFCLIGHTSOURCEPOSITIONAL",
    3422422726: "IFCLIGHTSOURCESPOT",
    1281925730: "IFCLINE",
    3092502836: "IFCLINESEGMENT2D",
    388784114: "IFCLINEARPLACEMENT",
    1154579445: "IFCLINEARPOSITIONINGELEMENT",
    2624227202: "IFCLOCALPLACEMENT",
    1008929658: "IFCLOOP",
    1425443689: "IFCMANIFOLDSOLIDBREP",
    3057273783: "IFCMAPCONVERSION",
    2347385850: "IFCMAPPEDITEM",
    1838606355: "IFCMATERIAL",
    1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
    3708119e3: "IFCMATERIALCONSTITUENT",
    2852063980: "IFCMATERIALCONSTITUENTSET",
    760658860: "IFCMATERIALDEFINITION",
    2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
    248100487: "IFCMATERIALLAYER",
    3303938423: "IFCMATERIALLAYERSET",
    1303795690: "IFCMATERIALLAYERSETUSAGE",
    1847252529: "IFCMATERIALLAYERWITHOFFSETS",
    2199411900: "IFCMATERIALLIST",
    2235152071: "IFCMATERIALPROFILE",
    164193824: "IFCMATERIALPROFILESET",
    3079605661: "IFCMATERIALPROFILESETUSAGE",
    3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
    552965576: "IFCMATERIALPROFILEWITHOFFSETS",
    3265635763: "IFCMATERIALPROPERTIES",
    853536259: "IFCMATERIALRELATIONSHIP",
    1507914824: "IFCMATERIALUSAGEDEFINITION",
    2597039031: "IFCMEASUREWITHUNIT",
    377706215: "IFCMECHANICALFASTENER",
    2108223431: "IFCMECHANICALFASTENERTYPE",
    1437502449: "IFCMEDICALDEVICE",
    1114901282: "IFCMEDICALDEVICETYPE",
    1073191201: "IFCMEMBER",
    1911478936: "IFCMEMBERSTANDARDCASE",
    3181161470: "IFCMEMBERTYPE",
    3368373690: "IFCMETRIC",
    2998442950: "IFCMIRROREDPROFILEDEF",
    2706619895: "IFCMONETARYUNIT",
    2474470126: "IFCMOTORCONNECTION",
    977012517: "IFCMOTORCONNECTIONTYPE",
    1918398963: "IFCNAMEDUNIT",
    3888040117: "IFCOBJECT",
    219451334: "IFCOBJECTDEFINITION",
    3701648758: "IFCOBJECTPLACEMENT",
    2251480897: "IFCOBJECTIVE",
    4143007308: "IFCOCCUPANT",
    590820931: "IFCOFFSETCURVE",
    3388369263: "IFCOFFSETCURVE2D",
    3505215534: "IFCOFFSETCURVE3D",
    2485787929: "IFCOFFSETCURVEBYDISTANCES",
    2665983363: "IFCOPENSHELL",
    3588315303: "IFCOPENINGELEMENT",
    3079942009: "IFCOPENINGSTANDARDCASE",
    4251960020: "IFCORGANIZATION",
    1411181986: "IFCORGANIZATIONRELATIONSHIP",
    643959842: "IFCORIENTATIONEXPRESSION",
    1029017970: "IFCORIENTEDEDGE",
    144952367: "IFCOUTERBOUNDARYCURVE",
    3694346114: "IFCOUTLET",
    2837617999: "IFCOUTLETTYPE",
    1207048766: "IFCOWNERHISTORY",
    2529465313: "IFCPARAMETERIZEDPROFILEDEF",
    2519244187: "IFCPATH",
    1682466193: "IFCPCURVE",
    2382730787: "IFCPERFORMANCEHISTORY",
    3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
    3327091369: "IFCPERMIT",
    2077209135: "IFCPERSON",
    101040310: "IFCPERSONANDORGANIZATION",
    3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
    2483315170: "IFCPHYSICALQUANTITY",
    2226359599: "IFCPHYSICALSIMPLEQUANTITY",
    1687234759: "IFCPILE",
    1158309216: "IFCPILETYPE",
    310824031: "IFCPIPEFITTING",
    804291784: "IFCPIPEFITTINGTYPE",
    3612865200: "IFCPIPESEGMENT",
    4231323485: "IFCPIPESEGMENTTYPE",
    597895409: "IFCPIXELTEXTURE",
    2004835150: "IFCPLACEMENT",
    603570806: "IFCPLANARBOX",
    1663979128: "IFCPLANAREXTENT",
    220341763: "IFCPLANE",
    3171933400: "IFCPLATE",
    1156407060: "IFCPLATESTANDARDCASE",
    4017108033: "IFCPLATETYPE",
    2067069095: "IFCPOINT",
    4022376103: "IFCPOINTONCURVE",
    1423911732: "IFCPOINTONSURFACE",
    2924175390: "IFCPOLYLOOP",
    2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
    2839578677: "IFCPOLYGONALFACESET",
    3724593414: "IFCPOLYLINE",
    3740093272: "IFCPORT",
    1946335990: "IFCPOSITIONINGELEMENT",
    3355820592: "IFCPOSTALADDRESS",
    759155922: "IFCPREDEFINEDCOLOUR",
    2559016684: "IFCPREDEFINEDCURVEFONT",
    3727388367: "IFCPREDEFINEDITEM",
    3778827333: "IFCPREDEFINEDPROPERTIES",
    3967405729: "IFCPREDEFINEDPROPERTYSET",
    1775413392: "IFCPREDEFINEDTEXTFONT",
    677532197: "IFCPRESENTATIONITEM",
    2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
    1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
    3119450353: "IFCPRESENTATIONSTYLE",
    2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
    2744685151: "IFCPROCEDURE",
    569719735: "IFCPROCEDURETYPE",
    2945172077: "IFCPROCESS",
    4208778838: "IFCPRODUCT",
    673634403: "IFCPRODUCTDEFINITIONSHAPE",
    2095639259: "IFCPRODUCTREPRESENTATION",
    3958567839: "IFCPROFILEDEF",
    2802850158: "IFCPROFILEPROPERTIES",
    103090709: "IFCPROJECT",
    653396225: "IFCPROJECTLIBRARY",
    2904328755: "IFCPROJECTORDER",
    3843373140: "IFCPROJECTEDCRS",
    3651124850: "IFCPROJECTIONELEMENT",
    2598011224: "IFCPROPERTY",
    986844984: "IFCPROPERTYABSTRACTION",
    871118103: "IFCPROPERTYBOUNDEDVALUE",
    1680319473: "IFCPROPERTYDEFINITION",
    148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
    4166981789: "IFCPROPERTYENUMERATEDVALUE",
    3710013099: "IFCPROPERTYENUMERATION",
    2752243245: "IFCPROPERTYLISTVALUE",
    941946838: "IFCPROPERTYREFERENCEVALUE",
    1451395588: "IFCPROPERTYSET",
    3357820518: "IFCPROPERTYSETDEFINITION",
    492091185: "IFCPROPERTYSETTEMPLATE",
    3650150729: "IFCPROPERTYSINGLEVALUE",
    110355661: "IFCPROPERTYTABLEVALUE",
    3521284610: "IFCPROPERTYTEMPLATE",
    1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
    738039164: "IFCPROTECTIVEDEVICE",
    2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
    655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
    1842657554: "IFCPROTECTIVEDEVICETYPE",
    3219374653: "IFCPROXY",
    90941305: "IFCPUMP",
    2250791053: "IFCPUMPTYPE",
    2044713172: "IFCQUANTITYAREA",
    2093928680: "IFCQUANTITYCOUNT",
    931644368: "IFCQUANTITYLENGTH",
    2090586900: "IFCQUANTITYSET",
    3252649465: "IFCQUANTITYTIME",
    2405470396: "IFCQUANTITYVOLUME",
    825690147: "IFCQUANTITYWEIGHT",
    2262370178: "IFCRAILING",
    2893384427: "IFCRAILINGTYPE",
    3024970846: "IFCRAMP",
    3283111854: "IFCRAMPFLIGHT",
    2324767716: "IFCRAMPFLIGHTTYPE",
    1469900589: "IFCRAMPTYPE",
    1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
    683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
    2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
    3615266464: "IFCRECTANGLEPROFILEDEF",
    2798486643: "IFCRECTANGULARPYRAMID",
    3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
    3915482550: "IFCRECURRENCEPATTERN",
    2433181523: "IFCREFERENCE",
    4021432810: "IFCREFERENT",
    3413951693: "IFCREGULARTIMESERIES",
    1580146022: "IFCREINFORCEMENTBARPROPERTIES",
    3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
    979691226: "IFCREINFORCINGBAR",
    2572171363: "IFCREINFORCINGBARTYPE",
    3027567501: "IFCREINFORCINGELEMENT",
    964333572: "IFCREINFORCINGELEMENTTYPE",
    2320036040: "IFCREINFORCINGMESH",
    2310774935: "IFCREINFORCINGMESHTYPE",
    160246688: "IFCRELAGGREGATES",
    3939117080: "IFCRELASSIGNS",
    1683148259: "IFCRELASSIGNSTOACTOR",
    2495723537: "IFCRELASSIGNSTOCONTROL",
    1307041759: "IFCRELASSIGNSTOGROUP",
    1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
    4278684876: "IFCRELASSIGNSTOPROCESS",
    2857406711: "IFCRELASSIGNSTOPRODUCT",
    205026976: "IFCRELASSIGNSTORESOURCE",
    1865459582: "IFCRELASSOCIATES",
    4095574036: "IFCRELASSOCIATESAPPROVAL",
    919958153: "IFCRELASSOCIATESCLASSIFICATION",
    2728634034: "IFCRELASSOCIATESCONSTRAINT",
    982818633: "IFCRELASSOCIATESDOCUMENT",
    3840914261: "IFCRELASSOCIATESLIBRARY",
    2655215786: "IFCRELASSOCIATESMATERIAL",
    826625072: "IFCRELCONNECTS",
    1204542856: "IFCRELCONNECTSELEMENTS",
    3945020480: "IFCRELCONNECTSPATHELEMENTS",
    4201705270: "IFCRELCONNECTSPORTTOELEMENT",
    3190031847: "IFCRELCONNECTSPORTS",
    2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
    1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
    504942748: "IFCRELCONNECTSWITHECCENTRICITY",
    3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
    3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
    886880790: "IFCRELCOVERSBLDGELEMENTS",
    2802773753: "IFCRELCOVERSSPACES",
    2565941209: "IFCRELDECLARES",
    2551354335: "IFCRELDECOMPOSES",
    693640335: "IFCRELDEFINES",
    1462361463: "IFCRELDEFINESBYOBJECT",
    4186316022: "IFCRELDEFINESBYPROPERTIES",
    307848117: "IFCRELDEFINESBYTEMPLATE",
    781010003: "IFCRELDEFINESBYTYPE",
    3940055652: "IFCRELFILLSELEMENT",
    279856033: "IFCRELFLOWCONTROLELEMENTS",
    427948657: "IFCRELINTERFERESELEMENTS",
    3268803585: "IFCRELNESTS",
    1441486842: "IFCRELPOSITIONS",
    750771296: "IFCRELPROJECTSELEMENT",
    1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
    4122056220: "IFCRELSEQUENCE",
    366585022: "IFCRELSERVICESBUILDINGS",
    3451746338: "IFCRELSPACEBOUNDARY",
    3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
    1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
    1401173127: "IFCRELVOIDSELEMENT",
    478536968: "IFCRELATIONSHIP",
    816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
    1076942058: "IFCREPRESENTATION",
    3377609919: "IFCREPRESENTATIONCONTEXT",
    3008791417: "IFCREPRESENTATIONITEM",
    1660063152: "IFCREPRESENTATIONMAP",
    2914609552: "IFCRESOURCE",
    2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
    1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
    2439245199: "IFCRESOURCELEVELRELATIONSHIP",
    1042787934: "IFCRESOURCETIME",
    1856042241: "IFCREVOLVEDAREASOLID",
    3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
    4158566097: "IFCRIGHTCIRCULARCONE",
    3626867408: "IFCRIGHTCIRCULARCYLINDER",
    2016517767: "IFCROOF",
    2781568857: "IFCROOFTYPE",
    2341007311: "IFCROOT",
    2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
    448429030: "IFCSIUNIT",
    3053780830: "IFCSANITARYTERMINAL",
    1768891740: "IFCSANITARYTERMINALTYPE",
    1054537805: "IFCSCHEDULINGTIME",
    2157484638: "IFCSEAMCURVE",
    2042790032: "IFCSECTIONPROPERTIES",
    4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
    1862484736: "IFCSECTIONEDSOLID",
    1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
    1509187699: "IFCSECTIONEDSPINE",
    4086658281: "IFCSENSOR",
    1783015770: "IFCSENSORTYPE",
    1329646415: "IFCSHADINGDEVICE",
    4074543187: "IFCSHADINGDEVICETYPE",
    867548509: "IFCSHAPEASPECT",
    3982875396: "IFCSHAPEMODEL",
    4240577450: "IFCSHAPEREPRESENTATION",
    4124623270: "IFCSHELLBASEDSURFACEMODEL",
    3692461612: "IFCSIMPLEPROPERTY",
    3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
    4097777520: "IFCSITE",
    1529196076: "IFCSLAB",
    3127900445: "IFCSLABELEMENTEDCASE",
    3027962421: "IFCSLABSTANDARDCASE",
    2533589738: "IFCSLABTYPE",
    2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
    3420628829: "IFCSOLARDEVICE",
    1072016465: "IFCSOLARDEVICETYPE",
    723233188: "IFCSOLIDMODEL",
    3856911033: "IFCSPACE",
    1999602285: "IFCSPACEHEATER",
    1305183839: "IFCSPACEHEATERTYPE",
    3812236995: "IFCSPACETYPE",
    1412071761: "IFCSPATIALELEMENT",
    710998568: "IFCSPATIALELEMENTTYPE",
    2706606064: "IFCSPATIALSTRUCTUREELEMENT",
    3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
    463610769: "IFCSPATIALZONE",
    2481509218: "IFCSPATIALZONETYPE",
    451544542: "IFCSPHERE",
    4015995234: "IFCSPHERICALSURFACE",
    1404847402: "IFCSTACKTERMINAL",
    3112655638: "IFCSTACKTERMINALTYPE",
    331165859: "IFCSTAIR",
    4252922144: "IFCSTAIRFLIGHT",
    1039846685: "IFCSTAIRFLIGHTTYPE",
    338393293: "IFCSTAIRTYPE",
    682877961: "IFCSTRUCTURALACTION",
    3544373492: "IFCSTRUCTURALACTIVITY",
    2515109513: "IFCSTRUCTURALANALYSISMODEL",
    1179482911: "IFCSTRUCTURALCONNECTION",
    2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
    1004757350: "IFCSTRUCTURALCURVEACTION",
    4243806635: "IFCSTRUCTURALCURVECONNECTION",
    214636428: "IFCSTRUCTURALCURVEMEMBER",
    2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
    2757150158: "IFCSTRUCTURALCURVEREACTION",
    3136571912: "IFCSTRUCTURALITEM",
    1807405624: "IFCSTRUCTURALLINEARACTION",
    2162789131: "IFCSTRUCTURALLOAD",
    385403989: "IFCSTRUCTURALLOADCASE",
    3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
    1252848954: "IFCSTRUCTURALLOADGROUP",
    1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
    609421318: "IFCSTRUCTURALLOADORRESULT",
    2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
    2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
    1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
    1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
    1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
    2525727697: "IFCSTRUCTURALLOADSTATIC",
    3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
    530289379: "IFCSTRUCTURALMEMBER",
    1621171031: "IFCSTRUCTURALPLANARACTION",
    2082059205: "IFCSTRUCTURALPOINTACTION",
    734778138: "IFCSTRUCTURALPOINTCONNECTION",
    1235345126: "IFCSTRUCTURALPOINTREACTION",
    3689010777: "IFCSTRUCTURALREACTION",
    2986769608: "IFCSTRUCTURALRESULTGROUP",
    3657597509: "IFCSTRUCTURALSURFACEACTION",
    1975003073: "IFCSTRUCTURALSURFACECONNECTION",
    3979015343: "IFCSTRUCTURALSURFACEMEMBER",
    2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
    603775116: "IFCSTRUCTURALSURFACEREACTION",
    2830218821: "IFCSTYLEMODEL",
    3958052878: "IFCSTYLEDITEM",
    3049322572: "IFCSTYLEDREPRESENTATION",
    148013059: "IFCSUBCONTRACTRESOURCE",
    4095615324: "IFCSUBCONTRACTRESOURCETYPE",
    2233826070: "IFCSUBEDGE",
    2513912981: "IFCSURFACE",
    699246055: "IFCSURFACECURVE",
    2028607225: "IFCSURFACECURVESWEPTAREASOLID",
    3101698114: "IFCSURFACEFEATURE",
    2809605785: "IFCSURFACEOFLINEAREXTRUSION",
    4124788165: "IFCSURFACEOFREVOLUTION",
    2934153892: "IFCSURFACEREINFORCEMENTAREA",
    1300840506: "IFCSURFACESTYLE",
    3303107099: "IFCSURFACESTYLELIGHTING",
    1607154358: "IFCSURFACESTYLEREFRACTION",
    1878645084: "IFCSURFACESTYLERENDERING",
    846575682: "IFCSURFACESTYLESHADING",
    1351298697: "IFCSURFACESTYLEWITHTEXTURES",
    626085974: "IFCSURFACETEXTURE",
    2247615214: "IFCSWEPTAREASOLID",
    1260650574: "IFCSWEPTDISKSOLID",
    1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
    230924584: "IFCSWEPTSURFACE",
    1162798199: "IFCSWITCHINGDEVICE",
    2315554128: "IFCSWITCHINGDEVICETYPE",
    2254336722: "IFCSYSTEM",
    413509423: "IFCSYSTEMFURNITUREELEMENT",
    1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
    3071757647: "IFCTSHAPEPROFILEDEF",
    985171141: "IFCTABLE",
    2043862942: "IFCTABLECOLUMN",
    531007025: "IFCTABLEROW",
    812556717: "IFCTANK",
    5716631: "IFCTANKTYPE",
    3473067441: "IFCTASK",
    1549132990: "IFCTASKTIME",
    2771591690: "IFCTASKTIMERECURRING",
    3206491090: "IFCTASKTYPE",
    912023232: "IFCTELECOMADDRESS",
    3824725483: "IFCTENDON",
    2347447852: "IFCTENDONANCHOR",
    3081323446: "IFCTENDONANCHORTYPE",
    3663046924: "IFCTENDONCONDUIT",
    2281632017: "IFCTENDONCONDUITTYPE",
    2415094496: "IFCTENDONTYPE",
    2387106220: "IFCTESSELLATEDFACESET",
    901063453: "IFCTESSELLATEDITEM",
    4282788508: "IFCTEXTLITERAL",
    3124975700: "IFCTEXTLITERALWITHEXTENT",
    1447204868: "IFCTEXTSTYLE",
    1983826977: "IFCTEXTSTYLEFONTMODEL",
    2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
    1640371178: "IFCTEXTSTYLETEXTMODEL",
    280115917: "IFCTEXTURECOORDINATE",
    1742049831: "IFCTEXTURECOORDINATEGENERATOR",
    2552916305: "IFCTEXTUREMAP",
    1210645708: "IFCTEXTUREVERTEX",
    3611470254: "IFCTEXTUREVERTEXLIST",
    1199560280: "IFCTIMEPERIOD",
    3101149627: "IFCTIMESERIES",
    581633288: "IFCTIMESERIESVALUE",
    1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
    1735638870: "IFCTOPOLOGYREPRESENTATION",
    1935646853: "IFCTOROIDALSURFACE",
    3825984169: "IFCTRANSFORMER",
    1692211062: "IFCTRANSFORMERTYPE",
    2595432518: "IFCTRANSITIONCURVESEGMENT2D",
    1620046519: "IFCTRANSPORTELEMENT",
    2097647324: "IFCTRANSPORTELEMENTTYPE",
    2715220739: "IFCTRAPEZIUMPROFILEDEF",
    2916149573: "IFCTRIANGULATEDFACESET",
    1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
    3593883385: "IFCTRIMMEDCURVE",
    3026737570: "IFCTUBEBUNDLE",
    1600972822: "IFCTUBEBUNDLETYPE",
    1628702193: "IFCTYPEOBJECT",
    3736923433: "IFCTYPEPROCESS",
    2347495698: "IFCTYPEPRODUCT",
    3698973494: "IFCTYPERESOURCE",
    427810014: "IFCUSHAPEPROFILEDEF",
    180925521: "IFCUNITASSIGNMENT",
    630975310: "IFCUNITARYCONTROLELEMENT",
    3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
    4292641817: "IFCUNITARYEQUIPMENT",
    1911125066: "IFCUNITARYEQUIPMENTTYPE",
    4207607924: "IFCVALVE",
    728799441: "IFCVALVETYPE",
    1417489154: "IFCVECTOR",
    2799835756: "IFCVERTEX",
    2759199220: "IFCVERTEXLOOP",
    1907098498: "IFCVERTEXPOINT",
    1530820697: "IFCVIBRATIONDAMPER",
    3956297820: "IFCVIBRATIONDAMPERTYPE",
    2391383451: "IFCVIBRATIONISOLATOR",
    3313531582: "IFCVIBRATIONISOLATORTYPE",
    2769231204: "IFCVIRTUALELEMENT",
    891718957: "IFCVIRTUALGRIDINTERSECTION",
    926996030: "IFCVOIDINGFEATURE",
    2391406946: "IFCWALL",
    4156078855: "IFCWALLELEMENTEDCASE",
    3512223829: "IFCWALLSTANDARDCASE",
    1898987631: "IFCWALLTYPE",
    4237592921: "IFCWASTETERMINAL",
    1133259667: "IFCWASTETERMINALTYPE",
    3304561284: "IFCWINDOW",
    336235671: "IFCWINDOWLININGPROPERTIES",
    512836454: "IFCWINDOWPANELPROPERTIES",
    486154966: "IFCWINDOWSTANDARDCASE",
    1299126871: "IFCWINDOWSTYLE",
    4009809668: "IFCWINDOWTYPE",
    4088093105: "IFCWORKCALENDAR",
    1028945134: "IFCWORKCONTROL",
    4218914973: "IFCWORKPLAN",
    3342526732: "IFCWORKSCHEDULE",
    1236880293: "IFCWORKTIME",
    2543172580: "IFCZSHAPEPROFILEDEF",
    1033361043: "IFCZONE"
  };

  // dist/helpers/properties.ts
  var PropsNames = {
    aggregates: {
      name: IFCRELAGGREGATES,
      relating: "RelatingObject",
      related: "RelatedObjects",
      key: "children"
    },
    spatial: {
      name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
      relating: "RelatingStructure",
      related: "RelatedElements",
      key: "children"
    },
    psets: {
      name: IFCRELDEFINESBYPROPERTIES,
      relating: "RelatingPropertyDefinition",
      related: "RelatedObjects",
      key: "hasPsets"
    },
    materials: {
      name: IFCRELASSOCIATESMATERIAL,
      relating: "RelatingMaterial",
      related: "RelatedObjects",
      key: "hasMaterial"
    },
    type: {
      name: IFCRELDEFINESBYTYPE,
      relating: "RelatingType",
      related: "RelatedObjects",
      key: "hasType"
    }
  };
  var Properties = class {
    constructor(api) {
      this.api = api;
    }
    getIfcType(type) {
      return IfcTypesMap[type];
    }
    getItemProperties(modelID, id, recursive = false) {
      return __async(this, null, function* () {
        return this.api.GetLine(modelID, id, recursive);
      });
    }
    getPropertySets(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.psets);
      });
    }
    getTypeProperties(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.type);
      });
    }
    getMaterialsProperties(modelID, elementID, recursive = false) {
      return __async(this, null, function* () {
        return yield this.getProperty(modelID, elementID, recursive, PropsNames.materials);
      });
    }
    getSpatialStructure(modelID, includeProperties) {
      return __async(this, null, function* () {
        yield this.getAllTypesOfModel(modelID);
        const chunks = yield this.getSpatialTreeChunks(modelID);
        const allLines = yield this.api.GetLineIDsWithType(modelID, IFCPROJECT);
        const projectID = allLines.get(0);
        const project = Properties.newIfcProject(projectID);
        yield this.getSpatialNode(modelID, project, chunks, includeProperties);
        this.cleanupTypes();
        return project;
      });
    }
    getAllItemsOfType(modelID, type, verbose) {
      return __async(this, null, function* () {
        let items = [];
        const lines = yield this.api.GetLineIDsWithType(modelID, type);
        for (let i = 0; i < lines.size(); i++)
          items.push(lines.get(i));
        if (!verbose)
          return items;
        const result = [];
        for (let i = 0; i < items.length; i++) {
          result.push(yield this.api.GetLine(modelID, items[i]));
        }
        return result;
      });
    }
    getProperty(modelID, elementID, recursive = false, propName) {
      return __async(this, null, function* () {
        const propSetIds = yield this.getAllRelatedItemsOfType(modelID, elementID, propName);
        const result = [];
        for (let i = 0; i < propSetIds.length; i++) {
          result.push(yield this.api.GetLine(modelID, propSetIds[i], recursive));
        }
        return result;
      });
    }
    getChunks(modelID, chunks, propNames) {
      return __async(this, null, function* () {
        const relation = yield this.api.GetLineIDsWithType(modelID, propNames.name);
        for (let i = 0; i < relation.size(); i++) {
          const rel = yield this.api.GetLine(modelID, relation.get(i), false);
          this.saveChunk(chunks, propNames, rel);
        }
      });
    }
    static isRelated(id, rel, propNames) {
      const relatedItems = rel[propNames.related];
      if (Array.isArray(relatedItems)) {
        const values = relatedItems.map((item) => item.value);
        return values.includes(id);
      }
      return relatedItems.value === id;
    }
    static newIfcProject(id) {
      return {
        expressID: id,
        type: "IFCPROJECT",
        children: []
      };
    }
    getSpatialNode(modelID, node, treeChunks, includeProperties) {
      return __async(this, null, function* () {
        yield this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);
        yield this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);
      });
    }
    getChildren(modelID, node, treeChunks, propNames, includeProperties) {
      return __async(this, null, function* () {
        const children = treeChunks[node.expressID];
        if (children == void 0)
          return;
        const prop = propNames.key;
        const nodes = [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          let node2 = this.newNode(child);
          if (includeProperties) {
            const properties = yield this.getItemProperties(modelID, node2.expressID);
            node2 = __spreadValues(__spreadValues({}, properties), node2);
          }
          yield this.getSpatialNode(modelID, node2, treeChunks, includeProperties);
          nodes.push(node2);
        }
        node[prop] = nodes;
      });
    }
    newNode(id) {
      const typeName = this.getNodeType(id);
      return {
        expressID: id,
        type: typeName,
        children: []
      };
    }
    getNodeType(id) {
      const typeID = this.types[id];
      return IfcElements2[typeID];
    }
    getSpatialTreeChunks(modelID) {
      return __async(this, null, function* () {
        const treeChunks = {};
        yield this.getChunks(modelID, treeChunks, PropsNames.aggregates);
        yield this.getChunks(modelID, treeChunks, PropsNames.spatial);
        return treeChunks;
      });
    }
    saveChunk(chunks, propNames, rel) {
      const relating = rel[propNames.relating].value;
      const related = rel[propNames.related].map((r) => r.value);
      if (chunks[relating] == void 0) {
        chunks[relating] = related;
      } else {
        chunks[relating] = chunks[relating].concat(related);
      }
    }
    getRelated(rel, propNames, IDs) {
      const element = rel[propNames.relating];
      if (!Array.isArray(element))
        IDs.push(element.value);
      else
        element.forEach((ele) => IDs.push(ele.value));
    }
    getAllRelatedItemsOfType(modelID, id, propNames) {
      return __async(this, null, function* () {
        const lines = yield this.api.GetLineIDsWithType(modelID, propNames.name);
        const IDs = [];
        for (let i = 0; i < lines.size(); i++) {
          const rel = yield this.api.GetLine(modelID, lines.get(i));
          const isRelated = Properties.isRelated(id, rel, propNames);
          if (isRelated)
            this.getRelated(rel, propNames, IDs);
        }
        return IDs;
      });
    }
    cleanupTypes() {
      this.types = {};
    }
    getAllTypesOfModel(modelID) {
      return __async(this, null, function* () {
        const result = {};
        const elements = Object.keys(IfcElements2).map((e) => parseInt(e));
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          const lines = yield this.api.GetLineIDsWithType(modelID, element);
          const size = lines.size();
          for (let i2 = 0; i2 < size; i2++)
            result[lines.get(i2)] = element;
        }
        this.types = result;
      });
    }
  };

  // dist/web-ifc-api.ts
  var WebIFCWasm;
  if (typeof self !== "undefined" && self.crossOriginIsolated) {
    WebIFCWasm = require_web_ifc_mt();
  } else {
    WebIFCWasm = require_web_ifc();
  }
  var UNKNOWN = 0;
  var STRING = 1;
  var LABEL = 2;
  var ENUM = 3;
  var REAL = 4;
  var REF = 5;
  var EMPTY = 6;
  var SET_BEGIN = 7;
  var SET_END = 8;
  var LINE_END = 9;
  function ms() {
    return new Date().getTime();
  }
  var IfcAPI2 = class {
    constructor() {
      this.wasmModule = void 0;
      this.fs = void 0;
      this.wasmPath = "";
      this.isWasmPathAbsolute = false;
      this.ifcGuidMap = new Map();
      this.properties = new Properties(this);
    }
    Init(customLocateFileHandler) {
      return __async(this, null, function* () {
        if (WebIFCWasm) {
          let locateFileHandler = (path, prefix) => {
            if (path.endsWith(".wasm")) {
              if (this.isWasmPathAbsolute) {
                return this.wasmPath + path;
              }
              return prefix + this.wasmPath + path;
            }
            return prefix + path;
          };
          this.wasmModule = yield WebIFCWasm({ noInitialRun: true, locateFile: customLocateFileHandler || locateFileHandler });
          this.fs = this.wasmModule.FS;
        } else {
          console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
        }
      });
    }
    OpenModel(data, settings) {
      let s = __spreadValues({
        COORDINATE_TO_ORIGIN: false,
        USE_FAST_BOOLS: false,
        CIRCLE_SEGMENTS_LOW: 5,
        CIRCLE_SEGMENTS_MEDIUM: 8,
        CIRCLE_SEGMENTS_HIGH: 12,
        BOOL_ABORT_THRESHOLD: 1e4
      }, settings);
      let offsetInSrc = 0;
      let result = this.wasmModule.OpenModel(s, (destPtr, destSize) => {
        let srcSize = Math.min(data.byteLength - offsetInSrc, destSize);
        let dest = this.wasmModule.HEAPU8.subarray(destPtr, destPtr + destSize);
        let src = data.subarray(offsetInSrc, offsetInSrc + srcSize);
        dest.set(src);
        offsetInSrc += srcSize;
        return srcSize;
      });
      return result;
    }
    CreateModel(settings) {
      let s = __spreadValues({
        COORDINATE_TO_ORIGIN: false,
        USE_FAST_BOOLS: false,
        CIRCLE_SEGMENTS_LOW: 5,
        CIRCLE_SEGMENTS_MEDIUM: 8,
        CIRCLE_SEGMENTS_HIGH: 12,
        BOOL_ABORT_THRESHOLD: 1e4
      }, settings);
      let result = this.wasmModule.CreateModel(s);
      return result;
    }
    ExportFileAsIFC(modelID) {
      this.wasmModule.ExportFileAsIFC(modelID);
      let result = this.fs.readFile("/export.ifc");
      this.wasmModule["FS_unlink"]("/export.ifc");
      return result;
    }
    GetGeometry(modelID, geometryExpressID) {
      return this.wasmModule.GetGeometry(modelID, geometryExpressID);
    }
    GetLine(modelID, expressID, flatten = false) {
      let rawLineData = this.GetRawLineData(modelID, expressID);
      let lineData = FromRawLineData[rawLineData.type](rawLineData);
      if (flatten) {
        this.FlattenLine(modelID, lineData);
      }
      return lineData;
    }
    GetAndClearErrors(modelID) {
      return this.wasmModule.GetAndClearErrors(modelID);
    }
    WriteLine(modelID, lineObject) {
      Object.keys(lineObject).forEach((propertyName) => {
        let property = lineObject[propertyName];
        if (property && property.expressID !== void 0) {
          this.WriteLine(modelID, property);
          lineObject[propertyName] = {
            type: 5,
            value: property.expressID
          };
        } else if (Array.isArray(property) && property.length > 0) {
          for (let i = 0; i < property.length; i++) {
            if (property[i].expressID !== void 0) {
              this.WriteLine(modelID, property[i]);
              lineObject[propertyName][i] = {
                type: 5,
                value: property[i].expressID
              };
            }
          }
        }
      });
      let rawLineData = {
        ID: lineObject.expressID,
        type: lineObject.type,
        arguments: lineObject.ToTape()
      };
      this.WriteRawLineData(modelID, rawLineData);
    }
    FlattenLine(modelID, line) {
      Object.keys(line).forEach((propertyName) => {
        let property = line[propertyName];
        if (property && property.type === 5) {
          line[propertyName] = this.GetLine(modelID, property.value, true);
        } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
          for (let i = 0; i < property.length; i++) {
            line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
          }
        }
      });
    }
    GetRawLineData(modelID, expressID) {
      return this.wasmModule.GetLine(modelID, expressID);
    }
    WriteRawLineData(modelID, data) {
      return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
    }
    GetLineIDsWithType(modelID, type) {
      return this.wasmModule.GetLineIDsWithType(modelID, type);
    }
    GetAllLines(modelID) {
      return this.wasmModule.GetAllLines(modelID);
    }
    SetGeometryTransformation(modelID, transformationMatrix) {
      if (transformationMatrix.length != 16) {
        console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
        return;
      }
      this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
    }
    GetCoordinationMatrix(modelID) {
      return this.wasmModule.GetCoordinationMatrix(modelID);
    }
    GetVertexArray(ptr, size) {
      return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
    }
    GetIndexArray(ptr, size) {
      return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
    }
    getSubArray(heap, startPtr, sizeBytes) {
      return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
    }
    CloseModel(modelID) {
      this.ifcGuidMap.delete(modelID);
      this.wasmModule.CloseModel(modelID);
    }
    StreamAllMeshes(modelID, meshCallback) {
      this.wasmModule.StreamAllMeshes(modelID, meshCallback);
    }
    StreamAllMeshesWithTypes(modelID, types, meshCallback) {
      this.wasmModule.StreamAllMeshesWithTypes(modelID, types, meshCallback);
    }
    IsModelOpen(modelID) {
      return this.wasmModule.IsModelOpen(modelID);
    }
    LoadAllGeometry(modelID) {
      return this.wasmModule.LoadAllGeometry(modelID);
    }
    GetFlatMesh(modelID, expressID) {
      return this.wasmModule.GetFlatMesh(modelID, expressID);
    }
    CreateIfcGuidToExpressIdMapping(modelID) {
      const map = new Map();
      for (let x = 0; x < IfcElements.length; x++) {
        const type = IfcElements[x];
        const lines = this.GetLineIDsWithType(modelID, type);
        const size = lines.size();
        for (let y = 0; y < size; y++) {
          const expressID = lines.get(y);
          const info = this.GetLine(modelID, expressID);
          const globalID = info.GlobalId.value;
          map.set(expressID, globalID);
          map.set(globalID, expressID);
        }
      }
      this.ifcGuidMap.set(modelID, map);
    }
    SetWasmPath(path, absolute = false) {
      this.wasmPath = path;
      this.isWasmPathAbsolute = absolute;
    }
  };
  return web_ifc_api_exports;
})();
